# id;timestamp;commentText;codeText;commentWords;codeWords
HashPartition -> HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors, 			int partitionNumber, int recursionLevel, MemorySegment initialBuffer, MemorySegmentSource memSource, 			int segmentSize);1405024514;Creates a new partition, initially in memory, with one buffer for the build side. The partition is_initialized to expect record insertions for the build side.__@param partitionNumber The number of the partition._@param recursionLevel The recursion level - zero for partitions from the initial build, <i>n + 1</i> for_partitions that are created from spilled partition with recursion level <i>n</i>._@param initialBuffer The initial buffer for this partition._@param writeBehindBuffers The queue from which to pop buffers for writing, once the partition is spilled.;HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors,_			int partitionNumber, int recursionLevel, MemorySegment initialBuffer, MemorySegmentSource memSource,_			int segmentSize)_	{_		super(0)__		_		this.buildSideSerializer = buildSideAccessors__		this.probeSideSerializer = probeSideAccessors__		this.partitionNumber = partitionNumber__		this.recursionLevel = recursionLevel__		_		this.memorySegmentSize = segmentSize__		this.segmentSizeBits = MathUtils.log2strict(segmentSize)__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		_		this.buildSideWriteBuffer = new BuildSideBuffer<BT>(initialBuffer, memSource)__	};creates,a,new,partition,initially,in,memory,with,one,buffer,for,the,build,side,the,partition,is,initialized,to,expect,record,insertions,for,the,build,side,param,partition,number,the,number,of,the,partition,param,recursion,level,the,recursion,level,zero,for,partitions,from,the,initial,build,i,n,1,i,for,partitions,that,are,created,from,spilled,partition,with,recursion,level,i,n,i,param,initial,buffer,the,initial,buffer,for,this,partition,param,write,behind,buffers,the,queue,from,which,to,pop,buffers,for,writing,once,the,partition,is,spilled;hash,partition,type,serializer,bt,build,side,accessors,type,serializer,pt,probe,side,accessors,int,partition,number,int,recursion,level,memory,segment,initial,buffer,memory,segment,source,mem,source,int,segment,size,super,0,this,build,side,serializer,build,side,accessors,this,probe,side,serializer,probe,side,accessors,this,partition,number,partition,number,this,recursion,level,recursion,level,this,memory,segment,size,segment,size,this,segment,size,bits,math,utils,log2strict,segment,size,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,build,side,write,buffer,new,build,side,buffer,bt,initial,buffer,mem,source
HashPartition -> HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors, 			int partitionNumber, int recursionLevel, MemorySegment initialBuffer, MemorySegmentSource memSource, 			int segmentSize);1405090423;Creates a new partition, initially in memory, with one buffer for the build side. The partition is_initialized to expect record insertions for the build side.__@param partitionNumber The number of the partition._@param recursionLevel The recursion level - zero for partitions from the initial build, <i>n + 1</i> for_partitions that are created from spilled partition with recursion level <i>n</i>._@param initialBuffer The initial buffer for this partition._@param writeBehindBuffers The queue from which to pop buffers for writing, once the partition is spilled.;HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors,_			int partitionNumber, int recursionLevel, MemorySegment initialBuffer, MemorySegmentSource memSource,_			int segmentSize)_	{_		super(0)__		_		this.buildSideSerializer = buildSideAccessors__		this.probeSideSerializer = probeSideAccessors__		this.partitionNumber = partitionNumber__		this.recursionLevel = recursionLevel__		_		this.memorySegmentSize = segmentSize__		this.segmentSizeBits = MathUtils.log2strict(segmentSize)__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		_		this.buildSideWriteBuffer = new BuildSideBuffer<BT>(initialBuffer, memSource)__	};creates,a,new,partition,initially,in,memory,with,one,buffer,for,the,build,side,the,partition,is,initialized,to,expect,record,insertions,for,the,build,side,param,partition,number,the,number,of,the,partition,param,recursion,level,the,recursion,level,zero,for,partitions,from,the,initial,build,i,n,1,i,for,partitions,that,are,created,from,spilled,partition,with,recursion,level,i,n,i,param,initial,buffer,the,initial,buffer,for,this,partition,param,write,behind,buffers,the,queue,from,which,to,pop,buffers,for,writing,once,the,partition,is,spilled;hash,partition,type,serializer,bt,build,side,accessors,type,serializer,pt,probe,side,accessors,int,partition,number,int,recursion,level,memory,segment,initial,buffer,memory,segment,source,mem,source,int,segment,size,super,0,this,build,side,serializer,build,side,accessors,this,probe,side,serializer,probe,side,accessors,this,partition,number,partition,number,this,recursion,level,recursion,level,this,memory,segment,size,segment,size,this,segment,size,bits,math,utils,log2strict,segment,size,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,build,side,write,buffer,new,build,side,buffer,bt,initial,buffer,mem,source
HashPartition -> HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors, 			int partitionNumber, int recursionLevel, MemorySegment initialBuffer, MemorySegmentSource memSource, 			int segmentSize);1411473593;Creates a new partition, initially in memory, with one buffer for the build side. The partition is_initialized to expect record insertions for the build side.__@param partitionNumber The number of the partition._@param recursionLevel The recursion level - zero for partitions from the initial build, <i>n + 1</i> for_partitions that are created from spilled partition with recursion level <i>n</i>._@param initialBuffer The initial buffer for this partition._@param writeBehindBuffers The queue from which to pop buffers for writing, once the partition is spilled.;HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors,_			int partitionNumber, int recursionLevel, MemorySegment initialBuffer, MemorySegmentSource memSource,_			int segmentSize)_	{_		super(0)__		_		this.buildSideSerializer = buildSideAccessors__		this.probeSideSerializer = probeSideAccessors__		this.partitionNumber = partitionNumber__		this.recursionLevel = recursionLevel__		_		this.memorySegmentSize = segmentSize__		this.segmentSizeBits = MathUtils.log2strict(segmentSize)__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		_		this.buildSideWriteBuffer = new BuildSideBuffer<BT>(initialBuffer, memSource)__	};creates,a,new,partition,initially,in,memory,with,one,buffer,for,the,build,side,the,partition,is,initialized,to,expect,record,insertions,for,the,build,side,param,partition,number,the,number,of,the,partition,param,recursion,level,the,recursion,level,zero,for,partitions,from,the,initial,build,i,n,1,i,for,partitions,that,are,created,from,spilled,partition,with,recursion,level,i,n,i,param,initial,buffer,the,initial,buffer,for,this,partition,param,write,behind,buffers,the,queue,from,which,to,pop,buffers,for,writing,once,the,partition,is,spilled;hash,partition,type,serializer,bt,build,side,accessors,type,serializer,pt,probe,side,accessors,int,partition,number,int,recursion,level,memory,segment,initial,buffer,memory,segment,source,mem,source,int,segment,size,super,0,this,build,side,serializer,build,side,accessors,this,probe,side,serializer,probe,side,accessors,this,partition,number,partition,number,this,recursion,level,recursion,level,this,memory,segment,size,segment,size,this,segment,size,bits,math,utils,log2strict,segment,size,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,build,side,write,buffer,new,build,side,buffer,bt,initial,buffer,mem,source
HashPartition -> HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors, 			int partitionNumber, int recursionLevel, MemorySegment initialBuffer, MemorySegmentSource memSource, 			int segmentSize);1412164980;Creates a new partition, initially in memory, with one buffer for the build side. The partition is_initialized to expect record insertions for the build side.__@param partitionNumber The number of the partition._@param recursionLevel The recursion level - zero for partitions from the initial build, <i>n + 1</i> for_partitions that are created from spilled partition with recursion level <i>n</i>._@param initialBuffer The initial buffer for this partition._@param writeBehindBuffers The queue from which to pop buffers for writing, once the partition is spilled.;HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors,_			int partitionNumber, int recursionLevel, MemorySegment initialBuffer, MemorySegmentSource memSource,_			int segmentSize)_	{_		super(0)__		_		this.buildSideSerializer = buildSideAccessors__		this.probeSideSerializer = probeSideAccessors__		this.partitionNumber = partitionNumber__		this.recursionLevel = recursionLevel__		_		this.memorySegmentSize = segmentSize__		this.segmentSizeBits = MathUtils.log2strict(segmentSize)__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		_		this.buildSideWriteBuffer = new BuildSideBuffer<BT>(initialBuffer, memSource)__	};creates,a,new,partition,initially,in,memory,with,one,buffer,for,the,build,side,the,partition,is,initialized,to,expect,record,insertions,for,the,build,side,param,partition,number,the,number,of,the,partition,param,recursion,level,the,recursion,level,zero,for,partitions,from,the,initial,build,i,n,1,i,for,partitions,that,are,created,from,spilled,partition,with,recursion,level,i,n,i,param,initial,buffer,the,initial,buffer,for,this,partition,param,write,behind,buffers,the,queue,from,which,to,pop,buffers,for,writing,once,the,partition,is,spilled;hash,partition,type,serializer,bt,build,side,accessors,type,serializer,pt,probe,side,accessors,int,partition,number,int,recursion,level,memory,segment,initial,buffer,memory,segment,source,mem,source,int,segment,size,super,0,this,build,side,serializer,build,side,accessors,this,probe,side,serializer,probe,side,accessors,this,partition,number,partition,number,this,recursion,level,recursion,level,this,memory,segment,size,segment,size,this,segment,size,bits,math,utils,log2strict,segment,size,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,build,side,write,buffer,new,build,side,buffer,bt,initial,buffer,mem,source
HashPartition -> HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors, 			int partitionNumber, int recursionLevel, MemorySegment initialBuffer, MemorySegmentSource memSource, 			int segmentSize);1414786554;Creates a new partition, initially in memory, with one buffer for the build side. The partition is_initialized to expect record insertions for the build side.__@param partitionNumber The number of the partition._@param recursionLevel The recursion level - zero for partitions from the initial build, <i>n + 1</i> for_partitions that are created from spilled partition with recursion level <i>n</i>._@param initialBuffer The initial buffer for this partition._@param writeBehindBuffers The queue from which to pop buffers for writing, once the partition is spilled.;HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors,_			int partitionNumber, int recursionLevel, MemorySegment initialBuffer, MemorySegmentSource memSource,_			int segmentSize)_	{_		super(0)__		_		this.buildSideSerializer = buildSideAccessors__		this.probeSideSerializer = probeSideAccessors__		this.partitionNumber = partitionNumber__		this.recursionLevel = recursionLevel__		_		this.memorySegmentSize = segmentSize__		this.segmentSizeBits = MathUtils.log2strict(segmentSize)__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		_		this.buildSideWriteBuffer = new BuildSideBuffer<BT>(initialBuffer, memSource)__	};creates,a,new,partition,initially,in,memory,with,one,buffer,for,the,build,side,the,partition,is,initialized,to,expect,record,insertions,for,the,build,side,param,partition,number,the,number,of,the,partition,param,recursion,level,the,recursion,level,zero,for,partitions,from,the,initial,build,i,n,1,i,for,partitions,that,are,created,from,spilled,partition,with,recursion,level,i,n,i,param,initial,buffer,the,initial,buffer,for,this,partition,param,write,behind,buffers,the,queue,from,which,to,pop,buffers,for,writing,once,the,partition,is,spilled;hash,partition,type,serializer,bt,build,side,accessors,type,serializer,pt,probe,side,accessors,int,partition,number,int,recursion,level,memory,segment,initial,buffer,memory,segment,source,mem,source,int,segment,size,super,0,this,build,side,serializer,build,side,accessors,this,probe,side,serializer,probe,side,accessors,this,partition,number,partition,number,this,recursion,level,recursion,level,this,memory,segment,size,segment,size,this,segment,size,bits,math,utils,log2strict,segment,size,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,build,side,write,buffer,new,build,side,buffer,bt,initial,buffer,mem,source
HashPartition -> HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors, 			int partitionNumber, int recursionLevel, MemorySegment initialBuffer, MemorySegmentSource memSource, 			int segmentSize);1415702894;Creates a new partition, initially in memory, with one buffer for the build side. The partition is_initialized to expect record insertions for the build side.__@param partitionNumber The number of the partition._@param recursionLevel The recursion level - zero for partitions from the initial build, <i>n + 1</i> for_partitions that are created from spilled partition with recursion level <i>n</i>._@param initialBuffer The initial buffer for this partition._@param writeBehindBuffers The queue from which to pop buffers for writing, once the partition is spilled.;HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors,_			int partitionNumber, int recursionLevel, MemorySegment initialBuffer, MemorySegmentSource memSource,_			int segmentSize)_	{_		super(0)__		_		this.buildSideSerializer = buildSideAccessors__		this.probeSideSerializer = probeSideAccessors__		this.partitionNumber = partitionNumber__		this.recursionLevel = recursionLevel__		_		this.memorySegmentSize = segmentSize__		this.segmentSizeBits = MathUtils.log2strict(segmentSize)__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		_		this.buildSideWriteBuffer = new BuildSideBuffer<BT>(initialBuffer, memSource)__	};creates,a,new,partition,initially,in,memory,with,one,buffer,for,the,build,side,the,partition,is,initialized,to,expect,record,insertions,for,the,build,side,param,partition,number,the,number,of,the,partition,param,recursion,level,the,recursion,level,zero,for,partitions,from,the,initial,build,i,n,1,i,for,partitions,that,are,created,from,spilled,partition,with,recursion,level,i,n,i,param,initial,buffer,the,initial,buffer,for,this,partition,param,write,behind,buffers,the,queue,from,which,to,pop,buffers,for,writing,once,the,partition,is,spilled;hash,partition,type,serializer,bt,build,side,accessors,type,serializer,pt,probe,side,accessors,int,partition,number,int,recursion,level,memory,segment,initial,buffer,memory,segment,source,mem,source,int,segment,size,super,0,this,build,side,serializer,build,side,accessors,this,probe,side,serializer,probe,side,accessors,this,partition,number,partition,number,this,recursion,level,recursion,level,this,memory,segment,size,segment,size,this,segment,size,bits,math,utils,log2strict,segment,size,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,build,side,write,buffer,new,build,side,buffer,bt,initial,buffer,mem,source
HashPartition -> HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors, 			int partitionNumber, int recursionLevel, MemorySegment initialBuffer, MemorySegmentSource memSource, 			int segmentSize);1418570573;Creates a new partition, initially in memory, with one buffer for the build side. The partition is_initialized to expect record insertions for the build side.__@param partitionNumber The number of the partition._@param recursionLevel The recursion level - zero for partitions from the initial build, <i>n + 1</i> for_partitions that are created from spilled partition with recursion level <i>n</i>._@param initialBuffer The initial buffer for this partition.;HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors,_			int partitionNumber, int recursionLevel, MemorySegment initialBuffer, MemorySegmentSource memSource,_			int segmentSize)_	{_		super(0)__		_		this.buildSideSerializer = buildSideAccessors__		this.probeSideSerializer = probeSideAccessors__		this.partitionNumber = partitionNumber__		this.recursionLevel = recursionLevel__		_		this.memorySegmentSize = segmentSize__		this.segmentSizeBits = MathUtils.log2strict(segmentSize)__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		_		this.buildSideWriteBuffer = new BuildSideBuffer<BT>(initialBuffer, memSource)__	};creates,a,new,partition,initially,in,memory,with,one,buffer,for,the,build,side,the,partition,is,initialized,to,expect,record,insertions,for,the,build,side,param,partition,number,the,number,of,the,partition,param,recursion,level,the,recursion,level,zero,for,partitions,from,the,initial,build,i,n,1,i,for,partitions,that,are,created,from,spilled,partition,with,recursion,level,i,n,i,param,initial,buffer,the,initial,buffer,for,this,partition;hash,partition,type,serializer,bt,build,side,accessors,type,serializer,pt,probe,side,accessors,int,partition,number,int,recursion,level,memory,segment,initial,buffer,memory,segment,source,mem,source,int,segment,size,super,0,this,build,side,serializer,build,side,accessors,this,probe,side,serializer,probe,side,accessors,this,partition,number,partition,number,this,recursion,level,recursion,level,this,memory,segment,size,segment,size,this,segment,size,bits,math,utils,log2strict,segment,size,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,build,side,write,buffer,new,build,side,buffer,bt,initial,buffer,mem,source
HashPartition -> HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors, 			int partitionNumber, int recursionLevel, MemorySegment initialBuffer, MemorySegmentSource memSource, 			int segmentSize);1420654570;Creates a new partition, initially in memory, with one buffer for the build side. The partition is_initialized to expect record insertions for the build side.__@param partitionNumber The number of the partition._@param recursionLevel The recursion level - zero for partitions from the initial build, <i>n + 1</i> for_partitions that are created from spilled partition with recursion level <i>n</i>._@param initialBuffer The initial buffer for this partition.;HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors,_			int partitionNumber, int recursionLevel, MemorySegment initialBuffer, MemorySegmentSource memSource,_			int segmentSize)_	{_		super(0)__		_		this.buildSideSerializer = buildSideAccessors__		this.probeSideSerializer = probeSideAccessors__		this.partitionNumber = partitionNumber__		this.recursionLevel = recursionLevel__		_		this.memorySegmentSize = segmentSize__		this.segmentSizeBits = MathUtils.log2strict(segmentSize)__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		_		this.buildSideWriteBuffer = new BuildSideBuffer<BT>(initialBuffer, memSource)__	};creates,a,new,partition,initially,in,memory,with,one,buffer,for,the,build,side,the,partition,is,initialized,to,expect,record,insertions,for,the,build,side,param,partition,number,the,number,of,the,partition,param,recursion,level,the,recursion,level,zero,for,partitions,from,the,initial,build,i,n,1,i,for,partitions,that,are,created,from,spilled,partition,with,recursion,level,i,n,i,param,initial,buffer,the,initial,buffer,for,this,partition;hash,partition,type,serializer,bt,build,side,accessors,type,serializer,pt,probe,side,accessors,int,partition,number,int,recursion,level,memory,segment,initial,buffer,memory,segment,source,mem,source,int,segment,size,super,0,this,build,side,serializer,build,side,accessors,this,probe,side,serializer,probe,side,accessors,this,partition,number,partition,number,this,recursion,level,recursion,level,this,memory,segment,size,segment,size,this,segment,size,bits,math,utils,log2strict,segment,size,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,build,side,write,buffer,new,build,side,buffer,bt,initial,buffer,mem,source
HashPartition -> HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors, 			int partitionNumber, int recursionLevel, MemorySegment initialBuffer, MemorySegmentSource memSource, 			int segmentSize);1420663430;Creates a new partition, initially in memory, with one buffer for the build side. The partition is_initialized to expect record insertions for the build side.__@param partitionNumber The number of the partition._@param recursionLevel The recursion level - zero for partitions from the initial build, <i>n + 1</i> for_partitions that are created from spilled partition with recursion level <i>n</i>._@param initialBuffer The initial buffer for this partition.;HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors,_			int partitionNumber, int recursionLevel, MemorySegment initialBuffer, MemorySegmentSource memSource,_			int segmentSize)_	{_		super(0)__		_		this.buildSideSerializer = buildSideAccessors__		this.probeSideSerializer = probeSideAccessors__		this.partitionNumber = partitionNumber__		this.recursionLevel = recursionLevel__		_		this.memorySegmentSize = segmentSize__		this.segmentSizeBits = MathUtils.log2strict(segmentSize)__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		_		this.buildSideWriteBuffer = new BuildSideBuffer<BT>(initialBuffer, memSource)__	};creates,a,new,partition,initially,in,memory,with,one,buffer,for,the,build,side,the,partition,is,initialized,to,expect,record,insertions,for,the,build,side,param,partition,number,the,number,of,the,partition,param,recursion,level,the,recursion,level,zero,for,partitions,from,the,initial,build,i,n,1,i,for,partitions,that,are,created,from,spilled,partition,with,recursion,level,i,n,i,param,initial,buffer,the,initial,buffer,for,this,partition;hash,partition,type,serializer,bt,build,side,accessors,type,serializer,pt,probe,side,accessors,int,partition,number,int,recursion,level,memory,segment,initial,buffer,memory,segment,source,mem,source,int,segment,size,super,0,this,build,side,serializer,build,side,accessors,this,probe,side,serializer,probe,side,accessors,this,partition,number,partition,number,this,recursion,level,recursion,level,this,memory,segment,size,segment,size,this,segment,size,bits,math,utils,log2strict,segment,size,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,build,side,write,buffer,new,build,side,buffer,bt,initial,buffer,mem,source
HashPartition -> HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors, 			int partitionNumber, int recursionLevel, MemorySegment initialBuffer, MemorySegmentSource memSource, 			int segmentSize);1426697080;Creates a new partition, initially in memory, with one buffer for the build side. The partition is_initialized to expect record insertions for the build side.__@param partitionNumber The number of the partition._@param recursionLevel The recursion level - zero for partitions from the initial build, <i>n + 1</i> for_partitions that are created from spilled partition with recursion level <i>n</i>._@param initialBuffer The initial buffer for this partition.;HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors,_			int partitionNumber, int recursionLevel, MemorySegment initialBuffer, MemorySegmentSource memSource,_			int segmentSize)_	{_		super(0)__		_		this.buildSideSerializer = buildSideAccessors__		this.probeSideSerializer = probeSideAccessors__		this.partitionNumber = partitionNumber__		this.recursionLevel = recursionLevel__		_		this.memorySegmentSize = segmentSize__		this.segmentSizeBits = MathUtils.log2strict(segmentSize)__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		_		this.buildSideWriteBuffer = new BuildSideBuffer<BT>(initialBuffer, memSource)__	};creates,a,new,partition,initially,in,memory,with,one,buffer,for,the,build,side,the,partition,is,initialized,to,expect,record,insertions,for,the,build,side,param,partition,number,the,number,of,the,partition,param,recursion,level,the,recursion,level,zero,for,partitions,from,the,initial,build,i,n,1,i,for,partitions,that,are,created,from,spilled,partition,with,recursion,level,i,n,i,param,initial,buffer,the,initial,buffer,for,this,partition;hash,partition,type,serializer,bt,build,side,accessors,type,serializer,pt,probe,side,accessors,int,partition,number,int,recursion,level,memory,segment,initial,buffer,memory,segment,source,mem,source,int,segment,size,super,0,this,build,side,serializer,build,side,accessors,this,probe,side,serializer,probe,side,accessors,this,partition,number,partition,number,this,recursion,level,recursion,level,this,memory,segment,size,segment,size,this,segment,size,bits,math,utils,log2strict,segment,size,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,build,side,write,buffer,new,build,side,buffer,bt,initial,buffer,mem,source
HashPartition -> HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors, 			int partitionNumber, int recursionLevel, MemorySegment initialBuffer, MemorySegmentSource memSource, 			int segmentSize);1440607697;Creates a new partition, initially in memory, with one buffer for the build side. The partition is_initialized to expect record insertions for the build side.__@param partitionNumber The number of the partition._@param recursionLevel The recursion level - zero for partitions from the initial build, <i>n + 1</i> for_partitions that are created from spilled partition with recursion level <i>n</i>._@param initialBuffer The initial buffer for this partition.;HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors,_			int partitionNumber, int recursionLevel, MemorySegment initialBuffer, MemorySegmentSource memSource,_			int segmentSize)_	{_		super(0)__		_		this.buildSideSerializer = buildSideAccessors__		this.probeSideSerializer = probeSideAccessors__		this.partitionNumber = partitionNumber__		this.recursionLevel = recursionLevel__		_		this.memorySegmentSize = segmentSize__		this.segmentSizeBits = MathUtils.log2strict(segmentSize)__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		_		this.buildSideWriteBuffer = new BuildSideBuffer(initialBuffer, memSource)__	};creates,a,new,partition,initially,in,memory,with,one,buffer,for,the,build,side,the,partition,is,initialized,to,expect,record,insertions,for,the,build,side,param,partition,number,the,number,of,the,partition,param,recursion,level,the,recursion,level,zero,for,partitions,from,the,initial,build,i,n,1,i,for,partitions,that,are,created,from,spilled,partition,with,recursion,level,i,n,i,param,initial,buffer,the,initial,buffer,for,this,partition;hash,partition,type,serializer,bt,build,side,accessors,type,serializer,pt,probe,side,accessors,int,partition,number,int,recursion,level,memory,segment,initial,buffer,memory,segment,source,mem,source,int,segment,size,super,0,this,build,side,serializer,build,side,accessors,this,probe,side,serializer,probe,side,accessors,this,partition,number,partition,number,this,recursion,level,recursion,level,this,memory,segment,size,segment,size,this,segment,size,bits,math,utils,log2strict,segment,size,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,build,side,write,buffer,new,build,side,buffer,initial,buffer,mem,source
HashPartition -> HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors, 			int partitionNumber, int recursionLevel, MemorySegment initialBuffer, MemorySegmentSource memSource, 			int segmentSize);1441738685;Creates a new partition, initially in memory, with one buffer for the build side. The partition is_initialized to expect record insertions for the build side.__@param partitionNumber The number of the partition._@param recursionLevel The recursion level - zero for partitions from the initial build, <i>n + 1</i> for_partitions that are created from spilled partition with recursion level <i>n</i>._@param initialBuffer The initial buffer for this partition.;HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors,_			int partitionNumber, int recursionLevel, MemorySegment initialBuffer, MemorySegmentSource memSource,_			int segmentSize)_	{_		super(0)__		_		this.buildSideSerializer = buildSideAccessors__		this.probeSideSerializer = probeSideAccessors__		this.partitionNumber = partitionNumber__		this.recursionLevel = recursionLevel__		_		this.memorySegmentSize = segmentSize__		this.segmentSizeBits = MathUtils.log2strict(segmentSize)__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		_		this.buildSideWriteBuffer = new BuildSideBuffer(initialBuffer, memSource)__	};creates,a,new,partition,initially,in,memory,with,one,buffer,for,the,build,side,the,partition,is,initialized,to,expect,record,insertions,for,the,build,side,param,partition,number,the,number,of,the,partition,param,recursion,level,the,recursion,level,zero,for,partitions,from,the,initial,build,i,n,1,i,for,partitions,that,are,created,from,spilled,partition,with,recursion,level,i,n,i,param,initial,buffer,the,initial,buffer,for,this,partition;hash,partition,type,serializer,bt,build,side,accessors,type,serializer,pt,probe,side,accessors,int,partition,number,int,recursion,level,memory,segment,initial,buffer,memory,segment,source,mem,source,int,segment,size,super,0,this,build,side,serializer,build,side,accessors,this,probe,side,serializer,probe,side,accessors,this,partition,number,partition,number,this,recursion,level,recursion,level,this,memory,segment,size,segment,size,this,segment,size,bits,math,utils,log2strict,segment,size,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,build,side,write,buffer,new,build,side,buffer,initial,buffer,mem,source
HashPartition -> HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors, 			int partitionNumber, int recursionLevel, MemorySegment initialBuffer, MemorySegmentSource memSource, 			int segmentSize);1443528421;Creates a new partition, initially in memory, with one buffer for the build side. The partition is_initialized to expect record insertions for the build side.__@param partitionNumber The number of the partition._@param recursionLevel The recursion level - zero for partitions from the initial build, <i>n + 1</i> for_partitions that are created from spilled partition with recursion level <i>n</i>._@param initialBuffer The initial buffer for this partition.;HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors,_			int partitionNumber, int recursionLevel, MemorySegment initialBuffer, MemorySegmentSource memSource,_			int segmentSize)_	{_		super(0)__		_		this.buildSideSerializer = buildSideAccessors__		this.probeSideSerializer = probeSideAccessors__		this.partitionNumber = partitionNumber__		this.recursionLevel = recursionLevel__		_		this.memorySegmentSize = segmentSize__		this.segmentSizeBits = MathUtils.log2strict(segmentSize)__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		_		this.buildSideWriteBuffer = new BuildSideBuffer(initialBuffer, memSource)__	};creates,a,new,partition,initially,in,memory,with,one,buffer,for,the,build,side,the,partition,is,initialized,to,expect,record,insertions,for,the,build,side,param,partition,number,the,number,of,the,partition,param,recursion,level,the,recursion,level,zero,for,partitions,from,the,initial,build,i,n,1,i,for,partitions,that,are,created,from,spilled,partition,with,recursion,level,i,n,i,param,initial,buffer,the,initial,buffer,for,this,partition;hash,partition,type,serializer,bt,build,side,accessors,type,serializer,pt,probe,side,accessors,int,partition,number,int,recursion,level,memory,segment,initial,buffer,memory,segment,source,mem,source,int,segment,size,super,0,this,build,side,serializer,build,side,accessors,this,probe,side,serializer,probe,side,accessors,this,partition,number,partition,number,this,recursion,level,recursion,level,this,memory,segment,size,segment,size,this,segment,size,bits,math,utils,log2strict,segment,size,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,build,side,write,buffer,new,build,side,buffer,initial,buffer,mem,source
HashPartition -> HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors, 			int partitionNumber, int recursionLevel, MemorySegment initialBuffer, MemorySegmentSource memSource, 			int segmentSize);1446633116;Creates a new partition, initially in memory, with one buffer for the build side. The partition is_initialized to expect record insertions for the build side.__@param partitionNumber The number of the partition._@param recursionLevel The recursion level - zero for partitions from the initial build, <i>n + 1</i> for_partitions that are created from spilled partition with recursion level <i>n</i>._@param initialBuffer The initial buffer for this partition.;HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors,_			int partitionNumber, int recursionLevel, MemorySegment initialBuffer, MemorySegmentSource memSource,_			int segmentSize)_	{_		super(0)__		_		this.buildSideSerializer = buildSideAccessors__		this.probeSideSerializer = probeSideAccessors__		this.partitionNumber = partitionNumber__		this.recursionLevel = recursionLevel__		_		this.memorySegmentSize = segmentSize__		this.segmentSizeBits = MathUtils.log2strict(segmentSize)__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		_		this.buildSideWriteBuffer = new BuildSideBuffer(initialBuffer, memSource)__	};creates,a,new,partition,initially,in,memory,with,one,buffer,for,the,build,side,the,partition,is,initialized,to,expect,record,insertions,for,the,build,side,param,partition,number,the,number,of,the,partition,param,recursion,level,the,recursion,level,zero,for,partitions,from,the,initial,build,i,n,1,i,for,partitions,that,are,created,from,spilled,partition,with,recursion,level,i,n,i,param,initial,buffer,the,initial,buffer,for,this,partition;hash,partition,type,serializer,bt,build,side,accessors,type,serializer,pt,probe,side,accessors,int,partition,number,int,recursion,level,memory,segment,initial,buffer,memory,segment,source,mem,source,int,segment,size,super,0,this,build,side,serializer,build,side,accessors,this,probe,side,serializer,probe,side,accessors,this,partition,number,partition,number,this,recursion,level,recursion,level,this,memory,segment,size,segment,size,this,segment,size,bits,math,utils,log2strict,segment,size,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,build,side,write,buffer,new,build,side,buffer,initial,buffer,mem,source
HashPartition -> HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors, 			int partitionNumber, int recursionLevel, MemorySegment initialBuffer, MemorySegmentSource memSource, 			int segmentSize);1456186722;Creates a new partition, initially in memory, with one buffer for the build side. The partition is_initialized to expect record insertions for the build side.__@param partitionNumber The number of the partition._@param recursionLevel The recursion level - zero for partitions from the initial build, <i>n + 1</i> for_partitions that are created from spilled partition with recursion level <i>n</i>._@param initialBuffer The initial buffer for this partition.;HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors,_			int partitionNumber, int recursionLevel, MemorySegment initialBuffer, MemorySegmentSource memSource,_			int segmentSize)_	{_		super(0)__		_		this.buildSideSerializer = buildSideAccessors__		this.probeSideSerializer = probeSideAccessors__		this.partitionNumber = partitionNumber__		this.recursionLevel = recursionLevel__		_		this.memorySegmentSize = segmentSize__		this.segmentSizeBits = MathUtils.log2strict(segmentSize)__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		_		this.buildSideWriteBuffer = new BuildSideBuffer(initialBuffer, memSource)__	};creates,a,new,partition,initially,in,memory,with,one,buffer,for,the,build,side,the,partition,is,initialized,to,expect,record,insertions,for,the,build,side,param,partition,number,the,number,of,the,partition,param,recursion,level,the,recursion,level,zero,for,partitions,from,the,initial,build,i,n,1,i,for,partitions,that,are,created,from,spilled,partition,with,recursion,level,i,n,i,param,initial,buffer,the,initial,buffer,for,this,partition;hash,partition,type,serializer,bt,build,side,accessors,type,serializer,pt,probe,side,accessors,int,partition,number,int,recursion,level,memory,segment,initial,buffer,memory,segment,source,mem,source,int,segment,size,super,0,this,build,side,serializer,build,side,accessors,this,probe,side,serializer,probe,side,accessors,this,partition,number,partition,number,this,recursion,level,recursion,level,this,memory,segment,size,segment,size,this,segment,size,bits,math,utils,log2strict,segment,size,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,build,side,write,buffer,new,build,side,buffer,initial,buffer,mem,source
HashPartition -> HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors, 			int partitionNumber, int recursionLevel, MemorySegment initialBuffer, MemorySegmentSource memSource, 			int segmentSize);1460741894;Creates a new partition, initially in memory, with one buffer for the build side. The partition is_initialized to expect record insertions for the build side.__@param partitionNumber The number of the partition._@param recursionLevel The recursion level - zero for partitions from the initial build, <i>n + 1</i> for_partitions that are created from spilled partition with recursion level <i>n</i>._@param initialBuffer The initial buffer for this partition.;HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors,_			int partitionNumber, int recursionLevel, MemorySegment initialBuffer, MemorySegmentSource memSource,_			int segmentSize)_	{_		super(0)__		_		this.buildSideSerializer = buildSideAccessors__		this.probeSideSerializer = probeSideAccessors__		this.partitionNumber = partitionNumber__		this.recursionLevel = recursionLevel__		_		this.memorySegmentSize = segmentSize__		this.segmentSizeBits = MathUtils.log2strict(segmentSize)__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		_		this.buildSideWriteBuffer = new BuildSideBuffer(initialBuffer, memSource)__	};creates,a,new,partition,initially,in,memory,with,one,buffer,for,the,build,side,the,partition,is,initialized,to,expect,record,insertions,for,the,build,side,param,partition,number,the,number,of,the,partition,param,recursion,level,the,recursion,level,zero,for,partitions,from,the,initial,build,i,n,1,i,for,partitions,that,are,created,from,spilled,partition,with,recursion,level,i,n,i,param,initial,buffer,the,initial,buffer,for,this,partition;hash,partition,type,serializer,bt,build,side,accessors,type,serializer,pt,probe,side,accessors,int,partition,number,int,recursion,level,memory,segment,initial,buffer,memory,segment,source,mem,source,int,segment,size,super,0,this,build,side,serializer,build,side,accessors,this,probe,side,serializer,probe,side,accessors,this,partition,number,partition,number,this,recursion,level,recursion,level,this,memory,segment,size,segment,size,this,segment,size,bits,math,utils,log2strict,segment,size,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,build,side,write,buffer,new,build,side,buffer,initial,buffer,mem,source
HashPartition -> public final long insertIntoBuildBuffer(BT record) throws IOException;1405024514;Inserts the given object into the current buffer. This method returns a pointer that_can be used to address the written record in this partition, if it is in-memory. The returned_pointers have no expressiveness in the case where the partition is spilled.__@param record The object to be written to the partition._@return A pointer to the object in the partition, or <code>-1</code>, if the partition is spilled._@throws IOException Thrown, when this is a spilled partition and the write failed.;public final long insertIntoBuildBuffer(BT record) throws IOException_	{_		this.buildSideRecordCounter++__		_		if (isInMemory()) {_			final long pointer = this.buildSideWriteBuffer.getCurrentPointer()__			this.buildSideSerializer.serialize(record, this.buildSideWriteBuffer)__			return isInMemory() ? pointer : -1__		} else {_			this.buildSideSerializer.serialize(record, this.buildSideWriteBuffer)__			return -1__		}_	};inserts,the,given,object,into,the,current,buffer,this,method,returns,a,pointer,that,can,be,used,to,address,the,written,record,in,this,partition,if,it,is,in,memory,the,returned,pointers,have,no,expressiveness,in,the,case,where,the,partition,is,spilled,param,record,the,object,to,be,written,to,the,partition,return,a,pointer,to,the,object,in,the,partition,or,code,1,code,if,the,partition,is,spilled,throws,ioexception,thrown,when,this,is,a,spilled,partition,and,the,write,failed;public,final,long,insert,into,build,buffer,bt,record,throws,ioexception,this,build,side,record,counter,if,is,in,memory,final,long,pointer,this,build,side,write,buffer,get,current,pointer,this,build,side,serializer,serialize,record,this,build,side,write,buffer,return,is,in,memory,pointer,1,else,this,build,side,serializer,serialize,record,this,build,side,write,buffer,return,1
HashPartition -> public final long insertIntoBuildBuffer(BT record) throws IOException;1405090423;Inserts the given object into the current buffer. This method returns a pointer that_can be used to address the written record in this partition, if it is in-memory. The returned_pointers have no expressiveness in the case where the partition is spilled.__@param record The object to be written to the partition._@return A pointer to the object in the partition, or <code>-1</code>, if the partition is spilled._@throws IOException Thrown, when this is a spilled partition and the write failed.;public final long insertIntoBuildBuffer(BT record) throws IOException_	{_		this.buildSideRecordCounter++__		_		if (isInMemory()) {_			final long pointer = this.buildSideWriteBuffer.getCurrentPointer()__			this.buildSideSerializer.serialize(record, this.buildSideWriteBuffer)__			return isInMemory() ? pointer : -1__		} else {_			this.buildSideSerializer.serialize(record, this.buildSideWriteBuffer)__			return -1__		}_	};inserts,the,given,object,into,the,current,buffer,this,method,returns,a,pointer,that,can,be,used,to,address,the,written,record,in,this,partition,if,it,is,in,memory,the,returned,pointers,have,no,expressiveness,in,the,case,where,the,partition,is,spilled,param,record,the,object,to,be,written,to,the,partition,return,a,pointer,to,the,object,in,the,partition,or,code,1,code,if,the,partition,is,spilled,throws,ioexception,thrown,when,this,is,a,spilled,partition,and,the,write,failed;public,final,long,insert,into,build,buffer,bt,record,throws,ioexception,this,build,side,record,counter,if,is,in,memory,final,long,pointer,this,build,side,write,buffer,get,current,pointer,this,build,side,serializer,serialize,record,this,build,side,write,buffer,return,is,in,memory,pointer,1,else,this,build,side,serializer,serialize,record,this,build,side,write,buffer,return,1
HashPartition -> public final long insertIntoBuildBuffer(BT record) throws IOException;1411473593;Inserts the given object into the current buffer. This method returns a pointer that_can be used to address the written record in this partition, if it is in-memory. The returned_pointers have no expressiveness in the case where the partition is spilled.__@param record The object to be written to the partition._@return A pointer to the object in the partition, or <code>-1</code>, if the partition is spilled._@throws IOException Thrown, when this is a spilled partition and the write failed.;public final long insertIntoBuildBuffer(BT record) throws IOException_	{_		this.buildSideRecordCounter++__		_		if (isInMemory()) {_			final long pointer = this.buildSideWriteBuffer.getCurrentPointer()__			this.buildSideSerializer.serialize(record, this.buildSideWriteBuffer)__			return isInMemory() ? pointer : -1__		} else {_			this.buildSideSerializer.serialize(record, this.buildSideWriteBuffer)__			return -1__		}_	};inserts,the,given,object,into,the,current,buffer,this,method,returns,a,pointer,that,can,be,used,to,address,the,written,record,in,this,partition,if,it,is,in,memory,the,returned,pointers,have,no,expressiveness,in,the,case,where,the,partition,is,spilled,param,record,the,object,to,be,written,to,the,partition,return,a,pointer,to,the,object,in,the,partition,or,code,1,code,if,the,partition,is,spilled,throws,ioexception,thrown,when,this,is,a,spilled,partition,and,the,write,failed;public,final,long,insert,into,build,buffer,bt,record,throws,ioexception,this,build,side,record,counter,if,is,in,memory,final,long,pointer,this,build,side,write,buffer,get,current,pointer,this,build,side,serializer,serialize,record,this,build,side,write,buffer,return,is,in,memory,pointer,1,else,this,build,side,serializer,serialize,record,this,build,side,write,buffer,return,1
HashPartition -> public final long insertIntoBuildBuffer(BT record) throws IOException;1412164980;Inserts the given object into the current buffer. This method returns a pointer that_can be used to address the written record in this partition, if it is in-memory. The returned_pointers have no expressiveness in the case where the partition is spilled.__@param record The object to be written to the partition._@return A pointer to the object in the partition, or <code>-1</code>, if the partition is spilled._@throws IOException Thrown, when this is a spilled partition and the write failed.;public final long insertIntoBuildBuffer(BT record) throws IOException_	{_		this.buildSideRecordCounter++__		_		if (isInMemory()) {_			final long pointer = this.buildSideWriteBuffer.getCurrentPointer()__			this.buildSideSerializer.serialize(record, this.buildSideWriteBuffer)__			return isInMemory() ? pointer : -1__		} else {_			this.buildSideSerializer.serialize(record, this.buildSideWriteBuffer)__			return -1__		}_	};inserts,the,given,object,into,the,current,buffer,this,method,returns,a,pointer,that,can,be,used,to,address,the,written,record,in,this,partition,if,it,is,in,memory,the,returned,pointers,have,no,expressiveness,in,the,case,where,the,partition,is,spilled,param,record,the,object,to,be,written,to,the,partition,return,a,pointer,to,the,object,in,the,partition,or,code,1,code,if,the,partition,is,spilled,throws,ioexception,thrown,when,this,is,a,spilled,partition,and,the,write,failed;public,final,long,insert,into,build,buffer,bt,record,throws,ioexception,this,build,side,record,counter,if,is,in,memory,final,long,pointer,this,build,side,write,buffer,get,current,pointer,this,build,side,serializer,serialize,record,this,build,side,write,buffer,return,is,in,memory,pointer,1,else,this,build,side,serializer,serialize,record,this,build,side,write,buffer,return,1
HashPartition -> public final long insertIntoBuildBuffer(BT record) throws IOException;1414786554;Inserts the given object into the current buffer. This method returns a pointer that_can be used to address the written record in this partition, if it is in-memory. The returned_pointers have no expressiveness in the case where the partition is spilled.__@param record The object to be written to the partition._@return A pointer to the object in the partition, or <code>-1</code>, if the partition is spilled._@throws IOException Thrown, when this is a spilled partition and the write failed.;public final long insertIntoBuildBuffer(BT record) throws IOException_	{_		this.buildSideRecordCounter++__		_		if (isInMemory()) {_			final long pointer = this.buildSideWriteBuffer.getCurrentPointer()__			this.buildSideSerializer.serialize(record, this.buildSideWriteBuffer)__			return isInMemory() ? pointer : -1__		} else {_			this.buildSideSerializer.serialize(record, this.buildSideWriteBuffer)__			return -1__		}_	};inserts,the,given,object,into,the,current,buffer,this,method,returns,a,pointer,that,can,be,used,to,address,the,written,record,in,this,partition,if,it,is,in,memory,the,returned,pointers,have,no,expressiveness,in,the,case,where,the,partition,is,spilled,param,record,the,object,to,be,written,to,the,partition,return,a,pointer,to,the,object,in,the,partition,or,code,1,code,if,the,partition,is,spilled,throws,ioexception,thrown,when,this,is,a,spilled,partition,and,the,write,failed;public,final,long,insert,into,build,buffer,bt,record,throws,ioexception,this,build,side,record,counter,if,is,in,memory,final,long,pointer,this,build,side,write,buffer,get,current,pointer,this,build,side,serializer,serialize,record,this,build,side,write,buffer,return,is,in,memory,pointer,1,else,this,build,side,serializer,serialize,record,this,build,side,write,buffer,return,1
HashPartition -> public final long insertIntoBuildBuffer(BT record) throws IOException;1415702894;Inserts the given object into the current buffer. This method returns a pointer that_can be used to address the written record in this partition, if it is in-memory. The returned_pointers have no expressiveness in the case where the partition is spilled.__@param record The object to be written to the partition._@return A pointer to the object in the partition, or <code>-1</code>, if the partition is spilled._@throws IOException Thrown, when this is a spilled partition and the write failed.;public final long insertIntoBuildBuffer(BT record) throws IOException_	{_		this.buildSideRecordCounter++__		_		if (isInMemory()) {_			final long pointer = this.buildSideWriteBuffer.getCurrentPointer()__			this.buildSideSerializer.serialize(record, this.buildSideWriteBuffer)__			return isInMemory() ? pointer : -1__		} else {_			this.buildSideSerializer.serialize(record, this.buildSideWriteBuffer)__			return -1__		}_	};inserts,the,given,object,into,the,current,buffer,this,method,returns,a,pointer,that,can,be,used,to,address,the,written,record,in,this,partition,if,it,is,in,memory,the,returned,pointers,have,no,expressiveness,in,the,case,where,the,partition,is,spilled,param,record,the,object,to,be,written,to,the,partition,return,a,pointer,to,the,object,in,the,partition,or,code,1,code,if,the,partition,is,spilled,throws,ioexception,thrown,when,this,is,a,spilled,partition,and,the,write,failed;public,final,long,insert,into,build,buffer,bt,record,throws,ioexception,this,build,side,record,counter,if,is,in,memory,final,long,pointer,this,build,side,write,buffer,get,current,pointer,this,build,side,serializer,serialize,record,this,build,side,write,buffer,return,is,in,memory,pointer,1,else,this,build,side,serializer,serialize,record,this,build,side,write,buffer,return,1
HashPartition -> public final long insertIntoBuildBuffer(BT record) throws IOException;1418570573;Inserts the given object into the current buffer. This method returns a pointer that_can be used to address the written record in this partition, if it is in-memory. The returned_pointers have no expressiveness in the case where the partition is spilled.__@param record The object to be written to the partition._@return A pointer to the object in the partition, or <code>-1</code>, if the partition is spilled._@throws IOException Thrown, when this is a spilled partition and the write failed.;public final long insertIntoBuildBuffer(BT record) throws IOException_	{_		this.buildSideRecordCounter++__		_		if (isInMemory()) {_			final long pointer = this.buildSideWriteBuffer.getCurrentPointer()__			this.buildSideSerializer.serialize(record, this.buildSideWriteBuffer)__			return isInMemory() ? pointer : -1__		} else {_			this.buildSideSerializer.serialize(record, this.buildSideWriteBuffer)__			return -1__		}_	};inserts,the,given,object,into,the,current,buffer,this,method,returns,a,pointer,that,can,be,used,to,address,the,written,record,in,this,partition,if,it,is,in,memory,the,returned,pointers,have,no,expressiveness,in,the,case,where,the,partition,is,spilled,param,record,the,object,to,be,written,to,the,partition,return,a,pointer,to,the,object,in,the,partition,or,code,1,code,if,the,partition,is,spilled,throws,ioexception,thrown,when,this,is,a,spilled,partition,and,the,write,failed;public,final,long,insert,into,build,buffer,bt,record,throws,ioexception,this,build,side,record,counter,if,is,in,memory,final,long,pointer,this,build,side,write,buffer,get,current,pointer,this,build,side,serializer,serialize,record,this,build,side,write,buffer,return,is,in,memory,pointer,1,else,this,build,side,serializer,serialize,record,this,build,side,write,buffer,return,1
HashPartition -> public final long insertIntoBuildBuffer(BT record) throws IOException;1420654570;Inserts the given object into the current buffer. This method returns a pointer that_can be used to address the written record in this partition, if it is in-memory. The returned_pointers have no expressiveness in the case where the partition is spilled.__@param record The object to be written to the partition._@return A pointer to the object in the partition, or <code>-1</code>, if the partition is spilled._@throws IOException Thrown, when this is a spilled partition and the write failed.;public final long insertIntoBuildBuffer(BT record) throws IOException_	{_		this.buildSideRecordCounter++__		_		if (isInMemory()) {_			final long pointer = this.buildSideWriteBuffer.getCurrentPointer()__			this.buildSideSerializer.serialize(record, this.buildSideWriteBuffer)__			return isInMemory() ? pointer : -1__		} else {_			this.buildSideSerializer.serialize(record, this.buildSideWriteBuffer)__			return -1__		}_	};inserts,the,given,object,into,the,current,buffer,this,method,returns,a,pointer,that,can,be,used,to,address,the,written,record,in,this,partition,if,it,is,in,memory,the,returned,pointers,have,no,expressiveness,in,the,case,where,the,partition,is,spilled,param,record,the,object,to,be,written,to,the,partition,return,a,pointer,to,the,object,in,the,partition,or,code,1,code,if,the,partition,is,spilled,throws,ioexception,thrown,when,this,is,a,spilled,partition,and,the,write,failed;public,final,long,insert,into,build,buffer,bt,record,throws,ioexception,this,build,side,record,counter,if,is,in,memory,final,long,pointer,this,build,side,write,buffer,get,current,pointer,this,build,side,serializer,serialize,record,this,build,side,write,buffer,return,is,in,memory,pointer,1,else,this,build,side,serializer,serialize,record,this,build,side,write,buffer,return,1
HashPartition -> public final long insertIntoBuildBuffer(BT record) throws IOException;1420663430;Inserts the given object into the current buffer. This method returns a pointer that_can be used to address the written record in this partition, if it is in-memory. The returned_pointers have no expressiveness in the case where the partition is spilled.__@param record The object to be written to the partition._@return A pointer to the object in the partition, or <code>-1</code>, if the partition is spilled._@throws IOException Thrown, when this is a spilled partition and the write failed.;public final long insertIntoBuildBuffer(BT record) throws IOException_	{_		this.buildSideRecordCounter++__		_		if (isInMemory()) {_			final long pointer = this.buildSideWriteBuffer.getCurrentPointer()__			this.buildSideSerializer.serialize(record, this.buildSideWriteBuffer)__			return isInMemory() ? pointer : -1__		} else {_			this.buildSideSerializer.serialize(record, this.buildSideWriteBuffer)__			return -1__		}_	};inserts,the,given,object,into,the,current,buffer,this,method,returns,a,pointer,that,can,be,used,to,address,the,written,record,in,this,partition,if,it,is,in,memory,the,returned,pointers,have,no,expressiveness,in,the,case,where,the,partition,is,spilled,param,record,the,object,to,be,written,to,the,partition,return,a,pointer,to,the,object,in,the,partition,or,code,1,code,if,the,partition,is,spilled,throws,ioexception,thrown,when,this,is,a,spilled,partition,and,the,write,failed;public,final,long,insert,into,build,buffer,bt,record,throws,ioexception,this,build,side,record,counter,if,is,in,memory,final,long,pointer,this,build,side,write,buffer,get,current,pointer,this,build,side,serializer,serialize,record,this,build,side,write,buffer,return,is,in,memory,pointer,1,else,this,build,side,serializer,serialize,record,this,build,side,write,buffer,return,1
HashPartition -> public final long insertIntoBuildBuffer(BT record) throws IOException;1426697080;Inserts the given object into the current buffer. This method returns a pointer that_can be used to address the written record in this partition, if it is in-memory. The returned_pointers have no expressiveness in the case where the partition is spilled.__@param record The object to be written to the partition._@return A pointer to the object in the partition, or <code>-1</code>, if the partition is spilled._@throws IOException Thrown, when this is a spilled partition and the write failed.;public final long insertIntoBuildBuffer(BT record) throws IOException_	{_		this.buildSideRecordCounter++__		_		if (isInMemory()) {_			final long pointer = this.buildSideWriteBuffer.getCurrentPointer()__			this.buildSideSerializer.serialize(record, this.buildSideWriteBuffer)__			return isInMemory() ? pointer : -1__		} else {_			this.buildSideSerializer.serialize(record, this.buildSideWriteBuffer)__			return -1__		}_	};inserts,the,given,object,into,the,current,buffer,this,method,returns,a,pointer,that,can,be,used,to,address,the,written,record,in,this,partition,if,it,is,in,memory,the,returned,pointers,have,no,expressiveness,in,the,case,where,the,partition,is,spilled,param,record,the,object,to,be,written,to,the,partition,return,a,pointer,to,the,object,in,the,partition,or,code,1,code,if,the,partition,is,spilled,throws,ioexception,thrown,when,this,is,a,spilled,partition,and,the,write,failed;public,final,long,insert,into,build,buffer,bt,record,throws,ioexception,this,build,side,record,counter,if,is,in,memory,final,long,pointer,this,build,side,write,buffer,get,current,pointer,this,build,side,serializer,serialize,record,this,build,side,write,buffer,return,is,in,memory,pointer,1,else,this,build,side,serializer,serialize,record,this,build,side,write,buffer,return,1
HashPartition -> public final long insertIntoBuildBuffer(BT record) throws IOException;1440607697;Inserts the given object into the current buffer. This method returns a pointer that_can be used to address the written record in this partition, if it is in-memory. The returned_pointers have no expressiveness in the case where the partition is spilled.__@param record The object to be written to the partition._@return A pointer to the object in the partition, or <code>-1</code>, if the partition is spilled._@throws IOException Thrown, when this is a spilled partition and the write failed.;public final long insertIntoBuildBuffer(BT record) throws IOException {_		this.buildSideRecordCounter++__		_		if (isInMemory()) {_			final long pointer = this.buildSideWriteBuffer.getCurrentPointer()__			this.buildSideSerializer.serialize(record, this.buildSideWriteBuffer)__			return isInMemory() ? pointer : -1__		} else {_			this.buildSideSerializer.serialize(record, this.buildSideWriteBuffer)__			return -1__		}_	};inserts,the,given,object,into,the,current,buffer,this,method,returns,a,pointer,that,can,be,used,to,address,the,written,record,in,this,partition,if,it,is,in,memory,the,returned,pointers,have,no,expressiveness,in,the,case,where,the,partition,is,spilled,param,record,the,object,to,be,written,to,the,partition,return,a,pointer,to,the,object,in,the,partition,or,code,1,code,if,the,partition,is,spilled,throws,ioexception,thrown,when,this,is,a,spilled,partition,and,the,write,failed;public,final,long,insert,into,build,buffer,bt,record,throws,ioexception,this,build,side,record,counter,if,is,in,memory,final,long,pointer,this,build,side,write,buffer,get,current,pointer,this,build,side,serializer,serialize,record,this,build,side,write,buffer,return,is,in,memory,pointer,1,else,this,build,side,serializer,serialize,record,this,build,side,write,buffer,return,1
HashPartition -> public final long insertIntoBuildBuffer(BT record) throws IOException;1441738685;Inserts the given object into the current buffer. This method returns a pointer that_can be used to address the written record in this partition, if it is in-memory. The returned_pointers have no expressiveness in the case where the partition is spilled.__@param record The object to be written to the partition._@return A pointer to the object in the partition, or <code>-1</code>, if the partition is spilled._@throws IOException Thrown, when this is a spilled partition and the write failed.;public final long insertIntoBuildBuffer(BT record) throws IOException {_		this.buildSideRecordCounter++__		_		if (isInMemory()) {_			final long pointer = this.buildSideWriteBuffer.getCurrentPointer()__			this.buildSideSerializer.serialize(record, this.buildSideWriteBuffer)__			return isInMemory() ? pointer : -1__		} else {_			this.buildSideSerializer.serialize(record, this.buildSideWriteBuffer)__			return -1__		}_	};inserts,the,given,object,into,the,current,buffer,this,method,returns,a,pointer,that,can,be,used,to,address,the,written,record,in,this,partition,if,it,is,in,memory,the,returned,pointers,have,no,expressiveness,in,the,case,where,the,partition,is,spilled,param,record,the,object,to,be,written,to,the,partition,return,a,pointer,to,the,object,in,the,partition,or,code,1,code,if,the,partition,is,spilled,throws,ioexception,thrown,when,this,is,a,spilled,partition,and,the,write,failed;public,final,long,insert,into,build,buffer,bt,record,throws,ioexception,this,build,side,record,counter,if,is,in,memory,final,long,pointer,this,build,side,write,buffer,get,current,pointer,this,build,side,serializer,serialize,record,this,build,side,write,buffer,return,is,in,memory,pointer,1,else,this,build,side,serializer,serialize,record,this,build,side,write,buffer,return,1
HashPartition -> public final long insertIntoBuildBuffer(BT record) throws IOException;1443528421;Inserts the given object into the current buffer. This method returns a pointer that_can be used to address the written record in this partition, if it is in-memory. The returned_pointers have no expressiveness in the case where the partition is spilled.__@param record The object to be written to the partition._@return A pointer to the object in the partition, or <code>-1</code>, if the partition is spilled._@throws IOException Thrown, when this is a spilled partition and the write failed.;public final long insertIntoBuildBuffer(BT record) throws IOException {_		this.buildSideRecordCounter++__		_		if (isInMemory()) {_			final long pointer = this.buildSideWriteBuffer.getCurrentPointer()__			this.buildSideSerializer.serialize(record, this.buildSideWriteBuffer)__			return isInMemory() ? pointer : -1__		} else {_			this.buildSideSerializer.serialize(record, this.buildSideWriteBuffer)__			return -1__		}_	};inserts,the,given,object,into,the,current,buffer,this,method,returns,a,pointer,that,can,be,used,to,address,the,written,record,in,this,partition,if,it,is,in,memory,the,returned,pointers,have,no,expressiveness,in,the,case,where,the,partition,is,spilled,param,record,the,object,to,be,written,to,the,partition,return,a,pointer,to,the,object,in,the,partition,or,code,1,code,if,the,partition,is,spilled,throws,ioexception,thrown,when,this,is,a,spilled,partition,and,the,write,failed;public,final,long,insert,into,build,buffer,bt,record,throws,ioexception,this,build,side,record,counter,if,is,in,memory,final,long,pointer,this,build,side,write,buffer,get,current,pointer,this,build,side,serializer,serialize,record,this,build,side,write,buffer,return,is,in,memory,pointer,1,else,this,build,side,serializer,serialize,record,this,build,side,write,buffer,return,1
HashPartition -> public final long insertIntoBuildBuffer(BT record) throws IOException;1446633116;Inserts the given object into the current buffer. This method returns a pointer that_can be used to address the written record in this partition, if it is in-memory. The returned_pointers have no expressiveness in the case where the partition is spilled.__@param record The object to be written to the partition._@return A pointer to the object in the partition, or <code>-1</code>, if the partition is spilled._@throws IOException Thrown, when this is a spilled partition and the write failed.;public final long insertIntoBuildBuffer(BT record) throws IOException {_		this.buildSideRecordCounter++__		_		if (isInMemory()) {_			final long pointer = this.buildSideWriteBuffer.getCurrentPointer()__			this.buildSideSerializer.serialize(record, this.buildSideWriteBuffer)__			return isInMemory() ? pointer : -1__		} else {_			this.buildSideSerializer.serialize(record, this.buildSideWriteBuffer)__			return -1__		}_	};inserts,the,given,object,into,the,current,buffer,this,method,returns,a,pointer,that,can,be,used,to,address,the,written,record,in,this,partition,if,it,is,in,memory,the,returned,pointers,have,no,expressiveness,in,the,case,where,the,partition,is,spilled,param,record,the,object,to,be,written,to,the,partition,return,a,pointer,to,the,object,in,the,partition,or,code,1,code,if,the,partition,is,spilled,throws,ioexception,thrown,when,this,is,a,spilled,partition,and,the,write,failed;public,final,long,insert,into,build,buffer,bt,record,throws,ioexception,this,build,side,record,counter,if,is,in,memory,final,long,pointer,this,build,side,write,buffer,get,current,pointer,this,build,side,serializer,serialize,record,this,build,side,write,buffer,return,is,in,memory,pointer,1,else,this,build,side,serializer,serialize,record,this,build,side,write,buffer,return,1
HashPartition -> public final long insertIntoBuildBuffer(BT record) throws IOException;1456186722;Inserts the given object into the current buffer. This method returns a pointer that_can be used to address the written record in this partition, if it is in-memory. The returned_pointers have no expressiveness in the case where the partition is spilled.__@param record The object to be written to the partition._@return A pointer to the object in the partition, or <code>-1</code>, if the partition is spilled._@throws IOException Thrown, when this is a spilled partition and the write failed.;public final long insertIntoBuildBuffer(BT record) throws IOException {_		this.buildSideRecordCounter++__		_		if (isInMemory()) {_			final long pointer = this.buildSideWriteBuffer.getCurrentPointer()__			this.buildSideSerializer.serialize(record, this.buildSideWriteBuffer)__			return isInMemory() ? pointer : -1__		} else {_			this.buildSideSerializer.serialize(record, this.buildSideWriteBuffer)__			return -1__		}_	};inserts,the,given,object,into,the,current,buffer,this,method,returns,a,pointer,that,can,be,used,to,address,the,written,record,in,this,partition,if,it,is,in,memory,the,returned,pointers,have,no,expressiveness,in,the,case,where,the,partition,is,spilled,param,record,the,object,to,be,written,to,the,partition,return,a,pointer,to,the,object,in,the,partition,or,code,1,code,if,the,partition,is,spilled,throws,ioexception,thrown,when,this,is,a,spilled,partition,and,the,write,failed;public,final,long,insert,into,build,buffer,bt,record,throws,ioexception,this,build,side,record,counter,if,is,in,memory,final,long,pointer,this,build,side,write,buffer,get,current,pointer,this,build,side,serializer,serialize,record,this,build,side,write,buffer,return,is,in,memory,pointer,1,else,this,build,side,serializer,serialize,record,this,build,side,write,buffer,return,1
HashPartition -> public final long insertIntoBuildBuffer(BT record) throws IOException;1460741894;Inserts the given object into the current buffer. This method returns a pointer that_can be used to address the written record in this partition, if it is in-memory. The returned_pointers have no expressiveness in the case where the partition is spilled.__@param record The object to be written to the partition._@return A pointer to the object in the partition, or <code>-1</code>, if the partition is spilled._@throws IOException Thrown, when this is a spilled partition and the write failed.;public final long insertIntoBuildBuffer(BT record) throws IOException {_		this.buildSideRecordCounter++__		_		if (isInMemory()) {_			final long pointer = this.buildSideWriteBuffer.getCurrentPointer()__			this.buildSideSerializer.serialize(record, this.buildSideWriteBuffer)__			return isInMemory() ? pointer : -1__		} else {_			this.buildSideSerializer.serialize(record, this.buildSideWriteBuffer)__			return -1__		}_	};inserts,the,given,object,into,the,current,buffer,this,method,returns,a,pointer,that,can,be,used,to,address,the,written,record,in,this,partition,if,it,is,in,memory,the,returned,pointers,have,no,expressiveness,in,the,case,where,the,partition,is,spilled,param,record,the,object,to,be,written,to,the,partition,return,a,pointer,to,the,object,in,the,partition,or,code,1,code,if,the,partition,is,spilled,throws,ioexception,thrown,when,this,is,a,spilled,partition,and,the,write,failed;public,final,long,insert,into,build,buffer,bt,record,throws,ioexception,this,build,side,record,counter,if,is,in,memory,final,long,pointer,this,build,side,write,buffer,get,current,pointer,this,build,side,serializer,serialize,record,this,build,side,write,buffer,return,is,in,memory,pointer,1,else,this,build,side,serializer,serialize,record,this,build,side,write,buffer,return,1
HashPartition -> public int getPartitionNumber();1405024514;Gets the partition number of this partition.__@return This partition's number.;public int getPartitionNumber() {_		return this.partitionNumber__	};gets,the,partition,number,of,this,partition,return,this,partition,s,number;public,int,get,partition,number,return,this,partition,number
HashPartition -> public int getPartitionNumber();1405090423;Gets the partition number of this partition.__@return This partition's number.;public int getPartitionNumber() {_		return this.partitionNumber__	};gets,the,partition,number,of,this,partition,return,this,partition,s,number;public,int,get,partition,number,return,this,partition,number
HashPartition -> public int getPartitionNumber();1411473593;Gets the partition number of this partition.__@return This partition's number.;public int getPartitionNumber() {_		return this.partitionNumber__	};gets,the,partition,number,of,this,partition,return,this,partition,s,number;public,int,get,partition,number,return,this,partition,number
HashPartition -> public int getPartitionNumber();1412164980;Gets the partition number of this partition.__@return This partition's number.;public int getPartitionNumber() {_		return this.partitionNumber__	};gets,the,partition,number,of,this,partition,return,this,partition,s,number;public,int,get,partition,number,return,this,partition,number
HashPartition -> public int getPartitionNumber();1414786554;Gets the partition number of this partition.__@return This partition's number.;public int getPartitionNumber() {_		return this.partitionNumber__	};gets,the,partition,number,of,this,partition,return,this,partition,s,number;public,int,get,partition,number,return,this,partition,number
HashPartition -> public int getPartitionNumber();1415702894;Gets the partition number of this partition.__@return This partition's number.;public int getPartitionNumber() {_		return this.partitionNumber__	};gets,the,partition,number,of,this,partition,return,this,partition,s,number;public,int,get,partition,number,return,this,partition,number
HashPartition -> public int getPartitionNumber();1418570573;Gets the partition number of this partition.__@return This partition's number.;public int getPartitionNumber() {_		return this.partitionNumber__	};gets,the,partition,number,of,this,partition,return,this,partition,s,number;public,int,get,partition,number,return,this,partition,number
HashPartition -> public int getPartitionNumber();1420654570;Gets the partition number of this partition.__@return This partition's number.;public int getPartitionNumber() {_		return this.partitionNumber__	};gets,the,partition,number,of,this,partition,return,this,partition,s,number;public,int,get,partition,number,return,this,partition,number
HashPartition -> public int getPartitionNumber();1420663430;Gets the partition number of this partition.__@return This partition's number.;public int getPartitionNumber() {_		return this.partitionNumber__	};gets,the,partition,number,of,this,partition,return,this,partition,s,number;public,int,get,partition,number,return,this,partition,number
HashPartition -> public int getPartitionNumber();1426697080;Gets the partition number of this partition.__@return This partition's number.;public int getPartitionNumber() {_		return this.partitionNumber__	};gets,the,partition,number,of,this,partition,return,this,partition,s,number;public,int,get,partition,number,return,this,partition,number
HashPartition -> public int getPartitionNumber();1440607697;Gets the partition number of this partition.__@return This partition's number.;public int getPartitionNumber() {_		return this.partitionNumber__	};gets,the,partition,number,of,this,partition,return,this,partition,s,number;public,int,get,partition,number,return,this,partition,number
HashPartition -> public int getPartitionNumber();1441738685;Gets the partition number of this partition.__@return This partition's number.;public int getPartitionNumber() {_		return this.partitionNumber__	};gets,the,partition,number,of,this,partition,return,this,partition,s,number;public,int,get,partition,number,return,this,partition,number
HashPartition -> public int getPartitionNumber();1443528421;Gets the partition number of this partition.__@return This partition's number.;public int getPartitionNumber() {_		return this.partitionNumber__	};gets,the,partition,number,of,this,partition,return,this,partition,s,number;public,int,get,partition,number,return,this,partition,number
HashPartition -> public int getPartitionNumber();1446633116;Gets the partition number of this partition.__@return This partition's number.;public int getPartitionNumber() {_		return this.partitionNumber__	};gets,the,partition,number,of,this,partition,return,this,partition,s,number;public,int,get,partition,number,return,this,partition,number
HashPartition -> public int getPartitionNumber();1456186722;Gets the partition number of this partition.__@return This partition's number.;public int getPartitionNumber() {_		return this.partitionNumber__	};gets,the,partition,number,of,this,partition,return,this,partition,s,number;public,int,get,partition,number,return,this,partition,number
HashPartition -> public int getPartitionNumber();1460741894;Gets the partition number of this partition.__@return This partition's number.;public int getPartitionNumber() {_		return this.partitionNumber__	};gets,the,partition,number,of,this,partition,return,this,partition,s,number;public,int,get,partition,number,return,this,partition,number
HashPartition -> public int spillPartition(List<MemorySegment> target, IOManager ioAccess, Channel.ID targetChannel, 			LinkedBlockingQueue<MemorySegment> bufferReturnQueue) 	throws IOException;1405024514;Spills this partition to disk and sets it up such that it continues spilling records that are added to_it. The spilling process must free at least one buffer, either in the partition's record buffers, or in_the memory segments for overflow buckets._The partition immediately takes back one buffer to use it for further spilling.__@param target The list to which memory segments from overflow buckets are added._@param ioAccess The I/O manager to be used to create a writer to disk._@param targetChannel The id of the target channel for this partition._@return The number of buffers that were freed by spilling this partition._@throws IOException Thrown, if the writing failed.;public int spillPartition(List<MemorySegment> target, IOManager ioAccess, Channel.ID targetChannel,_			LinkedBlockingQueue<MemorySegment> bufferReturnQueue)_	throws IOException_	{_		_		if (!isInMemory()) {_			throw new RuntimeException("Bug in Hybrid Hash Join: " +_					"Request to spill a partition that has already been spilled.")__		}_		if (getBuildSideBlockCount() + this.numOverflowSegments < 2) {_			throw new RuntimeException("Bug in Hybrid Hash Join: " +_				"Request to spill a partition with less than two buffers.")__		}_		_		_		for (int i = 0_ i < this.numOverflowSegments_ i++) {_			target.add(this.overflowSegments[i])__		}_		this.overflowSegments = null__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		_		_		_		_		this.buildSideChannel = ioAccess.createBlockChannelWriter(targetChannel, bufferReturnQueue)__		return this.buildSideWriteBuffer.spill(this.buildSideChannel)__	};spills,this,partition,to,disk,and,sets,it,up,such,that,it,continues,spilling,records,that,are,added,to,it,the,spilling,process,must,free,at,least,one,buffer,either,in,the,partition,s,record,buffers,or,in,the,memory,segments,for,overflow,buckets,the,partition,immediately,takes,back,one,buffer,to,use,it,for,further,spilling,param,target,the,list,to,which,memory,segments,from,overflow,buckets,are,added,param,io,access,the,i,o,manager,to,be,used,to,create,a,writer,to,disk,param,target,channel,the,id,of,the,target,channel,for,this,partition,return,the,number,of,buffers,that,were,freed,by,spilling,this,partition,throws,ioexception,thrown,if,the,writing,failed;public,int,spill,partition,list,memory,segment,target,iomanager,io,access,channel,id,target,channel,linked,blocking,queue,memory,segment,buffer,return,queue,throws,ioexception,if,is,in,memory,throw,new,runtime,exception,bug,in,hybrid,hash,join,request,to,spill,a,partition,that,has,already,been,spilled,if,get,build,side,block,count,this,num,overflow,segments,2,throw,new,runtime,exception,bug,in,hybrid,hash,join,request,to,spill,a,partition,with,less,than,two,buffers,for,int,i,0,i,this,num,overflow,segments,i,target,add,this,overflow,segments,i,this,overflow,segments,null,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,build,side,channel,io,access,create,block,channel,writer,target,channel,buffer,return,queue,return,this,build,side,write,buffer,spill,this,build,side,channel
HashPartition -> public int spillPartition(List<MemorySegment> target, IOManager ioAccess, Channel.ID targetChannel, 			LinkedBlockingQueue<MemorySegment> bufferReturnQueue) 	throws IOException;1405090423;Spills this partition to disk and sets it up such that it continues spilling records that are added to_it. The spilling process must free at least one buffer, either in the partition's record buffers, or in_the memory segments for overflow buckets._The partition immediately takes back one buffer to use it for further spilling.__@param target The list to which memory segments from overflow buckets are added._@param ioAccess The I/O manager to be used to create a writer to disk._@param targetChannel The id of the target channel for this partition._@return The number of buffers that were freed by spilling this partition._@throws IOException Thrown, if the writing failed.;public int spillPartition(List<MemorySegment> target, IOManager ioAccess, Channel.ID targetChannel,_			LinkedBlockingQueue<MemorySegment> bufferReturnQueue)_	throws IOException_	{_		_		if (!isInMemory()) {_			throw new RuntimeException("Bug in Hybrid Hash Join: " +_					"Request to spill a partition that has already been spilled.")__		}_		if (getBuildSideBlockCount() + this.numOverflowSegments < 2) {_			throw new RuntimeException("Bug in Hybrid Hash Join: " +_				"Request to spill a partition with less than two buffers.")__		}_		_		_		for (int i = 0_ i < this.numOverflowSegments_ i++) {_			target.add(this.overflowSegments[i])__		}_		this.overflowSegments = null__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		_		_		_		_		this.buildSideChannel = ioAccess.createBlockChannelWriter(targetChannel, bufferReturnQueue)__		return this.buildSideWriteBuffer.spill(this.buildSideChannel)__	};spills,this,partition,to,disk,and,sets,it,up,such,that,it,continues,spilling,records,that,are,added,to,it,the,spilling,process,must,free,at,least,one,buffer,either,in,the,partition,s,record,buffers,or,in,the,memory,segments,for,overflow,buckets,the,partition,immediately,takes,back,one,buffer,to,use,it,for,further,spilling,param,target,the,list,to,which,memory,segments,from,overflow,buckets,are,added,param,io,access,the,i,o,manager,to,be,used,to,create,a,writer,to,disk,param,target,channel,the,id,of,the,target,channel,for,this,partition,return,the,number,of,buffers,that,were,freed,by,spilling,this,partition,throws,ioexception,thrown,if,the,writing,failed;public,int,spill,partition,list,memory,segment,target,iomanager,io,access,channel,id,target,channel,linked,blocking,queue,memory,segment,buffer,return,queue,throws,ioexception,if,is,in,memory,throw,new,runtime,exception,bug,in,hybrid,hash,join,request,to,spill,a,partition,that,has,already,been,spilled,if,get,build,side,block,count,this,num,overflow,segments,2,throw,new,runtime,exception,bug,in,hybrid,hash,join,request,to,spill,a,partition,with,less,than,two,buffers,for,int,i,0,i,this,num,overflow,segments,i,target,add,this,overflow,segments,i,this,overflow,segments,null,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,build,side,channel,io,access,create,block,channel,writer,target,channel,buffer,return,queue,return,this,build,side,write,buffer,spill,this,build,side,channel
HashPartition -> public int spillPartition(List<MemorySegment> target, IOManager ioAccess, Channel.ID targetChannel, 			LinkedBlockingQueue<MemorySegment> bufferReturnQueue) 	throws IOException;1411473593;Spills this partition to disk and sets it up such that it continues spilling records that are added to_it. The spilling process must free at least one buffer, either in the partition's record buffers, or in_the memory segments for overflow buckets._The partition immediately takes back one buffer to use it for further spilling.__@param target The list to which memory segments from overflow buckets are added._@param ioAccess The I/O manager to be used to create a writer to disk._@param targetChannel The id of the target channel for this partition._@return The number of buffers that were freed by spilling this partition._@throws IOException Thrown, if the writing failed.;public int spillPartition(List<MemorySegment> target, IOManager ioAccess, Channel.ID targetChannel,_			LinkedBlockingQueue<MemorySegment> bufferReturnQueue)_	throws IOException_	{_		_		if (!isInMemory()) {_			throw new RuntimeException("Bug in Hybrid Hash Join: " +_					"Request to spill a partition that has already been spilled.")__		}_		if (getBuildSideBlockCount() + this.numOverflowSegments < 2) {_			throw new RuntimeException("Bug in Hybrid Hash Join: " +_				"Request to spill a partition with less than two buffers.")__		}_		_		_		for (int i = 0_ i < this.numOverflowSegments_ i++) {_			target.add(this.overflowSegments[i])__		}_		this.overflowSegments = null__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		_		_		_		_		this.buildSideChannel = ioAccess.createBlockChannelWriter(targetChannel, bufferReturnQueue)__		return this.buildSideWriteBuffer.spill(this.buildSideChannel)__	};spills,this,partition,to,disk,and,sets,it,up,such,that,it,continues,spilling,records,that,are,added,to,it,the,spilling,process,must,free,at,least,one,buffer,either,in,the,partition,s,record,buffers,or,in,the,memory,segments,for,overflow,buckets,the,partition,immediately,takes,back,one,buffer,to,use,it,for,further,spilling,param,target,the,list,to,which,memory,segments,from,overflow,buckets,are,added,param,io,access,the,i,o,manager,to,be,used,to,create,a,writer,to,disk,param,target,channel,the,id,of,the,target,channel,for,this,partition,return,the,number,of,buffers,that,were,freed,by,spilling,this,partition,throws,ioexception,thrown,if,the,writing,failed;public,int,spill,partition,list,memory,segment,target,iomanager,io,access,channel,id,target,channel,linked,blocking,queue,memory,segment,buffer,return,queue,throws,ioexception,if,is,in,memory,throw,new,runtime,exception,bug,in,hybrid,hash,join,request,to,spill,a,partition,that,has,already,been,spilled,if,get,build,side,block,count,this,num,overflow,segments,2,throw,new,runtime,exception,bug,in,hybrid,hash,join,request,to,spill,a,partition,with,less,than,two,buffers,for,int,i,0,i,this,num,overflow,segments,i,target,add,this,overflow,segments,i,this,overflow,segments,null,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,build,side,channel,io,access,create,block,channel,writer,target,channel,buffer,return,queue,return,this,build,side,write,buffer,spill,this,build,side,channel
HashPartition -> public int spillPartition(List<MemorySegment> target, IOManager ioAccess, Channel.ID targetChannel, 			LinkedBlockingQueue<MemorySegment> bufferReturnQueue) 	throws IOException;1412164980;Spills this partition to disk and sets it up such that it continues spilling records that are added to_it. The spilling process must free at least one buffer, either in the partition's record buffers, or in_the memory segments for overflow buckets._The partition immediately takes back one buffer to use it for further spilling.__@param target The list to which memory segments from overflow buckets are added._@param ioAccess The I/O manager to be used to create a writer to disk._@param targetChannel The id of the target channel for this partition._@return The number of buffers that were freed by spilling this partition._@throws IOException Thrown, if the writing failed.;public int spillPartition(List<MemorySegment> target, IOManager ioAccess, Channel.ID targetChannel,_			LinkedBlockingQueue<MemorySegment> bufferReturnQueue)_	throws IOException_	{_		_		if (!isInMemory()) {_			throw new RuntimeException("Bug in Hybrid Hash Join: " +_					"Request to spill a partition that has already been spilled.")__		}_		if (getBuildSideBlockCount() + this.numOverflowSegments < 2) {_			throw new RuntimeException("Bug in Hybrid Hash Join: " +_				"Request to spill a partition with less than two buffers.")__		}_		_		_		for (int i = 0_ i < this.numOverflowSegments_ i++) {_			target.add(this.overflowSegments[i])__		}_		this.overflowSegments = null__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		_		_		_		_		this.buildSideChannel = ioAccess.createBlockChannelWriter(targetChannel, bufferReturnQueue)__		return this.buildSideWriteBuffer.spill(this.buildSideChannel)__	};spills,this,partition,to,disk,and,sets,it,up,such,that,it,continues,spilling,records,that,are,added,to,it,the,spilling,process,must,free,at,least,one,buffer,either,in,the,partition,s,record,buffers,or,in,the,memory,segments,for,overflow,buckets,the,partition,immediately,takes,back,one,buffer,to,use,it,for,further,spilling,param,target,the,list,to,which,memory,segments,from,overflow,buckets,are,added,param,io,access,the,i,o,manager,to,be,used,to,create,a,writer,to,disk,param,target,channel,the,id,of,the,target,channel,for,this,partition,return,the,number,of,buffers,that,were,freed,by,spilling,this,partition,throws,ioexception,thrown,if,the,writing,failed;public,int,spill,partition,list,memory,segment,target,iomanager,io,access,channel,id,target,channel,linked,blocking,queue,memory,segment,buffer,return,queue,throws,ioexception,if,is,in,memory,throw,new,runtime,exception,bug,in,hybrid,hash,join,request,to,spill,a,partition,that,has,already,been,spilled,if,get,build,side,block,count,this,num,overflow,segments,2,throw,new,runtime,exception,bug,in,hybrid,hash,join,request,to,spill,a,partition,with,less,than,two,buffers,for,int,i,0,i,this,num,overflow,segments,i,target,add,this,overflow,segments,i,this,overflow,segments,null,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,build,side,channel,io,access,create,block,channel,writer,target,channel,buffer,return,queue,return,this,build,side,write,buffer,spill,this,build,side,channel
HashPartition -> public int spillPartition(List<MemorySegment> target, IOManager ioAccess, Channel.ID targetChannel, 			LinkedBlockingQueue<MemorySegment> bufferReturnQueue) 	throws IOException;1414786554;Spills this partition to disk and sets it up such that it continues spilling records that are added to_it. The spilling process must free at least one buffer, either in the partition's record buffers, or in_the memory segments for overflow buckets._The partition immediately takes back one buffer to use it for further spilling.__@param target The list to which memory segments from overflow buckets are added._@param ioAccess The I/O manager to be used to create a writer to disk._@param targetChannel The id of the target channel for this partition._@return The number of buffers that were freed by spilling this partition._@throws IOException Thrown, if the writing failed.;public int spillPartition(List<MemorySegment> target, IOManager ioAccess, Channel.ID targetChannel,_			LinkedBlockingQueue<MemorySegment> bufferReturnQueue)_	throws IOException_	{_		_		if (!isInMemory()) {_			throw new RuntimeException("Bug in Hybrid Hash Join: " +_					"Request to spill a partition that has already been spilled.")__		}_		if (getBuildSideBlockCount() + this.numOverflowSegments < 2) {_			throw new RuntimeException("Bug in Hybrid Hash Join: " +_				"Request to spill a partition with less than two buffers.")__		}_		_		_		for (int i = 0_ i < this.numOverflowSegments_ i++) {_			target.add(this.overflowSegments[i])__		}_		this.overflowSegments = null__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		_		_		_		_		this.buildSideChannel = ioAccess.createBlockChannelWriter(targetChannel, bufferReturnQueue)__		return this.buildSideWriteBuffer.spill(this.buildSideChannel)__	};spills,this,partition,to,disk,and,sets,it,up,such,that,it,continues,spilling,records,that,are,added,to,it,the,spilling,process,must,free,at,least,one,buffer,either,in,the,partition,s,record,buffers,or,in,the,memory,segments,for,overflow,buckets,the,partition,immediately,takes,back,one,buffer,to,use,it,for,further,spilling,param,target,the,list,to,which,memory,segments,from,overflow,buckets,are,added,param,io,access,the,i,o,manager,to,be,used,to,create,a,writer,to,disk,param,target,channel,the,id,of,the,target,channel,for,this,partition,return,the,number,of,buffers,that,were,freed,by,spilling,this,partition,throws,ioexception,thrown,if,the,writing,failed;public,int,spill,partition,list,memory,segment,target,iomanager,io,access,channel,id,target,channel,linked,blocking,queue,memory,segment,buffer,return,queue,throws,ioexception,if,is,in,memory,throw,new,runtime,exception,bug,in,hybrid,hash,join,request,to,spill,a,partition,that,has,already,been,spilled,if,get,build,side,block,count,this,num,overflow,segments,2,throw,new,runtime,exception,bug,in,hybrid,hash,join,request,to,spill,a,partition,with,less,than,two,buffers,for,int,i,0,i,this,num,overflow,segments,i,target,add,this,overflow,segments,i,this,overflow,segments,null,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,build,side,channel,io,access,create,block,channel,writer,target,channel,buffer,return,queue,return,this,build,side,write,buffer,spill,this,build,side,channel
HashPartition -> public void finalizeBuildPhase(IOManager ioAccess, Channel.Enumerator probeChannelEnumerator, 			LinkedBlockingQueue<MemorySegment> bufferReturnQueue) 	throws IOException;1405024514;@param spilledPartitions_@param ioAccess_@param probeChannelEnumerator_@throws IOException;public void finalizeBuildPhase(IOManager ioAccess, Channel.Enumerator probeChannelEnumerator,_			LinkedBlockingQueue<MemorySegment> bufferReturnQueue)_	throws IOException_	{_		this.finalBufferLimit = this.buildSideWriteBuffer.getCurrentPositionInSegment()__		this.partitionBuffers = this.buildSideWriteBuffer.close()__		_		if (!isInMemory()) {_			_			_			this.buildSideChannel.close()__			_			_			this.probeSideChannel = ioAccess.createBlockChannelWriter(probeChannelEnumerator.next(), bufferReturnQueue)__			_			_			this.probeSideBuffer = new ChannelWriterOutputView(this.probeSideChannel, this.memorySegmentSize)__		}_	};param,spilled,partitions,param,io,access,param,probe,channel,enumerator,throws,ioexception;public,void,finalize,build,phase,iomanager,io,access,channel,enumerator,probe,channel,enumerator,linked,blocking,queue,memory,segment,buffer,return,queue,throws,ioexception,this,final,buffer,limit,this,build,side,write,buffer,get,current,position,in,segment,this,partition,buffers,this,build,side,write,buffer,close,if,is,in,memory,this,build,side,channel,close,this,probe,side,channel,io,access,create,block,channel,writer,probe,channel,enumerator,next,buffer,return,queue,this,probe,side,buffer,new,channel,writer,output,view,this,probe,side,channel,this,memory,segment,size
HashPartition -> public void finalizeBuildPhase(IOManager ioAccess, Channel.Enumerator probeChannelEnumerator, 			LinkedBlockingQueue<MemorySegment> bufferReturnQueue) 	throws IOException;1405090423;@param spilledPartitions_@param ioAccess_@param probeChannelEnumerator_@throws IOException;public void finalizeBuildPhase(IOManager ioAccess, Channel.Enumerator probeChannelEnumerator,_			LinkedBlockingQueue<MemorySegment> bufferReturnQueue)_	throws IOException_	{_		this.finalBufferLimit = this.buildSideWriteBuffer.getCurrentPositionInSegment()__		this.partitionBuffers = this.buildSideWriteBuffer.close()__		_		if (!isInMemory()) {_			_			_			this.buildSideChannel.close()__			_			_			this.probeSideChannel = ioAccess.createBlockChannelWriter(probeChannelEnumerator.next(), bufferReturnQueue)__			_			_			this.probeSideBuffer = new ChannelWriterOutputView(this.probeSideChannel, this.memorySegmentSize)__		}_	};param,spilled,partitions,param,io,access,param,probe,channel,enumerator,throws,ioexception;public,void,finalize,build,phase,iomanager,io,access,channel,enumerator,probe,channel,enumerator,linked,blocking,queue,memory,segment,buffer,return,queue,throws,ioexception,this,final,buffer,limit,this,build,side,write,buffer,get,current,position,in,segment,this,partition,buffers,this,build,side,write,buffer,close,if,is,in,memory,this,build,side,channel,close,this,probe,side,channel,io,access,create,block,channel,writer,probe,channel,enumerator,next,buffer,return,queue,this,probe,side,buffer,new,channel,writer,output,view,this,probe,side,channel,this,memory,segment,size
HashPartition -> public void finalizeBuildPhase(IOManager ioAccess, Channel.Enumerator probeChannelEnumerator, 			LinkedBlockingQueue<MemorySegment> bufferReturnQueue) 	throws IOException;1411473593;@param spilledPartitions_@param ioAccess_@param probeChannelEnumerator_@throws IOException;public void finalizeBuildPhase(IOManager ioAccess, Channel.Enumerator probeChannelEnumerator,_			LinkedBlockingQueue<MemorySegment> bufferReturnQueue)_	throws IOException_	{_		this.finalBufferLimit = this.buildSideWriteBuffer.getCurrentPositionInSegment()__		this.partitionBuffers = this.buildSideWriteBuffer.close()__		_		if (!isInMemory()) {_			_			_			this.buildSideChannel.close()__			_			_			this.probeSideChannel = ioAccess.createBlockChannelWriter(probeChannelEnumerator.next(), bufferReturnQueue)__			_			_			this.probeSideBuffer = new ChannelWriterOutputView(this.probeSideChannel, this.memorySegmentSize)__		}_	};param,spilled,partitions,param,io,access,param,probe,channel,enumerator,throws,ioexception;public,void,finalize,build,phase,iomanager,io,access,channel,enumerator,probe,channel,enumerator,linked,blocking,queue,memory,segment,buffer,return,queue,throws,ioexception,this,final,buffer,limit,this,build,side,write,buffer,get,current,position,in,segment,this,partition,buffers,this,build,side,write,buffer,close,if,is,in,memory,this,build,side,channel,close,this,probe,side,channel,io,access,create,block,channel,writer,probe,channel,enumerator,next,buffer,return,queue,this,probe,side,buffer,new,channel,writer,output,view,this,probe,side,channel,this,memory,segment,size
HashPartition -> public final void insertIntoProbeBuffer(PT record) throws IOException;1405024514;Inserts the given record into the probe side buffers. This method is only applicable when the_partition was spilled while processing the build side._<p>_If this method is invoked when the partition is still being built, it has undefined behavior.__@param object The record to be inserted into the probe side buffers._@throws IOException Thrown, if the buffer is full, needs to be spilled, and spilling causes an error.;public final void insertIntoProbeBuffer(PT record) throws IOException_	{_		this.probeSideSerializer.serialize(record, this.probeSideBuffer)__		this.probeSideRecordCounter++__	};inserts,the,given,record,into,the,probe,side,buffers,this,method,is,only,applicable,when,the,partition,was,spilled,while,processing,the,build,side,p,if,this,method,is,invoked,when,the,partition,is,still,being,built,it,has,undefined,behavior,param,object,the,record,to,be,inserted,into,the,probe,side,buffers,throws,ioexception,thrown,if,the,buffer,is,full,needs,to,be,spilled,and,spilling,causes,an,error;public,final,void,insert,into,probe,buffer,pt,record,throws,ioexception,this,probe,side,serializer,serialize,record,this,probe,side,buffer,this,probe,side,record,counter
HashPartition -> public final void insertIntoProbeBuffer(PT record) throws IOException;1405090423;Inserts the given record into the probe side buffers. This method is only applicable when the_partition was spilled while processing the build side._<p>_If this method is invoked when the partition is still being built, it has undefined behavior.__@param object The record to be inserted into the probe side buffers._@throws IOException Thrown, if the buffer is full, needs to be spilled, and spilling causes an error.;public final void insertIntoProbeBuffer(PT record) throws IOException_	{_		this.probeSideSerializer.serialize(record, this.probeSideBuffer)__		this.probeSideRecordCounter++__	};inserts,the,given,record,into,the,probe,side,buffers,this,method,is,only,applicable,when,the,partition,was,spilled,while,processing,the,build,side,p,if,this,method,is,invoked,when,the,partition,is,still,being,built,it,has,undefined,behavior,param,object,the,record,to,be,inserted,into,the,probe,side,buffers,throws,ioexception,thrown,if,the,buffer,is,full,needs,to,be,spilled,and,spilling,causes,an,error;public,final,void,insert,into,probe,buffer,pt,record,throws,ioexception,this,probe,side,serializer,serialize,record,this,probe,side,buffer,this,probe,side,record,counter
HashPartition -> public final void insertIntoProbeBuffer(PT record) throws IOException;1411473593;Inserts the given record into the probe side buffers. This method is only applicable when the_partition was spilled while processing the build side._<p>_If this method is invoked when the partition is still being built, it has undefined behavior.__@param object The record to be inserted into the probe side buffers._@throws IOException Thrown, if the buffer is full, needs to be spilled, and spilling causes an error.;public final void insertIntoProbeBuffer(PT record) throws IOException_	{_		this.probeSideSerializer.serialize(record, this.probeSideBuffer)__		this.probeSideRecordCounter++__	};inserts,the,given,record,into,the,probe,side,buffers,this,method,is,only,applicable,when,the,partition,was,spilled,while,processing,the,build,side,p,if,this,method,is,invoked,when,the,partition,is,still,being,built,it,has,undefined,behavior,param,object,the,record,to,be,inserted,into,the,probe,side,buffers,throws,ioexception,thrown,if,the,buffer,is,full,needs,to,be,spilled,and,spilling,causes,an,error;public,final,void,insert,into,probe,buffer,pt,record,throws,ioexception,this,probe,side,serializer,serialize,record,this,probe,side,buffer,this,probe,side,record,counter
HashPartition -> public final void insertIntoProbeBuffer(PT record) throws IOException;1412164980;Inserts the given record into the probe side buffers. This method is only applicable when the_partition was spilled while processing the build side._<p>_If this method is invoked when the partition is still being built, it has undefined behavior.__@param record The record to be inserted into the probe side buffers._@throws IOException Thrown, if the buffer is full, needs to be spilled, and spilling causes an error.;public final void insertIntoProbeBuffer(PT record) throws IOException_	{_		this.probeSideSerializer.serialize(record, this.probeSideBuffer)__		this.probeSideRecordCounter++__	};inserts,the,given,record,into,the,probe,side,buffers,this,method,is,only,applicable,when,the,partition,was,spilled,while,processing,the,build,side,p,if,this,method,is,invoked,when,the,partition,is,still,being,built,it,has,undefined,behavior,param,record,the,record,to,be,inserted,into,the,probe,side,buffers,throws,ioexception,thrown,if,the,buffer,is,full,needs,to,be,spilled,and,spilling,causes,an,error;public,final,void,insert,into,probe,buffer,pt,record,throws,ioexception,this,probe,side,serializer,serialize,record,this,probe,side,buffer,this,probe,side,record,counter
HashPartition -> public final void insertIntoProbeBuffer(PT record) throws IOException;1414786554;Inserts the given record into the probe side buffers. This method is only applicable when the_partition was spilled while processing the build side._<p>_If this method is invoked when the partition is still being built, it has undefined behavior.__@param record The record to be inserted into the probe side buffers._@throws IOException Thrown, if the buffer is full, needs to be spilled, and spilling causes an error.;public final void insertIntoProbeBuffer(PT record) throws IOException_	{_		this.probeSideSerializer.serialize(record, this.probeSideBuffer)__		this.probeSideRecordCounter++__	};inserts,the,given,record,into,the,probe,side,buffers,this,method,is,only,applicable,when,the,partition,was,spilled,while,processing,the,build,side,p,if,this,method,is,invoked,when,the,partition,is,still,being,built,it,has,undefined,behavior,param,record,the,record,to,be,inserted,into,the,probe,side,buffers,throws,ioexception,thrown,if,the,buffer,is,full,needs,to,be,spilled,and,spilling,causes,an,error;public,final,void,insert,into,probe,buffer,pt,record,throws,ioexception,this,probe,side,serializer,serialize,record,this,probe,side,buffer,this,probe,side,record,counter
HashPartition -> public final void insertIntoProbeBuffer(PT record) throws IOException;1415702894;Inserts the given record into the probe side buffers. This method is only applicable when the_partition was spilled while processing the build side._<p>_If this method is invoked when the partition is still being built, it has undefined behavior.__@param record The record to be inserted into the probe side buffers._@throws IOException Thrown, if the buffer is full, needs to be spilled, and spilling causes an error.;public final void insertIntoProbeBuffer(PT record) throws IOException_	{_		this.probeSideSerializer.serialize(record, this.probeSideBuffer)__		this.probeSideRecordCounter++__	};inserts,the,given,record,into,the,probe,side,buffers,this,method,is,only,applicable,when,the,partition,was,spilled,while,processing,the,build,side,p,if,this,method,is,invoked,when,the,partition,is,still,being,built,it,has,undefined,behavior,param,record,the,record,to,be,inserted,into,the,probe,side,buffers,throws,ioexception,thrown,if,the,buffer,is,full,needs,to,be,spilled,and,spilling,causes,an,error;public,final,void,insert,into,probe,buffer,pt,record,throws,ioexception,this,probe,side,serializer,serialize,record,this,probe,side,buffer,this,probe,side,record,counter
HashPartition -> public final void insertIntoProbeBuffer(PT record) throws IOException;1418570573;Inserts the given record into the probe side buffers. This method is only applicable when the_partition was spilled while processing the build side._<p>_If this method is invoked when the partition is still being built, it has undefined behavior.__@param record The record to be inserted into the probe side buffers._@throws IOException Thrown, if the buffer is full, needs to be spilled, and spilling causes an error.;public final void insertIntoProbeBuffer(PT record) throws IOException_	{_		this.probeSideSerializer.serialize(record, this.probeSideBuffer)__		this.probeSideRecordCounter++__	};inserts,the,given,record,into,the,probe,side,buffers,this,method,is,only,applicable,when,the,partition,was,spilled,while,processing,the,build,side,p,if,this,method,is,invoked,when,the,partition,is,still,being,built,it,has,undefined,behavior,param,record,the,record,to,be,inserted,into,the,probe,side,buffers,throws,ioexception,thrown,if,the,buffer,is,full,needs,to,be,spilled,and,spilling,causes,an,error;public,final,void,insert,into,probe,buffer,pt,record,throws,ioexception,this,probe,side,serializer,serialize,record,this,probe,side,buffer,this,probe,side,record,counter
HashPartition -> public final void insertIntoProbeBuffer(PT record) throws IOException;1420654570;Inserts the given record into the probe side buffers. This method is only applicable when the_partition was spilled while processing the build side._<p>_If this method is invoked when the partition is still being built, it has undefined behavior.__@param record The record to be inserted into the probe side buffers._@throws IOException Thrown, if the buffer is full, needs to be spilled, and spilling causes an error.;public final void insertIntoProbeBuffer(PT record) throws IOException_	{_		this.probeSideSerializer.serialize(record, this.probeSideBuffer)__		this.probeSideRecordCounter++__	};inserts,the,given,record,into,the,probe,side,buffers,this,method,is,only,applicable,when,the,partition,was,spilled,while,processing,the,build,side,p,if,this,method,is,invoked,when,the,partition,is,still,being,built,it,has,undefined,behavior,param,record,the,record,to,be,inserted,into,the,probe,side,buffers,throws,ioexception,thrown,if,the,buffer,is,full,needs,to,be,spilled,and,spilling,causes,an,error;public,final,void,insert,into,probe,buffer,pt,record,throws,ioexception,this,probe,side,serializer,serialize,record,this,probe,side,buffer,this,probe,side,record,counter
HashPartition -> public final void insertIntoProbeBuffer(PT record) throws IOException;1420663430;Inserts the given record into the probe side buffers. This method is only applicable when the_partition was spilled while processing the build side._<p>_If this method is invoked when the partition is still being built, it has undefined behavior.__@param record The record to be inserted into the probe side buffers._@throws IOException Thrown, if the buffer is full, needs to be spilled, and spilling causes an error.;public final void insertIntoProbeBuffer(PT record) throws IOException_	{_		this.probeSideSerializer.serialize(record, this.probeSideBuffer)__		this.probeSideRecordCounter++__	};inserts,the,given,record,into,the,probe,side,buffers,this,method,is,only,applicable,when,the,partition,was,spilled,while,processing,the,build,side,p,if,this,method,is,invoked,when,the,partition,is,still,being,built,it,has,undefined,behavior,param,record,the,record,to,be,inserted,into,the,probe,side,buffers,throws,ioexception,thrown,if,the,buffer,is,full,needs,to,be,spilled,and,spilling,causes,an,error;public,final,void,insert,into,probe,buffer,pt,record,throws,ioexception,this,probe,side,serializer,serialize,record,this,probe,side,buffer,this,probe,side,record,counter
HashPartition -> public final void insertIntoProbeBuffer(PT record) throws IOException;1426697080;Inserts the given record into the probe side buffers. This method is only applicable when the_partition was spilled while processing the build side._<p>_If this method is invoked when the partition is still being built, it has undefined behavior.__@param record The record to be inserted into the probe side buffers._@throws IOException Thrown, if the buffer is full, needs to be spilled, and spilling causes an error.;public final void insertIntoProbeBuffer(PT record) throws IOException_	{_		this.probeSideSerializer.serialize(record, this.probeSideBuffer)__		this.probeSideRecordCounter++__	};inserts,the,given,record,into,the,probe,side,buffers,this,method,is,only,applicable,when,the,partition,was,spilled,while,processing,the,build,side,p,if,this,method,is,invoked,when,the,partition,is,still,being,built,it,has,undefined,behavior,param,record,the,record,to,be,inserted,into,the,probe,side,buffers,throws,ioexception,thrown,if,the,buffer,is,full,needs,to,be,spilled,and,spilling,causes,an,error;public,final,void,insert,into,probe,buffer,pt,record,throws,ioexception,this,probe,side,serializer,serialize,record,this,probe,side,buffer,this,probe,side,record,counter
HashPartition -> public final void insertIntoProbeBuffer(PT record) throws IOException;1440607697;Inserts the given record into the probe side buffers. This method is only applicable when the_partition was spilled while processing the build side._<p>_If this method is invoked when the partition is still being built, it has undefined behavior.__@param record The record to be inserted into the probe side buffers._@throws IOException Thrown, if the buffer is full, needs to be spilled, and spilling causes an error.;public final void insertIntoProbeBuffer(PT record) throws IOException {_		this.probeSideSerializer.serialize(record, this.probeSideBuffer)__		this.probeSideRecordCounter++__	};inserts,the,given,record,into,the,probe,side,buffers,this,method,is,only,applicable,when,the,partition,was,spilled,while,processing,the,build,side,p,if,this,method,is,invoked,when,the,partition,is,still,being,built,it,has,undefined,behavior,param,record,the,record,to,be,inserted,into,the,probe,side,buffers,throws,ioexception,thrown,if,the,buffer,is,full,needs,to,be,spilled,and,spilling,causes,an,error;public,final,void,insert,into,probe,buffer,pt,record,throws,ioexception,this,probe,side,serializer,serialize,record,this,probe,side,buffer,this,probe,side,record,counter
HashPartition -> public final void insertIntoProbeBuffer(PT record) throws IOException;1441738685;Inserts the given record into the probe side buffers. This method is only applicable when the_partition was spilled while processing the build side._<p>_If this method is invoked when the partition is still being built, it has undefined behavior.__@param record The record to be inserted into the probe side buffers._@throws IOException Thrown, if the buffer is full, needs to be spilled, and spilling causes an error.;public final void insertIntoProbeBuffer(PT record) throws IOException {_		this.probeSideSerializer.serialize(record, this.probeSideBuffer)__		this.probeSideRecordCounter++__	};inserts,the,given,record,into,the,probe,side,buffers,this,method,is,only,applicable,when,the,partition,was,spilled,while,processing,the,build,side,p,if,this,method,is,invoked,when,the,partition,is,still,being,built,it,has,undefined,behavior,param,record,the,record,to,be,inserted,into,the,probe,side,buffers,throws,ioexception,thrown,if,the,buffer,is,full,needs,to,be,spilled,and,spilling,causes,an,error;public,final,void,insert,into,probe,buffer,pt,record,throws,ioexception,this,probe,side,serializer,serialize,record,this,probe,side,buffer,this,probe,side,record,counter
HashPartition -> public final void insertIntoProbeBuffer(PT record) throws IOException;1443528421;Inserts the given record into the probe side buffers. This method is only applicable when the_partition was spilled while processing the build side._<p>_If this method is invoked when the partition is still being built, it has undefined behavior.__@param record The record to be inserted into the probe side buffers._@throws IOException Thrown, if the buffer is full, needs to be spilled, and spilling causes an error.;public final void insertIntoProbeBuffer(PT record) throws IOException {_		this.probeSideSerializer.serialize(record, this.probeSideBuffer)__		this.probeSideRecordCounter++__	};inserts,the,given,record,into,the,probe,side,buffers,this,method,is,only,applicable,when,the,partition,was,spilled,while,processing,the,build,side,p,if,this,method,is,invoked,when,the,partition,is,still,being,built,it,has,undefined,behavior,param,record,the,record,to,be,inserted,into,the,probe,side,buffers,throws,ioexception,thrown,if,the,buffer,is,full,needs,to,be,spilled,and,spilling,causes,an,error;public,final,void,insert,into,probe,buffer,pt,record,throws,ioexception,this,probe,side,serializer,serialize,record,this,probe,side,buffer,this,probe,side,record,counter
HashPartition -> public final void insertIntoProbeBuffer(PT record) throws IOException;1446633116;Inserts the given record into the probe side buffers. This method is only applicable when the_partition was spilled while processing the build side._<p>_If this method is invoked when the partition is still being built, it has undefined behavior.__@param record The record to be inserted into the probe side buffers._@throws IOException Thrown, if the buffer is full, needs to be spilled, and spilling causes an error.;public final void insertIntoProbeBuffer(PT record) throws IOException {_		this.probeSideSerializer.serialize(record, this.probeSideBuffer)__		this.probeSideRecordCounter++__	};inserts,the,given,record,into,the,probe,side,buffers,this,method,is,only,applicable,when,the,partition,was,spilled,while,processing,the,build,side,p,if,this,method,is,invoked,when,the,partition,is,still,being,built,it,has,undefined,behavior,param,record,the,record,to,be,inserted,into,the,probe,side,buffers,throws,ioexception,thrown,if,the,buffer,is,full,needs,to,be,spilled,and,spilling,causes,an,error;public,final,void,insert,into,probe,buffer,pt,record,throws,ioexception,this,probe,side,serializer,serialize,record,this,probe,side,buffer,this,probe,side,record,counter
HashPartition -> public final void insertIntoProbeBuffer(PT record) throws IOException;1456186722;Inserts the given record into the probe side buffers. This method is only applicable when the_partition was spilled while processing the build side._<p>_If this method is invoked when the partition is still being built, it has undefined behavior.__@param record The record to be inserted into the probe side buffers._@throws IOException Thrown, if the buffer is full, needs to be spilled, and spilling causes an error.;public final void insertIntoProbeBuffer(PT record) throws IOException {_		this.probeSideSerializer.serialize(record, this.probeSideBuffer)__		this.probeSideRecordCounter++__	};inserts,the,given,record,into,the,probe,side,buffers,this,method,is,only,applicable,when,the,partition,was,spilled,while,processing,the,build,side,p,if,this,method,is,invoked,when,the,partition,is,still,being,built,it,has,undefined,behavior,param,record,the,record,to,be,inserted,into,the,probe,side,buffers,throws,ioexception,thrown,if,the,buffer,is,full,needs,to,be,spilled,and,spilling,causes,an,error;public,final,void,insert,into,probe,buffer,pt,record,throws,ioexception,this,probe,side,serializer,serialize,record,this,probe,side,buffer,this,probe,side,record,counter
HashPartition -> public final void insertIntoProbeBuffer(PT record) throws IOException;1460741894;Inserts the given record into the probe side buffers. This method is only applicable when the_partition was spilled while processing the build side._<p>_If this method is invoked when the partition is still being built, it has undefined behavior.__@param record The record to be inserted into the probe side buffers._@throws IOException Thrown, if the buffer is full, needs to be spilled, and spilling causes an error.;public final void insertIntoProbeBuffer(PT record) throws IOException {_		this.probeSideSerializer.serialize(record, this.probeSideBuffer)__		this.probeSideRecordCounter++__	};inserts,the,given,record,into,the,probe,side,buffers,this,method,is,only,applicable,when,the,partition,was,spilled,while,processing,the,build,side,p,if,this,method,is,invoked,when,the,partition,is,still,being,built,it,has,undefined,behavior,param,record,the,record,to,be,inserted,into,the,probe,side,buffers,throws,ioexception,thrown,if,the,buffer,is,full,needs,to,be,spilled,and,spilling,causes,an,error;public,final,void,insert,into,probe,buffer,pt,record,throws,ioexception,this,probe,side,serializer,serialize,record,this,probe,side,buffer,this,probe,side,record,counter
HashPartition -> public int getRecursionLevel();1405024514;Gets this partition's recursion level.__@return The partition's recursion level.;public int getRecursionLevel() {_		return this.recursionLevel__	};gets,this,partition,s,recursion,level,return,the,partition,s,recursion,level;public,int,get,recursion,level,return,this,recursion,level
HashPartition -> public int getRecursionLevel();1405090423;Gets this partition's recursion level.__@return The partition's recursion level.;public int getRecursionLevel() {_		return this.recursionLevel__	};gets,this,partition,s,recursion,level,return,the,partition,s,recursion,level;public,int,get,recursion,level,return,this,recursion,level
HashPartition -> public int getRecursionLevel();1411473593;Gets this partition's recursion level.__@return The partition's recursion level.;public int getRecursionLevel() {_		return this.recursionLevel__	};gets,this,partition,s,recursion,level,return,the,partition,s,recursion,level;public,int,get,recursion,level,return,this,recursion,level
HashPartition -> public int getRecursionLevel();1412164980;Gets this partition's recursion level.__@return The partition's recursion level.;public int getRecursionLevel() {_		return this.recursionLevel__	};gets,this,partition,s,recursion,level,return,the,partition,s,recursion,level;public,int,get,recursion,level,return,this,recursion,level
HashPartition -> public int getRecursionLevel();1414786554;Gets this partition's recursion level.__@return The partition's recursion level.;public int getRecursionLevel() {_		return this.recursionLevel__	};gets,this,partition,s,recursion,level,return,the,partition,s,recursion,level;public,int,get,recursion,level,return,this,recursion,level
HashPartition -> public int getRecursionLevel();1415702894;Gets this partition's recursion level.__@return The partition's recursion level.;public int getRecursionLevel() {_		return this.recursionLevel__	};gets,this,partition,s,recursion,level,return,the,partition,s,recursion,level;public,int,get,recursion,level,return,this,recursion,level
HashPartition -> public int getRecursionLevel();1418570573;Gets this partition's recursion level.__@return The partition's recursion level.;public int getRecursionLevel() {_		return this.recursionLevel__	};gets,this,partition,s,recursion,level,return,the,partition,s,recursion,level;public,int,get,recursion,level,return,this,recursion,level
HashPartition -> public int getRecursionLevel();1420654570;Gets this partition's recursion level.__@return The partition's recursion level.;public int getRecursionLevel() {_		return this.recursionLevel__	};gets,this,partition,s,recursion,level,return,the,partition,s,recursion,level;public,int,get,recursion,level,return,this,recursion,level
HashPartition -> public int getRecursionLevel();1420663430;Gets this partition's recursion level.__@return The partition's recursion level.;public int getRecursionLevel() {_		return this.recursionLevel__	};gets,this,partition,s,recursion,level,return,the,partition,s,recursion,level;public,int,get,recursion,level,return,this,recursion,level
HashPartition -> public int getRecursionLevel();1426697080;Gets this partition's recursion level.__@return The partition's recursion level.;public int getRecursionLevel() {_		return this.recursionLevel__	};gets,this,partition,s,recursion,level,return,the,partition,s,recursion,level;public,int,get,recursion,level,return,this,recursion,level
HashPartition -> public int getRecursionLevel();1440607697;Gets this partition's recursion level.__@return The partition's recursion level.;public int getRecursionLevel() {_		return this.recursionLevel__	};gets,this,partition,s,recursion,level,return,the,partition,s,recursion,level;public,int,get,recursion,level,return,this,recursion,level
HashPartition -> public int getRecursionLevel();1441738685;Gets this partition's recursion level.__@return The partition's recursion level.;public int getRecursionLevel() {_		return this.recursionLevel__	};gets,this,partition,s,recursion,level,return,the,partition,s,recursion,level;public,int,get,recursion,level,return,this,recursion,level
HashPartition -> public int getRecursionLevel();1443528421;Gets this partition's recursion level.__@return The partition's recursion level.;public int getRecursionLevel() {_		return this.recursionLevel__	};gets,this,partition,s,recursion,level,return,the,partition,s,recursion,level;public,int,get,recursion,level,return,this,recursion,level
HashPartition -> public int getRecursionLevel();1446633116;Gets this partition's recursion level.__@return The partition's recursion level.;public int getRecursionLevel() {_		return this.recursionLevel__	};gets,this,partition,s,recursion,level,return,the,partition,s,recursion,level;public,int,get,recursion,level,return,this,recursion,level
HashPartition -> public int getRecursionLevel();1456186722;Gets this partition's recursion level.__@return The partition's recursion level.;public int getRecursionLevel() {_		return this.recursionLevel__	};gets,this,partition,s,recursion,level,return,the,partition,s,recursion,level;public,int,get,recursion,level,return,this,recursion,level
HashPartition -> public int getRecursionLevel();1460741894;Gets this partition's recursion level.__@return The partition's recursion level.;public int getRecursionLevel() {_		return this.recursionLevel__	};gets,this,partition,s,recursion,level,return,the,partition,s,recursion,level;public,int,get,recursion,level,return,this,recursion,level
HashPartition -> HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors, 			int partitionNumber, int recursionLevel, List<MemorySegment> buffers, 			long buildSideRecordCounter, int segmentSize, int lastSegmentLimit);1405024514;Constructor creating a partition from a spilled partition file that could be read in one because it was_known to completely fit into memory.__@param buildSideAccessors The data type accessors for the build side data-type._@param probeSideAccessors The data type accessors for the probe side data-type._@param partitionNumber The number of the partition._@param recursionLevel The recursion level of the partition._@param buffers The memory segments holding the records._@param buildSideRecordCounter The number of records in the buffers._@param segmentSize The size of the memory segments.;HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors,_			int partitionNumber, int recursionLevel, List<MemorySegment> buffers,_			long buildSideRecordCounter, int segmentSize, int lastSegmentLimit)_	{_		super(0)__		_		this.buildSideSerializer = buildSideAccessors__		this.probeSideSerializer = probeSideAccessors__		this.partitionNumber = partitionNumber__		this.recursionLevel = recursionLevel__		_		this.memorySegmentSize = segmentSize__		this.segmentSizeBits = MathUtils.log2strict(segmentSize)__		this.finalBufferLimit = lastSegmentLimit__		_		this.partitionBuffers = (MemorySegment[]) buffers.toArray(new MemorySegment[buffers.size()])__		this.buildSideRecordCounter = buildSideRecordCounter__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__	};constructor,creating,a,partition,from,a,spilled,partition,file,that,could,be,read,in,one,because,it,was,known,to,completely,fit,into,memory,param,build,side,accessors,the,data,type,accessors,for,the,build,side,data,type,param,probe,side,accessors,the,data,type,accessors,for,the,probe,side,data,type,param,partition,number,the,number,of,the,partition,param,recursion,level,the,recursion,level,of,the,partition,param,buffers,the,memory,segments,holding,the,records,param,build,side,record,counter,the,number,of,records,in,the,buffers,param,segment,size,the,size,of,the,memory,segments;hash,partition,type,serializer,bt,build,side,accessors,type,serializer,pt,probe,side,accessors,int,partition,number,int,recursion,level,list,memory,segment,buffers,long,build,side,record,counter,int,segment,size,int,last,segment,limit,super,0,this,build,side,serializer,build,side,accessors,this,probe,side,serializer,probe,side,accessors,this,partition,number,partition,number,this,recursion,level,recursion,level,this,memory,segment,size,segment,size,this,segment,size,bits,math,utils,log2strict,segment,size,this,final,buffer,limit,last,segment,limit,this,partition,buffers,memory,segment,buffers,to,array,new,memory,segment,buffers,size,this,build,side,record,counter,build,side,record,counter,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0
HashPartition -> HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors, 			int partitionNumber, int recursionLevel, List<MemorySegment> buffers, 			long buildSideRecordCounter, int segmentSize, int lastSegmentLimit);1405090423;Constructor creating a partition from a spilled partition file that could be read in one because it was_known to completely fit into memory.__@param buildSideAccessors The data type accessors for the build side data-type._@param probeSideAccessors The data type accessors for the probe side data-type._@param partitionNumber The number of the partition._@param recursionLevel The recursion level of the partition._@param buffers The memory segments holding the records._@param buildSideRecordCounter The number of records in the buffers._@param segmentSize The size of the memory segments.;HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors,_			int partitionNumber, int recursionLevel, List<MemorySegment> buffers,_			long buildSideRecordCounter, int segmentSize, int lastSegmentLimit)_	{_		super(0)__		_		this.buildSideSerializer = buildSideAccessors__		this.probeSideSerializer = probeSideAccessors__		this.partitionNumber = partitionNumber__		this.recursionLevel = recursionLevel__		_		this.memorySegmentSize = segmentSize__		this.segmentSizeBits = MathUtils.log2strict(segmentSize)__		this.finalBufferLimit = lastSegmentLimit__		_		this.partitionBuffers = (MemorySegment[]) buffers.toArray(new MemorySegment[buffers.size()])__		this.buildSideRecordCounter = buildSideRecordCounter__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__	};constructor,creating,a,partition,from,a,spilled,partition,file,that,could,be,read,in,one,because,it,was,known,to,completely,fit,into,memory,param,build,side,accessors,the,data,type,accessors,for,the,build,side,data,type,param,probe,side,accessors,the,data,type,accessors,for,the,probe,side,data,type,param,partition,number,the,number,of,the,partition,param,recursion,level,the,recursion,level,of,the,partition,param,buffers,the,memory,segments,holding,the,records,param,build,side,record,counter,the,number,of,records,in,the,buffers,param,segment,size,the,size,of,the,memory,segments;hash,partition,type,serializer,bt,build,side,accessors,type,serializer,pt,probe,side,accessors,int,partition,number,int,recursion,level,list,memory,segment,buffers,long,build,side,record,counter,int,segment,size,int,last,segment,limit,super,0,this,build,side,serializer,build,side,accessors,this,probe,side,serializer,probe,side,accessors,this,partition,number,partition,number,this,recursion,level,recursion,level,this,memory,segment,size,segment,size,this,segment,size,bits,math,utils,log2strict,segment,size,this,final,buffer,limit,last,segment,limit,this,partition,buffers,memory,segment,buffers,to,array,new,memory,segment,buffers,size,this,build,side,record,counter,build,side,record,counter,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0
HashPartition -> HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors, 			int partitionNumber, int recursionLevel, List<MemorySegment> buffers, 			long buildSideRecordCounter, int segmentSize, int lastSegmentLimit);1411473593;Constructor creating a partition from a spilled partition file that could be read in one because it was_known to completely fit into memory.__@param buildSideAccessors The data type accessors for the build side data-type._@param probeSideAccessors The data type accessors for the probe side data-type._@param partitionNumber The number of the partition._@param recursionLevel The recursion level of the partition._@param buffers The memory segments holding the records._@param buildSideRecordCounter The number of records in the buffers._@param segmentSize The size of the memory segments.;HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors,_			int partitionNumber, int recursionLevel, List<MemorySegment> buffers,_			long buildSideRecordCounter, int segmentSize, int lastSegmentLimit)_	{_		super(0)__		_		this.buildSideSerializer = buildSideAccessors__		this.probeSideSerializer = probeSideAccessors__		this.partitionNumber = partitionNumber__		this.recursionLevel = recursionLevel__		_		this.memorySegmentSize = segmentSize__		this.segmentSizeBits = MathUtils.log2strict(segmentSize)__		this.finalBufferLimit = lastSegmentLimit__		_		this.partitionBuffers = (MemorySegment[]) buffers.toArray(new MemorySegment[buffers.size()])__		this.buildSideRecordCounter = buildSideRecordCounter__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__	};constructor,creating,a,partition,from,a,spilled,partition,file,that,could,be,read,in,one,because,it,was,known,to,completely,fit,into,memory,param,build,side,accessors,the,data,type,accessors,for,the,build,side,data,type,param,probe,side,accessors,the,data,type,accessors,for,the,probe,side,data,type,param,partition,number,the,number,of,the,partition,param,recursion,level,the,recursion,level,of,the,partition,param,buffers,the,memory,segments,holding,the,records,param,build,side,record,counter,the,number,of,records,in,the,buffers,param,segment,size,the,size,of,the,memory,segments;hash,partition,type,serializer,bt,build,side,accessors,type,serializer,pt,probe,side,accessors,int,partition,number,int,recursion,level,list,memory,segment,buffers,long,build,side,record,counter,int,segment,size,int,last,segment,limit,super,0,this,build,side,serializer,build,side,accessors,this,probe,side,serializer,probe,side,accessors,this,partition,number,partition,number,this,recursion,level,recursion,level,this,memory,segment,size,segment,size,this,segment,size,bits,math,utils,log2strict,segment,size,this,final,buffer,limit,last,segment,limit,this,partition,buffers,memory,segment,buffers,to,array,new,memory,segment,buffers,size,this,build,side,record,counter,build,side,record,counter,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0
HashPartition -> HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors, 			int partitionNumber, int recursionLevel, List<MemorySegment> buffers, 			long buildSideRecordCounter, int segmentSize, int lastSegmentLimit);1412164980;Constructor creating a partition from a spilled partition file that could be read in one because it was_known to completely fit into memory.__@param buildSideAccessors The data type accessors for the build side data-type._@param probeSideAccessors The data type accessors for the probe side data-type._@param partitionNumber The number of the partition._@param recursionLevel The recursion level of the partition._@param buffers The memory segments holding the records._@param buildSideRecordCounter The number of records in the buffers._@param segmentSize The size of the memory segments.;HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors,_			int partitionNumber, int recursionLevel, List<MemorySegment> buffers,_			long buildSideRecordCounter, int segmentSize, int lastSegmentLimit)_	{_		super(0)__		_		this.buildSideSerializer = buildSideAccessors__		this.probeSideSerializer = probeSideAccessors__		this.partitionNumber = partitionNumber__		this.recursionLevel = recursionLevel__		_		this.memorySegmentSize = segmentSize__		this.segmentSizeBits = MathUtils.log2strict(segmentSize)__		this.finalBufferLimit = lastSegmentLimit__		_		this.partitionBuffers = (MemorySegment[]) buffers.toArray(new MemorySegment[buffers.size()])__		this.buildSideRecordCounter = buildSideRecordCounter__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__	};constructor,creating,a,partition,from,a,spilled,partition,file,that,could,be,read,in,one,because,it,was,known,to,completely,fit,into,memory,param,build,side,accessors,the,data,type,accessors,for,the,build,side,data,type,param,probe,side,accessors,the,data,type,accessors,for,the,probe,side,data,type,param,partition,number,the,number,of,the,partition,param,recursion,level,the,recursion,level,of,the,partition,param,buffers,the,memory,segments,holding,the,records,param,build,side,record,counter,the,number,of,records,in,the,buffers,param,segment,size,the,size,of,the,memory,segments;hash,partition,type,serializer,bt,build,side,accessors,type,serializer,pt,probe,side,accessors,int,partition,number,int,recursion,level,list,memory,segment,buffers,long,build,side,record,counter,int,segment,size,int,last,segment,limit,super,0,this,build,side,serializer,build,side,accessors,this,probe,side,serializer,probe,side,accessors,this,partition,number,partition,number,this,recursion,level,recursion,level,this,memory,segment,size,segment,size,this,segment,size,bits,math,utils,log2strict,segment,size,this,final,buffer,limit,last,segment,limit,this,partition,buffers,memory,segment,buffers,to,array,new,memory,segment,buffers,size,this,build,side,record,counter,build,side,record,counter,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0
HashPartition -> HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors, 			int partitionNumber, int recursionLevel, List<MemorySegment> buffers, 			long buildSideRecordCounter, int segmentSize, int lastSegmentLimit);1414786554;Constructor creating a partition from a spilled partition file that could be read in one because it was_known to completely fit into memory.__@param buildSideAccessors The data type accessors for the build side data-type._@param probeSideAccessors The data type accessors for the probe side data-type._@param partitionNumber The number of the partition._@param recursionLevel The recursion level of the partition._@param buffers The memory segments holding the records._@param buildSideRecordCounter The number of records in the buffers._@param segmentSize The size of the memory segments.;HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors,_			int partitionNumber, int recursionLevel, List<MemorySegment> buffers,_			long buildSideRecordCounter, int segmentSize, int lastSegmentLimit)_	{_		super(0)__		_		this.buildSideSerializer = buildSideAccessors__		this.probeSideSerializer = probeSideAccessors__		this.partitionNumber = partitionNumber__		this.recursionLevel = recursionLevel__		_		this.memorySegmentSize = segmentSize__		this.segmentSizeBits = MathUtils.log2strict(segmentSize)__		this.finalBufferLimit = lastSegmentLimit__		_		this.partitionBuffers = (MemorySegment[]) buffers.toArray(new MemorySegment[buffers.size()])__		this.buildSideRecordCounter = buildSideRecordCounter__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__	};constructor,creating,a,partition,from,a,spilled,partition,file,that,could,be,read,in,one,because,it,was,known,to,completely,fit,into,memory,param,build,side,accessors,the,data,type,accessors,for,the,build,side,data,type,param,probe,side,accessors,the,data,type,accessors,for,the,probe,side,data,type,param,partition,number,the,number,of,the,partition,param,recursion,level,the,recursion,level,of,the,partition,param,buffers,the,memory,segments,holding,the,records,param,build,side,record,counter,the,number,of,records,in,the,buffers,param,segment,size,the,size,of,the,memory,segments;hash,partition,type,serializer,bt,build,side,accessors,type,serializer,pt,probe,side,accessors,int,partition,number,int,recursion,level,list,memory,segment,buffers,long,build,side,record,counter,int,segment,size,int,last,segment,limit,super,0,this,build,side,serializer,build,side,accessors,this,probe,side,serializer,probe,side,accessors,this,partition,number,partition,number,this,recursion,level,recursion,level,this,memory,segment,size,segment,size,this,segment,size,bits,math,utils,log2strict,segment,size,this,final,buffer,limit,last,segment,limit,this,partition,buffers,memory,segment,buffers,to,array,new,memory,segment,buffers,size,this,build,side,record,counter,build,side,record,counter,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0
HashPartition -> HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors, 			int partitionNumber, int recursionLevel, List<MemorySegment> buffers, 			long buildSideRecordCounter, int segmentSize, int lastSegmentLimit);1415702894;Constructor creating a partition from a spilled partition file that could be read in one because it was_known to completely fit into memory.__@param buildSideAccessors The data type accessors for the build side data-type._@param probeSideAccessors The data type accessors for the probe side data-type._@param partitionNumber The number of the partition._@param recursionLevel The recursion level of the partition._@param buffers The memory segments holding the records._@param buildSideRecordCounter The number of records in the buffers._@param segmentSize The size of the memory segments.;HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors,_			int partitionNumber, int recursionLevel, List<MemorySegment> buffers,_			long buildSideRecordCounter, int segmentSize, int lastSegmentLimit)_	{_		super(0)__		_		this.buildSideSerializer = buildSideAccessors__		this.probeSideSerializer = probeSideAccessors__		this.partitionNumber = partitionNumber__		this.recursionLevel = recursionLevel__		_		this.memorySegmentSize = segmentSize__		this.segmentSizeBits = MathUtils.log2strict(segmentSize)__		this.finalBufferLimit = lastSegmentLimit__		_		this.partitionBuffers = (MemorySegment[]) buffers.toArray(new MemorySegment[buffers.size()])__		this.buildSideRecordCounter = buildSideRecordCounter__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__	};constructor,creating,a,partition,from,a,spilled,partition,file,that,could,be,read,in,one,because,it,was,known,to,completely,fit,into,memory,param,build,side,accessors,the,data,type,accessors,for,the,build,side,data,type,param,probe,side,accessors,the,data,type,accessors,for,the,probe,side,data,type,param,partition,number,the,number,of,the,partition,param,recursion,level,the,recursion,level,of,the,partition,param,buffers,the,memory,segments,holding,the,records,param,build,side,record,counter,the,number,of,records,in,the,buffers,param,segment,size,the,size,of,the,memory,segments;hash,partition,type,serializer,bt,build,side,accessors,type,serializer,pt,probe,side,accessors,int,partition,number,int,recursion,level,list,memory,segment,buffers,long,build,side,record,counter,int,segment,size,int,last,segment,limit,super,0,this,build,side,serializer,build,side,accessors,this,probe,side,serializer,probe,side,accessors,this,partition,number,partition,number,this,recursion,level,recursion,level,this,memory,segment,size,segment,size,this,segment,size,bits,math,utils,log2strict,segment,size,this,final,buffer,limit,last,segment,limit,this,partition,buffers,memory,segment,buffers,to,array,new,memory,segment,buffers,size,this,build,side,record,counter,build,side,record,counter,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0
HashPartition -> HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors, 			int partitionNumber, int recursionLevel, List<MemorySegment> buffers, 			long buildSideRecordCounter, int segmentSize, int lastSegmentLimit);1418570573;Constructor creating a partition from a spilled partition file that could be read in one because it was_known to completely fit into memory.__@param buildSideAccessors The data type accessors for the build side data-type._@param probeSideAccessors The data type accessors for the probe side data-type._@param partitionNumber The number of the partition._@param recursionLevel The recursion level of the partition._@param buffers The memory segments holding the records._@param buildSideRecordCounter The number of records in the buffers._@param segmentSize The size of the memory segments.;HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors,_			int partitionNumber, int recursionLevel, List<MemorySegment> buffers,_			long buildSideRecordCounter, int segmentSize, int lastSegmentLimit)_	{_		super(0)__		_		this.buildSideSerializer = buildSideAccessors__		this.probeSideSerializer = probeSideAccessors__		this.partitionNumber = partitionNumber__		this.recursionLevel = recursionLevel__		_		this.memorySegmentSize = segmentSize__		this.segmentSizeBits = MathUtils.log2strict(segmentSize)__		this.finalBufferLimit = lastSegmentLimit__		_		this.partitionBuffers = (MemorySegment[]) buffers.toArray(new MemorySegment[buffers.size()])__		this.buildSideRecordCounter = buildSideRecordCounter__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__	};constructor,creating,a,partition,from,a,spilled,partition,file,that,could,be,read,in,one,because,it,was,known,to,completely,fit,into,memory,param,build,side,accessors,the,data,type,accessors,for,the,build,side,data,type,param,probe,side,accessors,the,data,type,accessors,for,the,probe,side,data,type,param,partition,number,the,number,of,the,partition,param,recursion,level,the,recursion,level,of,the,partition,param,buffers,the,memory,segments,holding,the,records,param,build,side,record,counter,the,number,of,records,in,the,buffers,param,segment,size,the,size,of,the,memory,segments;hash,partition,type,serializer,bt,build,side,accessors,type,serializer,pt,probe,side,accessors,int,partition,number,int,recursion,level,list,memory,segment,buffers,long,build,side,record,counter,int,segment,size,int,last,segment,limit,super,0,this,build,side,serializer,build,side,accessors,this,probe,side,serializer,probe,side,accessors,this,partition,number,partition,number,this,recursion,level,recursion,level,this,memory,segment,size,segment,size,this,segment,size,bits,math,utils,log2strict,segment,size,this,final,buffer,limit,last,segment,limit,this,partition,buffers,memory,segment,buffers,to,array,new,memory,segment,buffers,size,this,build,side,record,counter,build,side,record,counter,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0
HashPartition -> HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors, 			int partitionNumber, int recursionLevel, List<MemorySegment> buffers, 			long buildSideRecordCounter, int segmentSize, int lastSegmentLimit);1420654570;Constructor creating a partition from a spilled partition file that could be read in one because it was_known to completely fit into memory.__@param buildSideAccessors The data type accessors for the build side data-type._@param probeSideAccessors The data type accessors for the probe side data-type._@param partitionNumber The number of the partition._@param recursionLevel The recursion level of the partition._@param buffers The memory segments holding the records._@param buildSideRecordCounter The number of records in the buffers._@param segmentSize The size of the memory segments.;HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors,_			int partitionNumber, int recursionLevel, List<MemorySegment> buffers,_			long buildSideRecordCounter, int segmentSize, int lastSegmentLimit)_	{_		super(0)__		_		this.buildSideSerializer = buildSideAccessors__		this.probeSideSerializer = probeSideAccessors__		this.partitionNumber = partitionNumber__		this.recursionLevel = recursionLevel__		_		this.memorySegmentSize = segmentSize__		this.segmentSizeBits = MathUtils.log2strict(segmentSize)__		this.finalBufferLimit = lastSegmentLimit__		_		this.partitionBuffers = (MemorySegment[]) buffers.toArray(new MemorySegment[buffers.size()])__		this.buildSideRecordCounter = buildSideRecordCounter__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__	};constructor,creating,a,partition,from,a,spilled,partition,file,that,could,be,read,in,one,because,it,was,known,to,completely,fit,into,memory,param,build,side,accessors,the,data,type,accessors,for,the,build,side,data,type,param,probe,side,accessors,the,data,type,accessors,for,the,probe,side,data,type,param,partition,number,the,number,of,the,partition,param,recursion,level,the,recursion,level,of,the,partition,param,buffers,the,memory,segments,holding,the,records,param,build,side,record,counter,the,number,of,records,in,the,buffers,param,segment,size,the,size,of,the,memory,segments;hash,partition,type,serializer,bt,build,side,accessors,type,serializer,pt,probe,side,accessors,int,partition,number,int,recursion,level,list,memory,segment,buffers,long,build,side,record,counter,int,segment,size,int,last,segment,limit,super,0,this,build,side,serializer,build,side,accessors,this,probe,side,serializer,probe,side,accessors,this,partition,number,partition,number,this,recursion,level,recursion,level,this,memory,segment,size,segment,size,this,segment,size,bits,math,utils,log2strict,segment,size,this,final,buffer,limit,last,segment,limit,this,partition,buffers,memory,segment,buffers,to,array,new,memory,segment,buffers,size,this,build,side,record,counter,build,side,record,counter,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0
HashPartition -> HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors, 			int partitionNumber, int recursionLevel, List<MemorySegment> buffers, 			long buildSideRecordCounter, int segmentSize, int lastSegmentLimit);1420663430;Constructor creating a partition from a spilled partition file that could be read in one because it was_known to completely fit into memory.__@param buildSideAccessors The data type accessors for the build side data-type._@param probeSideAccessors The data type accessors for the probe side data-type._@param partitionNumber The number of the partition._@param recursionLevel The recursion level of the partition._@param buffers The memory segments holding the records._@param buildSideRecordCounter The number of records in the buffers._@param segmentSize The size of the memory segments.;HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors,_			int partitionNumber, int recursionLevel, List<MemorySegment> buffers,_			long buildSideRecordCounter, int segmentSize, int lastSegmentLimit)_	{_		super(0)__		_		this.buildSideSerializer = buildSideAccessors__		this.probeSideSerializer = probeSideAccessors__		this.partitionNumber = partitionNumber__		this.recursionLevel = recursionLevel__		_		this.memorySegmentSize = segmentSize__		this.segmentSizeBits = MathUtils.log2strict(segmentSize)__		this.finalBufferLimit = lastSegmentLimit__		_		this.partitionBuffers = (MemorySegment[]) buffers.toArray(new MemorySegment[buffers.size()])__		this.buildSideRecordCounter = buildSideRecordCounter__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__	};constructor,creating,a,partition,from,a,spilled,partition,file,that,could,be,read,in,one,because,it,was,known,to,completely,fit,into,memory,param,build,side,accessors,the,data,type,accessors,for,the,build,side,data,type,param,probe,side,accessors,the,data,type,accessors,for,the,probe,side,data,type,param,partition,number,the,number,of,the,partition,param,recursion,level,the,recursion,level,of,the,partition,param,buffers,the,memory,segments,holding,the,records,param,build,side,record,counter,the,number,of,records,in,the,buffers,param,segment,size,the,size,of,the,memory,segments;hash,partition,type,serializer,bt,build,side,accessors,type,serializer,pt,probe,side,accessors,int,partition,number,int,recursion,level,list,memory,segment,buffers,long,build,side,record,counter,int,segment,size,int,last,segment,limit,super,0,this,build,side,serializer,build,side,accessors,this,probe,side,serializer,probe,side,accessors,this,partition,number,partition,number,this,recursion,level,recursion,level,this,memory,segment,size,segment,size,this,segment,size,bits,math,utils,log2strict,segment,size,this,final,buffer,limit,last,segment,limit,this,partition,buffers,memory,segment,buffers,to,array,new,memory,segment,buffers,size,this,build,side,record,counter,build,side,record,counter,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0
HashPartition -> HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors, 			int partitionNumber, int recursionLevel, List<MemorySegment> buffers, 			long buildSideRecordCounter, int segmentSize, int lastSegmentLimit);1426697080;Constructor creating a partition from a spilled partition file that could be read in one because it was_known to completely fit into memory.__@param buildSideAccessors The data type accessors for the build side data-type._@param probeSideAccessors The data type accessors for the probe side data-type._@param partitionNumber The number of the partition._@param recursionLevel The recursion level of the partition._@param buffers The memory segments holding the records._@param buildSideRecordCounter The number of records in the buffers._@param segmentSize The size of the memory segments.;HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors,_			int partitionNumber, int recursionLevel, List<MemorySegment> buffers,_			long buildSideRecordCounter, int segmentSize, int lastSegmentLimit)_	{_		super(0)__		_		this.buildSideSerializer = buildSideAccessors__		this.probeSideSerializer = probeSideAccessors__		this.partitionNumber = partitionNumber__		this.recursionLevel = recursionLevel__		_		this.memorySegmentSize = segmentSize__		this.segmentSizeBits = MathUtils.log2strict(segmentSize)__		this.finalBufferLimit = lastSegmentLimit__		_		this.partitionBuffers = (MemorySegment[]) buffers.toArray(new MemorySegment[buffers.size()])__		this.buildSideRecordCounter = buildSideRecordCounter__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__	};constructor,creating,a,partition,from,a,spilled,partition,file,that,could,be,read,in,one,because,it,was,known,to,completely,fit,into,memory,param,build,side,accessors,the,data,type,accessors,for,the,build,side,data,type,param,probe,side,accessors,the,data,type,accessors,for,the,probe,side,data,type,param,partition,number,the,number,of,the,partition,param,recursion,level,the,recursion,level,of,the,partition,param,buffers,the,memory,segments,holding,the,records,param,build,side,record,counter,the,number,of,records,in,the,buffers,param,segment,size,the,size,of,the,memory,segments;hash,partition,type,serializer,bt,build,side,accessors,type,serializer,pt,probe,side,accessors,int,partition,number,int,recursion,level,list,memory,segment,buffers,long,build,side,record,counter,int,segment,size,int,last,segment,limit,super,0,this,build,side,serializer,build,side,accessors,this,probe,side,serializer,probe,side,accessors,this,partition,number,partition,number,this,recursion,level,recursion,level,this,memory,segment,size,segment,size,this,segment,size,bits,math,utils,log2strict,segment,size,this,final,buffer,limit,last,segment,limit,this,partition,buffers,memory,segment,buffers,to,array,new,memory,segment,buffers,size,this,build,side,record,counter,build,side,record,counter,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0
HashPartition -> HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors, 			int partitionNumber, int recursionLevel, List<MemorySegment> buffers, 			long buildSideRecordCounter, int segmentSize, int lastSegmentLimit);1440607697;Constructor creating a partition from a spilled partition file that could be read in one because it was_known to completely fit into memory.__@param buildSideAccessors The data type accessors for the build side data-type._@param probeSideAccessors The data type accessors for the probe side data-type._@param partitionNumber The number of the partition._@param recursionLevel The recursion level of the partition._@param buffers The memory segments holding the records._@param buildSideRecordCounter The number of records in the buffers._@param segmentSize The size of the memory segments.;HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors,_			int partitionNumber, int recursionLevel, List<MemorySegment> buffers,_			long buildSideRecordCounter, int segmentSize, int lastSegmentLimit)_	{_		super(0)__		_		this.buildSideSerializer = buildSideAccessors__		this.probeSideSerializer = probeSideAccessors__		this.partitionNumber = partitionNumber__		this.recursionLevel = recursionLevel__		_		this.memorySegmentSize = segmentSize__		this.segmentSizeBits = MathUtils.log2strict(segmentSize)__		this.finalBufferLimit = lastSegmentLimit__		_		this.partitionBuffers = (MemorySegment[]) buffers.toArray(new MemorySegment[buffers.size()])__		this.buildSideRecordCounter = buildSideRecordCounter__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__	};constructor,creating,a,partition,from,a,spilled,partition,file,that,could,be,read,in,one,because,it,was,known,to,completely,fit,into,memory,param,build,side,accessors,the,data,type,accessors,for,the,build,side,data,type,param,probe,side,accessors,the,data,type,accessors,for,the,probe,side,data,type,param,partition,number,the,number,of,the,partition,param,recursion,level,the,recursion,level,of,the,partition,param,buffers,the,memory,segments,holding,the,records,param,build,side,record,counter,the,number,of,records,in,the,buffers,param,segment,size,the,size,of,the,memory,segments;hash,partition,type,serializer,bt,build,side,accessors,type,serializer,pt,probe,side,accessors,int,partition,number,int,recursion,level,list,memory,segment,buffers,long,build,side,record,counter,int,segment,size,int,last,segment,limit,super,0,this,build,side,serializer,build,side,accessors,this,probe,side,serializer,probe,side,accessors,this,partition,number,partition,number,this,recursion,level,recursion,level,this,memory,segment,size,segment,size,this,segment,size,bits,math,utils,log2strict,segment,size,this,final,buffer,limit,last,segment,limit,this,partition,buffers,memory,segment,buffers,to,array,new,memory,segment,buffers,size,this,build,side,record,counter,build,side,record,counter,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0
HashPartition -> HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors, 			int partitionNumber, int recursionLevel, List<MemorySegment> buffers, 			long buildSideRecordCounter, int segmentSize, int lastSegmentLimit);1441738685;Constructor creating a partition from a spilled partition file that could be read in one because it was_known to completely fit into memory.__@param buildSideAccessors The data type accessors for the build side data-type._@param probeSideAccessors The data type accessors for the probe side data-type._@param partitionNumber The number of the partition._@param recursionLevel The recursion level of the partition._@param buffers The memory segments holding the records._@param buildSideRecordCounter The number of records in the buffers._@param segmentSize The size of the memory segments.;HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors,_			int partitionNumber, int recursionLevel, List<MemorySegment> buffers,_			long buildSideRecordCounter, int segmentSize, int lastSegmentLimit)_	{_		super(0)__		_		this.buildSideSerializer = buildSideAccessors__		this.probeSideSerializer = probeSideAccessors__		this.partitionNumber = partitionNumber__		this.recursionLevel = recursionLevel__		_		this.memorySegmentSize = segmentSize__		this.segmentSizeBits = MathUtils.log2strict(segmentSize)__		this.finalBufferLimit = lastSegmentLimit__		_		this.partitionBuffers = (MemorySegment[]) buffers.toArray(new MemorySegment[buffers.size()])__		this.buildSideRecordCounter = buildSideRecordCounter__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__	};constructor,creating,a,partition,from,a,spilled,partition,file,that,could,be,read,in,one,because,it,was,known,to,completely,fit,into,memory,param,build,side,accessors,the,data,type,accessors,for,the,build,side,data,type,param,probe,side,accessors,the,data,type,accessors,for,the,probe,side,data,type,param,partition,number,the,number,of,the,partition,param,recursion,level,the,recursion,level,of,the,partition,param,buffers,the,memory,segments,holding,the,records,param,build,side,record,counter,the,number,of,records,in,the,buffers,param,segment,size,the,size,of,the,memory,segments;hash,partition,type,serializer,bt,build,side,accessors,type,serializer,pt,probe,side,accessors,int,partition,number,int,recursion,level,list,memory,segment,buffers,long,build,side,record,counter,int,segment,size,int,last,segment,limit,super,0,this,build,side,serializer,build,side,accessors,this,probe,side,serializer,probe,side,accessors,this,partition,number,partition,number,this,recursion,level,recursion,level,this,memory,segment,size,segment,size,this,segment,size,bits,math,utils,log2strict,segment,size,this,final,buffer,limit,last,segment,limit,this,partition,buffers,memory,segment,buffers,to,array,new,memory,segment,buffers,size,this,build,side,record,counter,build,side,record,counter,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0
HashPartition -> HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors, 			int partitionNumber, int recursionLevel, List<MemorySegment> buffers, 			long buildSideRecordCounter, int segmentSize, int lastSegmentLimit);1443528421;Constructor creating a partition from a spilled partition file that could be read in one because it was_known to completely fit into memory.__@param buildSideAccessors The data type accessors for the build side data-type._@param probeSideAccessors The data type accessors for the probe side data-type._@param partitionNumber The number of the partition._@param recursionLevel The recursion level of the partition._@param buffers The memory segments holding the records._@param buildSideRecordCounter The number of records in the buffers._@param segmentSize The size of the memory segments.;HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors,_			int partitionNumber, int recursionLevel, List<MemorySegment> buffers,_			long buildSideRecordCounter, int segmentSize, int lastSegmentLimit)_	{_		super(0)__		_		this.buildSideSerializer = buildSideAccessors__		this.probeSideSerializer = probeSideAccessors__		this.partitionNumber = partitionNumber__		this.recursionLevel = recursionLevel__		_		this.memorySegmentSize = segmentSize__		this.segmentSizeBits = MathUtils.log2strict(segmentSize)__		this.finalBufferLimit = lastSegmentLimit__		_		this.partitionBuffers = (MemorySegment[]) buffers.toArray(new MemorySegment[buffers.size()])__		this.buildSideRecordCounter = buildSideRecordCounter__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__	};constructor,creating,a,partition,from,a,spilled,partition,file,that,could,be,read,in,one,because,it,was,known,to,completely,fit,into,memory,param,build,side,accessors,the,data,type,accessors,for,the,build,side,data,type,param,probe,side,accessors,the,data,type,accessors,for,the,probe,side,data,type,param,partition,number,the,number,of,the,partition,param,recursion,level,the,recursion,level,of,the,partition,param,buffers,the,memory,segments,holding,the,records,param,build,side,record,counter,the,number,of,records,in,the,buffers,param,segment,size,the,size,of,the,memory,segments;hash,partition,type,serializer,bt,build,side,accessors,type,serializer,pt,probe,side,accessors,int,partition,number,int,recursion,level,list,memory,segment,buffers,long,build,side,record,counter,int,segment,size,int,last,segment,limit,super,0,this,build,side,serializer,build,side,accessors,this,probe,side,serializer,probe,side,accessors,this,partition,number,partition,number,this,recursion,level,recursion,level,this,memory,segment,size,segment,size,this,segment,size,bits,math,utils,log2strict,segment,size,this,final,buffer,limit,last,segment,limit,this,partition,buffers,memory,segment,buffers,to,array,new,memory,segment,buffers,size,this,build,side,record,counter,build,side,record,counter,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0
HashPartition -> HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors, 			int partitionNumber, int recursionLevel, List<MemorySegment> buffers, 			long buildSideRecordCounter, int segmentSize, int lastSegmentLimit);1446633116;Constructor creating a partition from a spilled partition file that could be read in one because it was_known to completely fit into memory.__@param buildSideAccessors The data type accessors for the build side data-type._@param probeSideAccessors The data type accessors for the probe side data-type._@param partitionNumber The number of the partition._@param recursionLevel The recursion level of the partition._@param buffers The memory segments holding the records._@param buildSideRecordCounter The number of records in the buffers._@param segmentSize The size of the memory segments.;HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors,_			int partitionNumber, int recursionLevel, List<MemorySegment> buffers,_			long buildSideRecordCounter, int segmentSize, int lastSegmentLimit)_	{_		super(0)__		_		this.buildSideSerializer = buildSideAccessors__		this.probeSideSerializer = probeSideAccessors__		this.partitionNumber = partitionNumber__		this.recursionLevel = recursionLevel__		_		this.memorySegmentSize = segmentSize__		this.segmentSizeBits = MathUtils.log2strict(segmentSize)__		this.finalBufferLimit = lastSegmentLimit__		_		this.partitionBuffers = (MemorySegment[]) buffers.toArray(new MemorySegment[buffers.size()])__		this.buildSideRecordCounter = buildSideRecordCounter__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__	};constructor,creating,a,partition,from,a,spilled,partition,file,that,could,be,read,in,one,because,it,was,known,to,completely,fit,into,memory,param,build,side,accessors,the,data,type,accessors,for,the,build,side,data,type,param,probe,side,accessors,the,data,type,accessors,for,the,probe,side,data,type,param,partition,number,the,number,of,the,partition,param,recursion,level,the,recursion,level,of,the,partition,param,buffers,the,memory,segments,holding,the,records,param,build,side,record,counter,the,number,of,records,in,the,buffers,param,segment,size,the,size,of,the,memory,segments;hash,partition,type,serializer,bt,build,side,accessors,type,serializer,pt,probe,side,accessors,int,partition,number,int,recursion,level,list,memory,segment,buffers,long,build,side,record,counter,int,segment,size,int,last,segment,limit,super,0,this,build,side,serializer,build,side,accessors,this,probe,side,serializer,probe,side,accessors,this,partition,number,partition,number,this,recursion,level,recursion,level,this,memory,segment,size,segment,size,this,segment,size,bits,math,utils,log2strict,segment,size,this,final,buffer,limit,last,segment,limit,this,partition,buffers,memory,segment,buffers,to,array,new,memory,segment,buffers,size,this,build,side,record,counter,build,side,record,counter,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0
HashPartition -> HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors, 			int partitionNumber, int recursionLevel, List<MemorySegment> buffers, 			long buildSideRecordCounter, int segmentSize, int lastSegmentLimit);1456186722;Constructor creating a partition from a spilled partition file that could be read in one because it was_known to completely fit into memory.__@param buildSideAccessors The data type accessors for the build side data-type._@param probeSideAccessors The data type accessors for the probe side data-type._@param partitionNumber The number of the partition._@param recursionLevel The recursion level of the partition._@param buffers The memory segments holding the records._@param buildSideRecordCounter The number of records in the buffers._@param segmentSize The size of the memory segments.;HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors,_			int partitionNumber, int recursionLevel, List<MemorySegment> buffers,_			long buildSideRecordCounter, int segmentSize, int lastSegmentLimit)_	{_		super(0)__		_		this.buildSideSerializer = buildSideAccessors__		this.probeSideSerializer = probeSideAccessors__		this.partitionNumber = partitionNumber__		this.recursionLevel = recursionLevel__		_		this.memorySegmentSize = segmentSize__		this.segmentSizeBits = MathUtils.log2strict(segmentSize)__		this.finalBufferLimit = lastSegmentLimit__		_		this.partitionBuffers = (MemorySegment[]) buffers.toArray(new MemorySegment[buffers.size()])__		this.buildSideRecordCounter = buildSideRecordCounter__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__	};constructor,creating,a,partition,from,a,spilled,partition,file,that,could,be,read,in,one,because,it,was,known,to,completely,fit,into,memory,param,build,side,accessors,the,data,type,accessors,for,the,build,side,data,type,param,probe,side,accessors,the,data,type,accessors,for,the,probe,side,data,type,param,partition,number,the,number,of,the,partition,param,recursion,level,the,recursion,level,of,the,partition,param,buffers,the,memory,segments,holding,the,records,param,build,side,record,counter,the,number,of,records,in,the,buffers,param,segment,size,the,size,of,the,memory,segments;hash,partition,type,serializer,bt,build,side,accessors,type,serializer,pt,probe,side,accessors,int,partition,number,int,recursion,level,list,memory,segment,buffers,long,build,side,record,counter,int,segment,size,int,last,segment,limit,super,0,this,build,side,serializer,build,side,accessors,this,probe,side,serializer,probe,side,accessors,this,partition,number,partition,number,this,recursion,level,recursion,level,this,memory,segment,size,segment,size,this,segment,size,bits,math,utils,log2strict,segment,size,this,final,buffer,limit,last,segment,limit,this,partition,buffers,memory,segment,buffers,to,array,new,memory,segment,buffers,size,this,build,side,record,counter,build,side,record,counter,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0
HashPartition -> HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors, 			int partitionNumber, int recursionLevel, List<MemorySegment> buffers, 			long buildSideRecordCounter, int segmentSize, int lastSegmentLimit);1460741894;Constructor creating a partition from a spilled partition file that could be read in one because it was_known to completely fit into memory.__@param buildSideAccessors The data type accessors for the build side data-type._@param probeSideAccessors The data type accessors for the probe side data-type._@param partitionNumber The number of the partition._@param recursionLevel The recursion level of the partition._@param buffers The memory segments holding the records._@param buildSideRecordCounter The number of records in the buffers._@param segmentSize The size of the memory segments.;HashPartition(TypeSerializer<BT> buildSideAccessors, TypeSerializer<PT> probeSideAccessors,_			int partitionNumber, int recursionLevel, List<MemorySegment> buffers,_			long buildSideRecordCounter, int segmentSize, int lastSegmentLimit)_	{_		super(0)__		_		this.buildSideSerializer = buildSideAccessors__		this.probeSideSerializer = probeSideAccessors__		this.partitionNumber = partitionNumber__		this.recursionLevel = recursionLevel__		_		this.memorySegmentSize = segmentSize__		this.segmentSizeBits = MathUtils.log2strict(segmentSize)__		this.finalBufferLimit = lastSegmentLimit__		_		this.partitionBuffers = (MemorySegment[]) buffers.toArray(new MemorySegment[buffers.size()])__		this.buildSideRecordCounter = buildSideRecordCounter__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__	};constructor,creating,a,partition,from,a,spilled,partition,file,that,could,be,read,in,one,because,it,was,known,to,completely,fit,into,memory,param,build,side,accessors,the,data,type,accessors,for,the,build,side,data,type,param,probe,side,accessors,the,data,type,accessors,for,the,probe,side,data,type,param,partition,number,the,number,of,the,partition,param,recursion,level,the,recursion,level,of,the,partition,param,buffers,the,memory,segments,holding,the,records,param,build,side,record,counter,the,number,of,records,in,the,buffers,param,segment,size,the,size,of,the,memory,segments;hash,partition,type,serializer,bt,build,side,accessors,type,serializer,pt,probe,side,accessors,int,partition,number,int,recursion,level,list,memory,segment,buffers,long,build,side,record,counter,int,segment,size,int,last,segment,limit,super,0,this,build,side,serializer,build,side,accessors,this,probe,side,serializer,probe,side,accessors,this,partition,number,partition,number,this,recursion,level,recursion,level,this,memory,segment,size,segment,size,this,segment,size,bits,math,utils,log2strict,segment,size,this,final,buffer,limit,last,segment,limit,this,partition,buffers,memory,segment,buffers,to,array,new,memory,segment,buffers,size,this,build,side,record,counter,build,side,record,counter,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0
HashPartition -> public int getNumOccupiedMemorySegments();1443528421;Gets the number of memory segments used by this partition, which includes build side_memory buffers and overflow memory segments.__@return The number of occupied memory segments.;public int getNumOccupiedMemorySegments() {_		_		final int numPartitionBuffers = this.partitionBuffers != null ? this.partitionBuffers.length : 1__		return numPartitionBuffers + numOverflowSegments__	};gets,the,number,of,memory,segments,used,by,this,partition,which,includes,build,side,memory,buffers,and,overflow,memory,segments,return,the,number,of,occupied,memory,segments;public,int,get,num,occupied,memory,segments,final,int,num,partition,buffers,this,partition,buffers,null,this,partition,buffers,length,1,return,num,partition,buffers,num,overflow,segments
HashPartition -> public int getNumOccupiedMemorySegments();1446633116;Gets the number of memory segments used by this partition, which includes build side_memory buffers and overflow memory segments.__@return The number of occupied memory segments.;public int getNumOccupiedMemorySegments() {_		_		final int numPartitionBuffers = this.partitionBuffers != null ?_			this.partitionBuffers.length : this.buildSideWriteBuffer.getNumOccupiedMemorySegments()__		return numPartitionBuffers + numOverflowSegments__	};gets,the,number,of,memory,segments,used,by,this,partition,which,includes,build,side,memory,buffers,and,overflow,memory,segments,return,the,number,of,occupied,memory,segments;public,int,get,num,occupied,memory,segments,final,int,num,partition,buffers,this,partition,buffers,null,this,partition,buffers,length,this,build,side,write,buffer,get,num,occupied,memory,segments,return,num,partition,buffers,num,overflow,segments
HashPartition -> public int getNumOccupiedMemorySegments();1456186722;Gets the number of memory segments used by this partition, which includes build side_memory buffers and overflow memory segments.__@return The number of occupied memory segments.;public int getNumOccupiedMemorySegments() {_		_		final int numPartitionBuffers = this.partitionBuffers != null ?_			this.partitionBuffers.length : this.buildSideWriteBuffer.getNumOccupiedMemorySegments()__		return numPartitionBuffers + numOverflowSegments__	};gets,the,number,of,memory,segments,used,by,this,partition,which,includes,build,side,memory,buffers,and,overflow,memory,segments,return,the,number,of,occupied,memory,segments;public,int,get,num,occupied,memory,segments,final,int,num,partition,buffers,this,partition,buffers,null,this,partition,buffers,length,this,build,side,write,buffer,get,num,occupied,memory,segments,return,num,partition,buffers,num,overflow,segments
HashPartition -> public int getNumOccupiedMemorySegments();1460741894;Gets the number of memory segments used by this partition, which includes build side_memory buffers and overflow memory segments.__@return The number of occupied memory segments.;public int getNumOccupiedMemorySegments() {_		_		final int numPartitionBuffers = this.partitionBuffers != null ?_			this.partitionBuffers.length : this.buildSideWriteBuffer.getNumOccupiedMemorySegments()__		return numPartitionBuffers + numOverflowSegments__	};gets,the,number,of,memory,segments,used,by,this,partition,which,includes,build,side,memory,buffers,and,overflow,memory,segments,return,the,number,of,occupied,memory,segments;public,int,get,num,occupied,memory,segments,final,int,num,partition,buffers,this,partition,buffers,null,this,partition,buffers,length,this,build,side,write,buffer,get,num,occupied,memory,segments,return,num,partition,buffers,num,overflow,segments
HashPartition -> public int finalizeProbePhase(List<MemorySegment> freeMemory, List<HashPartition<BT, PT>> spilledPartitions, 			boolean keepUnprobedSpilledPartitions) 	throws IOException;1456186722;@param keepUnprobedSpilledPartitions If true then partitions that were spilled but received no further probe_requests will be retained_ used for build-side outer joins._@return The number of write-behind buffers reclaimable after this method call.__@throws IOException;public int finalizeProbePhase(List<MemorySegment> freeMemory, List<HashPartition<BT, PT>> spilledPartitions,_			boolean keepUnprobedSpilledPartitions)_	throws IOException_	{_		if (isInMemory()) {_			_			_			_			for (int k = 0_ k < this.numOverflowSegments_ k++) {_				freeMemory.add(this.overflowSegments[k])__			}_			this.overflowSegments = null__			this.numOverflowSegments = 0__			this.nextOverflowBucket = 0__			_			for (MemorySegment partitionBuffer : this.partitionBuffers) {_				freeMemory.add(partitionBuffer)__			}_			this.partitionBuffers = null__			return 0__		}_		else if (this.probeSideRecordCounter == 0 && !keepUnprobedSpilledPartitions) {_			_			_			freeMemory.add(this.probeSideBuffer.getCurrentSegment())___			_			this.probeSideChannel.close()__			this.buildSideChannel.deleteChannel()__			this.probeSideChannel.deleteChannel()__			return 0__		}_		else {_			_			this.probeSideBuffer.close()__			this.probeSideChannel.close()__			spilledPartitions.add(this)__			return 1__		}_	};param,keep,unprobed,spilled,partitions,if,true,then,partitions,that,were,spilled,but,received,no,further,probe,requests,will,be,retained,used,for,build,side,outer,joins,return,the,number,of,write,behind,buffers,reclaimable,after,this,method,call,throws,ioexception;public,int,finalize,probe,phase,list,memory,segment,free,memory,list,hash,partition,bt,pt,spilled,partitions,boolean,keep,unprobed,spilled,partitions,throws,ioexception,if,is,in,memory,for,int,k,0,k,this,num,overflow,segments,k,free,memory,add,this,overflow,segments,k,this,overflow,segments,null,this,num,overflow,segments,0,this,next,overflow,bucket,0,for,memory,segment,partition,buffer,this,partition,buffers,free,memory,add,partition,buffer,this,partition,buffers,null,return,0,else,if,this,probe,side,record,counter,0,keep,unprobed,spilled,partitions,free,memory,add,this,probe,side,buffer,get,current,segment,this,probe,side,channel,close,this,build,side,channel,delete,channel,this,probe,side,channel,delete,channel,return,0,else,this,probe,side,buffer,close,this,probe,side,channel,close,spilled,partitions,add,this,return,1
HashPartition -> public int finalizeProbePhase(List<MemorySegment> freeMemory, List<HashPartition<BT, PT>> spilledPartitions, 			boolean keepUnprobedSpilledPartitions) 	throws IOException;1460741894;@param keepUnprobedSpilledPartitions If true then partitions that were spilled but received no further probe_requests will be retained_ used for build-side outer joins._@return The number of write-behind buffers reclaimable after this method call.__@throws IOException;public int finalizeProbePhase(List<MemorySegment> freeMemory, List<HashPartition<BT, PT>> spilledPartitions,_			boolean keepUnprobedSpilledPartitions)_	throws IOException_	{_		if (isInMemory()) {_			_			_			_			for (int k = 0_ k < this.numOverflowSegments_ k++) {_				freeMemory.add(this.overflowSegments[k])__			}_			this.overflowSegments = null__			this.numOverflowSegments = 0__			this.nextOverflowBucket = 0__			_			for (MemorySegment partitionBuffer : this.partitionBuffers) {_				freeMemory.add(partitionBuffer)__			}_			this.partitionBuffers = null__			return 0__		}_		else if (this.probeSideRecordCounter == 0 && !keepUnprobedSpilledPartitions) {_			_			_			freeMemory.add(this.probeSideBuffer.getCurrentSegment())___			_			this.probeSideChannel.close()__			this.buildSideChannel.deleteChannel()__			this.probeSideChannel.deleteChannel()__			return 0__		}_		else {_			_			this.probeSideBuffer.close()__			this.probeSideChannel.close()__			spilledPartitions.add(this)__			return 1__		}_	};param,keep,unprobed,spilled,partitions,if,true,then,partitions,that,were,spilled,but,received,no,further,probe,requests,will,be,retained,used,for,build,side,outer,joins,return,the,number,of,write,behind,buffers,reclaimable,after,this,method,call,throws,ioexception;public,int,finalize,probe,phase,list,memory,segment,free,memory,list,hash,partition,bt,pt,spilled,partitions,boolean,keep,unprobed,spilled,partitions,throws,ioexception,if,is,in,memory,for,int,k,0,k,this,num,overflow,segments,k,free,memory,add,this,overflow,segments,k,this,overflow,segments,null,this,num,overflow,segments,0,this,next,overflow,bucket,0,for,memory,segment,partition,buffer,this,partition,buffers,free,memory,add,partition,buffer,this,partition,buffers,null,return,0,else,if,this,probe,side,record,counter,0,keep,unprobed,spilled,partitions,free,memory,add,this,probe,side,buffer,get,current,segment,this,probe,side,channel,close,this,build,side,channel,delete,channel,this,probe,side,channel,delete,channel,return,0,else,this,probe,side,buffer,close,this,probe,side,channel,close,spilled,partitions,add,this,return,1
HashPartition -> public final boolean isInMemory();1405024514;Checks whether this partition is in memory or spilled.__@return True, if the partition is in memory, false if it is spilled.;public final boolean isInMemory() {_		return this.buildSideChannel == null__	};checks,whether,this,partition,is,in,memory,or,spilled,return,true,if,the,partition,is,in,memory,false,if,it,is,spilled;public,final,boolean,is,in,memory,return,this,build,side,channel,null
HashPartition -> public final boolean isInMemory();1405090423;Checks whether this partition is in memory or spilled.__@return True, if the partition is in memory, false if it is spilled.;public final boolean isInMemory() {_		return this.buildSideChannel == null__	};checks,whether,this,partition,is,in,memory,or,spilled,return,true,if,the,partition,is,in,memory,false,if,it,is,spilled;public,final,boolean,is,in,memory,return,this,build,side,channel,null
HashPartition -> public final boolean isInMemory();1411473593;Checks whether this partition is in memory or spilled.__@return True, if the partition is in memory, false if it is spilled.;public final boolean isInMemory() {_		return this.buildSideChannel == null__	};checks,whether,this,partition,is,in,memory,or,spilled,return,true,if,the,partition,is,in,memory,false,if,it,is,spilled;public,final,boolean,is,in,memory,return,this,build,side,channel,null
HashPartition -> public final boolean isInMemory();1412164980;Checks whether this partition is in memory or spilled.__@return True, if the partition is in memory, false if it is spilled.;public final boolean isInMemory() {_		return this.buildSideChannel == null__	};checks,whether,this,partition,is,in,memory,or,spilled,return,true,if,the,partition,is,in,memory,false,if,it,is,spilled;public,final,boolean,is,in,memory,return,this,build,side,channel,null
HashPartition -> public final boolean isInMemory();1414786554;Checks whether this partition is in memory or spilled.__@return True, if the partition is in memory, false if it is spilled.;public final boolean isInMemory() {_		return this.buildSideChannel == null__	};checks,whether,this,partition,is,in,memory,or,spilled,return,true,if,the,partition,is,in,memory,false,if,it,is,spilled;public,final,boolean,is,in,memory,return,this,build,side,channel,null
HashPartition -> public final boolean isInMemory();1415702894;Checks whether this partition is in memory or spilled.__@return True, if the partition is in memory, false if it is spilled.;public final boolean isInMemory() {_		return this.buildSideChannel == null__	};checks,whether,this,partition,is,in,memory,or,spilled,return,true,if,the,partition,is,in,memory,false,if,it,is,spilled;public,final,boolean,is,in,memory,return,this,build,side,channel,null
HashPartition -> public final boolean isInMemory();1418570573;Checks whether this partition is in memory or spilled.__@return True, if the partition is in memory, false if it is spilled.;public final boolean isInMemory() {_		return this.buildSideChannel == null__	};checks,whether,this,partition,is,in,memory,or,spilled,return,true,if,the,partition,is,in,memory,false,if,it,is,spilled;public,final,boolean,is,in,memory,return,this,build,side,channel,null
HashPartition -> public final boolean isInMemory();1420654570;Checks whether this partition is in memory or spilled.__@return True, if the partition is in memory, false if it is spilled.;public final boolean isInMemory() {_		return this.buildSideChannel == null__	};checks,whether,this,partition,is,in,memory,or,spilled,return,true,if,the,partition,is,in,memory,false,if,it,is,spilled;public,final,boolean,is,in,memory,return,this,build,side,channel,null
HashPartition -> public final boolean isInMemory();1420663430;Checks whether this partition is in memory or spilled.__@return True, if the partition is in memory, false if it is spilled.;public final boolean isInMemory() {_		return this.buildSideChannel == null__	};checks,whether,this,partition,is,in,memory,or,spilled,return,true,if,the,partition,is,in,memory,false,if,it,is,spilled;public,final,boolean,is,in,memory,return,this,build,side,channel,null
HashPartition -> public final boolean isInMemory();1426697080;Checks whether this partition is in memory or spilled.__@return True, if the partition is in memory, false if it is spilled.;public final boolean isInMemory() {_		return this.buildSideChannel == null__	};checks,whether,this,partition,is,in,memory,or,spilled,return,true,if,the,partition,is,in,memory,false,if,it,is,spilled;public,final,boolean,is,in,memory,return,this,build,side,channel,null
HashPartition -> public final boolean isInMemory();1440607697;Checks whether this partition is in memory or spilled.__@return True, if the partition is in memory, false if it is spilled.;public final boolean isInMemory() {_		return this.buildSideChannel == null__	};checks,whether,this,partition,is,in,memory,or,spilled,return,true,if,the,partition,is,in,memory,false,if,it,is,spilled;public,final,boolean,is,in,memory,return,this,build,side,channel,null
HashPartition -> public final boolean isInMemory();1441738685;Checks whether this partition is in memory or spilled.__@return True, if the partition is in memory, false if it is spilled.;public final boolean isInMemory() {_		return this.buildSideChannel == null__	};checks,whether,this,partition,is,in,memory,or,spilled,return,true,if,the,partition,is,in,memory,false,if,it,is,spilled;public,final,boolean,is,in,memory,return,this,build,side,channel,null
HashPartition -> public final boolean isInMemory();1443528421;Checks whether this partition is in memory or spilled.__@return True, if the partition is in memory, false if it is spilled.;public final boolean isInMemory() {_		return this.buildSideChannel == null__	};checks,whether,this,partition,is,in,memory,or,spilled,return,true,if,the,partition,is,in,memory,false,if,it,is,spilled;public,final,boolean,is,in,memory,return,this,build,side,channel,null
HashPartition -> public final boolean isInMemory();1446633116;Checks whether this partition is in memory or spilled.__@return True, if the partition is in memory, false if it is spilled.;public final boolean isInMemory() {_		return this.buildSideChannel == null__	};checks,whether,this,partition,is,in,memory,or,spilled,return,true,if,the,partition,is,in,memory,false,if,it,is,spilled;public,final,boolean,is,in,memory,return,this,build,side,channel,null
HashPartition -> public final boolean isInMemory();1456186722;Checks whether this partition is in memory or spilled.__@return True, if the partition is in memory, false if it is spilled.;public final boolean isInMemory() {_		return this.buildSideChannel == null__	};checks,whether,this,partition,is,in,memory,or,spilled,return,true,if,the,partition,is,in,memory,false,if,it,is,spilled;public,final,boolean,is,in,memory,return,this,build,side,channel,null
HashPartition -> public final boolean isInMemory();1460741894;Checks whether this partition is in memory or spilled.__@return True, if the partition is in memory, false if it is spilled.;public final boolean isInMemory() {_		return this.buildSideChannel == null__	};checks,whether,this,partition,is,in,memory,or,spilled,return,true,if,the,partition,is,in,memory,false,if,it,is,spilled;public,final,boolean,is,in,memory,return,this,build,side,channel,null
HashPartition -> public int finalizeProbePhase(List<MemorySegment> freeMemory, List<HashPartition<BT, PT>> spilledPartitions) 	throws IOException;1405024514;@param freeMemory_@param spilledPartitions_@return The number of write-behind buffers reclaimable after this method call.__@throws IOException;public int finalizeProbePhase(List<MemorySegment> freeMemory, List<HashPartition<BT, PT>> spilledPartitions)_	throws IOException_	{_		if (isInMemory()) {_			_			_			_			for (int k = 0_ k < this.numOverflowSegments_ k++) {_				freeMemory.add(this.overflowSegments[k])__			}_			this.overflowSegments = null__			this.numOverflowSegments = 0__			this.nextOverflowBucket = 0__			_			for (int i = 0_ i < this.partitionBuffers.length_ i++) {_				freeMemory.add(this.partitionBuffers[i])__			}_			this.partitionBuffers = null__			return 0__		}_		else if (this.probeSideRecordCounter == 0) { _			_			_			freeMemory.add(this.probeSideBuffer.getCurrentSegment())__			_			_			this.probeSideChannel.close()__			this.buildSideChannel.deleteChannel()__			this.probeSideChannel.deleteChannel()__			_			return 0__		}_		else {_			_			this.probeSideBuffer.close()__			this.probeSideChannel.close()__			spilledPartitions.add(this)__			return 1__		}_	};param,free,memory,param,spilled,partitions,return,the,number,of,write,behind,buffers,reclaimable,after,this,method,call,throws,ioexception;public,int,finalize,probe,phase,list,memory,segment,free,memory,list,hash,partition,bt,pt,spilled,partitions,throws,ioexception,if,is,in,memory,for,int,k,0,k,this,num,overflow,segments,k,free,memory,add,this,overflow,segments,k,this,overflow,segments,null,this,num,overflow,segments,0,this,next,overflow,bucket,0,for,int,i,0,i,this,partition,buffers,length,i,free,memory,add,this,partition,buffers,i,this,partition,buffers,null,return,0,else,if,this,probe,side,record,counter,0,free,memory,add,this,probe,side,buffer,get,current,segment,this,probe,side,channel,close,this,build,side,channel,delete,channel,this,probe,side,channel,delete,channel,return,0,else,this,probe,side,buffer,close,this,probe,side,channel,close,spilled,partitions,add,this,return,1
HashPartition -> public int finalizeProbePhase(List<MemorySegment> freeMemory, List<HashPartition<BT, PT>> spilledPartitions) 	throws IOException;1405090423;@param freeMemory_@param spilledPartitions_@return The number of write-behind buffers reclaimable after this method call.__@throws IOException;public int finalizeProbePhase(List<MemorySegment> freeMemory, List<HashPartition<BT, PT>> spilledPartitions)_	throws IOException_	{_		if (isInMemory()) {_			_			_			_			for (int k = 0_ k < this.numOverflowSegments_ k++) {_				freeMemory.add(this.overflowSegments[k])__			}_			this.overflowSegments = null__			this.numOverflowSegments = 0__			this.nextOverflowBucket = 0__			_			for (int i = 0_ i < this.partitionBuffers.length_ i++) {_				freeMemory.add(this.partitionBuffers[i])__			}_			this.partitionBuffers = null__			return 0__		}_		else if (this.probeSideRecordCounter == 0) { _			_			_			freeMemory.add(this.probeSideBuffer.getCurrentSegment())__			_			_			this.probeSideChannel.close()__			this.buildSideChannel.deleteChannel()__			this.probeSideChannel.deleteChannel()__			_			return 0__		}_		else {_			_			this.probeSideBuffer.close()__			this.probeSideChannel.close()__			spilledPartitions.add(this)__			return 1__		}_	};param,free,memory,param,spilled,partitions,return,the,number,of,write,behind,buffers,reclaimable,after,this,method,call,throws,ioexception;public,int,finalize,probe,phase,list,memory,segment,free,memory,list,hash,partition,bt,pt,spilled,partitions,throws,ioexception,if,is,in,memory,for,int,k,0,k,this,num,overflow,segments,k,free,memory,add,this,overflow,segments,k,this,overflow,segments,null,this,num,overflow,segments,0,this,next,overflow,bucket,0,for,int,i,0,i,this,partition,buffers,length,i,free,memory,add,this,partition,buffers,i,this,partition,buffers,null,return,0,else,if,this,probe,side,record,counter,0,free,memory,add,this,probe,side,buffer,get,current,segment,this,probe,side,channel,close,this,build,side,channel,delete,channel,this,probe,side,channel,delete,channel,return,0,else,this,probe,side,buffer,close,this,probe,side,channel,close,spilled,partitions,add,this,return,1
HashPartition -> public int finalizeProbePhase(List<MemorySegment> freeMemory, List<HashPartition<BT, PT>> spilledPartitions) 	throws IOException;1411473593;@param freeMemory_@param spilledPartitions_@return The number of write-behind buffers reclaimable after this method call.__@throws IOException;public int finalizeProbePhase(List<MemorySegment> freeMemory, List<HashPartition<BT, PT>> spilledPartitions)_	throws IOException_	{_		if (isInMemory()) {_			_			_			_			for (int k = 0_ k < this.numOverflowSegments_ k++) {_				freeMemory.add(this.overflowSegments[k])__			}_			this.overflowSegments = null__			this.numOverflowSegments = 0__			this.nextOverflowBucket = 0__			_			for (int i = 0_ i < this.partitionBuffers.length_ i++) {_				freeMemory.add(this.partitionBuffers[i])__			}_			this.partitionBuffers = null__			return 0__		}_		else if (this.probeSideRecordCounter == 0) { _			_			_			freeMemory.add(this.probeSideBuffer.getCurrentSegment())__			_			_			this.probeSideChannel.close()__			this.buildSideChannel.deleteChannel()__			this.probeSideChannel.deleteChannel()__			_			return 0__		}_		else {_			_			this.probeSideBuffer.close()__			this.probeSideChannel.close()__			spilledPartitions.add(this)__			return 1__		}_	};param,free,memory,param,spilled,partitions,return,the,number,of,write,behind,buffers,reclaimable,after,this,method,call,throws,ioexception;public,int,finalize,probe,phase,list,memory,segment,free,memory,list,hash,partition,bt,pt,spilled,partitions,throws,ioexception,if,is,in,memory,for,int,k,0,k,this,num,overflow,segments,k,free,memory,add,this,overflow,segments,k,this,overflow,segments,null,this,num,overflow,segments,0,this,next,overflow,bucket,0,for,int,i,0,i,this,partition,buffers,length,i,free,memory,add,this,partition,buffers,i,this,partition,buffers,null,return,0,else,if,this,probe,side,record,counter,0,free,memory,add,this,probe,side,buffer,get,current,segment,this,probe,side,channel,close,this,build,side,channel,delete,channel,this,probe,side,channel,delete,channel,return,0,else,this,probe,side,buffer,close,this,probe,side,channel,close,spilled,partitions,add,this,return,1
HashPartition -> public int finalizeProbePhase(List<MemorySegment> freeMemory, List<HashPartition<BT, PT>> spilledPartitions) 	throws IOException;1412164980;@param freeMemory_@param spilledPartitions_@return The number of write-behind buffers reclaimable after this method call.__@throws IOException;public int finalizeProbePhase(List<MemorySegment> freeMemory, List<HashPartition<BT, PT>> spilledPartitions)_	throws IOException_	{_		if (isInMemory()) {_			_			_			_			for (int k = 0_ k < this.numOverflowSegments_ k++) {_				freeMemory.add(this.overflowSegments[k])__			}_			this.overflowSegments = null__			this.numOverflowSegments = 0__			this.nextOverflowBucket = 0__			_			for (int i = 0_ i < this.partitionBuffers.length_ i++) {_				freeMemory.add(this.partitionBuffers[i])__			}_			this.partitionBuffers = null__			return 0__		}_		else if (this.probeSideRecordCounter == 0) { _			_			_			freeMemory.add(this.probeSideBuffer.getCurrentSegment())__			_			_			this.probeSideChannel.close()__			this.buildSideChannel.deleteChannel()__			this.probeSideChannel.deleteChannel()__			_			return 0__		}_		else {_			_			this.probeSideBuffer.close()__			this.probeSideChannel.close()__			spilledPartitions.add(this)__			return 1__		}_	};param,free,memory,param,spilled,partitions,return,the,number,of,write,behind,buffers,reclaimable,after,this,method,call,throws,ioexception;public,int,finalize,probe,phase,list,memory,segment,free,memory,list,hash,partition,bt,pt,spilled,partitions,throws,ioexception,if,is,in,memory,for,int,k,0,k,this,num,overflow,segments,k,free,memory,add,this,overflow,segments,k,this,overflow,segments,null,this,num,overflow,segments,0,this,next,overflow,bucket,0,for,int,i,0,i,this,partition,buffers,length,i,free,memory,add,this,partition,buffers,i,this,partition,buffers,null,return,0,else,if,this,probe,side,record,counter,0,free,memory,add,this,probe,side,buffer,get,current,segment,this,probe,side,channel,close,this,build,side,channel,delete,channel,this,probe,side,channel,delete,channel,return,0,else,this,probe,side,buffer,close,this,probe,side,channel,close,spilled,partitions,add,this,return,1
HashPartition -> public int finalizeProbePhase(List<MemorySegment> freeMemory, List<HashPartition<BT, PT>> spilledPartitions) 	throws IOException;1414786554;@param freeMemory_@param spilledPartitions_@return The number of write-behind buffers reclaimable after this method call.__@throws IOException;public int finalizeProbePhase(List<MemorySegment> freeMemory, List<HashPartition<BT, PT>> spilledPartitions)_	throws IOException_	{_		if (isInMemory()) {_			_			_			_			for (int k = 0_ k < this.numOverflowSegments_ k++) {_				freeMemory.add(this.overflowSegments[k])__			}_			this.overflowSegments = null__			this.numOverflowSegments = 0__			this.nextOverflowBucket = 0__			_			for (int i = 0_ i < this.partitionBuffers.length_ i++) {_				freeMemory.add(this.partitionBuffers[i])__			}_			this.partitionBuffers = null__			return 0__		}_		else if (this.probeSideRecordCounter == 0) { _			_			_			freeMemory.add(this.probeSideBuffer.getCurrentSegment())__			_			_			this.probeSideChannel.close()__			this.buildSideChannel.deleteChannel()__			this.probeSideChannel.deleteChannel()__			_			return 0__		}_		else {_			_			this.probeSideBuffer.close()__			this.probeSideChannel.close()__			spilledPartitions.add(this)__			return 1__		}_	};param,free,memory,param,spilled,partitions,return,the,number,of,write,behind,buffers,reclaimable,after,this,method,call,throws,ioexception;public,int,finalize,probe,phase,list,memory,segment,free,memory,list,hash,partition,bt,pt,spilled,partitions,throws,ioexception,if,is,in,memory,for,int,k,0,k,this,num,overflow,segments,k,free,memory,add,this,overflow,segments,k,this,overflow,segments,null,this,num,overflow,segments,0,this,next,overflow,bucket,0,for,int,i,0,i,this,partition,buffers,length,i,free,memory,add,this,partition,buffers,i,this,partition,buffers,null,return,0,else,if,this,probe,side,record,counter,0,free,memory,add,this,probe,side,buffer,get,current,segment,this,probe,side,channel,close,this,build,side,channel,delete,channel,this,probe,side,channel,delete,channel,return,0,else,this,probe,side,buffer,close,this,probe,side,channel,close,spilled,partitions,add,this,return,1
HashPartition -> public int finalizeProbePhase(List<MemorySegment> freeMemory, List<HashPartition<BT, PT>> spilledPartitions) 	throws IOException;1415702894;@param freeMemory_@param spilledPartitions_@return The number of write-behind buffers reclaimable after this method call.__@throws IOException;public int finalizeProbePhase(List<MemorySegment> freeMemory, List<HashPartition<BT, PT>> spilledPartitions)_	throws IOException_	{_		if (isInMemory()) {_			_			_			_			for (int k = 0_ k < this.numOverflowSegments_ k++) {_				freeMemory.add(this.overflowSegments[k])__			}_			this.overflowSegments = null__			this.numOverflowSegments = 0__			this.nextOverflowBucket = 0__			_			for (int i = 0_ i < this.partitionBuffers.length_ i++) {_				freeMemory.add(this.partitionBuffers[i])__			}_			this.partitionBuffers = null__			return 0__		}_		else if (this.probeSideRecordCounter == 0) { _			_			_			freeMemory.add(this.probeSideBuffer.getCurrentSegment())__			_			_			this.probeSideChannel.close()__			this.buildSideChannel.deleteChannel()__			this.probeSideChannel.deleteChannel()__			_			return 0__		}_		else {_			_			this.probeSideBuffer.close()__			this.probeSideChannel.close()__			spilledPartitions.add(this)__			return 1__		}_	};param,free,memory,param,spilled,partitions,return,the,number,of,write,behind,buffers,reclaimable,after,this,method,call,throws,ioexception;public,int,finalize,probe,phase,list,memory,segment,free,memory,list,hash,partition,bt,pt,spilled,partitions,throws,ioexception,if,is,in,memory,for,int,k,0,k,this,num,overflow,segments,k,free,memory,add,this,overflow,segments,k,this,overflow,segments,null,this,num,overflow,segments,0,this,next,overflow,bucket,0,for,int,i,0,i,this,partition,buffers,length,i,free,memory,add,this,partition,buffers,i,this,partition,buffers,null,return,0,else,if,this,probe,side,record,counter,0,free,memory,add,this,probe,side,buffer,get,current,segment,this,probe,side,channel,close,this,build,side,channel,delete,channel,this,probe,side,channel,delete,channel,return,0,else,this,probe,side,buffer,close,this,probe,side,channel,close,spilled,partitions,add,this,return,1
HashPartition -> public int finalizeProbePhase(List<MemorySegment> freeMemory, List<HashPartition<BT, PT>> spilledPartitions) 	throws IOException;1418570573;@param freeMemory_@param spilledPartitions_@return The number of write-behind buffers reclaimable after this method call.__@throws IOException;public int finalizeProbePhase(List<MemorySegment> freeMemory, List<HashPartition<BT, PT>> spilledPartitions)_	throws IOException_	{_		if (isInMemory()) {_			_			_			_			for (int k = 0_ k < this.numOverflowSegments_ k++) {_				freeMemory.add(this.overflowSegments[k])__			}_			this.overflowSegments = null__			this.numOverflowSegments = 0__			this.nextOverflowBucket = 0__			_			for (int i = 0_ i < this.partitionBuffers.length_ i++) {_				freeMemory.add(this.partitionBuffers[i])__			}_			this.partitionBuffers = null__			return 0__		}_		else if (this.probeSideRecordCounter == 0) { _			_			_			freeMemory.add(this.probeSideBuffer.getCurrentSegment())__			_			_			this.probeSideChannel.close()__			this.buildSideChannel.deleteChannel()__			this.probeSideChannel.deleteChannel()__			_			return 0__		}_		else {_			_			this.probeSideBuffer.close()__			this.probeSideChannel.close()__			spilledPartitions.add(this)__			return 1__		}_	};param,free,memory,param,spilled,partitions,return,the,number,of,write,behind,buffers,reclaimable,after,this,method,call,throws,ioexception;public,int,finalize,probe,phase,list,memory,segment,free,memory,list,hash,partition,bt,pt,spilled,partitions,throws,ioexception,if,is,in,memory,for,int,k,0,k,this,num,overflow,segments,k,free,memory,add,this,overflow,segments,k,this,overflow,segments,null,this,num,overflow,segments,0,this,next,overflow,bucket,0,for,int,i,0,i,this,partition,buffers,length,i,free,memory,add,this,partition,buffers,i,this,partition,buffers,null,return,0,else,if,this,probe,side,record,counter,0,free,memory,add,this,probe,side,buffer,get,current,segment,this,probe,side,channel,close,this,build,side,channel,delete,channel,this,probe,side,channel,delete,channel,return,0,else,this,probe,side,buffer,close,this,probe,side,channel,close,spilled,partitions,add,this,return,1
HashPartition -> public int finalizeProbePhase(List<MemorySegment> freeMemory, List<HashPartition<BT, PT>> spilledPartitions) 	throws IOException;1420654570;@param freeMemory_@param spilledPartitions_@return The number of write-behind buffers reclaimable after this method call.__@throws IOException;public int finalizeProbePhase(List<MemorySegment> freeMemory, List<HashPartition<BT, PT>> spilledPartitions)_	throws IOException_	{_		if (isInMemory()) {_			_			_			_			for (int k = 0_ k < this.numOverflowSegments_ k++) {_				freeMemory.add(this.overflowSegments[k])__			}_			this.overflowSegments = null__			this.numOverflowSegments = 0__			this.nextOverflowBucket = 0__			_			for (int i = 0_ i < this.partitionBuffers.length_ i++) {_				freeMemory.add(this.partitionBuffers[i])__			}_			this.partitionBuffers = null__			return 0__		}_		else if (this.probeSideRecordCounter == 0) { _			_			_			freeMemory.add(this.probeSideBuffer.getCurrentSegment())__			_			_			this.probeSideChannel.close()__			this.buildSideChannel.deleteChannel()__			this.probeSideChannel.deleteChannel()__			_			return 0__		}_		else {_			_			this.probeSideBuffer.close()__			this.probeSideChannel.close()__			spilledPartitions.add(this)__			return 1__		}_	};param,free,memory,param,spilled,partitions,return,the,number,of,write,behind,buffers,reclaimable,after,this,method,call,throws,ioexception;public,int,finalize,probe,phase,list,memory,segment,free,memory,list,hash,partition,bt,pt,spilled,partitions,throws,ioexception,if,is,in,memory,for,int,k,0,k,this,num,overflow,segments,k,free,memory,add,this,overflow,segments,k,this,overflow,segments,null,this,num,overflow,segments,0,this,next,overflow,bucket,0,for,int,i,0,i,this,partition,buffers,length,i,free,memory,add,this,partition,buffers,i,this,partition,buffers,null,return,0,else,if,this,probe,side,record,counter,0,free,memory,add,this,probe,side,buffer,get,current,segment,this,probe,side,channel,close,this,build,side,channel,delete,channel,this,probe,side,channel,delete,channel,return,0,else,this,probe,side,buffer,close,this,probe,side,channel,close,spilled,partitions,add,this,return,1
HashPartition -> public int finalizeProbePhase(List<MemorySegment> freeMemory, List<HashPartition<BT, PT>> spilledPartitions) 	throws IOException;1420663430;@param freeMemory_@param spilledPartitions_@return The number of write-behind buffers reclaimable after this method call.__@throws IOException;public int finalizeProbePhase(List<MemorySegment> freeMemory, List<HashPartition<BT, PT>> spilledPartitions)_	throws IOException_	{_		if (isInMemory()) {_			_			_			_			for (int k = 0_ k < this.numOverflowSegments_ k++) {_				freeMemory.add(this.overflowSegments[k])__			}_			this.overflowSegments = null__			this.numOverflowSegments = 0__			this.nextOverflowBucket = 0__			_			for (int i = 0_ i < this.partitionBuffers.length_ i++) {_				freeMemory.add(this.partitionBuffers[i])__			}_			this.partitionBuffers = null__			return 0__		}_		else if (this.probeSideRecordCounter == 0) { _			_			_			freeMemory.add(this.probeSideBuffer.getCurrentSegment())__			_			_			this.probeSideChannel.close()__			this.buildSideChannel.deleteChannel()__			this.probeSideChannel.deleteChannel()__			_			return 0__		}_		else {_			_			this.probeSideBuffer.close()__			this.probeSideChannel.close()__			spilledPartitions.add(this)__			return 1__		}_	};param,free,memory,param,spilled,partitions,return,the,number,of,write,behind,buffers,reclaimable,after,this,method,call,throws,ioexception;public,int,finalize,probe,phase,list,memory,segment,free,memory,list,hash,partition,bt,pt,spilled,partitions,throws,ioexception,if,is,in,memory,for,int,k,0,k,this,num,overflow,segments,k,free,memory,add,this,overflow,segments,k,this,overflow,segments,null,this,num,overflow,segments,0,this,next,overflow,bucket,0,for,int,i,0,i,this,partition,buffers,length,i,free,memory,add,this,partition,buffers,i,this,partition,buffers,null,return,0,else,if,this,probe,side,record,counter,0,free,memory,add,this,probe,side,buffer,get,current,segment,this,probe,side,channel,close,this,build,side,channel,delete,channel,this,probe,side,channel,delete,channel,return,0,else,this,probe,side,buffer,close,this,probe,side,channel,close,spilled,partitions,add,this,return,1
HashPartition -> public int finalizeProbePhase(List<MemorySegment> freeMemory, List<HashPartition<BT, PT>> spilledPartitions) 	throws IOException;1426697080;@param freeMemory_@param spilledPartitions_@return The number of write-behind buffers reclaimable after this method call.__@throws IOException;public int finalizeProbePhase(List<MemorySegment> freeMemory, List<HashPartition<BT, PT>> spilledPartitions)_	throws IOException_	{_		if (isInMemory()) {_			_			_			_			for (int k = 0_ k < this.numOverflowSegments_ k++) {_				freeMemory.add(this.overflowSegments[k])__			}_			this.overflowSegments = null__			this.numOverflowSegments = 0__			this.nextOverflowBucket = 0__			_			for (int i = 0_ i < this.partitionBuffers.length_ i++) {_				freeMemory.add(this.partitionBuffers[i])__			}_			this.partitionBuffers = null__			return 0__		}_		else if (this.probeSideRecordCounter == 0) { _			_			_			freeMemory.add(this.probeSideBuffer.getCurrentSegment())__			_			_			this.probeSideChannel.close()__			this.buildSideChannel.deleteChannel()__			this.probeSideChannel.deleteChannel()__			_			return 0__		}_		else {_			_			this.probeSideBuffer.close()__			this.probeSideChannel.close()__			spilledPartitions.add(this)__			return 1__		}_	};param,free,memory,param,spilled,partitions,return,the,number,of,write,behind,buffers,reclaimable,after,this,method,call,throws,ioexception;public,int,finalize,probe,phase,list,memory,segment,free,memory,list,hash,partition,bt,pt,spilled,partitions,throws,ioexception,if,is,in,memory,for,int,k,0,k,this,num,overflow,segments,k,free,memory,add,this,overflow,segments,k,this,overflow,segments,null,this,num,overflow,segments,0,this,next,overflow,bucket,0,for,int,i,0,i,this,partition,buffers,length,i,free,memory,add,this,partition,buffers,i,this,partition,buffers,null,return,0,else,if,this,probe,side,record,counter,0,free,memory,add,this,probe,side,buffer,get,current,segment,this,probe,side,channel,close,this,build,side,channel,delete,channel,this,probe,side,channel,delete,channel,return,0,else,this,probe,side,buffer,close,this,probe,side,channel,close,spilled,partitions,add,this,return,1
HashPartition -> public int finalizeProbePhase(List<MemorySegment> freeMemory, List<HashPartition<BT, PT>> spilledPartitions) 	throws IOException;1440607697;@return The number of write-behind buffers reclaimable after this method call.__@throws IOException;public int finalizeProbePhase(List<MemorySegment> freeMemory, List<HashPartition<BT, PT>> spilledPartitions)_	throws IOException_	{_		if (isInMemory()) {_			_			_			_			for (int k = 0_ k < this.numOverflowSegments_ k++) {_				freeMemory.add(this.overflowSegments[k])__			}_			this.overflowSegments = null__			this.numOverflowSegments = 0__			this.nextOverflowBucket = 0__			_			for (MemorySegment partitionBuffer : this.partitionBuffers) {_				freeMemory.add(partitionBuffer)__			}_			this.partitionBuffers = null__			return 0__		}_		else if (this.probeSideRecordCounter == 0) { _			_			_			freeMemory.add(this.probeSideBuffer.getCurrentSegment())__			_			_			this.probeSideChannel.close()__			this.buildSideChannel.deleteChannel()__			this.probeSideChannel.deleteChannel()__			return 0__		}_		else {_			_			this.probeSideBuffer.close()__			this.probeSideChannel.close()__			spilledPartitions.add(this)__			return 1__		}_	};return,the,number,of,write,behind,buffers,reclaimable,after,this,method,call,throws,ioexception;public,int,finalize,probe,phase,list,memory,segment,free,memory,list,hash,partition,bt,pt,spilled,partitions,throws,ioexception,if,is,in,memory,for,int,k,0,k,this,num,overflow,segments,k,free,memory,add,this,overflow,segments,k,this,overflow,segments,null,this,num,overflow,segments,0,this,next,overflow,bucket,0,for,memory,segment,partition,buffer,this,partition,buffers,free,memory,add,partition,buffer,this,partition,buffers,null,return,0,else,if,this,probe,side,record,counter,0,free,memory,add,this,probe,side,buffer,get,current,segment,this,probe,side,channel,close,this,build,side,channel,delete,channel,this,probe,side,channel,delete,channel,return,0,else,this,probe,side,buffer,close,this,probe,side,channel,close,spilled,partitions,add,this,return,1
HashPartition -> public int finalizeProbePhase(List<MemorySegment> freeMemory, List<HashPartition<BT, PT>> spilledPartitions) 	throws IOException;1441738685;@return The number of write-behind buffers reclaimable after this method call.__@throws IOException;public int finalizeProbePhase(List<MemorySegment> freeMemory, List<HashPartition<BT, PT>> spilledPartitions)_	throws IOException_	{_		if (isInMemory()) {_			_			_			_			for (int k = 0_ k < this.numOverflowSegments_ k++) {_				freeMemory.add(this.overflowSegments[k])__			}_			this.overflowSegments = null__			this.numOverflowSegments = 0__			this.nextOverflowBucket = 0__			_			for (MemorySegment partitionBuffer : this.partitionBuffers) {_				freeMemory.add(partitionBuffer)__			}_			this.partitionBuffers = null__			return 0__		}_		else if (this.probeSideRecordCounter == 0) { _			_			_			freeMemory.add(this.probeSideBuffer.getCurrentSegment())__			_			_			this.probeSideChannel.close()__			this.buildSideChannel.deleteChannel()__			this.probeSideChannel.deleteChannel()__			return 0__		}_		else {_			_			this.probeSideBuffer.close()__			this.probeSideChannel.close()__			spilledPartitions.add(this)__			return 1__		}_	};return,the,number,of,write,behind,buffers,reclaimable,after,this,method,call,throws,ioexception;public,int,finalize,probe,phase,list,memory,segment,free,memory,list,hash,partition,bt,pt,spilled,partitions,throws,ioexception,if,is,in,memory,for,int,k,0,k,this,num,overflow,segments,k,free,memory,add,this,overflow,segments,k,this,overflow,segments,null,this,num,overflow,segments,0,this,next,overflow,bucket,0,for,memory,segment,partition,buffer,this,partition,buffers,free,memory,add,partition,buffer,this,partition,buffers,null,return,0,else,if,this,probe,side,record,counter,0,free,memory,add,this,probe,side,buffer,get,current,segment,this,probe,side,channel,close,this,build,side,channel,delete,channel,this,probe,side,channel,delete,channel,return,0,else,this,probe,side,buffer,close,this,probe,side,channel,close,spilled,partitions,add,this,return,1
HashPartition -> public int finalizeProbePhase(List<MemorySegment> freeMemory, List<HashPartition<BT, PT>> spilledPartitions) 	throws IOException;1443528421;@return The number of write-behind buffers reclaimable after this method call.__@throws IOException;public int finalizeProbePhase(List<MemorySegment> freeMemory, List<HashPartition<BT, PT>> spilledPartitions)_	throws IOException_	{_		if (isInMemory()) {_			_			_			_			for (int k = 0_ k < this.numOverflowSegments_ k++) {_				freeMemory.add(this.overflowSegments[k])__			}_			this.overflowSegments = null__			this.numOverflowSegments = 0__			this.nextOverflowBucket = 0__			_			for (MemorySegment partitionBuffer : this.partitionBuffers) {_				freeMemory.add(partitionBuffer)__			}_			this.partitionBuffers = null__			return 0__		}_		else if (this.probeSideRecordCounter == 0) { _			_			_			freeMemory.add(this.probeSideBuffer.getCurrentSegment())__			_			_			this.probeSideChannel.close()__			this.buildSideChannel.deleteChannel()__			this.probeSideChannel.deleteChannel()__			return 0__		}_		else {_			_			this.probeSideBuffer.close()__			this.probeSideChannel.close()__			spilledPartitions.add(this)__			return 1__		}_	};return,the,number,of,write,behind,buffers,reclaimable,after,this,method,call,throws,ioexception;public,int,finalize,probe,phase,list,memory,segment,free,memory,list,hash,partition,bt,pt,spilled,partitions,throws,ioexception,if,is,in,memory,for,int,k,0,k,this,num,overflow,segments,k,free,memory,add,this,overflow,segments,k,this,overflow,segments,null,this,num,overflow,segments,0,this,next,overflow,bucket,0,for,memory,segment,partition,buffer,this,partition,buffers,free,memory,add,partition,buffer,this,partition,buffers,null,return,0,else,if,this,probe,side,record,counter,0,free,memory,add,this,probe,side,buffer,get,current,segment,this,probe,side,channel,close,this,build,side,channel,delete,channel,this,probe,side,channel,delete,channel,return,0,else,this,probe,side,buffer,close,this,probe,side,channel,close,spilled,partitions,add,this,return,1
HashPartition -> public int finalizeProbePhase(List<MemorySegment> freeMemory, List<HashPartition<BT, PT>> spilledPartitions) 	throws IOException;1446633116;@return The number of write-behind buffers reclaimable after this method call.__@throws IOException;public int finalizeProbePhase(List<MemorySegment> freeMemory, List<HashPartition<BT, PT>> spilledPartitions)_	throws IOException_	{_		if (isInMemory()) {_			_			_			_			for (int k = 0_ k < this.numOverflowSegments_ k++) {_				freeMemory.add(this.overflowSegments[k])__			}_			this.overflowSegments = null__			this.numOverflowSegments = 0__			this.nextOverflowBucket = 0__			_			for (MemorySegment partitionBuffer : this.partitionBuffers) {_				freeMemory.add(partitionBuffer)__			}_			this.partitionBuffers = null__			return 0__		}_		else if (this.probeSideRecordCounter == 0) { _			_			_			freeMemory.add(this.probeSideBuffer.getCurrentSegment())__			_			_			this.probeSideChannel.close()__			this.buildSideChannel.deleteChannel()__			this.probeSideChannel.deleteChannel()__			return 0__		}_		else {_			_			this.probeSideBuffer.close()__			this.probeSideChannel.close()__			spilledPartitions.add(this)__			return 1__		}_	};return,the,number,of,write,behind,buffers,reclaimable,after,this,method,call,throws,ioexception;public,int,finalize,probe,phase,list,memory,segment,free,memory,list,hash,partition,bt,pt,spilled,partitions,throws,ioexception,if,is,in,memory,for,int,k,0,k,this,num,overflow,segments,k,free,memory,add,this,overflow,segments,k,this,overflow,segments,null,this,num,overflow,segments,0,this,next,overflow,bucket,0,for,memory,segment,partition,buffer,this,partition,buffers,free,memory,add,partition,buffer,this,partition,buffers,null,return,0,else,if,this,probe,side,record,counter,0,free,memory,add,this,probe,side,buffer,get,current,segment,this,probe,side,channel,close,this,build,side,channel,delete,channel,this,probe,side,channel,delete,channel,return,0,else,this,probe,side,buffer,close,this,probe,side,channel,close,spilled,partitions,add,this,return,1
HashPartition -> public int spillPartition(List<MemorySegment> target, IOManager ioAccess, FileIOChannel.ID targetChannel, 			LinkedBlockingQueue<MemorySegment> bufferReturnQueue) 	throws IOException;1415702894;Spills this partition to disk and sets it up such that it continues spilling records that are added to_it. The spilling process must free at least one buffer, either in the partition's record buffers, or in_the memory segments for overflow buckets._The partition immediately takes back one buffer to use it for further spilling.__@param target The list to which memory segments from overflow buckets are added._@param ioAccess The I/O manager to be used to create a writer to disk._@param targetChannel The id of the target channel for this partition._@return The number of buffers that were freed by spilling this partition._@throws IOException Thrown, if the writing failed.;public int spillPartition(List<MemorySegment> target, IOManager ioAccess, FileIOChannel.ID targetChannel,_			LinkedBlockingQueue<MemorySegment> bufferReturnQueue)_	throws IOException_	{_		_		if (!isInMemory()) {_			throw new RuntimeException("Bug in Hybrid Hash Join: " +_					"Request to spill a partition that has already been spilled.")__		}_		if (getBuildSideBlockCount() + this.numOverflowSegments < 2) {_			throw new RuntimeException("Bug in Hybrid Hash Join: " +_				"Request to spill a partition with less than two buffers.")__		}_		_		_		for (int i = 0_ i < this.numOverflowSegments_ i++) {_			target.add(this.overflowSegments[i])__		}_		this.overflowSegments = null__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		_		_		_		_		this.buildSideChannel = ioAccess.createBlockChannelWriter(targetChannel, bufferReturnQueue)__		return this.buildSideWriteBuffer.spill(this.buildSideChannel)__	};spills,this,partition,to,disk,and,sets,it,up,such,that,it,continues,spilling,records,that,are,added,to,it,the,spilling,process,must,free,at,least,one,buffer,either,in,the,partition,s,record,buffers,or,in,the,memory,segments,for,overflow,buckets,the,partition,immediately,takes,back,one,buffer,to,use,it,for,further,spilling,param,target,the,list,to,which,memory,segments,from,overflow,buckets,are,added,param,io,access,the,i,o,manager,to,be,used,to,create,a,writer,to,disk,param,target,channel,the,id,of,the,target,channel,for,this,partition,return,the,number,of,buffers,that,were,freed,by,spilling,this,partition,throws,ioexception,thrown,if,the,writing,failed;public,int,spill,partition,list,memory,segment,target,iomanager,io,access,file,iochannel,id,target,channel,linked,blocking,queue,memory,segment,buffer,return,queue,throws,ioexception,if,is,in,memory,throw,new,runtime,exception,bug,in,hybrid,hash,join,request,to,spill,a,partition,that,has,already,been,spilled,if,get,build,side,block,count,this,num,overflow,segments,2,throw,new,runtime,exception,bug,in,hybrid,hash,join,request,to,spill,a,partition,with,less,than,two,buffers,for,int,i,0,i,this,num,overflow,segments,i,target,add,this,overflow,segments,i,this,overflow,segments,null,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,build,side,channel,io,access,create,block,channel,writer,target,channel,buffer,return,queue,return,this,build,side,write,buffer,spill,this,build,side,channel
HashPartition -> public int spillPartition(List<MemorySegment> target, IOManager ioAccess, FileIOChannel.ID targetChannel, 			LinkedBlockingQueue<MemorySegment> bufferReturnQueue) 	throws IOException;1418570573;Spills this partition to disk and sets it up such that it continues spilling records that are added to_it. The spilling process must free at least one buffer, either in the partition's record buffers, or in_the memory segments for overflow buckets._The partition immediately takes back one buffer to use it for further spilling.__@param target The list to which memory segments from overflow buckets are added._@param ioAccess The I/O manager to be used to create a writer to disk._@param targetChannel The id of the target channel for this partition._@return The number of buffers that were freed by spilling this partition._@throws IOException Thrown, if the writing failed.;public int spillPartition(List<MemorySegment> target, IOManager ioAccess, FileIOChannel.ID targetChannel,_			LinkedBlockingQueue<MemorySegment> bufferReturnQueue)_	throws IOException_	{_		_		if (!isInMemory()) {_			throw new RuntimeException("Bug in Hybrid Hash Join: " +_					"Request to spill a partition that has already been spilled.")__		}_		if (getBuildSideBlockCount() + this.numOverflowSegments < 2) {_			throw new RuntimeException("Bug in Hybrid Hash Join: " +_				"Request to spill a partition with less than two buffers.")__		}_		_		_		for (int i = 0_ i < this.numOverflowSegments_ i++) {_			target.add(this.overflowSegments[i])__		}_		this.overflowSegments = null__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		_		_		_		_		this.buildSideChannel = ioAccess.createBlockChannelWriter(targetChannel, bufferReturnQueue)__		return this.buildSideWriteBuffer.spill(this.buildSideChannel)__	};spills,this,partition,to,disk,and,sets,it,up,such,that,it,continues,spilling,records,that,are,added,to,it,the,spilling,process,must,free,at,least,one,buffer,either,in,the,partition,s,record,buffers,or,in,the,memory,segments,for,overflow,buckets,the,partition,immediately,takes,back,one,buffer,to,use,it,for,further,spilling,param,target,the,list,to,which,memory,segments,from,overflow,buckets,are,added,param,io,access,the,i,o,manager,to,be,used,to,create,a,writer,to,disk,param,target,channel,the,id,of,the,target,channel,for,this,partition,return,the,number,of,buffers,that,were,freed,by,spilling,this,partition,throws,ioexception,thrown,if,the,writing,failed;public,int,spill,partition,list,memory,segment,target,iomanager,io,access,file,iochannel,id,target,channel,linked,blocking,queue,memory,segment,buffer,return,queue,throws,ioexception,if,is,in,memory,throw,new,runtime,exception,bug,in,hybrid,hash,join,request,to,spill,a,partition,that,has,already,been,spilled,if,get,build,side,block,count,this,num,overflow,segments,2,throw,new,runtime,exception,bug,in,hybrid,hash,join,request,to,spill,a,partition,with,less,than,two,buffers,for,int,i,0,i,this,num,overflow,segments,i,target,add,this,overflow,segments,i,this,overflow,segments,null,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,build,side,channel,io,access,create,block,channel,writer,target,channel,buffer,return,queue,return,this,build,side,write,buffer,spill,this,build,side,channel
HashPartition -> public int spillPartition(List<MemorySegment> target, IOManager ioAccess, FileIOChannel.ID targetChannel, 			LinkedBlockingQueue<MemorySegment> bufferReturnQueue) 	throws IOException;1420654570;Spills this partition to disk and sets it up such that it continues spilling records that are added to_it. The spilling process must free at least one buffer, either in the partition's record buffers, or in_the memory segments for overflow buckets._The partition immediately takes back one buffer to use it for further spilling.__@param target The list to which memory segments from overflow buckets are added._@param ioAccess The I/O manager to be used to create a writer to disk._@param targetChannel The id of the target channel for this partition._@return The number of buffers that were freed by spilling this partition._@throws IOException Thrown, if the writing failed.;public int spillPartition(List<MemorySegment> target, IOManager ioAccess, FileIOChannel.ID targetChannel,_			LinkedBlockingQueue<MemorySegment> bufferReturnQueue)_	throws IOException_	{_		_		if (!isInMemory()) {_			throw new RuntimeException("Bug in Hybrid Hash Join: " +_					"Request to spill a partition that has already been spilled.")__		}_		if (getBuildSideBlockCount() + this.numOverflowSegments < 2) {_			throw new RuntimeException("Bug in Hybrid Hash Join: " +_				"Request to spill a partition with less than two buffers.")__		}_		_		_		for (int i = 0_ i < this.numOverflowSegments_ i++) {_			target.add(this.overflowSegments[i])__		}_		this.overflowSegments = null__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		_		_		_		_		this.buildSideChannel = ioAccess.createBlockChannelWriter(targetChannel, bufferReturnQueue)__		return this.buildSideWriteBuffer.spill(this.buildSideChannel)__	};spills,this,partition,to,disk,and,sets,it,up,such,that,it,continues,spilling,records,that,are,added,to,it,the,spilling,process,must,free,at,least,one,buffer,either,in,the,partition,s,record,buffers,or,in,the,memory,segments,for,overflow,buckets,the,partition,immediately,takes,back,one,buffer,to,use,it,for,further,spilling,param,target,the,list,to,which,memory,segments,from,overflow,buckets,are,added,param,io,access,the,i,o,manager,to,be,used,to,create,a,writer,to,disk,param,target,channel,the,id,of,the,target,channel,for,this,partition,return,the,number,of,buffers,that,were,freed,by,spilling,this,partition,throws,ioexception,thrown,if,the,writing,failed;public,int,spill,partition,list,memory,segment,target,iomanager,io,access,file,iochannel,id,target,channel,linked,blocking,queue,memory,segment,buffer,return,queue,throws,ioexception,if,is,in,memory,throw,new,runtime,exception,bug,in,hybrid,hash,join,request,to,spill,a,partition,that,has,already,been,spilled,if,get,build,side,block,count,this,num,overflow,segments,2,throw,new,runtime,exception,bug,in,hybrid,hash,join,request,to,spill,a,partition,with,less,than,two,buffers,for,int,i,0,i,this,num,overflow,segments,i,target,add,this,overflow,segments,i,this,overflow,segments,null,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,build,side,channel,io,access,create,block,channel,writer,target,channel,buffer,return,queue,return,this,build,side,write,buffer,spill,this,build,side,channel
HashPartition -> public int spillPartition(List<MemorySegment> target, IOManager ioAccess, FileIOChannel.ID targetChannel, 			LinkedBlockingQueue<MemorySegment> bufferReturnQueue) 	throws IOException;1420663430;Spills this partition to disk and sets it up such that it continues spilling records that are added to_it. The spilling process must free at least one buffer, either in the partition's record buffers, or in_the memory segments for overflow buckets._The partition immediately takes back one buffer to use it for further spilling.__@param target The list to which memory segments from overflow buckets are added._@param ioAccess The I/O manager to be used to create a writer to disk._@param targetChannel The id of the target channel for this partition._@return The number of buffers that were freed by spilling this partition._@throws IOException Thrown, if the writing failed.;public int spillPartition(List<MemorySegment> target, IOManager ioAccess, FileIOChannel.ID targetChannel,_			LinkedBlockingQueue<MemorySegment> bufferReturnQueue)_	throws IOException_	{_		_		if (!isInMemory()) {_			throw new RuntimeException("Bug in Hybrid Hash Join: " +_					"Request to spill a partition that has already been spilled.")__		}_		if (getBuildSideBlockCount() + this.numOverflowSegments < 2) {_			throw new RuntimeException("Bug in Hybrid Hash Join: " +_				"Request to spill a partition with less than two buffers.")__		}_		_		_		for (int i = 0_ i < this.numOverflowSegments_ i++) {_			target.add(this.overflowSegments[i])__		}_		this.overflowSegments = null__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		_		_		_		_		this.buildSideChannel = ioAccess.createBlockChannelWriter(targetChannel, bufferReturnQueue)__		return this.buildSideWriteBuffer.spill(this.buildSideChannel)__	};spills,this,partition,to,disk,and,sets,it,up,such,that,it,continues,spilling,records,that,are,added,to,it,the,spilling,process,must,free,at,least,one,buffer,either,in,the,partition,s,record,buffers,or,in,the,memory,segments,for,overflow,buckets,the,partition,immediately,takes,back,one,buffer,to,use,it,for,further,spilling,param,target,the,list,to,which,memory,segments,from,overflow,buckets,are,added,param,io,access,the,i,o,manager,to,be,used,to,create,a,writer,to,disk,param,target,channel,the,id,of,the,target,channel,for,this,partition,return,the,number,of,buffers,that,were,freed,by,spilling,this,partition,throws,ioexception,thrown,if,the,writing,failed;public,int,spill,partition,list,memory,segment,target,iomanager,io,access,file,iochannel,id,target,channel,linked,blocking,queue,memory,segment,buffer,return,queue,throws,ioexception,if,is,in,memory,throw,new,runtime,exception,bug,in,hybrid,hash,join,request,to,spill,a,partition,that,has,already,been,spilled,if,get,build,side,block,count,this,num,overflow,segments,2,throw,new,runtime,exception,bug,in,hybrid,hash,join,request,to,spill,a,partition,with,less,than,two,buffers,for,int,i,0,i,this,num,overflow,segments,i,target,add,this,overflow,segments,i,this,overflow,segments,null,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,build,side,channel,io,access,create,block,channel,writer,target,channel,buffer,return,queue,return,this,build,side,write,buffer,spill,this,build,side,channel
HashPartition -> public int spillPartition(List<MemorySegment> target, IOManager ioAccess, FileIOChannel.ID targetChannel, 			LinkedBlockingQueue<MemorySegment> bufferReturnQueue) 	throws IOException;1426697080;Spills this partition to disk and sets it up such that it continues spilling records that are added to_it. The spilling process must free at least one buffer, either in the partition's record buffers, or in_the memory segments for overflow buckets._The partition immediately takes back one buffer to use it for further spilling.__@param target The list to which memory segments from overflow buckets are added._@param ioAccess The I/O manager to be used to create a writer to disk._@param targetChannel The id of the target channel for this partition._@return The number of buffers that were freed by spilling this partition._@throws IOException Thrown, if the writing failed.;public int spillPartition(List<MemorySegment> target, IOManager ioAccess, FileIOChannel.ID targetChannel,_			LinkedBlockingQueue<MemorySegment> bufferReturnQueue)_	throws IOException_	{_		_		if (!isInMemory()) {_			throw new RuntimeException("Bug in Hybrid Hash Join: " +_					"Request to spill a partition that has already been spilled.")__		}_		if (getBuildSideBlockCount() + this.numOverflowSegments < 2) {_			throw new RuntimeException("Bug in Hybrid Hash Join: " +_				"Request to spill a partition with less than two buffers.")__		}_		_		_		for (int i = 0_ i < this.numOverflowSegments_ i++) {_			target.add(this.overflowSegments[i])__		}_		this.overflowSegments = null__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		_		_		_		_		this.buildSideChannel = ioAccess.createBlockChannelWriter(targetChannel, bufferReturnQueue)__		return this.buildSideWriteBuffer.spill(this.buildSideChannel)__	};spills,this,partition,to,disk,and,sets,it,up,such,that,it,continues,spilling,records,that,are,added,to,it,the,spilling,process,must,free,at,least,one,buffer,either,in,the,partition,s,record,buffers,or,in,the,memory,segments,for,overflow,buckets,the,partition,immediately,takes,back,one,buffer,to,use,it,for,further,spilling,param,target,the,list,to,which,memory,segments,from,overflow,buckets,are,added,param,io,access,the,i,o,manager,to,be,used,to,create,a,writer,to,disk,param,target,channel,the,id,of,the,target,channel,for,this,partition,return,the,number,of,buffers,that,were,freed,by,spilling,this,partition,throws,ioexception,thrown,if,the,writing,failed;public,int,spill,partition,list,memory,segment,target,iomanager,io,access,file,iochannel,id,target,channel,linked,blocking,queue,memory,segment,buffer,return,queue,throws,ioexception,if,is,in,memory,throw,new,runtime,exception,bug,in,hybrid,hash,join,request,to,spill,a,partition,that,has,already,been,spilled,if,get,build,side,block,count,this,num,overflow,segments,2,throw,new,runtime,exception,bug,in,hybrid,hash,join,request,to,spill,a,partition,with,less,than,two,buffers,for,int,i,0,i,this,num,overflow,segments,i,target,add,this,overflow,segments,i,this,overflow,segments,null,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,build,side,channel,io,access,create,block,channel,writer,target,channel,buffer,return,queue,return,this,build,side,write,buffer,spill,this,build,side,channel
HashPartition -> public int spillPartition(List<MemorySegment> target, IOManager ioAccess, FileIOChannel.ID targetChannel, 			LinkedBlockingQueue<MemorySegment> bufferReturnQueue) 	throws IOException;1440607697;Spills this partition to disk and sets it up such that it continues spilling records that are added to_it. The spilling process must free at least one buffer, either in the partition's record buffers, or in_the memory segments for overflow buckets._The partition immediately takes back one buffer to use it for further spilling.__@param target The list to which memory segments from overflow buckets are added._@param ioAccess The I/O manager to be used to create a writer to disk._@param targetChannel The id of the target channel for this partition._@return The number of buffers that were freed by spilling this partition._@throws IOException Thrown, if the writing failed.;public int spillPartition(List<MemorySegment> target, IOManager ioAccess, FileIOChannel.ID targetChannel,_			LinkedBlockingQueue<MemorySegment> bufferReturnQueue)_	throws IOException_	{_		_		if (!isInMemory()) {_			throw new RuntimeException("Bug in Hybrid Hash Join: " +_					"Request to spill a partition that has already been spilled.")__		}_		if (getBuildSideBlockCount() + this.numOverflowSegments < 2) {_			throw new RuntimeException("Bug in Hybrid Hash Join: " +_				"Request to spill a partition with less than two buffers.")__		}_		_		_		for (int i = 0_ i < this.numOverflowSegments_ i++) {_			target.add(this.overflowSegments[i])__		}_		this.overflowSegments = null__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		_		_		_		_		this.buildSideChannel = ioAccess.createBlockChannelWriter(targetChannel, bufferReturnQueue)__		return this.buildSideWriteBuffer.spill(this.buildSideChannel)__	};spills,this,partition,to,disk,and,sets,it,up,such,that,it,continues,spilling,records,that,are,added,to,it,the,spilling,process,must,free,at,least,one,buffer,either,in,the,partition,s,record,buffers,or,in,the,memory,segments,for,overflow,buckets,the,partition,immediately,takes,back,one,buffer,to,use,it,for,further,spilling,param,target,the,list,to,which,memory,segments,from,overflow,buckets,are,added,param,io,access,the,i,o,manager,to,be,used,to,create,a,writer,to,disk,param,target,channel,the,id,of,the,target,channel,for,this,partition,return,the,number,of,buffers,that,were,freed,by,spilling,this,partition,throws,ioexception,thrown,if,the,writing,failed;public,int,spill,partition,list,memory,segment,target,iomanager,io,access,file,iochannel,id,target,channel,linked,blocking,queue,memory,segment,buffer,return,queue,throws,ioexception,if,is,in,memory,throw,new,runtime,exception,bug,in,hybrid,hash,join,request,to,spill,a,partition,that,has,already,been,spilled,if,get,build,side,block,count,this,num,overflow,segments,2,throw,new,runtime,exception,bug,in,hybrid,hash,join,request,to,spill,a,partition,with,less,than,two,buffers,for,int,i,0,i,this,num,overflow,segments,i,target,add,this,overflow,segments,i,this,overflow,segments,null,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,build,side,channel,io,access,create,block,channel,writer,target,channel,buffer,return,queue,return,this,build,side,write,buffer,spill,this,build,side,channel
HashPartition -> public int spillPartition(List<MemorySegment> target, IOManager ioAccess, FileIOChannel.ID targetChannel, 			LinkedBlockingQueue<MemorySegment> bufferReturnQueue) 	throws IOException;1441738685;Spills this partition to disk and sets it up such that it continues spilling records that are added to_it. The spilling process must free at least one buffer, either in the partition's record buffers, or in_the memory segments for overflow buckets._The partition immediately takes back one buffer to use it for further spilling.__@param target The list to which memory segments from overflow buckets are added._@param ioAccess The I/O manager to be used to create a writer to disk._@param targetChannel The id of the target channel for this partition._@return The number of buffers that were freed by spilling this partition._@throws IOException Thrown, if the writing failed.;public int spillPartition(List<MemorySegment> target, IOManager ioAccess, FileIOChannel.ID targetChannel,_			LinkedBlockingQueue<MemorySegment> bufferReturnQueue)_	throws IOException_	{_		_		if (!isInMemory()) {_			throw new RuntimeException("Bug in Hybrid Hash Join: " +_					"Request to spill a partition that has already been spilled.")__		}_		if (getBuildSideBlockCount() + this.numOverflowSegments < 2) {_			throw new RuntimeException("Bug in Hybrid Hash Join: " +_				"Request to spill a partition with less than two buffers.")__		}_		_		_		for (int i = 0_ i < this.numOverflowSegments_ i++) {_			target.add(this.overflowSegments[i])__		}_		this.overflowSegments = null__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		_		_		_		_		this.buildSideChannel = ioAccess.createBlockChannelWriter(targetChannel, bufferReturnQueue)__		return this.buildSideWriteBuffer.spill(this.buildSideChannel)__	};spills,this,partition,to,disk,and,sets,it,up,such,that,it,continues,spilling,records,that,are,added,to,it,the,spilling,process,must,free,at,least,one,buffer,either,in,the,partition,s,record,buffers,or,in,the,memory,segments,for,overflow,buckets,the,partition,immediately,takes,back,one,buffer,to,use,it,for,further,spilling,param,target,the,list,to,which,memory,segments,from,overflow,buckets,are,added,param,io,access,the,i,o,manager,to,be,used,to,create,a,writer,to,disk,param,target,channel,the,id,of,the,target,channel,for,this,partition,return,the,number,of,buffers,that,were,freed,by,spilling,this,partition,throws,ioexception,thrown,if,the,writing,failed;public,int,spill,partition,list,memory,segment,target,iomanager,io,access,file,iochannel,id,target,channel,linked,blocking,queue,memory,segment,buffer,return,queue,throws,ioexception,if,is,in,memory,throw,new,runtime,exception,bug,in,hybrid,hash,join,request,to,spill,a,partition,that,has,already,been,spilled,if,get,build,side,block,count,this,num,overflow,segments,2,throw,new,runtime,exception,bug,in,hybrid,hash,join,request,to,spill,a,partition,with,less,than,two,buffers,for,int,i,0,i,this,num,overflow,segments,i,target,add,this,overflow,segments,i,this,overflow,segments,null,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,build,side,channel,io,access,create,block,channel,writer,target,channel,buffer,return,queue,return,this,build,side,write,buffer,spill,this,build,side,channel
HashPartition -> public int spillPartition(List<MemorySegment> target, IOManager ioAccess, FileIOChannel.ID targetChannel, 			LinkedBlockingQueue<MemorySegment> bufferReturnQueue) 	throws IOException;1443528421;Spills this partition to disk and sets it up such that it continues spilling records that are added to_it. The spilling process must free at least one buffer, either in the partition's record buffers, or in_the memory segments for overflow buckets._The partition immediately takes back one buffer to use it for further spilling.__@param target The list to which memory segments from overflow buckets are added._@param ioAccess The I/O manager to be used to create a writer to disk._@param targetChannel The id of the target channel for this partition._@return The number of buffers that were freed by spilling this partition._@throws IOException Thrown, if the writing failed.;public int spillPartition(List<MemorySegment> target, IOManager ioAccess, FileIOChannel.ID targetChannel,_			LinkedBlockingQueue<MemorySegment> bufferReturnQueue)_	throws IOException_	{_		_		if (!isInMemory()) {_			throw new RuntimeException("Bug in Hybrid Hash Join: " +_					"Request to spill a partition that has already been spilled.")__		}_		if (getNumOccupiedMemorySegments() < 2) {_			throw new RuntimeException("Bug in Hybrid Hash Join: " +_				"Request to spill a partition with less than two buffers.")__		}_		_		_		for (int i = 0_ i < this.numOverflowSegments_ i++) {_			target.add(this.overflowSegments[i])__		}_		this.overflowSegments = null__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		_		_		_		_		this.buildSideChannel = ioAccess.createBlockChannelWriter(targetChannel, bufferReturnQueue)__		return this.buildSideWriteBuffer.spill(this.buildSideChannel)__	};spills,this,partition,to,disk,and,sets,it,up,such,that,it,continues,spilling,records,that,are,added,to,it,the,spilling,process,must,free,at,least,one,buffer,either,in,the,partition,s,record,buffers,or,in,the,memory,segments,for,overflow,buckets,the,partition,immediately,takes,back,one,buffer,to,use,it,for,further,spilling,param,target,the,list,to,which,memory,segments,from,overflow,buckets,are,added,param,io,access,the,i,o,manager,to,be,used,to,create,a,writer,to,disk,param,target,channel,the,id,of,the,target,channel,for,this,partition,return,the,number,of,buffers,that,were,freed,by,spilling,this,partition,throws,ioexception,thrown,if,the,writing,failed;public,int,spill,partition,list,memory,segment,target,iomanager,io,access,file,iochannel,id,target,channel,linked,blocking,queue,memory,segment,buffer,return,queue,throws,ioexception,if,is,in,memory,throw,new,runtime,exception,bug,in,hybrid,hash,join,request,to,spill,a,partition,that,has,already,been,spilled,if,get,num,occupied,memory,segments,2,throw,new,runtime,exception,bug,in,hybrid,hash,join,request,to,spill,a,partition,with,less,than,two,buffers,for,int,i,0,i,this,num,overflow,segments,i,target,add,this,overflow,segments,i,this,overflow,segments,null,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,build,side,channel,io,access,create,block,channel,writer,target,channel,buffer,return,queue,return,this,build,side,write,buffer,spill,this,build,side,channel
HashPartition -> public int spillPartition(List<MemorySegment> target, IOManager ioAccess, FileIOChannel.ID targetChannel, 			LinkedBlockingQueue<MemorySegment> bufferReturnQueue) 	throws IOException;1446633116;Spills this partition to disk and sets it up such that it continues spilling records that are added to_it. The spilling process must free at least one buffer, either in the partition's record buffers, or in_the memory segments for overflow buckets._The partition immediately takes back one buffer to use it for further spilling.__@param target The list to which memory segments from overflow buckets are added._@param ioAccess The I/O manager to be used to create a writer to disk._@param targetChannel The id of the target channel for this partition._@return The number of buffers that were freed by spilling this partition._@throws IOException Thrown, if the writing failed.;public int spillPartition(List<MemorySegment> target, IOManager ioAccess, FileIOChannel.ID targetChannel,_			LinkedBlockingQueue<MemorySegment> bufferReturnQueue)_	throws IOException_	{_		_		if (!isInMemory()) {_			throw new RuntimeException("Bug in Hybrid Hash Join: " +_					"Request to spill a partition that has already been spilled.")__		}_		if (getNumOccupiedMemorySegments() < 2) {_			throw new RuntimeException("Bug in Hybrid Hash Join: " +_				"Request to spill a partition with less than two buffers.")__		}_		_		_		for (int i = 0_ i < this.numOverflowSegments_ i++) {_			target.add(this.overflowSegments[i])__		}_		this.overflowSegments = null__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		_		_		_		_		this.buildSideChannel = ioAccess.createBlockChannelWriter(targetChannel, bufferReturnQueue)__		return this.buildSideWriteBuffer.spill(this.buildSideChannel)__	};spills,this,partition,to,disk,and,sets,it,up,such,that,it,continues,spilling,records,that,are,added,to,it,the,spilling,process,must,free,at,least,one,buffer,either,in,the,partition,s,record,buffers,or,in,the,memory,segments,for,overflow,buckets,the,partition,immediately,takes,back,one,buffer,to,use,it,for,further,spilling,param,target,the,list,to,which,memory,segments,from,overflow,buckets,are,added,param,io,access,the,i,o,manager,to,be,used,to,create,a,writer,to,disk,param,target,channel,the,id,of,the,target,channel,for,this,partition,return,the,number,of,buffers,that,were,freed,by,spilling,this,partition,throws,ioexception,thrown,if,the,writing,failed;public,int,spill,partition,list,memory,segment,target,iomanager,io,access,file,iochannel,id,target,channel,linked,blocking,queue,memory,segment,buffer,return,queue,throws,ioexception,if,is,in,memory,throw,new,runtime,exception,bug,in,hybrid,hash,join,request,to,spill,a,partition,that,has,already,been,spilled,if,get,num,occupied,memory,segments,2,throw,new,runtime,exception,bug,in,hybrid,hash,join,request,to,spill,a,partition,with,less,than,two,buffers,for,int,i,0,i,this,num,overflow,segments,i,target,add,this,overflow,segments,i,this,overflow,segments,null,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,build,side,channel,io,access,create,block,channel,writer,target,channel,buffer,return,queue,return,this,build,side,write,buffer,spill,this,build,side,channel
HashPartition -> public int spillPartition(List<MemorySegment> target, IOManager ioAccess, FileIOChannel.ID targetChannel, 			LinkedBlockingQueue<MemorySegment> bufferReturnQueue) 	throws IOException;1456186722;Spills this partition to disk and sets it up such that it continues spilling records that are added to_it. The spilling process must free at least one buffer, either in the partition's record buffers, or in_the memory segments for overflow buckets._The partition immediately takes back one buffer to use it for further spilling.__@param target The list to which memory segments from overflow buckets are added._@param ioAccess The I/O manager to be used to create a writer to disk._@param targetChannel The id of the target channel for this partition._@return The number of buffers that were freed by spilling this partition._@throws IOException Thrown, if the writing failed.;public int spillPartition(List<MemorySegment> target, IOManager ioAccess, FileIOChannel.ID targetChannel,_			LinkedBlockingQueue<MemorySegment> bufferReturnQueue)_	throws IOException_	{_		_		if (!isInMemory()) {_			throw new RuntimeException("Bug in Hybrid Hash Join: " +_					"Request to spill a partition that has already been spilled.")__		}_		if (getNumOccupiedMemorySegments() < 2) {_			throw new RuntimeException("Bug in Hybrid Hash Join: " +_				"Request to spill a partition with less than two buffers.")__		}_		_		_		for (int i = 0_ i < this.numOverflowSegments_ i++) {_			target.add(this.overflowSegments[i])__		}_		this.overflowSegments = null__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		_		_		_		_		this.buildSideChannel = ioAccess.createBlockChannelWriter(targetChannel, bufferReturnQueue)__		return this.buildSideWriteBuffer.spill(this.buildSideChannel)__	};spills,this,partition,to,disk,and,sets,it,up,such,that,it,continues,spilling,records,that,are,added,to,it,the,spilling,process,must,free,at,least,one,buffer,either,in,the,partition,s,record,buffers,or,in,the,memory,segments,for,overflow,buckets,the,partition,immediately,takes,back,one,buffer,to,use,it,for,further,spilling,param,target,the,list,to,which,memory,segments,from,overflow,buckets,are,added,param,io,access,the,i,o,manager,to,be,used,to,create,a,writer,to,disk,param,target,channel,the,id,of,the,target,channel,for,this,partition,return,the,number,of,buffers,that,were,freed,by,spilling,this,partition,throws,ioexception,thrown,if,the,writing,failed;public,int,spill,partition,list,memory,segment,target,iomanager,io,access,file,iochannel,id,target,channel,linked,blocking,queue,memory,segment,buffer,return,queue,throws,ioexception,if,is,in,memory,throw,new,runtime,exception,bug,in,hybrid,hash,join,request,to,spill,a,partition,that,has,already,been,spilled,if,get,num,occupied,memory,segments,2,throw,new,runtime,exception,bug,in,hybrid,hash,join,request,to,spill,a,partition,with,less,than,two,buffers,for,int,i,0,i,this,num,overflow,segments,i,target,add,this,overflow,segments,i,this,overflow,segments,null,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,build,side,channel,io,access,create,block,channel,writer,target,channel,buffer,return,queue,return,this,build,side,write,buffer,spill,this,build,side,channel
HashPartition -> public int spillPartition(List<MemorySegment> target, IOManager ioAccess, FileIOChannel.ID targetChannel, 			LinkedBlockingQueue<MemorySegment> bufferReturnQueue) 	throws IOException;1460741894;Spills this partition to disk and sets it up such that it continues spilling records that are added to_it. The spilling process must free at least one buffer, either in the partition's record buffers, or in_the memory segments for overflow buckets._The partition immediately takes back one buffer to use it for further spilling.__@param target The list to which memory segments from overflow buckets are added._@param ioAccess The I/O manager to be used to create a writer to disk._@param targetChannel The id of the target channel for this partition._@return The number of buffers that were freed by spilling this partition._@throws IOException Thrown, if the writing failed.;public int spillPartition(List<MemorySegment> target, IOManager ioAccess, FileIOChannel.ID targetChannel,_			LinkedBlockingQueue<MemorySegment> bufferReturnQueue)_	throws IOException_	{_		_		if (!isInMemory()) {_			throw new RuntimeException("Bug in Hybrid Hash Join: " +_					"Request to spill a partition that has already been spilled.")__		}_		if (getNumOccupiedMemorySegments() < 2) {_			throw new RuntimeException("Bug in Hybrid Hash Join: " +_				"Request to spill a partition with less than two buffers.")__		}_		_		_		for (int i = 0_ i < this.numOverflowSegments_ i++) {_			target.add(this.overflowSegments[i])__		}_		this.overflowSegments = null__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		_		_		_		_		this.buildSideChannel = ioAccess.createBlockChannelWriter(targetChannel, bufferReturnQueue)__		return this.buildSideWriteBuffer.spill(this.buildSideChannel)__	};spills,this,partition,to,disk,and,sets,it,up,such,that,it,continues,spilling,records,that,are,added,to,it,the,spilling,process,must,free,at,least,one,buffer,either,in,the,partition,s,record,buffers,or,in,the,memory,segments,for,overflow,buckets,the,partition,immediately,takes,back,one,buffer,to,use,it,for,further,spilling,param,target,the,list,to,which,memory,segments,from,overflow,buckets,are,added,param,io,access,the,i,o,manager,to,be,used,to,create,a,writer,to,disk,param,target,channel,the,id,of,the,target,channel,for,this,partition,return,the,number,of,buffers,that,were,freed,by,spilling,this,partition,throws,ioexception,thrown,if,the,writing,failed;public,int,spill,partition,list,memory,segment,target,iomanager,io,access,file,iochannel,id,target,channel,linked,blocking,queue,memory,segment,buffer,return,queue,throws,ioexception,if,is,in,memory,throw,new,runtime,exception,bug,in,hybrid,hash,join,request,to,spill,a,partition,that,has,already,been,spilled,if,get,num,occupied,memory,segments,2,throw,new,runtime,exception,bug,in,hybrid,hash,join,request,to,spill,a,partition,with,less,than,two,buffers,for,int,i,0,i,this,num,overflow,segments,i,target,add,this,overflow,segments,i,this,overflow,segments,null,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,build,side,channel,io,access,create,block,channel,writer,target,channel,buffer,return,queue,return,this,build,side,write,buffer,spill,this,build,side,channel
