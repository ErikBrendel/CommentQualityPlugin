# id;timestamp;commentText;codeText;commentWords;codeWords
PermanentBlobCache -> public void releaseJob(JobID jobId);1499764760;Unregisters use of job-related BLOBs and allow them to be released.__@param jobId_ID of the job this blob belongs to__@see #registerJob(JobID);public void releaseJob(JobID jobId) {_		synchronized (jobRefCounters) {_			RefCount ref = jobRefCounters.get(jobId)___			if (ref == null) {_				LOG.warn("improper use of releaseJob() without a matching number of registerJob() calls for jobId " + jobId)__				return__			}__			--ref.references__			if (ref.references == 0) {_				ref.keepUntil = System.currentTimeMillis() + cleanupInterval__			}_		}_	};unregisters,use,of,job,related,blobs,and,allow,them,to,be,released,param,job,id,id,of,the,job,this,blob,belongs,to,see,register,job,job,id;public,void,release,job,job,id,job,id,synchronized,job,ref,counters,ref,count,ref,job,ref,counters,get,job,id,if,ref,null,log,warn,improper,use,of,release,job,without,a,matching,number,of,register,job,calls,for,job,id,job,id,return,ref,references,if,ref,references,0,ref,keep,until,system,current,time,millis,cleanup,interval
PermanentBlobCache -> public void releaseJob(JobID jobId);1500980433;Unregisters use of job-related BLOBs and allow them to be released.__@param jobId_ID of the job this blob belongs to__@see #registerJob(JobID);public void releaseJob(JobID jobId) {_		synchronized (jobRefCounters) {_			RefCount ref = jobRefCounters.get(jobId)___			if (ref == null) {_				LOG.warn("improper use of releaseJob() without a matching number of registerJob() calls for jobId " + jobId)__				return__			}__			--ref.references__			if (ref.references == 0) {_				ref.keepUntil = System.currentTimeMillis() + cleanupInterval__			}_		}_	};unregisters,use,of,job,related,blobs,and,allow,them,to,be,released,param,job,id,id,of,the,job,this,blob,belongs,to,see,register,job,job,id;public,void,release,job,job,id,job,id,synchronized,job,ref,counters,ref,count,ref,job,ref,counters,get,job,id,if,ref,null,log,warn,improper,use,of,release,job,without,a,matching,number,of,register,job,calls,for,job,id,job,id,return,ref,references,if,ref,references,0,ref,keep,until,system,current,time,millis,cleanup,interval
PermanentBlobCache -> public void releaseJob(JobID jobId);1505901925;Unregisters use of job-related BLOBs and allow them to be released.__@param jobId_ID of the job this blob belongs to__@see #registerJob(JobID);public void releaseJob(JobID jobId) {_		checkNotNull(jobId)___		synchronized (jobRefCounters) {_			RefCount ref = jobRefCounters.get(jobId)___			if (ref == null || ref.references == 0) {_				log.warn("improper use of releaseJob() without a matching number of registerJob() calls for jobId " + jobId)__				return__			}__			--ref.references__			if (ref.references == 0) {_				ref.keepUntil = System.currentTimeMillis() + cleanupInterval__			}_		}_	};unregisters,use,of,job,related,blobs,and,allow,them,to,be,released,param,job,id,id,of,the,job,this,blob,belongs,to,see,register,job,job,id;public,void,release,job,job,id,job,id,check,not,null,job,id,synchronized,job,ref,counters,ref,count,ref,job,ref,counters,get,job,id,if,ref,null,ref,references,0,log,warn,improper,use,of,release,job,without,a,matching,number,of,register,job,calls,for,job,id,job,id,return,ref,references,if,ref,references,0,ref,keep,until,system,current,time,millis,cleanup,interval
PermanentBlobCache -> public void releaseJob(JobID jobId);1507209538;Unregisters use of job-related BLOBs and allow them to be released.__@param jobId_ID of the job this blob belongs to__@see #registerJob(JobID);public void releaseJob(JobID jobId) {_		checkNotNull(jobId)___		synchronized (jobRefCounters) {_			RefCount ref = jobRefCounters.get(jobId)___			if (ref == null || ref.references == 0) {_				log.warn("improper use of releaseJob() without a matching number of registerJob() calls for jobId " + jobId)__				return__			}__			--ref.references__			if (ref.references == 0) {_				ref.keepUntil = System.currentTimeMillis() + cleanupInterval__			}_		}_	};unregisters,use,of,job,related,blobs,and,allow,them,to,be,released,param,job,id,id,of,the,job,this,blob,belongs,to,see,register,job,job,id;public,void,release,job,job,id,job,id,check,not,null,job,id,synchronized,job,ref,counters,ref,count,ref,job,ref,counters,get,job,id,if,ref,null,ref,references,0,log,warn,improper,use,of,release,job,without,a,matching,number,of,register,job,calls,for,job,id,job,id,return,ref,references,if,ref,references,0,ref,keep,until,system,current,time,millis,cleanup,interval
PermanentBlobCache -> public void releaseJob(JobID jobId);1515007198;Unregisters use of job-related BLOBs and allow them to be released.__@param jobId_ID of the job this blob belongs to__@see #registerJob(JobID);public void releaseJob(JobID jobId) {_		checkNotNull(jobId)___		synchronized (jobRefCounters) {_			RefCount ref = jobRefCounters.get(jobId)___			if (ref == null || ref.references == 0) {_				log.warn("improper use of releaseJob() without a matching number of registerJob() calls for jobId " + jobId)__				return__			}__			--ref.references__			if (ref.references == 0) {_				ref.keepUntil = System.currentTimeMillis() + cleanupInterval__			}_		}_	};unregisters,use,of,job,related,blobs,and,allow,them,to,be,released,param,job,id,id,of,the,job,this,blob,belongs,to,see,register,job,job,id;public,void,release,job,job,id,job,id,check,not,null,job,id,synchronized,job,ref,counters,ref,count,ref,job,ref,counters,get,job,id,if,ref,null,ref,references,0,log,warn,improper,use,of,release,job,without,a,matching,number,of,register,job,calls,for,job,id,job,id,return,ref,references,if,ref,references,0,ref,keep,until,system,current,time,millis,cleanup,interval
PermanentBlobCache -> public void releaseJob(JobID jobId);1517911296;Unregisters use of job-related BLOBs and allow them to be released.__@param jobId_ID of the job this blob belongs to__@see #registerJob(JobID);public void releaseJob(JobID jobId) {_		checkNotNull(jobId)___		synchronized (jobRefCounters) {_			RefCount ref = jobRefCounters.get(jobId)___			if (ref == null || ref.references == 0) {_				log.warn("improper use of releaseJob() without a matching number of registerJob() calls for jobId " + jobId)__				return__			}__			--ref.references__			if (ref.references == 0) {_				ref.keepUntil = System.currentTimeMillis() + cleanupInterval__			}_		}_	};unregisters,use,of,job,related,blobs,and,allow,them,to,be,released,param,job,id,id,of,the,job,this,blob,belongs,to,see,register,job,job,id;public,void,release,job,job,id,job,id,check,not,null,job,id,synchronized,job,ref,counters,ref,count,ref,job,ref,counters,get,job,id,if,ref,null,ref,references,0,log,warn,improper,use,of,release,job,without,a,matching,number,of,register,job,calls,for,job,id,job,id,return,ref,references,if,ref,references,0,ref,keep,until,system,current,time,millis,cleanup,interval
PermanentBlobCache -> public void releaseJob(JobID jobId);1522640804;Unregisters use of job-related BLOBs and allow them to be released.__@param jobId_ID of the job this blob belongs to__@see #registerJob(JobID);public void releaseJob(JobID jobId) {_		checkNotNull(jobId)___		synchronized (jobRefCounters) {_			RefCount ref = jobRefCounters.get(jobId)___			if (ref == null || ref.references == 0) {_				log.warn("improper use of releaseJob() without a matching number of registerJob() calls for jobId " + jobId)__				return__			}__			--ref.references__			if (ref.references == 0) {_				ref.keepUntil = System.currentTimeMillis() + cleanupInterval__			}_		}_	};unregisters,use,of,job,related,blobs,and,allow,them,to,be,released,param,job,id,id,of,the,job,this,blob,belongs,to,see,register,job,job,id;public,void,release,job,job,id,job,id,check,not,null,job,id,synchronized,job,ref,counters,ref,count,ref,job,ref,counters,get,job,id,if,ref,null,ref,references,0,log,warn,improper,use,of,release,job,without,a,matching,number,of,register,job,calls,for,job,id,job,id,return,ref,references,if,ref,references,0,ref,keep,until,system,current,time,millis,cleanup,interval
PermanentBlobCache -> File createTemporaryFilename() throws IOException;1499764760;Returns a temporary file inside the BLOB server's incoming directory.__@return a temporary file inside the BLOB server's incoming directory__@throws IOException_if creating the directory fails;File createTemporaryFilename() throws IOException {_		return new File(BlobUtils.getIncomingDirectory(storageDir),_			String.format("temp-%08d", tempFileCounter.getAndIncrement()))__	};returns,a,temporary,file,inside,the,blob,server,s,incoming,directory,return,a,temporary,file,inside,the,blob,server,s,incoming,directory,throws,ioexception,if,creating,the,directory,fails;file,create,temporary,filename,throws,ioexception,return,new,file,blob,utils,get,incoming,directory,storage,dir,string,format,temp,08d,temp,file,counter,get,and,increment
PermanentBlobCache -> File createTemporaryFilename() throws IOException;1500980433;Returns a temporary file inside the BLOB server's incoming directory.__@return a temporary file inside the BLOB server's incoming directory__@throws IOException_if creating the directory fails;File createTemporaryFilename() throws IOException {_		return new File(BlobUtils.getIncomingDirectory(storageDir),_			String.format("temp-%08d", tempFileCounter.getAndIncrement()))__	};returns,a,temporary,file,inside,the,blob,server,s,incoming,directory,return,a,temporary,file,inside,the,blob,server,s,incoming,directory,throws,ioexception,if,creating,the,directory,fails;file,create,temporary,filename,throws,ioexception,return,new,file,blob,utils,get,incoming,directory,storage,dir,string,format,temp,08d,temp,file,counter,get,and,increment
PermanentBlobCache -> public PermanentBlobCache( 		final InetSocketAddress serverAddress, 		final Configuration blobClientConfig, 		final BlobView blobView) throws IOException;1499764760;Instantiates a new cache for permanent BLOBs which are also available in an HA store.__@param serverAddress_address of the {@link BlobServer} to use for fetching files from_@param blobClientConfig_global configuration_@param blobView_(distributed) HA blob store file system to retrieve files from first__@throws IOException_thrown if the (local or distributed) file storage cannot be created or is not usable;public PermanentBlobCache(_		final InetSocketAddress serverAddress,_		final Configuration blobClientConfig,_		final BlobView blobView) throws IOException {__		this.serverAddress = checkNotNull(serverAddress)__		this.blobClientConfig = checkNotNull(blobClientConfig)__		this.blobView = checkNotNull(blobView, "blobStore")__		this.readWriteLock = new ReentrantReadWriteLock()___		_		String storageDirectory = blobClientConfig.getString(BlobServerOptions.STORAGE_DIRECTORY)__		this.storageDir = BlobUtils.initLocalStorageDirectory(storageDirectory)__		LOG.info("Created permanent BLOB cache storage directory " + storageDir)___		_		final int fetchRetries = blobClientConfig.getInteger(BlobServerOptions.FETCH_RETRIES)__		if (fetchRetries >= 0) {_			this.numFetchRetries = fetchRetries__		} else {_			LOG.warn("Invalid value for {}. System will attempt no retries on failed fetch operations of BLOBs.",_				BlobServerOptions.FETCH_RETRIES.key())__			this.numFetchRetries = 0__		}__		_		this.cleanupTimer = new Timer(true)___		this.cleanupInterval = blobClientConfig.getLong(BlobServerOptions.CLEANUP_INTERVAL) * 1000__		this.cleanupTimer.schedule(this, cleanupInterval, cleanupInterval)___		_		shutdownHook = BlobUtils.addShutdownHook(this, LOG)__	};instantiates,a,new,cache,for,permanent,blobs,which,are,also,available,in,an,ha,store,param,server,address,address,of,the,link,blob,server,to,use,for,fetching,files,from,param,blob,client,config,global,configuration,param,blob,view,distributed,ha,blob,store,file,system,to,retrieve,files,from,first,throws,ioexception,thrown,if,the,local,or,distributed,file,storage,cannot,be,created,or,is,not,usable;public,permanent,blob,cache,final,inet,socket,address,server,address,final,configuration,blob,client,config,final,blob,view,blob,view,throws,ioexception,this,server,address,check,not,null,server,address,this,blob,client,config,check,not,null,blob,client,config,this,blob,view,check,not,null,blob,view,blob,store,this,read,write,lock,new,reentrant,read,write,lock,string,storage,directory,blob,client,config,get,string,blob,server,options,this,storage,dir,blob,utils,init,local,storage,directory,storage,directory,log,info,created,permanent,blob,cache,storage,directory,storage,dir,final,int,fetch,retries,blob,client,config,get,integer,blob,server,options,if,fetch,retries,0,this,num,fetch,retries,fetch,retries,else,log,warn,invalid,value,for,system,will,attempt,no,retries,on,failed,fetch,operations,of,blobs,blob,server,options,key,this,num,fetch,retries,0,this,cleanup,timer,new,timer,true,this,cleanup,interval,blob,client,config,get,long,blob,server,options,1000,this,cleanup,timer,schedule,this,cleanup,interval,cleanup,interval,shutdown,hook,blob,utils,add,shutdown,hook,this,log
PermanentBlobCache -> public PermanentBlobCache( 		final InetSocketAddress serverAddress, 		final Configuration blobClientConfig, 		final BlobView blobView) throws IOException;1500980433;Instantiates a new cache for permanent BLOBs which are also available in an HA store.__@param serverAddress_address of the {@link BlobServer} to use for fetching files from_@param blobClientConfig_global configuration_@param blobView_(distributed) HA blob store file system to retrieve files from first__@throws IOException_thrown if the (local or distributed) file storage cannot be created or is not usable;public PermanentBlobCache(_		final InetSocketAddress serverAddress,_		final Configuration blobClientConfig,_		final BlobView blobView) throws IOException {__		this.serverAddress = checkNotNull(serverAddress)__		this.blobClientConfig = checkNotNull(blobClientConfig)__		this.blobView = checkNotNull(blobView, "blobStore")__		this.readWriteLock = new ReentrantReadWriteLock()___		_		String storageDirectory = blobClientConfig.getString(BlobServerOptions.STORAGE_DIRECTORY)__		this.storageDir = BlobUtils.initLocalStorageDirectory(storageDirectory)__		LOG.info("Created permanent BLOB cache storage directory " + storageDir)___		_		final int fetchRetries = blobClientConfig.getInteger(BlobServerOptions.FETCH_RETRIES)__		if (fetchRetries >= 0) {_			this.numFetchRetries = fetchRetries__		} else {_			LOG.warn("Invalid value for {}. System will attempt no retries on failed fetch operations of BLOBs.",_				BlobServerOptions.FETCH_RETRIES.key())__			this.numFetchRetries = 0__		}__		_		this.cleanupTimer = new Timer(true)___		this.cleanupInterval = blobClientConfig.getLong(BlobServerOptions.CLEANUP_INTERVAL) * 1000__		this.cleanupTimer.schedule(this, cleanupInterval, cleanupInterval)___		_		shutdownHook = BlobUtils.addShutdownHook(this, LOG)__	};instantiates,a,new,cache,for,permanent,blobs,which,are,also,available,in,an,ha,store,param,server,address,address,of,the,link,blob,server,to,use,for,fetching,files,from,param,blob,client,config,global,configuration,param,blob,view,distributed,ha,blob,store,file,system,to,retrieve,files,from,first,throws,ioexception,thrown,if,the,local,or,distributed,file,storage,cannot,be,created,or,is,not,usable;public,permanent,blob,cache,final,inet,socket,address,server,address,final,configuration,blob,client,config,final,blob,view,blob,view,throws,ioexception,this,server,address,check,not,null,server,address,this,blob,client,config,check,not,null,blob,client,config,this,blob,view,check,not,null,blob,view,blob,store,this,read,write,lock,new,reentrant,read,write,lock,string,storage,directory,blob,client,config,get,string,blob,server,options,this,storage,dir,blob,utils,init,local,storage,directory,storage,directory,log,info,created,permanent,blob,cache,storage,directory,storage,dir,final,int,fetch,retries,blob,client,config,get,integer,blob,server,options,if,fetch,retries,0,this,num,fetch,retries,fetch,retries,else,log,warn,invalid,value,for,system,will,attempt,no,retries,on,failed,fetch,operations,of,blobs,blob,server,options,key,this,num,fetch,retries,0,this,cleanup,timer,new,timer,true,this,cleanup,interval,blob,client,config,get,long,blob,server,options,1000,this,cleanup,timer,schedule,this,cleanup,interval,cleanup,interval,shutdown,hook,blob,utils,add,shutdown,hook,this,log
PermanentBlobCache -> @VisibleForTesting 	public File getStorageLocation(JobID jobId, BlobKey key) throws IOException;1499764760;Returns a file handle to the file associated with the given blob key on the blob_server.__@param jobId_ID of the job this blob belongs to (or <tt>null</tt> if job-unrelated)_@param key_identifying the file__@return file handle to the file__@throws IOException_if creating the directory fails;@VisibleForTesting_	public File getStorageLocation(JobID jobId, BlobKey key) throws IOException {_		checkNotNull(jobId)__		return BlobUtils.getStorageLocation(storageDir, jobId, key)__	};returns,a,file,handle,to,the,file,associated,with,the,given,blob,key,on,the,blob,server,param,job,id,id,of,the,job,this,blob,belongs,to,or,tt,null,tt,if,job,unrelated,param,key,identifying,the,file,return,file,handle,to,the,file,throws,ioexception,if,creating,the,directory,fails;visible,for,testing,public,file,get,storage,location,job,id,job,id,blob,key,key,throws,ioexception,check,not,null,job,id,return,blob,utils,get,storage,location,storage,dir,job,id,key
PermanentBlobCache -> @VisibleForTesting 	public File getStorageLocation(JobID jobId, BlobKey key) throws IOException;1500980433;Returns a file handle to the file associated with the given blob key on the blob_server.__@param jobId_ID of the job this blob belongs to (or <tt>null</tt> if job-unrelated)_@param key_identifying the file__@return file handle to the file__@throws IOException_if creating the directory fails;@VisibleForTesting_	public File getStorageLocation(JobID jobId, BlobKey key) throws IOException {_		checkNotNull(jobId)__		return BlobUtils.getStorageLocation(storageDir, jobId, key)__	};returns,a,file,handle,to,the,file,associated,with,the,given,blob,key,on,the,blob,server,param,job,id,id,of,the,job,this,blob,belongs,to,or,tt,null,tt,if,job,unrelated,param,key,identifying,the,file,return,file,handle,to,the,file,throws,ioexception,if,creating,the,directory,fails;visible,for,testing,public,file,get,storage,location,job,id,job,id,blob,key,key,throws,ioexception,check,not,null,job,id,return,blob,utils,get,storage,location,storage,dir,job,id,key
PermanentBlobCache -> @VisibleForTesting 	public File getStorageLocation(JobID jobId, BlobKey key) throws IOException;1505901925;Returns a file handle to the file associated with the given blob key on the blob_server.__@param jobId_ID of the job this blob belongs to (or <tt>null</tt> if job-unrelated)_@param key_identifying the file__@return file handle to the file__@throws IOException_if creating the directory fails;@VisibleForTesting_	public File getStorageLocation(JobID jobId, BlobKey key) throws IOException {_		checkNotNull(jobId)__		return BlobUtils.getStorageLocation(storageDir, jobId, key)__	};returns,a,file,handle,to,the,file,associated,with,the,given,blob,key,on,the,blob,server,param,job,id,id,of,the,job,this,blob,belongs,to,or,tt,null,tt,if,job,unrelated,param,key,identifying,the,file,return,file,handle,to,the,file,throws,ioexception,if,creating,the,directory,fails;visible,for,testing,public,file,get,storage,location,job,id,job,id,blob,key,key,throws,ioexception,check,not,null,job,id,return,blob,utils,get,storage,location,storage,dir,job,id,key
PermanentBlobCache -> @VisibleForTesting 	public File getStorageLocation(JobID jobId, BlobKey key) throws IOException;1507209538;Returns a file handle to the file associated with the given blob key on the blob_server.__@param jobId_ID of the job this blob belongs to (or <tt>null</tt> if job-unrelated)_@param key_identifying the file__@return file handle to the file__@throws IOException_if creating the directory fails;@VisibleForTesting_	public File getStorageLocation(JobID jobId, BlobKey key) throws IOException {_		checkNotNull(jobId)__		return BlobUtils.getStorageLocation(storageDir, jobId, key)__	};returns,a,file,handle,to,the,file,associated,with,the,given,blob,key,on,the,blob,server,param,job,id,id,of,the,job,this,blob,belongs,to,or,tt,null,tt,if,job,unrelated,param,key,identifying,the,file,return,file,handle,to,the,file,throws,ioexception,if,creating,the,directory,fails;visible,for,testing,public,file,get,storage,location,job,id,job,id,blob,key,key,throws,ioexception,check,not,null,job,id,return,blob,utils,get,storage,location,storage,dir,job,id,key
PermanentBlobCache -> @VisibleForTesting 	public File getStorageLocation(JobID jobId, BlobKey key) throws IOException;1515007198;Returns a file handle to the file associated with the given blob key on the blob_server.__@param jobId_ID of the job this blob belongs to (or <tt>null</tt> if job-unrelated)_@param key_identifying the file__@return file handle to the file__@throws IOException_if creating the directory fails;@VisibleForTesting_	public File getStorageLocation(JobID jobId, BlobKey key) throws IOException {_		checkNotNull(jobId)__		return BlobUtils.getStorageLocation(storageDir, jobId, key)__	};returns,a,file,handle,to,the,file,associated,with,the,given,blob,key,on,the,blob,server,param,job,id,id,of,the,job,this,blob,belongs,to,or,tt,null,tt,if,job,unrelated,param,key,identifying,the,file,return,file,handle,to,the,file,throws,ioexception,if,creating,the,directory,fails;visible,for,testing,public,file,get,storage,location,job,id,job,id,blob,key,key,throws,ioexception,check,not,null,job,id,return,blob,utils,get,storage,location,storage,dir,job,id,key
PermanentBlobCache -> @VisibleForTesting 	public File getStorageLocation(JobID jobId, BlobKey key) throws IOException;1517911296;Returns a file handle to the file associated with the given blob key on the blob_server.__@param jobId_ID of the job this blob belongs to (or <tt>null</tt> if job-unrelated)_@param key_identifying the file__@return file handle to the file__@throws IOException_if creating the directory fails;@VisibleForTesting_	public File getStorageLocation(JobID jobId, BlobKey key) throws IOException {_		checkNotNull(jobId)__		return BlobUtils.getStorageLocation(storageDir, jobId, key)__	};returns,a,file,handle,to,the,file,associated,with,the,given,blob,key,on,the,blob,server,param,job,id,id,of,the,job,this,blob,belongs,to,or,tt,null,tt,if,job,unrelated,param,key,identifying,the,file,return,file,handle,to,the,file,throws,ioexception,if,creating,the,directory,fails;visible,for,testing,public,file,get,storage,location,job,id,job,id,blob,key,key,throws,ioexception,check,not,null,job,id,return,blob,utils,get,storage,location,storage,dir,job,id,key
PermanentBlobCache -> @VisibleForTesting 	public File getStorageLocation(JobID jobId, BlobKey key) throws IOException;1522640804;Returns a file handle to the file associated with the given blob key on the blob_server.__@param jobId_ID of the job this blob belongs to (or <tt>null</tt> if job-unrelated)_@param key_identifying the file__@return file handle to the file__@throws IOException_if creating the directory fails;@VisibleForTesting_	public File getStorageLocation(JobID jobId, BlobKey key) throws IOException {_		checkNotNull(jobId)__		return BlobUtils.getStorageLocation(storageDir, jobId, key)__	};returns,a,file,handle,to,the,file,associated,with,the,given,blob,key,on,the,blob,server,param,job,id,id,of,the,job,this,blob,belongs,to,or,tt,null,tt,if,job,unrelated,param,key,identifying,the,file,return,file,handle,to,the,file,throws,ioexception,if,creating,the,directory,fails;visible,for,testing,public,file,get,storage,location,job,id,job,id,blob,key,key,throws,ioexception,check,not,null,job,id,return,blob,utils,get,storage,location,storage,dir,job,id,key
PermanentBlobCache -> PermanentBlobCleanupTask -> @Override 		public void run();1505901925;Cleans up BLOBs which are not referenced anymore.;@Override_		public void run() {_			synchronized (jobRefCounters) {_				Iterator<Map.Entry<JobID, RefCount>> entryIter = jobRefCounters.entrySet().iterator()__				final long currentTimeMillis = System.currentTimeMillis()___				while (entryIter.hasNext()) {_					Map.Entry<JobID, RefCount> entry = entryIter.next()__					RefCount ref = entry.getValue()___					if (ref.references <= 0 && ref.keepUntil > 0 && currentTimeMillis >= ref.keepUntil) {_						JobID jobId = entry.getKey()___						final File localFile =_							new File(BlobUtils.getStorageLocationPath(storageDir.getAbsolutePath(), jobId))___					_						readWriteLock.writeLock().lock()___						boolean success = false__						try {_							FileUtils.deleteDirectory(localFile)__							success = true__						} catch (Throwable t) {_							log.warn("Failed to locally delete job directory " + localFile.getAbsolutePath(), t)__						} finally {_							readWriteLock.writeLock().unlock()__						}__						_						_						if (success) {_							entryIter.remove()__						}_					}_				}_			}_		};cleans,up,blobs,which,are,not,referenced,anymore;override,public,void,run,synchronized,job,ref,counters,iterator,map,entry,job,id,ref,count,entry,iter,job,ref,counters,entry,set,iterator,final,long,current,time,millis,system,current,time,millis,while,entry,iter,has,next,map,entry,job,id,ref,count,entry,entry,iter,next,ref,count,ref,entry,get,value,if,ref,references,0,ref,keep,until,0,current,time,millis,ref,keep,until,job,id,job,id,entry,get,key,final,file,local,file,new,file,blob,utils,get,storage,location,path,storage,dir,get,absolute,path,job,id,read,write,lock,write,lock,lock,boolean,success,false,try,file,utils,delete,directory,local,file,success,true,catch,throwable,t,log,warn,failed,to,locally,delete,job,directory,local,file,get,absolute,path,t,finally,read,write,lock,write,lock,unlock,if,success,entry,iter,remove
PermanentBlobCache -> PermanentBlobCleanupTask -> @Override 		public void run();1507209538;Cleans up BLOBs which are not referenced anymore.;@Override_		public void run() {_			synchronized (jobRefCounters) {_				Iterator<Map.Entry<JobID, RefCount>> entryIter = jobRefCounters.entrySet().iterator()__				final long currentTimeMillis = System.currentTimeMillis()___				while (entryIter.hasNext()) {_					Map.Entry<JobID, RefCount> entry = entryIter.next()__					RefCount ref = entry.getValue()___					if (ref.references <= 0 && ref.keepUntil > 0 && currentTimeMillis >= ref.keepUntil) {_						JobID jobId = entry.getKey()___						final File localFile =_							new File(BlobUtils.getStorageLocationPath(storageDir.getAbsolutePath(), jobId))___					_						readWriteLock.writeLock().lock()___						boolean success = false__						try {_							FileUtils.deleteDirectory(localFile)__							success = true__						} catch (Throwable t) {_							log.warn("Failed to locally delete job directory " + localFile.getAbsolutePath(), t)__						} finally {_							readWriteLock.writeLock().unlock()__						}__						_						_						if (success) {_							entryIter.remove()__						}_					}_				}_			}_		};cleans,up,blobs,which,are,not,referenced,anymore;override,public,void,run,synchronized,job,ref,counters,iterator,map,entry,job,id,ref,count,entry,iter,job,ref,counters,entry,set,iterator,final,long,current,time,millis,system,current,time,millis,while,entry,iter,has,next,map,entry,job,id,ref,count,entry,entry,iter,next,ref,count,ref,entry,get,value,if,ref,references,0,ref,keep,until,0,current,time,millis,ref,keep,until,job,id,job,id,entry,get,key,final,file,local,file,new,file,blob,utils,get,storage,location,path,storage,dir,get,absolute,path,job,id,read,write,lock,write,lock,lock,boolean,success,false,try,file,utils,delete,directory,local,file,success,true,catch,throwable,t,log,warn,failed,to,locally,delete,job,directory,local,file,get,absolute,path,t,finally,read,write,lock,write,lock,unlock,if,success,entry,iter,remove
PermanentBlobCache -> PermanentBlobCleanupTask -> @Override 		public void run();1515007198;Cleans up BLOBs which are not referenced anymore.;@Override_		public void run() {_			synchronized (jobRefCounters) {_				Iterator<Map.Entry<JobID, RefCount>> entryIter = jobRefCounters.entrySet().iterator()__				final long currentTimeMillis = System.currentTimeMillis()___				while (entryIter.hasNext()) {_					Map.Entry<JobID, RefCount> entry = entryIter.next()__					RefCount ref = entry.getValue()___					if (ref.references <= 0 && ref.keepUntil > 0 && currentTimeMillis >= ref.keepUntil) {_						JobID jobId = entry.getKey()___						final File localFile =_							new File(BlobUtils.getStorageLocationPath(storageDir.getAbsolutePath(), jobId))___					_						readWriteLock.writeLock().lock()___						boolean success = false__						try {_							FileUtils.deleteDirectory(localFile)__							success = true__						} catch (Throwable t) {_							log.warn("Failed to locally delete job directory " + localFile.getAbsolutePath(), t)__						} finally {_							readWriteLock.writeLock().unlock()__						}__						_						_						if (success) {_							entryIter.remove()__						}_					}_				}_			}_		};cleans,up,blobs,which,are,not,referenced,anymore;override,public,void,run,synchronized,job,ref,counters,iterator,map,entry,job,id,ref,count,entry,iter,job,ref,counters,entry,set,iterator,final,long,current,time,millis,system,current,time,millis,while,entry,iter,has,next,map,entry,job,id,ref,count,entry,entry,iter,next,ref,count,ref,entry,get,value,if,ref,references,0,ref,keep,until,0,current,time,millis,ref,keep,until,job,id,job,id,entry,get,key,final,file,local,file,new,file,blob,utils,get,storage,location,path,storage,dir,get,absolute,path,job,id,read,write,lock,write,lock,lock,boolean,success,false,try,file,utils,delete,directory,local,file,success,true,catch,throwable,t,log,warn,failed,to,locally,delete,job,directory,local,file,get,absolute,path,t,finally,read,write,lock,write,lock,unlock,if,success,entry,iter,remove
PermanentBlobCache -> PermanentBlobCleanupTask -> @Override 		public void run();1517911296;Cleans up BLOBs which are not referenced anymore.;@Override_		public void run() {_			synchronized (jobRefCounters) {_				Iterator<Map.Entry<JobID, RefCount>> entryIter = jobRefCounters.entrySet().iterator()__				final long currentTimeMillis = System.currentTimeMillis()___				while (entryIter.hasNext()) {_					Map.Entry<JobID, RefCount> entry = entryIter.next()__					RefCount ref = entry.getValue()___					if (ref.references <= 0 && ref.keepUntil > 0 && currentTimeMillis >= ref.keepUntil) {_						JobID jobId = entry.getKey()___						final File localFile =_							new File(BlobUtils.getStorageLocationPath(storageDir.getAbsolutePath(), jobId))___					_						readWriteLock.writeLock().lock()___						boolean success = false__						try {_							FileUtils.deleteDirectory(localFile)__							success = true__						} catch (Throwable t) {_							log.warn("Failed to locally delete job directory " + localFile.getAbsolutePath(), t)__						} finally {_							readWriteLock.writeLock().unlock()__						}__						_						_						if (success) {_							entryIter.remove()__						}_					}_				}_			}_		};cleans,up,blobs,which,are,not,referenced,anymore;override,public,void,run,synchronized,job,ref,counters,iterator,map,entry,job,id,ref,count,entry,iter,job,ref,counters,entry,set,iterator,final,long,current,time,millis,system,current,time,millis,while,entry,iter,has,next,map,entry,job,id,ref,count,entry,entry,iter,next,ref,count,ref,entry,get,value,if,ref,references,0,ref,keep,until,0,current,time,millis,ref,keep,until,job,id,job,id,entry,get,key,final,file,local,file,new,file,blob,utils,get,storage,location,path,storage,dir,get,absolute,path,job,id,read,write,lock,write,lock,lock,boolean,success,false,try,file,utils,delete,directory,local,file,success,true,catch,throwable,t,log,warn,failed,to,locally,delete,job,directory,local,file,get,absolute,path,t,finally,read,write,lock,write,lock,unlock,if,success,entry,iter,remove
PermanentBlobCache -> PermanentBlobCleanupTask -> @Override 		public void run();1522640804;Cleans up BLOBs which are not referenced anymore.;@Override_		public void run() {_			synchronized (jobRefCounters) {_				Iterator<Map.Entry<JobID, RefCount>> entryIter = jobRefCounters.entrySet().iterator()__				final long currentTimeMillis = System.currentTimeMillis()___				while (entryIter.hasNext()) {_					Map.Entry<JobID, RefCount> entry = entryIter.next()__					RefCount ref = entry.getValue()___					if (ref.references <= 0 && ref.keepUntil > 0 && currentTimeMillis >= ref.keepUntil) {_						JobID jobId = entry.getKey()___						final File localFile =_							new File(BlobUtils.getStorageLocationPath(storageDir.getAbsolutePath(), jobId))___					_						readWriteLock.writeLock().lock()___						boolean success = false__						try {_							FileUtils.deleteDirectory(localFile)__							success = true__						} catch (Throwable t) {_							log.warn("Failed to locally delete job directory " + localFile.getAbsolutePath(), t)__						} finally {_							readWriteLock.writeLock().unlock()__						}__						_						_						if (success) {_							entryIter.remove()__						}_					}_				}_			}_		};cleans,up,blobs,which,are,not,referenced,anymore;override,public,void,run,synchronized,job,ref,counters,iterator,map,entry,job,id,ref,count,entry,iter,job,ref,counters,entry,set,iterator,final,long,current,time,millis,system,current,time,millis,while,entry,iter,has,next,map,entry,job,id,ref,count,entry,entry,iter,next,ref,count,ref,entry,get,value,if,ref,references,0,ref,keep,until,0,current,time,millis,ref,keep,until,job,id,job,id,entry,get,key,final,file,local,file,new,file,blob,utils,get,storage,location,path,storage,dir,get,absolute,path,job,id,read,write,lock,write,lock,lock,boolean,success,false,try,file,utils,delete,directory,local,file,success,true,catch,throwable,t,log,warn,failed,to,locally,delete,job,directory,local,file,get,absolute,path,t,finally,read,write,lock,write,lock,unlock,if,success,entry,iter,remove
PermanentBlobCache -> public PermanentBlobCache( 			final Configuration blobClientConfig, 			final BlobView blobView, 			@Nullable final InetSocketAddress serverAddress) throws IOException;1517911296;Instantiates a new cache for permanent BLOBs which are also available in an HA store.__@param blobClientConfig_global configuration_@param blobView_(distributed) HA blob store file system to retrieve files from first_@param serverAddress_address of the {@link BlobServer} to use for fetching files from or {@code null} if none yet_@throws IOException_thrown if the (local or distributed) file storage cannot be created or is not usable;public PermanentBlobCache(_			final Configuration blobClientConfig,_			final BlobView blobView,_			@Nullable final InetSocketAddress serverAddress) throws IOException {__		super(blobClientConfig, blobView, LoggerFactory.getLogger(PermanentBlobCache.class), serverAddress_		)___		_		this.cleanupTimer = new Timer(true)___		this.cleanupInterval = blobClientConfig.getLong(BlobServerOptions.CLEANUP_INTERVAL) * 1000__		this.cleanupTimer.schedule(new PermanentBlobCleanupTask(), cleanupInterval, cleanupInterval)__	};instantiates,a,new,cache,for,permanent,blobs,which,are,also,available,in,an,ha,store,param,blob,client,config,global,configuration,param,blob,view,distributed,ha,blob,store,file,system,to,retrieve,files,from,first,param,server,address,address,of,the,link,blob,server,to,use,for,fetching,files,from,or,code,null,if,none,yet,throws,ioexception,thrown,if,the,local,or,distributed,file,storage,cannot,be,created,or,is,not,usable;public,permanent,blob,cache,final,configuration,blob,client,config,final,blob,view,blob,view,nullable,final,inet,socket,address,server,address,throws,ioexception,super,blob,client,config,blob,view,logger,factory,get,logger,permanent,blob,cache,class,server,address,this,cleanup,timer,new,timer,true,this,cleanup,interval,blob,client,config,get,long,blob,server,options,1000,this,cleanup,timer,schedule,new,permanent,blob,cleanup,task,cleanup,interval,cleanup,interval
PermanentBlobCache -> public PermanentBlobCache( 			final Configuration blobClientConfig, 			final BlobView blobView, 			@Nullable final InetSocketAddress serverAddress) throws IOException;1522640804;Instantiates a new cache for permanent BLOBs which are also available in an HA store.__@param blobClientConfig_global configuration_@param blobView_(distributed) HA blob store file system to retrieve files from first_@param serverAddress_address of the {@link BlobServer} to use for fetching files from or {@code null} if none yet_@throws IOException_thrown if the (local or distributed) file storage cannot be created or is not usable;public PermanentBlobCache(_			final Configuration blobClientConfig,_			final BlobView blobView,_			@Nullable final InetSocketAddress serverAddress) throws IOException {__		super(blobClientConfig, blobView, LoggerFactory.getLogger(PermanentBlobCache.class), serverAddress_		)___		_		this.cleanupTimer = new Timer(true)___		this.cleanupInterval = blobClientConfig.getLong(BlobServerOptions.CLEANUP_INTERVAL) * 1000__		this.cleanupTimer.schedule(new PermanentBlobCleanupTask(), cleanupInterval, cleanupInterval)__	};instantiates,a,new,cache,for,permanent,blobs,which,are,also,available,in,an,ha,store,param,blob,client,config,global,configuration,param,blob,view,distributed,ha,blob,store,file,system,to,retrieve,files,from,first,param,server,address,address,of,the,link,blob,server,to,use,for,fetching,files,from,or,code,null,if,none,yet,throws,ioexception,thrown,if,the,local,or,distributed,file,storage,cannot,be,created,or,is,not,usable;public,permanent,blob,cache,final,configuration,blob,client,config,final,blob,view,blob,view,nullable,final,inet,socket,address,server,address,throws,ioexception,super,blob,client,config,blob,view,logger,factory,get,logger,permanent,blob,cache,class,server,address,this,cleanup,timer,new,timer,true,this,cleanup,interval,blob,client,config,get,long,blob,server,options,1000,this,cleanup,timer,schedule,new,permanent,blob,cleanup,task,cleanup,interval,cleanup,interval
PermanentBlobCache -> @Override 	public void run();1499764760;Cleans up BLOBs which are not referenced anymore.;@Override_	public void run() {_		synchronized (jobRefCounters) {_			Iterator<Map.Entry<JobID, RefCount>> entryIter = jobRefCounters.entrySet().iterator()__			final long currentTimeMillis = System.currentTimeMillis()___			while (entryIter.hasNext()) {_				Map.Entry<JobID, RefCount> entry = entryIter.next()__				RefCount ref = entry.getValue()___				if (ref.references <= 0 && ref.keepUntil > 0 && currentTimeMillis >= ref.keepUntil) {_					JobID jobId = entry.getKey()___					final File localFile =_						new File(BlobUtils.getStorageLocationPath(storageDir.getAbsolutePath(), jobId))___					_					readWriteLock.writeLock().lock()___					boolean success = false__					try {_						FileUtils.deleteDirectory(localFile)__						success = true__					} catch (Throwable t) {_						LOG.warn("Failed to locally delete job directory " + localFile.getAbsolutePath(), t)__					} finally {_						readWriteLock.writeLock().unlock()__					}__					_					_					if (success) {_						entryIter.remove()__					}_				}_			}_		}_	};cleans,up,blobs,which,are,not,referenced,anymore;override,public,void,run,synchronized,job,ref,counters,iterator,map,entry,job,id,ref,count,entry,iter,job,ref,counters,entry,set,iterator,final,long,current,time,millis,system,current,time,millis,while,entry,iter,has,next,map,entry,job,id,ref,count,entry,entry,iter,next,ref,count,ref,entry,get,value,if,ref,references,0,ref,keep,until,0,current,time,millis,ref,keep,until,job,id,job,id,entry,get,key,final,file,local,file,new,file,blob,utils,get,storage,location,path,storage,dir,get,absolute,path,job,id,read,write,lock,write,lock,lock,boolean,success,false,try,file,utils,delete,directory,local,file,success,true,catch,throwable,t,log,warn,failed,to,locally,delete,job,directory,local,file,get,absolute,path,t,finally,read,write,lock,write,lock,unlock,if,success,entry,iter,remove
PermanentBlobCache -> @Override 	public void run();1500980433;Cleans up BLOBs which are not referenced anymore.;@Override_	public void run() {_		synchronized (jobRefCounters) {_			Iterator<Map.Entry<JobID, RefCount>> entryIter = jobRefCounters.entrySet().iterator()__			final long currentTimeMillis = System.currentTimeMillis()___			while (entryIter.hasNext()) {_				Map.Entry<JobID, RefCount> entry = entryIter.next()__				RefCount ref = entry.getValue()___				if (ref.references <= 0 && ref.keepUntil > 0 && currentTimeMillis >= ref.keepUntil) {_					JobID jobId = entry.getKey()___					final File localFile =_						new File(BlobUtils.getStorageLocationPath(storageDir.getAbsolutePath(), jobId))___					_					readWriteLock.writeLock().lock()___					boolean success = false__					try {_						FileUtils.deleteDirectory(localFile)__						success = true__					} catch (Throwable t) {_						LOG.warn("Failed to locally delete job directory " + localFile.getAbsolutePath(), t)__					} finally {_						readWriteLock.writeLock().unlock()__					}__					_					_					if (success) {_						entryIter.remove()__					}_				}_			}_		}_	};cleans,up,blobs,which,are,not,referenced,anymore;override,public,void,run,synchronized,job,ref,counters,iterator,map,entry,job,id,ref,count,entry,iter,job,ref,counters,entry,set,iterator,final,long,current,time,millis,system,current,time,millis,while,entry,iter,has,next,map,entry,job,id,ref,count,entry,entry,iter,next,ref,count,ref,entry,get,value,if,ref,references,0,ref,keep,until,0,current,time,millis,ref,keep,until,job,id,job,id,entry,get,key,final,file,local,file,new,file,blob,utils,get,storage,location,path,storage,dir,get,absolute,path,job,id,read,write,lock,write,lock,lock,boolean,success,false,try,file,utils,delete,directory,local,file,success,true,catch,throwable,t,log,warn,failed,to,locally,delete,job,directory,local,file,get,absolute,path,t,finally,read,write,lock,write,lock,unlock,if,success,entry,iter,remove
PermanentBlobCache -> @VisibleForTesting 	Map<JobID, RefCount> getJobRefCounters();1499764760;Returns the job reference counters - for testing purposes only!__@return job reference counters (internal state!);@VisibleForTesting_	Map<JobID, RefCount> getJobRefCounters() {_		return jobRefCounters__	};returns,the,job,reference,counters,for,testing,purposes,only,return,job,reference,counters,internal,state;visible,for,testing,map,job,id,ref,count,get,job,ref,counters,return,job,ref,counters
PermanentBlobCache -> @VisibleForTesting 	Map<JobID, RefCount> getJobRefCounters();1500980433;Returns the job reference counters - for testing purposes only!__@return job reference counters (internal state!);@VisibleForTesting_	Map<JobID, RefCount> getJobRefCounters() {_		return jobRefCounters__	};returns,the,job,reference,counters,for,testing,purposes,only,return,job,reference,counters,internal,state;visible,for,testing,map,job,id,ref,count,get,job,ref,counters,return,job,ref,counters
PermanentBlobCache -> @VisibleForTesting 	Map<JobID, RefCount> getJobRefCounters();1505901925;Returns the job reference counters - for testing purposes only!__@return job reference counters (internal state!);@VisibleForTesting_	Map<JobID, RefCount> getJobRefCounters() {_		return jobRefCounters__	};returns,the,job,reference,counters,for,testing,purposes,only,return,job,reference,counters,internal,state;visible,for,testing,map,job,id,ref,count,get,job,ref,counters,return,job,ref,counters
PermanentBlobCache -> @VisibleForTesting 	Map<JobID, RefCount> getJobRefCounters();1507209538;Returns the job reference counters - for testing purposes only!__@return job reference counters (internal state!);@VisibleForTesting_	Map<JobID, RefCount> getJobRefCounters() {_		return jobRefCounters__	};returns,the,job,reference,counters,for,testing,purposes,only,return,job,reference,counters,internal,state;visible,for,testing,map,job,id,ref,count,get,job,ref,counters,return,job,ref,counters
PermanentBlobCache -> @VisibleForTesting 	Map<JobID, RefCount> getJobRefCounters();1515007198;Returns the job reference counters - for testing purposes only!__@return job reference counters (internal state!);@VisibleForTesting_	Map<JobID, RefCount> getJobRefCounters() {_		return jobRefCounters__	};returns,the,job,reference,counters,for,testing,purposes,only,return,job,reference,counters,internal,state;visible,for,testing,map,job,id,ref,count,get,job,ref,counters,return,job,ref,counters
PermanentBlobCache -> @VisibleForTesting 	Map<JobID, RefCount> getJobRefCounters();1517911296;Returns the job reference counters - for testing purposes only!__@return job reference counters (internal state!);@VisibleForTesting_	Map<JobID, RefCount> getJobRefCounters() {_		return jobRefCounters__	};returns,the,job,reference,counters,for,testing,purposes,only,return,job,reference,counters,internal,state;visible,for,testing,map,job,id,ref,count,get,job,ref,counters,return,job,ref,counters
PermanentBlobCache -> @VisibleForTesting 	Map<JobID, RefCount> getJobRefCounters();1522640804;Returns the job reference counters - for testing purposes only!__@return job reference counters (internal state!);@VisibleForTesting_	Map<JobID, RefCount> getJobRefCounters() {_		return jobRefCounters__	};returns,the,job,reference,counters,for,testing,purposes,only,return,job,reference,counters,internal,state;visible,for,testing,map,job,id,ref,count,get,job,ref,counters,return,job,ref,counters
PermanentBlobCache -> private File getHAFileInternal(@Nullable JobID jobId, BlobKey blobKey) throws IOException;1499764760;Returns local copy of the file for the BLOB with the given key._<p>_The method will first attempt to serve the BLOB from its local cache. If the BLOB is not in_the cache, the method will try to download it from this cache's BLOB server.__@param jobId_ID of the job this blob belongs to (or <tt>null</tt> if job-unrelated)_@param blobKey_The key of the desired BLOB.__@return file referring to the local storage location of the BLOB.__@throws IOException_Thrown if an I/O error occurs while downloading the BLOBs from the BLOB server.;private File getHAFileInternal(@Nullable JobID jobId, BlobKey blobKey) throws IOException {_		checkArgument(blobKey != null, "BLOB key cannot be null.")___		final File localFile = BlobUtils.getStorageLocation(storageDir, jobId, blobKey)__		readWriteLock.readLock().lock()___		try {_			if (localFile.exists()) {_				return localFile__			}_		} finally {_			readWriteLock.readLock().unlock()__		}__		_		_		File incomingFile = createTemporaryFilename()__		try {_			try {_				blobView.get(jobId, blobKey, incomingFile)__				BlobUtils.moveTempFileToStore(_					incomingFile, jobId, blobKey, localFile, readWriteLock.writeLock(), LOG, null)___				return localFile__			} catch (Exception e) {_				LOG.info("Failed to copy from blob store. Downloading from BLOB server instead.", e)__			}__			_			BlobClient.downloadFromBlobServer(_				jobId, blobKey, true, incomingFile, serverAddress, blobClientConfig, numFetchRetries)__			BlobUtils.moveTempFileToStore(_				incomingFile, jobId, blobKey, localFile, readWriteLock.writeLock(), LOG, null)___			return localFile__		} finally {_			_			if (!incomingFile.delete() && incomingFile.exists()) {_				LOG.warn("Could not delete the staging file {} for blob key {} and job {}.",_					incomingFile, blobKey, jobId)__			}_		}_	};returns,local,copy,of,the,file,for,the,blob,with,the,given,key,p,the,method,will,first,attempt,to,serve,the,blob,from,its,local,cache,if,the,blob,is,not,in,the,cache,the,method,will,try,to,download,it,from,this,cache,s,blob,server,param,job,id,id,of,the,job,this,blob,belongs,to,or,tt,null,tt,if,job,unrelated,param,blob,key,the,key,of,the,desired,blob,return,file,referring,to,the,local,storage,location,of,the,blob,throws,ioexception,thrown,if,an,i,o,error,occurs,while,downloading,the,blobs,from,the,blob,server;private,file,get,hafile,internal,nullable,job,id,job,id,blob,key,blob,key,throws,ioexception,check,argument,blob,key,null,blob,key,cannot,be,null,final,file,local,file,blob,utils,get,storage,location,storage,dir,job,id,blob,key,read,write,lock,read,lock,lock,try,if,local,file,exists,return,local,file,finally,read,write,lock,read,lock,unlock,file,incoming,file,create,temporary,filename,try,try,blob,view,get,job,id,blob,key,incoming,file,blob,utils,move,temp,file,to,store,incoming,file,job,id,blob,key,local,file,read,write,lock,write,lock,log,null,return,local,file,catch,exception,e,log,info,failed,to,copy,from,blob,store,downloading,from,blob,server,instead,e,blob,client,download,from,blob,server,job,id,blob,key,true,incoming,file,server,address,blob,client,config,num,fetch,retries,blob,utils,move,temp,file,to,store,incoming,file,job,id,blob,key,local,file,read,write,lock,write,lock,log,null,return,local,file,finally,if,incoming,file,delete,incoming,file,exists,log,warn,could,not,delete,the,staging,file,for,blob,key,and,job,incoming,file,blob,key,job,id
PermanentBlobCache -> private File getHAFileInternal(@Nullable JobID jobId, BlobKey blobKey) throws IOException;1500980433;Returns local copy of the file for the BLOB with the given key._<p>_The method will first attempt to serve the BLOB from its local cache. If the BLOB is not in_the cache, the method will try to download it from this cache's BLOB server.__@param jobId_ID of the job this blob belongs to (or <tt>null</tt> if job-unrelated)_@param blobKey_The key of the desired BLOB.__@return file referring to the local storage location of the BLOB.__@throws IOException_Thrown if an I/O error occurs while downloading the BLOBs from the BLOB server.;private File getHAFileInternal(@Nullable JobID jobId, BlobKey blobKey) throws IOException {_		checkArgument(blobKey != null, "BLOB key cannot be null.")___		final File localFile = BlobUtils.getStorageLocation(storageDir, jobId, blobKey)__		readWriteLock.readLock().lock()___		try {_			if (localFile.exists()) {_				return localFile__			}_		} finally {_			readWriteLock.readLock().unlock()__		}__		_		_		File incomingFile = createTemporaryFilename()__		try {_			try {_				if (blobView.get(jobId, blobKey, incomingFile)) {_					_					BlobUtils.moveTempFileToStore(_						incomingFile, jobId, blobKey, localFile, readWriteLock.writeLock(), LOG, null)___					return localFile__				}_			} catch (Exception e) {_				LOG.info("Failed to copy from blob store. Downloading from BLOB server instead.", e)__			}__			_			BlobClient.downloadFromBlobServer(_				jobId, blobKey, true, incomingFile, serverAddress, blobClientConfig, numFetchRetries)__			BlobUtils.moveTempFileToStore(_				incomingFile, jobId, blobKey, localFile, readWriteLock.writeLock(), LOG, null)___			return localFile__		} finally {_			_			if (!incomingFile.delete() && incomingFile.exists()) {_				LOG.warn("Could not delete the staging file {} for blob key {} and job {}.",_					incomingFile, blobKey, jobId)__			}_		}_	};returns,local,copy,of,the,file,for,the,blob,with,the,given,key,p,the,method,will,first,attempt,to,serve,the,blob,from,its,local,cache,if,the,blob,is,not,in,the,cache,the,method,will,try,to,download,it,from,this,cache,s,blob,server,param,job,id,id,of,the,job,this,blob,belongs,to,or,tt,null,tt,if,job,unrelated,param,blob,key,the,key,of,the,desired,blob,return,file,referring,to,the,local,storage,location,of,the,blob,throws,ioexception,thrown,if,an,i,o,error,occurs,while,downloading,the,blobs,from,the,blob,server;private,file,get,hafile,internal,nullable,job,id,job,id,blob,key,blob,key,throws,ioexception,check,argument,blob,key,null,blob,key,cannot,be,null,final,file,local,file,blob,utils,get,storage,location,storage,dir,job,id,blob,key,read,write,lock,read,lock,lock,try,if,local,file,exists,return,local,file,finally,read,write,lock,read,lock,unlock,file,incoming,file,create,temporary,filename,try,try,if,blob,view,get,job,id,blob,key,incoming,file,blob,utils,move,temp,file,to,store,incoming,file,job,id,blob,key,local,file,read,write,lock,write,lock,log,null,return,local,file,catch,exception,e,log,info,failed,to,copy,from,blob,store,downloading,from,blob,server,instead,e,blob,client,download,from,blob,server,job,id,blob,key,true,incoming,file,server,address,blob,client,config,num,fetch,retries,blob,utils,move,temp,file,to,store,incoming,file,job,id,blob,key,local,file,read,write,lock,write,lock,log,null,return,local,file,finally,if,incoming,file,delete,incoming,file,exists,log,warn,could,not,delete,the,staging,file,for,blob,key,and,job,incoming,file,blob,key,job,id
PermanentBlobCache -> @Override 	public File getFile(JobID jobId, PermanentBlobKey key) throws IOException;1505901925;Returns the path to a local copy of the file associated with the provided job ID and blob_key.__<p>We will first attempt to serve the BLOB from the local storage. If the BLOB is not in_there, we will try to download it from the HA store, or directly from the {@link BlobServer}.__@param jobId_ID of the job this blob belongs to_@param key_blob key associated with the requested file__@return The path to the file.__@throws java.io.FileNotFoundException_if the BLOB does not exist__@throws IOException_if any other error occurs when retrieving the file;@Override_	public File getFile(JobID jobId, PermanentBlobKey key) throws IOException {_		checkNotNull(jobId)__		return getFileInternal(jobId, key)__	};returns,the,path,to,a,local,copy,of,the,file,associated,with,the,provided,job,id,and,blob,key,p,we,will,first,attempt,to,serve,the,blob,from,the,local,storage,if,the,blob,is,not,in,there,we,will,try,to,download,it,from,the,ha,store,or,directly,from,the,link,blob,server,param,job,id,id,of,the,job,this,blob,belongs,to,param,key,blob,key,associated,with,the,requested,file,return,the,path,to,the,file,throws,java,io,file,not,found,exception,if,the,blob,does,not,exist,throws,ioexception,if,any,other,error,occurs,when,retrieving,the,file;override,public,file,get,file,job,id,job,id,permanent,blob,key,key,throws,ioexception,check,not,null,job,id,return,get,file,internal,job,id,key
PermanentBlobCache -> @Override 	public File getFile(JobID jobId, PermanentBlobKey key) throws IOException;1507209538;Returns the path to a local copy of the file associated with the provided job ID and blob_key.__<p>We will first attempt to serve the BLOB from the local storage. If the BLOB is not in_there, we will try to download it from the HA store, or directly from the {@link BlobServer}.__@param jobId_ID of the job this blob belongs to_@param key_blob key associated with the requested file__@return The path to the file.__@throws java.io.FileNotFoundException_if the BLOB does not exist__@throws IOException_if any other error occurs when retrieving the file;@Override_	public File getFile(JobID jobId, PermanentBlobKey key) throws IOException {_		checkNotNull(jobId)__		return getFileInternal(jobId, key)__	};returns,the,path,to,a,local,copy,of,the,file,associated,with,the,provided,job,id,and,blob,key,p,we,will,first,attempt,to,serve,the,blob,from,the,local,storage,if,the,blob,is,not,in,there,we,will,try,to,download,it,from,the,ha,store,or,directly,from,the,link,blob,server,param,job,id,id,of,the,job,this,blob,belongs,to,param,key,blob,key,associated,with,the,requested,file,return,the,path,to,the,file,throws,java,io,file,not,found,exception,if,the,blob,does,not,exist,throws,ioexception,if,any,other,error,occurs,when,retrieving,the,file;override,public,file,get,file,job,id,job,id,permanent,blob,key,key,throws,ioexception,check,not,null,job,id,return,get,file,internal,job,id,key
PermanentBlobCache -> @Override 	public File getFile(JobID jobId, PermanentBlobKey key) throws IOException;1515007198;Returns the path to a local copy of the file associated with the provided job ID and blob_key.__<p>We will first attempt to serve the BLOB from the local storage. If the BLOB is not in_there, we will try to download it from the HA store, or directly from the {@link BlobServer}.__@param jobId_ID of the job this blob belongs to_@param key_blob key associated with the requested file__@return The path to the file.__@throws java.io.FileNotFoundException_if the BLOB does not exist__@throws IOException_if any other error occurs when retrieving the file;@Override_	public File getFile(JobID jobId, PermanentBlobKey key) throws IOException {_		checkNotNull(jobId)__		return getFileInternal(jobId, key)__	};returns,the,path,to,a,local,copy,of,the,file,associated,with,the,provided,job,id,and,blob,key,p,we,will,first,attempt,to,serve,the,blob,from,the,local,storage,if,the,blob,is,not,in,there,we,will,try,to,download,it,from,the,ha,store,or,directly,from,the,link,blob,server,param,job,id,id,of,the,job,this,blob,belongs,to,param,key,blob,key,associated,with,the,requested,file,return,the,path,to,the,file,throws,java,io,file,not,found,exception,if,the,blob,does,not,exist,throws,ioexception,if,any,other,error,occurs,when,retrieving,the,file;override,public,file,get,file,job,id,job,id,permanent,blob,key,key,throws,ioexception,check,not,null,job,id,return,get,file,internal,job,id,key
PermanentBlobCache -> @Override 	public File getFile(JobID jobId, PermanentBlobKey key) throws IOException;1517911296;Returns the path to a local copy of the file associated with the provided job ID and blob_key.__<p>We will first attempt to serve the BLOB from the local storage. If the BLOB is not in_there, we will try to download it from the HA store, or directly from the {@link BlobServer}.__@param jobId_ID of the job this blob belongs to_@param key_blob key associated with the requested file__@return The path to the file.__@throws java.io.FileNotFoundException_if the BLOB does not exist__@throws IOException_if any other error occurs when retrieving the file;@Override_	public File getFile(JobID jobId, PermanentBlobKey key) throws IOException {_		checkNotNull(jobId)__		return getFileInternal(jobId, key)__	};returns,the,path,to,a,local,copy,of,the,file,associated,with,the,provided,job,id,and,blob,key,p,we,will,first,attempt,to,serve,the,blob,from,the,local,storage,if,the,blob,is,not,in,there,we,will,try,to,download,it,from,the,ha,store,or,directly,from,the,link,blob,server,param,job,id,id,of,the,job,this,blob,belongs,to,param,key,blob,key,associated,with,the,requested,file,return,the,path,to,the,file,throws,java,io,file,not,found,exception,if,the,blob,does,not,exist,throws,ioexception,if,any,other,error,occurs,when,retrieving,the,file;override,public,file,get,file,job,id,job,id,permanent,blob,key,key,throws,ioexception,check,not,null,job,id,return,get,file,internal,job,id,key
PermanentBlobCache -> @Override 	public File getFile(JobID jobId, PermanentBlobKey key) throws IOException;1522640804;Returns the path to a local copy of the file associated with the provided job ID and blob_key.__<p>We will first attempt to serve the BLOB from the local storage. If the BLOB is not in_there, we will try to download it from the HA store, or directly from the {@link BlobServer}.__@param jobId_ID of the job this blob belongs to_@param key_blob key associated with the requested file__@return The path to the file.__@throws java.io.FileNotFoundException_if the BLOB does not exist__@throws IOException_if any other error occurs when retrieving the file;@Override_	public File getFile(JobID jobId, PermanentBlobKey key) throws IOException {_		checkNotNull(jobId)__		return getFileInternal(jobId, key)__	};returns,the,path,to,a,local,copy,of,the,file,associated,with,the,provided,job,id,and,blob,key,p,we,will,first,attempt,to,serve,the,blob,from,the,local,storage,if,the,blob,is,not,in,there,we,will,try,to,download,it,from,the,ha,store,or,directly,from,the,link,blob,server,param,job,id,id,of,the,job,this,blob,belongs,to,param,key,blob,key,associated,with,the,requested,file,return,the,path,to,the,file,throws,java,io,file,not,found,exception,if,the,blob,does,not,exist,throws,ioexception,if,any,other,error,occurs,when,retrieving,the,file;override,public,file,get,file,job,id,job,id,permanent,blob,key,key,throws,ioexception,check,not,null,job,id,return,get,file,internal,job,id,key
PermanentBlobCache -> public void registerJob(JobID jobId);1499764760;Registers use of job-related BLOBs._<p>_Using any other method to access BLOBs, e.g. {@link #getHAFile}, is only valid within calls_to <tt>registerJob(JobID)</tt> and {@link #releaseJob(JobID)}.__@param jobId_ID of the job this blob belongs to__@see #releaseJob(JobID);public void registerJob(JobID jobId) {_		synchronized (jobRefCounters) {_			RefCount ref = jobRefCounters.get(jobId)__			if (ref == null) {_				ref = new RefCount()__				jobRefCounters.put(jobId, ref)__			} else {_				_				ref.keepUntil = -1__			}_			++ref.references__		}_	};registers,use,of,job,related,blobs,p,using,any,other,method,to,access,blobs,e,g,link,get,hafile,is,only,valid,within,calls,to,tt,register,job,job,id,tt,and,link,release,job,job,id,param,job,id,id,of,the,job,this,blob,belongs,to,see,release,job,job,id;public,void,register,job,job,id,job,id,synchronized,job,ref,counters,ref,count,ref,job,ref,counters,get,job,id,if,ref,null,ref,new,ref,count,job,ref,counters,put,job,id,ref,else,ref,keep,until,1,ref,references
PermanentBlobCache -> public void registerJob(JobID jobId);1500980433;Registers use of job-related BLOBs._<p>_Using any other method to access BLOBs, e.g. {@link #getHAFile}, is only valid within calls_to <tt>registerJob(JobID)</tt> and {@link #releaseJob(JobID)}.__@param jobId_ID of the job this blob belongs to__@see #releaseJob(JobID);public void registerJob(JobID jobId) {_		synchronized (jobRefCounters) {_			RefCount ref = jobRefCounters.get(jobId)__			if (ref == null) {_				ref = new RefCount()__				jobRefCounters.put(jobId, ref)__			} else {_				_				ref.keepUntil = -1__			}_			++ref.references__		}_	};registers,use,of,job,related,blobs,p,using,any,other,method,to,access,blobs,e,g,link,get,hafile,is,only,valid,within,calls,to,tt,register,job,job,id,tt,and,link,release,job,job,id,param,job,id,id,of,the,job,this,blob,belongs,to,see,release,job,job,id;public,void,register,job,job,id,job,id,synchronized,job,ref,counters,ref,count,ref,job,ref,counters,get,job,id,if,ref,null,ref,new,ref,count,job,ref,counters,put,job,id,ref,else,ref,keep,until,1,ref,references
PermanentBlobCache -> public void registerJob(JobID jobId);1505901925;Registers use of job-related BLOBs.__<p>Using any other method to access BLOBs, e.g. {@link #getFile}, is only valid within_calls to <tt>registerJob(JobID)</tt> and {@link #releaseJob(JobID)}.__@param jobId_ID of the job this blob belongs to__@see #releaseJob(JobID);public void registerJob(JobID jobId) {_		checkNotNull(jobId)___		synchronized (jobRefCounters) {_			RefCount ref = jobRefCounters.get(jobId)__			if (ref == null) {_				ref = new RefCount()__				jobRefCounters.put(jobId, ref)__			} else {_				_				ref.keepUntil = -1__			}_			++ref.references__		}_	};registers,use,of,job,related,blobs,p,using,any,other,method,to,access,blobs,e,g,link,get,file,is,only,valid,within,calls,to,tt,register,job,job,id,tt,and,link,release,job,job,id,param,job,id,id,of,the,job,this,blob,belongs,to,see,release,job,job,id;public,void,register,job,job,id,job,id,check,not,null,job,id,synchronized,job,ref,counters,ref,count,ref,job,ref,counters,get,job,id,if,ref,null,ref,new,ref,count,job,ref,counters,put,job,id,ref,else,ref,keep,until,1,ref,references
PermanentBlobCache -> public void registerJob(JobID jobId);1507209538;Registers use of job-related BLOBs.__<p>Using any other method to access BLOBs, e.g. {@link #getFile}, is only valid within_calls to <tt>registerJob(JobID)</tt> and {@link #releaseJob(JobID)}.__@param jobId_ID of the job this blob belongs to__@see #releaseJob(JobID);public void registerJob(JobID jobId) {_		checkNotNull(jobId)___		synchronized (jobRefCounters) {_			RefCount ref = jobRefCounters.get(jobId)__			if (ref == null) {_				ref = new RefCount()__				jobRefCounters.put(jobId, ref)__			} else {_				_				ref.keepUntil = -1__			}_			++ref.references__		}_	};registers,use,of,job,related,blobs,p,using,any,other,method,to,access,blobs,e,g,link,get,file,is,only,valid,within,calls,to,tt,register,job,job,id,tt,and,link,release,job,job,id,param,job,id,id,of,the,job,this,blob,belongs,to,see,release,job,job,id;public,void,register,job,job,id,job,id,check,not,null,job,id,synchronized,job,ref,counters,ref,count,ref,job,ref,counters,get,job,id,if,ref,null,ref,new,ref,count,job,ref,counters,put,job,id,ref,else,ref,keep,until,1,ref,references
PermanentBlobCache -> public void registerJob(JobID jobId);1515007198;Registers use of job-related BLOBs.__<p>Using any other method to access BLOBs, e.g. {@link #getFile}, is only valid within_calls to <tt>registerJob(JobID)</tt> and {@link #releaseJob(JobID)}.__@param jobId_ID of the job this blob belongs to__@see #releaseJob(JobID);public void registerJob(JobID jobId) {_		checkNotNull(jobId)___		synchronized (jobRefCounters) {_			RefCount ref = jobRefCounters.get(jobId)__			if (ref == null) {_				ref = new RefCount()__				jobRefCounters.put(jobId, ref)__			} else {_				_				ref.keepUntil = -1__			}_			++ref.references__		}_	};registers,use,of,job,related,blobs,p,using,any,other,method,to,access,blobs,e,g,link,get,file,is,only,valid,within,calls,to,tt,register,job,job,id,tt,and,link,release,job,job,id,param,job,id,id,of,the,job,this,blob,belongs,to,see,release,job,job,id;public,void,register,job,job,id,job,id,check,not,null,job,id,synchronized,job,ref,counters,ref,count,ref,job,ref,counters,get,job,id,if,ref,null,ref,new,ref,count,job,ref,counters,put,job,id,ref,else,ref,keep,until,1,ref,references
PermanentBlobCache -> public void registerJob(JobID jobId);1517911296;Registers use of job-related BLOBs.__<p>Using any other method to access BLOBs, e.g. {@link #getFile}, is only valid within_calls to <tt>registerJob(JobID)</tt> and {@link #releaseJob(JobID)}.__@param jobId_ID of the job this blob belongs to__@see #releaseJob(JobID);public void registerJob(JobID jobId) {_		checkNotNull(jobId)___		synchronized (jobRefCounters) {_			RefCount ref = jobRefCounters.get(jobId)__			if (ref == null) {_				ref = new RefCount()__				jobRefCounters.put(jobId, ref)__			} else {_				_				ref.keepUntil = -1__			}_			++ref.references__		}_	};registers,use,of,job,related,blobs,p,using,any,other,method,to,access,blobs,e,g,link,get,file,is,only,valid,within,calls,to,tt,register,job,job,id,tt,and,link,release,job,job,id,param,job,id,id,of,the,job,this,blob,belongs,to,see,release,job,job,id;public,void,register,job,job,id,job,id,check,not,null,job,id,synchronized,job,ref,counters,ref,count,ref,job,ref,counters,get,job,id,if,ref,null,ref,new,ref,count,job,ref,counters,put,job,id,ref,else,ref,keep,until,1,ref,references
PermanentBlobCache -> public void registerJob(JobID jobId);1522640804;Registers use of job-related BLOBs.__<p>Using any other method to access BLOBs, e.g. {@link #getFile}, is only valid within_calls to <tt>registerJob(JobID)</tt> and {@link #releaseJob(JobID)}.__@param jobId_ID of the job this blob belongs to__@see #releaseJob(JobID);public void registerJob(JobID jobId) {_		checkNotNull(jobId)___		synchronized (jobRefCounters) {_			RefCount ref = jobRefCounters.get(jobId)__			if (ref == null) {_				ref = new RefCount()__				jobRefCounters.put(jobId, ref)__			} else {_				_				ref.keepUntil = -1__			}_			++ref.references__		}_	};registers,use,of,job,related,blobs,p,using,any,other,method,to,access,blobs,e,g,link,get,file,is,only,valid,within,calls,to,tt,register,job,job,id,tt,and,link,release,job,job,id,param,job,id,id,of,the,job,this,blob,belongs,to,see,release,job,job,id;public,void,register,job,job,id,job,id,check,not,null,job,id,synchronized,job,ref,counters,ref,count,ref,job,ref,counters,get,job,id,if,ref,null,ref,new,ref,count,job,ref,counters,put,job,id,ref,else,ref,keep,until,1,ref,references
PermanentBlobCache -> @Override 	public File getHAFile(JobID jobId, BlobKey key) throws IOException;1499764760;Returns the path to a local copy of the file associated with the provided job ID and blob_key._<p>_We will first attempt to serve the BLOB from the local storage. If the BLOB is not in_there, we will try to download it from the HA store, or directly from the {@link BlobServer}.__@param jobId_ID of the job this blob belongs to_@param key_blob key associated with the requested file__@return The path to the file.__@throws java.io.FileNotFoundException_if the BLOB does not exist__@throws IOException_if any other error occurs when retrieving the file;@Override_	public File getHAFile(JobID jobId, BlobKey key) throws IOException {_		checkNotNull(jobId)__		return getHAFileInternal(jobId, key)__	};returns,the,path,to,a,local,copy,of,the,file,associated,with,the,provided,job,id,and,blob,key,p,we,will,first,attempt,to,serve,the,blob,from,the,local,storage,if,the,blob,is,not,in,there,we,will,try,to,download,it,from,the,ha,store,or,directly,from,the,link,blob,server,param,job,id,id,of,the,job,this,blob,belongs,to,param,key,blob,key,associated,with,the,requested,file,return,the,path,to,the,file,throws,java,io,file,not,found,exception,if,the,blob,does,not,exist,throws,ioexception,if,any,other,error,occurs,when,retrieving,the,file;override,public,file,get,hafile,job,id,job,id,blob,key,key,throws,ioexception,check,not,null,job,id,return,get,hafile,internal,job,id,key
PermanentBlobCache -> @Override 	public File getHAFile(JobID jobId, BlobKey key) throws IOException;1500980433;Returns the path to a local copy of the file associated with the provided job ID and blob_key._<p>_We will first attempt to serve the BLOB from the local storage. If the BLOB is not in_there, we will try to download it from the HA store, or directly from the {@link BlobServer}.__@param jobId_ID of the job this blob belongs to_@param key_blob key associated with the requested file__@return The path to the file.__@throws java.io.FileNotFoundException_if the BLOB does not exist__@throws IOException_if any other error occurs when retrieving the file;@Override_	public File getHAFile(JobID jobId, BlobKey key) throws IOException {_		checkNotNull(jobId)__		return getHAFileInternal(jobId, key)__	};returns,the,path,to,a,local,copy,of,the,file,associated,with,the,provided,job,id,and,blob,key,p,we,will,first,attempt,to,serve,the,blob,from,the,local,storage,if,the,blob,is,not,in,there,we,will,try,to,download,it,from,the,ha,store,or,directly,from,the,link,blob,server,param,job,id,id,of,the,job,this,blob,belongs,to,param,key,blob,key,associated,with,the,requested,file,return,the,path,to,the,file,throws,java,io,file,not,found,exception,if,the,blob,does,not,exist,throws,ioexception,if,any,other,error,occurs,when,retrieving,the,file;override,public,file,get,hafile,job,id,job,id,blob,key,key,throws,ioexception,check,not,null,job,id,return,get,hafile,internal,job,id,key
PermanentBlobCache -> public PermanentBlobCache( 			final InetSocketAddress serverAddress, 			final Configuration blobClientConfig, 			final BlobView blobView) throws IOException;1505901925;Instantiates a new cache for permanent BLOBs which are also available in an HA store.__@param serverAddress_address of the {@link BlobServer} to use for fetching files from_@param blobClientConfig_global configuration_@param blobView_(distributed) HA blob store file system to retrieve files from first__@throws IOException_thrown if the (local or distributed) file storage cannot be created or is not usable;public PermanentBlobCache(_			final InetSocketAddress serverAddress,_			final Configuration blobClientConfig,_			final BlobView blobView) throws IOException {__		super(serverAddress, blobClientConfig, blobView,_			LoggerFactory.getLogger(PermanentBlobCache.class))___		_		this.cleanupTimer = new Timer(true)___		this.cleanupInterval = blobClientConfig.getLong(BlobServerOptions.CLEANUP_INTERVAL) * 1000__		this.cleanupTimer.schedule(new PermanentBlobCleanupTask(), cleanupInterval, cleanupInterval)__	};instantiates,a,new,cache,for,permanent,blobs,which,are,also,available,in,an,ha,store,param,server,address,address,of,the,link,blob,server,to,use,for,fetching,files,from,param,blob,client,config,global,configuration,param,blob,view,distributed,ha,blob,store,file,system,to,retrieve,files,from,first,throws,ioexception,thrown,if,the,local,or,distributed,file,storage,cannot,be,created,or,is,not,usable;public,permanent,blob,cache,final,inet,socket,address,server,address,final,configuration,blob,client,config,final,blob,view,blob,view,throws,ioexception,super,server,address,blob,client,config,blob,view,logger,factory,get,logger,permanent,blob,cache,class,this,cleanup,timer,new,timer,true,this,cleanup,interval,blob,client,config,get,long,blob,server,options,1000,this,cleanup,timer,schedule,new,permanent,blob,cleanup,task,cleanup,interval,cleanup,interval
PermanentBlobCache -> public PermanentBlobCache( 			final InetSocketAddress serverAddress, 			final Configuration blobClientConfig, 			final BlobView blobView) throws IOException;1507209538;Instantiates a new cache for permanent BLOBs which are also available in an HA store.__@param serverAddress_address of the {@link BlobServer} to use for fetching files from_@param blobClientConfig_global configuration_@param blobView_(distributed) HA blob store file system to retrieve files from first__@throws IOException_thrown if the (local or distributed) file storage cannot be created or is not usable;public PermanentBlobCache(_			final InetSocketAddress serverAddress,_			final Configuration blobClientConfig,_			final BlobView blobView) throws IOException {__		super(serverAddress, blobClientConfig, blobView,_			LoggerFactory.getLogger(PermanentBlobCache.class))___		_		this.cleanupTimer = new Timer(true)___		this.cleanupInterval = blobClientConfig.getLong(BlobServerOptions.CLEANUP_INTERVAL) * 1000__		this.cleanupTimer.schedule(new PermanentBlobCleanupTask(), cleanupInterval, cleanupInterval)__	};instantiates,a,new,cache,for,permanent,blobs,which,are,also,available,in,an,ha,store,param,server,address,address,of,the,link,blob,server,to,use,for,fetching,files,from,param,blob,client,config,global,configuration,param,blob,view,distributed,ha,blob,store,file,system,to,retrieve,files,from,first,throws,ioexception,thrown,if,the,local,or,distributed,file,storage,cannot,be,created,or,is,not,usable;public,permanent,blob,cache,final,inet,socket,address,server,address,final,configuration,blob,client,config,final,blob,view,blob,view,throws,ioexception,super,server,address,blob,client,config,blob,view,logger,factory,get,logger,permanent,blob,cache,class,this,cleanup,timer,new,timer,true,this,cleanup,interval,blob,client,config,get,long,blob,server,options,1000,this,cleanup,timer,schedule,new,permanent,blob,cleanup,task,cleanup,interval,cleanup,interval
PermanentBlobCache -> public PermanentBlobCache( 			final InetSocketAddress serverAddress, 			final Configuration blobClientConfig, 			final BlobView blobView) throws IOException;1515007198;Instantiates a new cache for permanent BLOBs which are also available in an HA store.__@param serverAddress_address of the {@link BlobServer} to use for fetching files from_@param blobClientConfig_global configuration_@param blobView_(distributed) HA blob store file system to retrieve files from first__@throws IOException_thrown if the (local or distributed) file storage cannot be created or is not usable;public PermanentBlobCache(_			final InetSocketAddress serverAddress,_			final Configuration blobClientConfig,_			final BlobView blobView) throws IOException {__		super(serverAddress, blobClientConfig, blobView,_			LoggerFactory.getLogger(PermanentBlobCache.class))___		_		this.cleanupTimer = new Timer(true)___		this.cleanupInterval = blobClientConfig.getLong(BlobServerOptions.CLEANUP_INTERVAL) * 1000__		this.cleanupTimer.schedule(new PermanentBlobCleanupTask(), cleanupInterval, cleanupInterval)__	};instantiates,a,new,cache,for,permanent,blobs,which,are,also,available,in,an,ha,store,param,server,address,address,of,the,link,blob,server,to,use,for,fetching,files,from,param,blob,client,config,global,configuration,param,blob,view,distributed,ha,blob,store,file,system,to,retrieve,files,from,first,throws,ioexception,thrown,if,the,local,or,distributed,file,storage,cannot,be,created,or,is,not,usable;public,permanent,blob,cache,final,inet,socket,address,server,address,final,configuration,blob,client,config,final,blob,view,blob,view,throws,ioexception,super,server,address,blob,client,config,blob,view,logger,factory,get,logger,permanent,blob,cache,class,this,cleanup,timer,new,timer,true,this,cleanup,interval,blob,client,config,get,long,blob,server,options,1000,this,cleanup,timer,schedule,new,permanent,blob,cleanup,task,cleanup,interval,cleanup,interval
