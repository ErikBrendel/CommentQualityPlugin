# id;timestamp;commentText;codeText;commentWords;codeWords
IOManager -> ReaderThread -> protected void shutdown();1404155775;Shuts the thread down. This operation does not wait for all pending requests to be served, halts the thread_immediately. All buffers of pending requests are handed back to their channel readers and an exception is_reported to them, declaring their request queue as closed.;protected void shutdown()_		{_			if (this.alive) {_				_				try {_					this.alive = false__					this.requestQueue.close()__					this.interrupt()__				}_				catch (Throwable t) {}_			}_			_			_			IOException ioex = new IOException("IO-Manager has been closed.")__			_			while (!this.requestQueue.isEmpty()) {_				ReadRequest request = this.requestQueue.poll()__				request.requestDone(ioex)__			}_		};shuts,the,thread,down,this,operation,does,not,wait,for,all,pending,requests,to,be,served,halts,the,thread,immediately,all,buffers,of,pending,requests,are,handed,back,to,their,channel,readers,and,an,exception,is,reported,to,them,declaring,their,request,queue,as,closed;protected,void,shutdown,if,this,alive,try,this,alive,false,this,request,queue,close,this,interrupt,catch,throwable,t,ioexception,ioex,new,ioexception,io,manager,has,been,closed,while,this,request,queue,is,empty,read,request,request,this,request,queue,poll,request,request,done,ioex
IOManager -> ReaderThread -> protected void shutdown();1404986750;Shuts the thread down. This operation does not wait for all pending requests to be served, halts the thread_immediately. All buffers of pending requests are handed back to their channel readers and an exception is_reported to them, declaring their request queue as closed.;protected void shutdown()_		{_			if (this.alive) {_				_				try {_					this.alive = false__					this.requestQueue.close()__					this.interrupt()__				}_				catch (Throwable t) {}_			}_			_			_			IOException ioex = new IOException("IO-Manager has been closed.")__			_			while (!this.requestQueue.isEmpty()) {_				ReadRequest request = this.requestQueue.poll()__				request.requestDone(ioex)__			}_		};shuts,the,thread,down,this,operation,does,not,wait,for,all,pending,requests,to,be,served,halts,the,thread,immediately,all,buffers,of,pending,requests,are,handed,back,to,their,channel,readers,and,an,exception,is,reported,to,them,declaring,their,request,queue,as,closed;protected,void,shutdown,if,this,alive,try,this,alive,false,this,request,queue,close,this,interrupt,catch,throwable,t,ioexception,ioex,new,ioexception,io,manager,has,been,closed,while,this,request,queue,is,empty,read,request,request,this,request,queue,poll,request,request,done,ioex
IOManager -> ReaderThread -> protected void shutdown();1405088715;Shuts the thread down. This operation does not wait for all pending requests to be served, halts the thread_immediately. All buffers of pending requests are handed back to their channel readers and an exception is_reported to them, declaring their request queue as closed.;protected void shutdown()_		{_			if (this.alive) {_				_				try {_					this.alive = false__					this.requestQueue.close()__					this.interrupt()__				}_				catch (Throwable t) {}_			}_			_			_			IOException ioex = new IOException("IO-Manager has been closed.")__			_			while (!this.requestQueue.isEmpty()) {_				ReadRequest request = this.requestQueue.poll()__				request.requestDone(ioex)__			}_		};shuts,the,thread,down,this,operation,does,not,wait,for,all,pending,requests,to,be,served,halts,the,thread,immediately,all,buffers,of,pending,requests,are,handed,back,to,their,channel,readers,and,an,exception,is,reported,to,them,declaring,their,request,queue,as,closed;protected,void,shutdown,if,this,alive,try,this,alive,false,this,request,queue,close,this,interrupt,catch,throwable,t,ioexception,ioex,new,ioexception,io,manager,has,been,closed,while,this,request,queue,is,empty,read,request,request,this,request,queue,poll,request,request,done,ioex
IOManager -> ReaderThread -> protected void shutdown();1409222213;Shuts the thread down. This operation does not wait for all pending requests to be served, halts the thread_immediately. All buffers of pending requests are handed back to their channel readers and an exception is_reported to them, declaring their request queue as closed.;protected void shutdown()_		{_			if (this.alive) {_				_				try {_					this.alive = false__					this.requestQueue.close()__					this.interrupt()__				}_				catch (Throwable t) {}_			}_			_			_			IOException ioex = new IOException("IO-Manager has been closed.")__			_			while (!this.requestQueue.isEmpty()) {_				ReadRequest request = this.requestQueue.poll()__				request.requestDone(ioex)__			}_		};shuts,the,thread,down,this,operation,does,not,wait,for,all,pending,requests,to,be,served,halts,the,thread,immediately,all,buffers,of,pending,requests,are,handed,back,to,their,channel,readers,and,an,exception,is,reported,to,them,declaring,their,request,queue,as,closed;protected,void,shutdown,if,this,alive,try,this,alive,false,this,request,queue,close,this,interrupt,catch,throwable,t,ioexception,ioex,new,ioexception,io,manager,has,been,closed,while,this,request,queue,is,empty,read,request,request,this,request,queue,poll,request,request,done,ioex
IOManager -> ReaderThread -> protected void shutdown();1410211782;Shuts the thread down. This operation does not wait for all pending requests to be served, halts the thread_immediately. All buffers of pending requests are handed back to their channel readers and an exception is_reported to them, declaring their request queue as closed.;protected void shutdown()_		{_			if (this.alive) {_				_				try {_					this.alive = false__					this.requestQueue.close()__					this.interrupt()__				}_				catch (Throwable t) {}_			}_			_			_			IOException ioex = new IOException("IO-Manager has been closed.")__			_			while (!this.requestQueue.isEmpty()) {_				ReadRequest request = this.requestQueue.poll()__				request.requestDone(ioex)__			}_		};shuts,the,thread,down,this,operation,does,not,wait,for,all,pending,requests,to,be,served,halts,the,thread,immediately,all,buffers,of,pending,requests,are,handed,back,to,their,channel,readers,and,an,exception,is,reported,to,them,declaring,their,request,queue,as,closed;protected,void,shutdown,if,this,alive,try,this,alive,false,this,request,queue,close,this,interrupt,catch,throwable,t,ioexception,ioex,new,ioexception,io,manager,has,been,closed,while,this,request,queue,is,empty,read,request,request,this,request,queue,poll,request,request,done,ioex
IOManager -> ReaderThread -> protected void shutdown();1411473561;Shuts the thread down. This operation does not wait for all pending requests to be served, halts the thread_immediately. All buffers of pending requests are handed back to their channel readers and an exception is_reported to them, declaring their request queue as closed.;protected void shutdown()_		{_			if (this.alive) {_				_				try {_					this.alive = false__					this.requestQueue.close()__					this.interrupt()__				}_				catch (Throwable t) {}_			}_			_			_			IOException ioex = new IOException("IO-Manager has been closed.")__			_			while (!this.requestQueue.isEmpty()) {_				ReadRequest request = this.requestQueue.poll()__				request.requestDone(ioex)__			}_		};shuts,the,thread,down,this,operation,does,not,wait,for,all,pending,requests,to,be,served,halts,the,thread,immediately,all,buffers,of,pending,requests,are,handed,back,to,their,channel,readers,and,an,exception,is,reported,to,them,declaring,their,request,queue,as,closed;protected,void,shutdown,if,this,alive,try,this,alive,false,this,request,queue,close,this,interrupt,catch,throwable,t,ioexception,ioex,new,ioexception,io,manager,has,been,closed,while,this,request,queue,is,empty,read,request,request,this,request,queue,poll,request,request,done,ioex
IOManager -> public abstract BlockChannelWriterWithCallback createBlockChannelWriter(FileIOChannel.ID channelID, RequestDoneCallback<MemorySegment> callback) throws IOException_;1412761231;Creates a block channel writer that writes to the given channel. The writer calls the given callback_after the I/O operation has been performed (successfully or unsuccessfully), to allow_for asynchronous implementations.__@param channelID The descriptor for the channel to write to._@param callback The callback to be called for_@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public abstract BlockChannelWriterWithCallback createBlockChannelWriter(FileIOChannel.ID channelID, RequestDoneCallback<MemorySegment> callback) throws IOException_;creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,calls,the,given,callback,after,the,i,o,operation,has,been,performed,successfully,or,unsuccessfully,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,callback,the,callback,to,be,called,for,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,abstract,block,channel,writer,with,callback,create,block,channel,writer,file,iochannel,id,channel,id,request,done,callback,memory,segment,callback,throws,ioexception
IOManager -> public abstract BlockChannelWriterWithCallback createBlockChannelWriter(FileIOChannel.ID channelID, RequestDoneCallback<MemorySegment> callback) throws IOException_;1417555226;Creates a block channel writer that writes to the given channel. The writer calls the given callback_after the I/O operation has been performed (successfully or unsuccessfully), to allow_for asynchronous implementations.__@param channelID The descriptor for the channel to write to._@param callback The callback to be called for_@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public abstract BlockChannelWriterWithCallback createBlockChannelWriter(FileIOChannel.ID channelID, RequestDoneCallback<MemorySegment> callback) throws IOException_;creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,calls,the,given,callback,after,the,i,o,operation,has,been,performed,successfully,or,unsuccessfully,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,callback,the,callback,to,be,called,for,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,abstract,block,channel,writer,with,callback,create,block,channel,writer,file,iochannel,id,channel,id,request,done,callback,memory,segment,callback,throws,ioexception
IOManager -> public abstract BlockChannelWriterWithCallback createBlockChannelWriter(FileIOChannel.ID channelID, RequestDoneCallback<MemorySegment> callback) throws IOException_;1421771162;Creates a block channel writer that writes to the given channel. The writer calls the given callback_after the I/O operation has been performed (successfully or unsuccessfully), to allow_for asynchronous implementations.__@param channelID The descriptor for the channel to write to._@param callback The callback to be called for_@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public abstract BlockChannelWriterWithCallback createBlockChannelWriter(FileIOChannel.ID channelID, RequestDoneCallback<MemorySegment> callback) throws IOException_;creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,calls,the,given,callback,after,the,i,o,operation,has,been,performed,successfully,or,unsuccessfully,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,callback,the,callback,to,be,called,for,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,abstract,block,channel,writer,with,callback,create,block,channel,writer,file,iochannel,id,channel,id,request,done,callback,memory,segment,callback,throws,ioexception
IOManager -> public abstract BlockChannelWriterWithCallback createBlockChannelWriter(FileIOChannel.ID channelID, RequestDoneCallback<MemorySegment> callback) throws IOException_;1424268205;Creates a block channel writer that writes to the given channel. The writer calls the given callback_after the I/O operation has been performed (successfully or unsuccessfully), to allow_for asynchronous implementations.__@param channelID The descriptor for the channel to write to._@param callback The callback to be called for_@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public abstract BlockChannelWriterWithCallback createBlockChannelWriter(FileIOChannel.ID channelID, RequestDoneCallback<MemorySegment> callback) throws IOException_;creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,calls,the,given,callback,after,the,i,o,operation,has,been,performed,successfully,or,unsuccessfully,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,callback,the,callback,to,be,called,for,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,abstract,block,channel,writer,with,callback,create,block,channel,writer,file,iochannel,id,channel,id,request,done,callback,memory,segment,callback,throws,ioexception
IOManager -> public abstract BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID, 										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;1420560668;Creates a block channel reader that reads blocks from the given channel. The reader pushes the full segments_to the given queue, to allow for asynchronous implementations.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the full buffers into._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public abstract BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID,_										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,pushes,the,full,segments,to,the,given,queue,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,full,buffers,into,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,abstract,block,channel,reader,memory,segment,create,block,channel,reader,file,iochannel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception
IOManager -> public abstract BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID, 										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;1428680960;Creates a block channel reader that reads blocks from the given channel. The reader pushes the full segments_to the given queue, to allow for asynchronous implementations.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the full buffers into._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public abstract BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID,_										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,pushes,the,full,segments,to,the,given,queue,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,full,buffers,into,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,abstract,block,channel,reader,memory,segment,create,block,channel,reader,file,iochannel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception
IOManager -> public abstract BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID, 										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;1437929917;Creates a block channel reader that reads blocks from the given channel. The reader pushes the full segments_to the given queue, to allow for asynchronous implementations.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the full buffers into._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public abstract BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID,_										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,pushes,the,full,segments,to,the,given,queue,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,full,buffers,into,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,abstract,block,channel,reader,memory,segment,create,block,channel,reader,file,iochannel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception
IOManager -> public abstract BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID, 										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;1441102230;Creates a block channel reader that reads blocks from the given channel. The reader pushes the full segments_to the given queue, to allow for asynchronous implementations.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the full buffers into._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public abstract BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID,_										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,pushes,the,full,segments,to,the,given,queue,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,full,buffers,into,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,abstract,block,channel,reader,memory,segment,create,block,channel,reader,file,iochannel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception
IOManager -> public abstract BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID, 										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;1464188671;Creates a block channel reader that reads blocks from the given channel. The reader pushes the full segments_to the given queue, to allow for asynchronous implementations.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the full buffers into._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public abstract BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID,_										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,pushes,the,full,segments,to,the,given,queue,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,full,buffers,into,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,abstract,block,channel,reader,memory,segment,create,block,channel,reader,file,iochannel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception
IOManager -> public abstract BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID, 										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;1484214553;Creates a block channel reader that reads blocks from the given channel. The reader pushes the full segments_to the given queue, to allow for asynchronous implementations.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the full buffers into._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public abstract BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID,_										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,pushes,the,full,segments,to,the,given,queue,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,full,buffers,into,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,abstract,block,channel,reader,memory,segment,create,block,channel,reader,file,iochannel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception
IOManager -> public abstract void shutdown()_;1412761231;Close method, marks the I/O manager as closed.;public abstract void shutdown()_;close,method,marks,the,i,o,manager,as,closed;public,abstract,void,shutdown
IOManager -> public abstract void shutdown()_;1415382319;Close method, marks the I/O manager as closed.;public abstract void shutdown()_;close,method,marks,the,i,o,manager,as,closed;public,abstract,void,shutdown
IOManager -> public abstract void shutdown()_;1417555226;Close method, marks the I/O manager as closed.;public abstract void shutdown()_;close,method,marks,the,i,o,manager,as,closed;public,abstract,void,shutdown
IOManager -> public abstract void shutdown()_;1421771162;Close method, marks the I/O manager as closed.;public abstract void shutdown()_;close,method,marks,the,i,o,manager,as,closed;public,abstract,void,shutdown
IOManager -> public boolean isProperlyShutDown();1420560668;Utility method to check whether the IO manager has been properly shut down._For this base implementation, this means that all files have been removed.__@return True, if the IO manager has properly shut down, false otherwise.;public boolean isProperlyShutDown() {_		for (File path : paths) {_			if (path != null && path.exists()) {_				return false__			}_		}_		return true__	};utility,method,to,check,whether,the,io,manager,has,been,properly,shut,down,for,this,base,implementation,this,means,that,all,files,have,been,removed,return,true,if,the,io,manager,has,properly,shut,down,false,otherwise;public,boolean,is,properly,shut,down,for,file,path,paths,if,path,null,path,exists,return,false,return,true
IOManager -> public boolean isProperlyShutDown();1424268205;Utility method to check whether the IO manager has been properly shut down._For this base implementation, this means that all files have been removed.__@return True, if the IO manager has properly shut down, false otherwise.;public boolean isProperlyShutDown() {_		for (File path : paths) {_			if (path != null && path.exists()) {_				return false__			}_		}_		return true__	};utility,method,to,check,whether,the,io,manager,has,been,properly,shut,down,for,this,base,implementation,this,means,that,all,files,have,been,removed,return,true,if,the,io,manager,has,properly,shut,down,false,otherwise;public,boolean,is,properly,shut,down,for,file,path,paths,if,path,null,path,exists,return,false,return,true
IOManager -> public boolean isProperlyShutDown();1428680960;Utility method to check whether the IO manager has been properly shut down._For this base implementation, this means that all files have been removed.__@return True, if the IO manager has properly shut down, false otherwise.;public boolean isProperlyShutDown() {_		for (File path : paths) {_			if (path != null && path.exists()) {_				return false__			}_		}_		return true__	};utility,method,to,check,whether,the,io,manager,has,been,properly,shut,down,for,this,base,implementation,this,means,that,all,files,have,been,removed,return,true,if,the,io,manager,has,properly,shut,down,false,otherwise;public,boolean,is,properly,shut,down,for,file,path,paths,if,path,null,path,exists,return,false,return,true
IOManager -> public boolean isProperlyShutDown();1437929917;Utility method to check whether the IO manager has been properly shut down._For this base implementation, this means that all files have been removed.__@return True, if the IO manager has properly shut down, false otherwise.;public boolean isProperlyShutDown() {_		for (File path : paths) {_			if (path != null && path.exists()) {_				return false__			}_		}_		return true__	};utility,method,to,check,whether,the,io,manager,has,been,properly,shut,down,for,this,base,implementation,this,means,that,all,files,have,been,removed,return,true,if,the,io,manager,has,properly,shut,down,false,otherwise;public,boolean,is,properly,shut,down,for,file,path,paths,if,path,null,path,exists,return,false,return,true
IOManager -> public boolean isProperlyShutDown();1441102230;Utility method to check whether the IO manager has been properly shut down._For this base implementation, this means that all files have been removed.__@return True, if the IO manager has properly shut down, false otherwise.;public boolean isProperlyShutDown() {_		for (File path : paths) {_			if (path != null && path.exists()) {_				return false__			}_		}_		return true__	};utility,method,to,check,whether,the,io,manager,has,been,properly,shut,down,for,this,base,implementation,this,means,that,all,files,have,been,removed,return,true,if,the,io,manager,has,properly,shut,down,false,otherwise;public,boolean,is,properly,shut,down,for,file,path,paths,if,path,null,path,exists,return,false,return,true
IOManager -> public boolean isProperlyShutDown();1464188671;Utility method to check whether the IO manager has been properly shut down._For this base implementation, this means that all files have been removed.__@return True, if the IO manager has properly shut down, false otherwise.;public boolean isProperlyShutDown() {_		for (File path : paths) {_			if (path != null && path.exists()) {_				return false__			}_		}_		return true__	};utility,method,to,check,whether,the,io,manager,has,been,properly,shut,down,for,this,base,implementation,this,means,that,all,files,have,been,removed,return,true,if,the,io,manager,has,properly,shut,down,false,otherwise;public,boolean,is,properly,shut,down,for,file,path,paths,if,path,null,path,exists,return,false,return,true
IOManager -> public boolean isProperlyShutDown();1484214553;Utility method to check whether the IO manager has been properly shut down._For this base implementation, this means that all files have been removed.__@return True, if the IO manager has properly shut down, false otherwise.;public boolean isProperlyShutDown() {_		for (File path : paths) {_			if (path != null && path.exists()) {_				return false__			}_		}_		return true__	};utility,method,to,check,whether,the,io,manager,has,been,properly,shut,down,for,this,base,implementation,this,means,that,all,files,have,been,removed,return,true,if,the,io,manager,has,properly,shut,down,false,otherwise;public,boolean,is,properly,shut,down,for,file,path,paths,if,path,null,path,exists,return,false,return,true
IOManager -> public Channel.ID createChannel();1404155775;Creates a new {@link Channel.ID} in one of the temp directories. Multiple_invocations of this method spread the channels evenly across the different directories.__@return A channel to a temporary directory.;public Channel.ID createChannel()_	{_		final int num = getNextPathNum()__		return new Channel.ID(this.paths[num], num, this.random)__	};creates,a,new,link,channel,id,in,one,of,the,temp,directories,multiple,invocations,of,this,method,spread,the,channels,evenly,across,the,different,directories,return,a,channel,to,a,temporary,directory;public,channel,id,create,channel,final,int,num,get,next,path,num,return,new,channel,id,this,paths,num,num,this,random
IOManager -> public Channel.ID createChannel();1404986750;Creates a new {@link Channel.ID} in one of the temp directories. Multiple_invocations of this method spread the channels evenly across the different directories.__@return A channel to a temporary directory.;public Channel.ID createChannel()_	{_		final int num = getNextPathNum()__		return new Channel.ID(this.paths[num], num, this.random)__	};creates,a,new,link,channel,id,in,one,of,the,temp,directories,multiple,invocations,of,this,method,spread,the,channels,evenly,across,the,different,directories,return,a,channel,to,a,temporary,directory;public,channel,id,create,channel,final,int,num,get,next,path,num,return,new,channel,id,this,paths,num,num,this,random
IOManager -> public Channel.ID createChannel();1405088715;Creates a new {@link Channel.ID} in one of the temp directories. Multiple_invocations of this method spread the channels evenly across the different directories.__@return A channel to a temporary directory.;public Channel.ID createChannel()_	{_		final int num = getNextPathNum()__		return new Channel.ID(this.paths[num], num, this.random)__	};creates,a,new,link,channel,id,in,one,of,the,temp,directories,multiple,invocations,of,this,method,spread,the,channels,evenly,across,the,different,directories,return,a,channel,to,a,temporary,directory;public,channel,id,create,channel,final,int,num,get,next,path,num,return,new,channel,id,this,paths,num,num,this,random
IOManager -> public Channel.ID createChannel();1409222213;Creates a new {@link Channel.ID} in one of the temp directories. Multiple_invocations of this method spread the channels evenly across the different directories.__@return A channel to a temporary directory.;public Channel.ID createChannel()_	{_		final int num = getNextPathNum()__		return new Channel.ID(this.paths[num], num, this.random)__	};creates,a,new,link,channel,id,in,one,of,the,temp,directories,multiple,invocations,of,this,method,spread,the,channels,evenly,across,the,different,directories,return,a,channel,to,a,temporary,directory;public,channel,id,create,channel,final,int,num,get,next,path,num,return,new,channel,id,this,paths,num,num,this,random
IOManager -> public Channel.ID createChannel();1410211782;Creates a new {@link Channel.ID} in one of the temp directories. Multiple_invocations of this method spread the channels evenly across the different directories.__@return A channel to a temporary directory.;public Channel.ID createChannel()_	{_		final int num = getNextPathNum()__		return new Channel.ID(this.paths[num], num, this.random)__	};creates,a,new,link,channel,id,in,one,of,the,temp,directories,multiple,invocations,of,this,method,spread,the,channels,evenly,across,the,different,directories,return,a,channel,to,a,temporary,directory;public,channel,id,create,channel,final,int,num,get,next,path,num,return,new,channel,id,this,paths,num,num,this,random
IOManager -> public Channel.ID createChannel();1411473561;Creates a new {@link Channel.ID} in one of the temp directories. Multiple_invocations of this method spread the channels evenly across the different directories.__@return A channel to a temporary directory.;public Channel.ID createChannel()_	{_		final int num = getNextPathNum()__		return new Channel.ID(this.paths[num], num, this.random)__	};creates,a,new,link,channel,id,in,one,of,the,temp,directories,multiple,invocations,of,this,method,spread,the,channels,evenly,across,the,different,directories,return,a,channel,to,a,temporary,directory;public,channel,id,create,channel,final,int,num,get,next,path,num,return,new,channel,id,this,paths,num,num,this,random
IOManager -> public abstract BlockChannelReader createBlockChannelReader(FileIOChannel.ID channelID, 										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;1412761231;Creates a block channel reader that reads blocks from the given channel. The reader pushes the full segments_to the given queue, to allow for asynchronous implementations.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the full buffers into._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public abstract BlockChannelReader createBlockChannelReader(FileIOChannel.ID channelID,_										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,pushes,the,full,segments,to,the,given,queue,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,full,buffers,into,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,abstract,block,channel,reader,create,block,channel,reader,file,iochannel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception
IOManager -> public abstract BlockChannelReader createBlockChannelReader(FileIOChannel.ID channelID, 										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;1417555226;Creates a block channel reader that reads blocks from the given channel. The reader pushes the full segments_to the given queue, to allow for asynchronous implementations.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the full buffers into._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public abstract BlockChannelReader createBlockChannelReader(FileIOChannel.ID channelID,_										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,pushes,the,full,segments,to,the,given,queue,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,full,buffers,into,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,abstract,block,channel,reader,create,block,channel,reader,file,iochannel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception
IOManager -> public abstract BlockChannelReader createBlockChannelReader(FileIOChannel.ID channelID, 										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;1421771162;Creates a block channel reader that reads blocks from the given channel. The reader pushes the full segments_to the given queue, to allow for asynchronous implementations.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the full buffers into._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public abstract BlockChannelReader createBlockChannelReader(FileIOChannel.ID channelID,_										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,pushes,the,full,segments,to,the,given,queue,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,full,buffers,into,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,abstract,block,channel,reader,create,block,channel,reader,file,iochannel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception
IOManager -> public abstract BlockChannelReader createBlockChannelReader(FileIOChannel.ID channelID, 										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;1424268205;Creates a block channel reader that reads blocks from the given channel. The reader pushes the full segments_to the given queue, to allow for asynchronous implementations.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the full buffers into._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public abstract BlockChannelReader createBlockChannelReader(FileIOChannel.ID channelID,_										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,pushes,the,full,segments,to,the,given,queue,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,full,buffers,into,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,abstract,block,channel,reader,create,block,channel,reader,file,iochannel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception
IOManager -> public BlockChannelWriter createBlockChannelWriter(FileIOChannel.ID channelID) throws IOException;1412761231;Creates a block channel writer that writes to the given channel. The writer adds the_written segment to its return-queue afterwards (to allow for asynchronous implementations).__@param channelID The descriptor for the channel to write to._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public BlockChannelWriter createBlockChannelWriter(FileIOChannel.ID channelID) throws IOException {_		return createBlockChannelWriter(channelID, new LinkedBlockingQueue<MemorySegment>())__	};creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,adds,the,written,segment,to,its,return,queue,afterwards,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,block,channel,writer,create,block,channel,writer,file,iochannel,id,channel,id,throws,ioexception,return,create,block,channel,writer,channel,id,new,linked,blocking,queue,memory,segment
IOManager -> public BlockChannelWriter createBlockChannelWriter(FileIOChannel.ID channelID) throws IOException;1415382319;Creates a block channel writer that writes to the given channel. The writer adds the_written segment to its return-queue afterwards (to allow for asynchronous implementations).__@param channelID The descriptor for the channel to write to._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public BlockChannelWriter createBlockChannelWriter(FileIOChannel.ID channelID) throws IOException {_		return createBlockChannelWriter(channelID, new LinkedBlockingQueue<MemorySegment>())__	};creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,adds,the,written,segment,to,its,return,queue,afterwards,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,block,channel,writer,create,block,channel,writer,file,iochannel,id,channel,id,throws,ioexception,return,create,block,channel,writer,channel,id,new,linked,blocking,queue,memory,segment
IOManager -> public BlockChannelWriter createBlockChannelWriter(FileIOChannel.ID channelID) throws IOException;1417555226;Creates a block channel writer that writes to the given channel. The writer adds the_written segment to its return-queue afterwards (to allow for asynchronous implementations).__@param channelID The descriptor for the channel to write to._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public BlockChannelWriter createBlockChannelWriter(FileIOChannel.ID channelID) throws IOException {_		return createBlockChannelWriter(channelID, new LinkedBlockingQueue<MemorySegment>())__	};creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,adds,the,written,segment,to,its,return,queue,afterwards,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,block,channel,writer,create,block,channel,writer,file,iochannel,id,channel,id,throws,ioexception,return,create,block,channel,writer,channel,id,new,linked,blocking,queue,memory,segment
IOManager -> public BlockChannelWriter createBlockChannelWriter(FileIOChannel.ID channelID) throws IOException;1421771162;Creates a block channel writer that writes to the given channel. The writer adds the_written segment to its return-queue afterwards (to allow for asynchronous implementations).__@param channelID The descriptor for the channel to write to._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public BlockChannelWriter createBlockChannelWriter(FileIOChannel.ID channelID) throws IOException {_		return createBlockChannelWriter(channelID, new LinkedBlockingQueue<MemorySegment>())__	};creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,adds,the,written,segment,to,its,return,queue,afterwards,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,block,channel,writer,create,block,channel,writer,file,iochannel,id,channel,id,throws,ioexception,return,create,block,channel,writer,channel,id,new,linked,blocking,queue,memory,segment
IOManager -> public BlockChannelWriter createBlockChannelWriter(FileIOChannel.ID channelID) throws IOException;1424268205;Creates a block channel writer that writes to the given channel. The writer adds the_written segment to its return-queue afterwards (to allow for asynchronous implementations).__@param channelID The descriptor for the channel to write to._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public BlockChannelWriter createBlockChannelWriter(FileIOChannel.ID channelID) throws IOException {_		return createBlockChannelWriter(channelID, new LinkedBlockingQueue<MemorySegment>())__	};creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,adds,the,written,segment,to,its,return,queue,afterwards,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,block,channel,writer,create,block,channel,writer,file,iochannel,id,channel,id,throws,ioexception,return,create,block,channel,writer,channel,id,new,linked,blocking,queue,memory,segment
IOManager -> public void deleteChannel(FileIOChannel.ID channel) throws IOException;1417555226;Deletes the file underlying the given channel. If the channel is still open, this_call may fail.__@param channel The channel to be deleted._@throws IOException Thrown if the deletion fails.;public void deleteChannel(FileIOChannel.ID channel) throws IOException {_		if (channel != null) {_			new File(channel.getPath()).delete()__		}_	};deletes,the,file,underlying,the,given,channel,if,the,channel,is,still,open,this,call,may,fail,param,channel,the,channel,to,be,deleted,throws,ioexception,thrown,if,the,deletion,fails;public,void,delete,channel,file,iochannel,id,channel,throws,ioexception,if,channel,null,new,file,channel,get,path,delete
IOManager -> public void deleteChannel(FileIOChannel.ID channel) throws IOException;1420560668;Deletes the file underlying the given channel. If the channel is still open, this_call may fail.__@param channel The channel to be deleted._@throws IOException Thrown if the deletion fails.;public void deleteChannel(FileIOChannel.ID channel) throws IOException {_		if (channel != null) {_			if (channel.getPathFile().exists() && !channel.getPathFile().delete()) {_				LOG.warn("IOManager failed to delete temporary file {}", channel.getPath())__			}_		}_	};deletes,the,file,underlying,the,given,channel,if,the,channel,is,still,open,this,call,may,fail,param,channel,the,channel,to,be,deleted,throws,ioexception,thrown,if,the,deletion,fails;public,void,delete,channel,file,iochannel,id,channel,throws,ioexception,if,channel,null,if,channel,get,path,file,exists,channel,get,path,file,delete,log,warn,iomanager,failed,to,delete,temporary,file,channel,get,path
IOManager -> public void deleteChannel(FileIOChannel.ID channel) throws IOException;1421771162;Deletes the file underlying the given channel. If the channel is still open, this_call may fail.__@param channel The channel to be deleted._@throws IOException Thrown if the deletion fails.;public void deleteChannel(FileIOChannel.ID channel) throws IOException {_		if (channel != null) {_			new File(channel.getPath()).delete()__		}_	};deletes,the,file,underlying,the,given,channel,if,the,channel,is,still,open,this,call,may,fail,param,channel,the,channel,to,be,deleted,throws,ioexception,thrown,if,the,deletion,fails;public,void,delete,channel,file,iochannel,id,channel,throws,ioexception,if,channel,null,new,file,channel,get,path,delete
IOManager -> public void deleteChannel(FileIOChannel.ID channel) throws IOException;1424268205;Deletes the file underlying the given channel. If the channel is still open, this_call may fail.__@param channel The channel to be deleted._@throws IOException Thrown if the deletion fails.;public void deleteChannel(FileIOChannel.ID channel) throws IOException {_		if (channel != null) {_			if (channel.getPathFile().exists() && !channel.getPathFile().delete()) {_				LOG.warn("IOManager failed to delete temporary file {}", channel.getPath())__			}_		}_	};deletes,the,file,underlying,the,given,channel,if,the,channel,is,still,open,this,call,may,fail,param,channel,the,channel,to,be,deleted,throws,ioexception,thrown,if,the,deletion,fails;public,void,delete,channel,file,iochannel,id,channel,throws,ioexception,if,channel,null,if,channel,get,path,file,exists,channel,get,path,file,delete,log,warn,iomanager,failed,to,delete,temporary,file,channel,get,path
IOManager -> public void deleteChannel(FileIOChannel.ID channel) throws IOException;1428680960;Deletes the file underlying the given channel. If the channel is still open, this_call may fail.__@param channel The channel to be deleted._@throws IOException Thrown if the deletion fails.;public void deleteChannel(FileIOChannel.ID channel) throws IOException {_		if (channel != null) {_			if (channel.getPathFile().exists() && !channel.getPathFile().delete()) {_				LOG.warn("IOManager failed to delete temporary file {}", channel.getPath())__			}_		}_	};deletes,the,file,underlying,the,given,channel,if,the,channel,is,still,open,this,call,may,fail,param,channel,the,channel,to,be,deleted,throws,ioexception,thrown,if,the,deletion,fails;public,void,delete,channel,file,iochannel,id,channel,throws,ioexception,if,channel,null,if,channel,get,path,file,exists,channel,get,path,file,delete,log,warn,iomanager,failed,to,delete,temporary,file,channel,get,path
IOManager -> public void deleteChannel(FileIOChannel.ID channel) throws IOException;1437929917;Deletes the file underlying the given channel. If the channel is still open, this_call may fail.__@param channel The channel to be deleted._@throws IOException Thrown if the deletion fails.;public void deleteChannel(FileIOChannel.ID channel) throws IOException {_		if (channel != null) {_			if (channel.getPathFile().exists() && !channel.getPathFile().delete()) {_				LOG.warn("IOManager failed to delete temporary file {}", channel.getPath())__			}_		}_	};deletes,the,file,underlying,the,given,channel,if,the,channel,is,still,open,this,call,may,fail,param,channel,the,channel,to,be,deleted,throws,ioexception,thrown,if,the,deletion,fails;public,void,delete,channel,file,iochannel,id,channel,throws,ioexception,if,channel,null,if,channel,get,path,file,exists,channel,get,path,file,delete,log,warn,iomanager,failed,to,delete,temporary,file,channel,get,path
IOManager -> public void deleteChannel(FileIOChannel.ID channel) throws IOException;1441102230;Deletes the file underlying the given channel. If the channel is still open, this_call may fail.__@param channel The channel to be deleted._@throws IOException Thrown if the deletion fails.;public void deleteChannel(FileIOChannel.ID channel) throws IOException {_		if (channel != null) {_			if (channel.getPathFile().exists() && !channel.getPathFile().delete()) {_				LOG.warn("IOManager failed to delete temporary file {}", channel.getPath())__			}_		}_	};deletes,the,file,underlying,the,given,channel,if,the,channel,is,still,open,this,call,may,fail,param,channel,the,channel,to,be,deleted,throws,ioexception,thrown,if,the,deletion,fails;public,void,delete,channel,file,iochannel,id,channel,throws,ioexception,if,channel,null,if,channel,get,path,file,exists,channel,get,path,file,delete,log,warn,iomanager,failed,to,delete,temporary,file,channel,get,path
IOManager -> public void deleteChannel(FileIOChannel.ID channel) throws IOException;1464188671;Deletes the file underlying the given channel. If the channel is still open, this_call may fail.__@param channel The channel to be deleted._@throws IOException Thrown if the deletion fails.;public void deleteChannel(FileIOChannel.ID channel) throws IOException {_		if (channel != null) {_			if (channel.getPathFile().exists() && !channel.getPathFile().delete()) {_				LOG.warn("IOManager failed to delete temporary file {}", channel.getPath())__			}_		}_	};deletes,the,file,underlying,the,given,channel,if,the,channel,is,still,open,this,call,may,fail,param,channel,the,channel,to,be,deleted,throws,ioexception,thrown,if,the,deletion,fails;public,void,delete,channel,file,iochannel,id,channel,throws,ioexception,if,channel,null,if,channel,get,path,file,exists,channel,get,path,file,delete,log,warn,iomanager,failed,to,delete,temporary,file,channel,get,path
IOManager -> public void deleteChannel(FileIOChannel.ID channel) throws IOException;1484214553;Deletes the file underlying the given channel. If the channel is still open, this_call may fail.__@param channel The channel to be deleted._@throws IOException Thrown if the deletion fails.;public void deleteChannel(FileIOChannel.ID channel) throws IOException {_		if (channel != null) {_			if (channel.getPathFile().exists() && !channel.getPathFile().delete()) {_				LOG.warn("IOManager failed to delete temporary file {}", channel.getPath())__			}_		}_	};deletes,the,file,underlying,the,given,channel,if,the,channel,is,still,open,this,call,may,fail,param,channel,the,channel,to,be,deleted,throws,ioexception,thrown,if,the,deletion,fails;public,void,delete,channel,file,iochannel,id,channel,throws,ioexception,if,channel,null,if,channel,get,path,file,exists,channel,get,path,file,delete,log,warn,iomanager,failed,to,delete,temporary,file,channel,get,path
IOManager -> public abstract BlockChannelWriter createBlockChannelWriter(FileIOChannel.ID channelID, 				LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;1412761231;Creates a block channel writer that writes to the given channel. The writer adds the_written segment to the given queue (to allow for asynchronous implementations).__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the written buffers into._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public abstract BlockChannelWriter createBlockChannelWriter(FileIOChannel.ID channelID,_				LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,adds,the,written,segment,to,the,given,queue,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,written,buffers,into,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,abstract,block,channel,writer,create,block,channel,writer,file,iochannel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception
IOManager -> public abstract BlockChannelWriter createBlockChannelWriter(FileIOChannel.ID channelID, 				LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;1415382319;Creates a block channel writer that writes to the given channel. The writer adds the_written segment to the given queue (to allow for asynchronous implementations).__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the written buffers into._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public abstract BlockChannelWriter createBlockChannelWriter(FileIOChannel.ID channelID,_				LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,adds,the,written,segment,to,the,given,queue,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,written,buffers,into,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,abstract,block,channel,writer,create,block,channel,writer,file,iochannel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception
IOManager -> public abstract BlockChannelWriter createBlockChannelWriter(FileIOChannel.ID channelID, 				LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;1417555226;Creates a block channel writer that writes to the given channel. The writer adds the_written segment to the given queue (to allow for asynchronous implementations).__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the written buffers into._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public abstract BlockChannelWriter createBlockChannelWriter(FileIOChannel.ID channelID,_				LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,adds,the,written,segment,to,the,given,queue,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,written,buffers,into,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,abstract,block,channel,writer,create,block,channel,writer,file,iochannel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception
IOManager -> public abstract BlockChannelWriter createBlockChannelWriter(FileIOChannel.ID channelID, 				LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;1421771162;Creates a block channel writer that writes to the given channel. The writer adds the_written segment to the given queue (to allow for asynchronous implementations).__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the written buffers into._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public abstract BlockChannelWriter createBlockChannelWriter(FileIOChannel.ID channelID,_				LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,adds,the,written,segment,to,the,given,queue,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,written,buffers,into,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,abstract,block,channel,writer,create,block,channel,writer,file,iochannel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception
IOManager -> public abstract BlockChannelWriter createBlockChannelWriter(FileIOChannel.ID channelID, 				LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;1424268205;Creates a block channel writer that writes to the given channel. The writer adds the_written segment to the given queue (to allow for asynchronous implementations).__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the written buffers into._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public abstract BlockChannelWriter createBlockChannelWriter(FileIOChannel.ID channelID,_				LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,adds,the,written,segment,to,the,given,queue,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,written,buffers,into,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,abstract,block,channel,writer,create,block,channel,writer,file,iochannel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception
IOManager -> public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID, 								LinkedBlockingQueue<MemorySegment> returnQueue, int numRequestsToCombine) 	throws IOException;1404155775;Creates a block channel writer that writes to the given channel. The writer writes asynchronously (write-behind),_accepting write request, carrying them out at some time and returning the written segment to the given queue_afterwards._<p>_The writer will collect a specified number of write requests and carry them out_in one, effectively writing one block in the size of multiple memory pages._Note that this means that no memory segment will reach the return queue before_the given number of requests are collected, so the number of buffers used with_the writer should be greater than the number of requests to combine. Ideally,_the number of memory segments used is a multiple of the number of requests to_combine.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the written buffers into._@param numRequestsToCombine The number of write requests to combine to one I/O request._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID,_								LinkedBlockingQueue<MemorySegment> returnQueue, int numRequestsToCombine)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelWriter(channelID, this.writers[channelID.getThreadNum()].requestQueue, returnQueue, numRequestsToCombine)__	};creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,writes,asynchronously,write,behind,accepting,write,request,carrying,them,out,at,some,time,and,returning,the,written,segment,to,the,given,queue,afterwards,p,the,writer,will,collect,a,specified,number,of,write,requests,and,carry,them,out,in,one,effectively,writing,one,block,in,the,size,of,multiple,memory,pages,note,that,this,means,that,no,memory,segment,will,reach,the,return,queue,before,the,given,number,of,requests,are,collected,so,the,number,of,buffers,used,with,the,writer,should,be,greater,than,the,number,of,requests,to,combine,ideally,the,number,of,memory,segments,used,is,a,multiple,of,the,number,of,requests,to,combine,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,written,buffers,into,param,num,requests,to,combine,the,number,of,write,requests,to,combine,to,one,i,o,request,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,block,channel,writer,create,block,channel,writer,channel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,int,num,requests,to,combine,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,writer,channel,id,this,writers,channel,id,get,thread,num,request,queue,return,queue,num,requests,to,combine
IOManager -> public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID, 								LinkedBlockingQueue<MemorySegment> returnQueue, int numRequestsToCombine) 	throws IOException;1404986750;Creates a block channel writer that writes to the given channel. The writer writes asynchronously (write-behind),_accepting write request, carrying them out at some time and returning the written segment to the given queue_afterwards._<p>_The writer will collect a specified number of write requests and carry them out_in one, effectively writing one block in the size of multiple memory pages._Note that this means that no memory segment will reach the return queue before_the given number of requests are collected, so the number of buffers used with_the writer should be greater than the number of requests to combine. Ideally,_the number of memory segments used is a multiple of the number of requests to_combine.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the written buffers into._@param numRequestsToCombine The number of write requests to combine to one I/O request._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID,_								LinkedBlockingQueue<MemorySegment> returnQueue, int numRequestsToCombine)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelWriter(channelID, this.writers[channelID.getThreadNum()].requestQueue, returnQueue, numRequestsToCombine)__	};creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,writes,asynchronously,write,behind,accepting,write,request,carrying,them,out,at,some,time,and,returning,the,written,segment,to,the,given,queue,afterwards,p,the,writer,will,collect,a,specified,number,of,write,requests,and,carry,them,out,in,one,effectively,writing,one,block,in,the,size,of,multiple,memory,pages,note,that,this,means,that,no,memory,segment,will,reach,the,return,queue,before,the,given,number,of,requests,are,collected,so,the,number,of,buffers,used,with,the,writer,should,be,greater,than,the,number,of,requests,to,combine,ideally,the,number,of,memory,segments,used,is,a,multiple,of,the,number,of,requests,to,combine,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,written,buffers,into,param,num,requests,to,combine,the,number,of,write,requests,to,combine,to,one,i,o,request,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,block,channel,writer,create,block,channel,writer,channel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,int,num,requests,to,combine,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,writer,channel,id,this,writers,channel,id,get,thread,num,request,queue,return,queue,num,requests,to,combine
IOManager -> public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID, 								LinkedBlockingQueue<MemorySegment> returnQueue, int numRequestsToCombine) 	throws IOException;1405088715;Creates a block channel writer that writes to the given channel. The writer writes asynchronously (write-behind),_accepting write request, carrying them out at some time and returning the written segment to the given queue_afterwards._<p>_The writer will collect a specified number of write requests and carry them out_in one, effectively writing one block in the size of multiple memory pages._Note that this means that no memory segment will reach the return queue before_the given number of requests are collected, so the number of buffers used with_the writer should be greater than the number of requests to combine. Ideally,_the number of memory segments used is a multiple of the number of requests to_combine.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the written buffers into._@param numRequestsToCombine The number of write requests to combine to one I/O request._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID,_								LinkedBlockingQueue<MemorySegment> returnQueue, int numRequestsToCombine)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelWriter(channelID, this.writers[channelID.getThreadNum()].requestQueue, returnQueue, numRequestsToCombine)__	};creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,writes,asynchronously,write,behind,accepting,write,request,carrying,them,out,at,some,time,and,returning,the,written,segment,to,the,given,queue,afterwards,p,the,writer,will,collect,a,specified,number,of,write,requests,and,carry,them,out,in,one,effectively,writing,one,block,in,the,size,of,multiple,memory,pages,note,that,this,means,that,no,memory,segment,will,reach,the,return,queue,before,the,given,number,of,requests,are,collected,so,the,number,of,buffers,used,with,the,writer,should,be,greater,than,the,number,of,requests,to,combine,ideally,the,number,of,memory,segments,used,is,a,multiple,of,the,number,of,requests,to,combine,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,written,buffers,into,param,num,requests,to,combine,the,number,of,write,requests,to,combine,to,one,i,o,request,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,block,channel,writer,create,block,channel,writer,channel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,int,num,requests,to,combine,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,writer,channel,id,this,writers,channel,id,get,thread,num,request,queue,return,queue,num,requests,to,combine
IOManager -> public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID, 								LinkedBlockingQueue<MemorySegment> returnQueue, int numRequestsToCombine) 	throws IOException;1409222213;Creates a block channel writer that writes to the given channel. The writer writes asynchronously (write-behind),_accepting write request, carrying them out at some time and returning the written segment to the given queue_afterwards._<p>_The writer will collect a specified number of write requests and carry them out_in one, effectively writing one block in the size of multiple memory pages._Note that this means that no memory segment will reach the return queue before_the given number of requests are collected, so the number of buffers used with_the writer should be greater than the number of requests to combine. Ideally,_the number of memory segments used is a multiple of the number of requests to_combine.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the written buffers into._@param numRequestsToCombine The number of write requests to combine to one I/O request._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID,_								LinkedBlockingQueue<MemorySegment> returnQueue, int numRequestsToCombine)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelWriter(channelID, this.writers[channelID.getThreadNum()].requestQueue, returnQueue, numRequestsToCombine)__	};creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,writes,asynchronously,write,behind,accepting,write,request,carrying,them,out,at,some,time,and,returning,the,written,segment,to,the,given,queue,afterwards,p,the,writer,will,collect,a,specified,number,of,write,requests,and,carry,them,out,in,one,effectively,writing,one,block,in,the,size,of,multiple,memory,pages,note,that,this,means,that,no,memory,segment,will,reach,the,return,queue,before,the,given,number,of,requests,are,collected,so,the,number,of,buffers,used,with,the,writer,should,be,greater,than,the,number,of,requests,to,combine,ideally,the,number,of,memory,segments,used,is,a,multiple,of,the,number,of,requests,to,combine,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,written,buffers,into,param,num,requests,to,combine,the,number,of,write,requests,to,combine,to,one,i,o,request,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,block,channel,writer,create,block,channel,writer,channel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,int,num,requests,to,combine,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,writer,channel,id,this,writers,channel,id,get,thread,num,request,queue,return,queue,num,requests,to,combine
IOManager -> public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID, 								LinkedBlockingQueue<MemorySegment> returnQueue, int numRequestsToCombine) 	throws IOException;1410211782;Creates a block channel writer that writes to the given channel. The writer writes asynchronously (write-behind),_accepting write request, carrying them out at some time and returning the written segment to the given queue_afterwards._<p>_The writer will collect a specified number of write requests and carry them out_in one, effectively writing one block in the size of multiple memory pages._Note that this means that no memory segment will reach the return queue before_the given number of requests are collected, so the number of buffers used with_the writer should be greater than the number of requests to combine. Ideally,_the number of memory segments used is a multiple of the number of requests to_combine.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the written buffers into._@param numRequestsToCombine The number of write requests to combine to one I/O request._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID,_								LinkedBlockingQueue<MemorySegment> returnQueue, int numRequestsToCombine)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelWriter(channelID, this.writers[channelID.getThreadNum()].requestQueue, returnQueue, numRequestsToCombine)__	};creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,writes,asynchronously,write,behind,accepting,write,request,carrying,them,out,at,some,time,and,returning,the,written,segment,to,the,given,queue,afterwards,p,the,writer,will,collect,a,specified,number,of,write,requests,and,carry,them,out,in,one,effectively,writing,one,block,in,the,size,of,multiple,memory,pages,note,that,this,means,that,no,memory,segment,will,reach,the,return,queue,before,the,given,number,of,requests,are,collected,so,the,number,of,buffers,used,with,the,writer,should,be,greater,than,the,number,of,requests,to,combine,ideally,the,number,of,memory,segments,used,is,a,multiple,of,the,number,of,requests,to,combine,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,written,buffers,into,param,num,requests,to,combine,the,number,of,write,requests,to,combine,to,one,i,o,request,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,block,channel,writer,create,block,channel,writer,channel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,int,num,requests,to,combine,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,writer,channel,id,this,writers,channel,id,get,thread,num,request,queue,return,queue,num,requests,to,combine
IOManager -> public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID, 								LinkedBlockingQueue<MemorySegment> returnQueue, int numRequestsToCombine) 	throws IOException;1411473561;Creates a block channel writer that writes to the given channel. The writer writes asynchronously (write-behind),_accepting write request, carrying them out at some time and returning the written segment to the given queue_afterwards._<p>_The writer will collect a specified number of write requests and carry them out_in one, effectively writing one block in the size of multiple memory pages._Note that this means that no memory segment will reach the return queue before_the given number of requests are collected, so the number of buffers used with_the writer should be greater than the number of requests to combine. Ideally,_the number of memory segments used is a multiple of the number of requests to_combine.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the written buffers into._@param numRequestsToCombine The number of write requests to combine to one I/O request._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID,_								LinkedBlockingQueue<MemorySegment> returnQueue, int numRequestsToCombine)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelWriter(channelID, this.writers[channelID.getThreadNum()].requestQueue, returnQueue, numRequestsToCombine)__	};creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,writes,asynchronously,write,behind,accepting,write,request,carrying,them,out,at,some,time,and,returning,the,written,segment,to,the,given,queue,afterwards,p,the,writer,will,collect,a,specified,number,of,write,requests,and,carry,them,out,in,one,effectively,writing,one,block,in,the,size,of,multiple,memory,pages,note,that,this,means,that,no,memory,segment,will,reach,the,return,queue,before,the,given,number,of,requests,are,collected,so,the,number,of,buffers,used,with,the,writer,should,be,greater,than,the,number,of,requests,to,combine,ideally,the,number,of,memory,segments,used,is,a,multiple,of,the,number,of,requests,to,combine,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,written,buffers,into,param,num,requests,to,combine,the,number,of,write,requests,to,combine,to,one,i,o,request,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,block,channel,writer,create,block,channel,writer,channel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,int,num,requests,to,combine,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,writer,channel,id,this,writers,channel,id,get,thread,num,request,queue,return,queue,num,requests,to,combine
IOManager -> public BlockChannelReader createBlockChannelReader(Channel.ID channelID, 										LinkedBlockingQueue<MemorySegment> returnQueue) 	throws IOException;1404155775;Creates a block channel reader that reads blocks from the given channel. The reader reads asynchronously,_such that a read request is accepted, carried out at some (close) point in time, and the full segment_is pushed to the given queue.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the full buffers into._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BlockChannelReader createBlockChannelReader(Channel.ID channelID,_										LinkedBlockingQueue<MemorySegment> returnQueue)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, returnQueue, 1)__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,reads,asynchronously,such,that,a,read,request,is,accepted,carried,out,at,some,close,point,in,time,and,the,full,segment,is,pushed,to,the,given,queue,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,full,buffers,into,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,block,channel,reader,create,block,channel,reader,channel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,return,queue,1
IOManager -> public BlockChannelReader createBlockChannelReader(Channel.ID channelID, 										LinkedBlockingQueue<MemorySegment> returnQueue) 	throws IOException;1404986750;Creates a block channel reader that reads blocks from the given channel. The reader reads asynchronously,_such that a read request is accepted, carried out at some (close) point in time, and the full segment_is pushed to the given queue.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the full buffers into._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BlockChannelReader createBlockChannelReader(Channel.ID channelID,_										LinkedBlockingQueue<MemorySegment> returnQueue)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, returnQueue, 1)__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,reads,asynchronously,such,that,a,read,request,is,accepted,carried,out,at,some,close,point,in,time,and,the,full,segment,is,pushed,to,the,given,queue,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,full,buffers,into,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,block,channel,reader,create,block,channel,reader,channel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,return,queue,1
IOManager -> public BlockChannelReader createBlockChannelReader(Channel.ID channelID, 										LinkedBlockingQueue<MemorySegment> returnQueue) 	throws IOException;1405088715;Creates a block channel reader that reads blocks from the given channel. The reader reads asynchronously,_such that a read request is accepted, carried out at some (close) point in time, and the full segment_is pushed to the given queue.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the full buffers into._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BlockChannelReader createBlockChannelReader(Channel.ID channelID,_										LinkedBlockingQueue<MemorySegment> returnQueue)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, returnQueue, 1)__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,reads,asynchronously,such,that,a,read,request,is,accepted,carried,out,at,some,close,point,in,time,and,the,full,segment,is,pushed,to,the,given,queue,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,full,buffers,into,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,block,channel,reader,create,block,channel,reader,channel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,return,queue,1
IOManager -> public BlockChannelReader createBlockChannelReader(Channel.ID channelID, 										LinkedBlockingQueue<MemorySegment> returnQueue) 	throws IOException;1409222213;Creates a block channel reader that reads blocks from the given channel. The reader reads asynchronously,_such that a read request is accepted, carried out at some (close) point in time, and the full segment_is pushed to the given queue.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the full buffers into._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BlockChannelReader createBlockChannelReader(Channel.ID channelID,_										LinkedBlockingQueue<MemorySegment> returnQueue)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, returnQueue, 1)__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,reads,asynchronously,such,that,a,read,request,is,accepted,carried,out,at,some,close,point,in,time,and,the,full,segment,is,pushed,to,the,given,queue,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,full,buffers,into,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,block,channel,reader,create,block,channel,reader,channel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,return,queue,1
IOManager -> public BlockChannelReader createBlockChannelReader(Channel.ID channelID, 										LinkedBlockingQueue<MemorySegment> returnQueue) 	throws IOException;1410211782;Creates a block channel reader that reads blocks from the given channel. The reader reads asynchronously,_such that a read request is accepted, carried out at some (close) point in time, and the full segment_is pushed to the given queue.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the full buffers into._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BlockChannelReader createBlockChannelReader(Channel.ID channelID,_										LinkedBlockingQueue<MemorySegment> returnQueue)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, returnQueue, 1)__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,reads,asynchronously,such,that,a,read,request,is,accepted,carried,out,at,some,close,point,in,time,and,the,full,segment,is,pushed,to,the,given,queue,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,full,buffers,into,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,block,channel,reader,create,block,channel,reader,channel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,return,queue,1
IOManager -> public BlockChannelReader createBlockChannelReader(Channel.ID channelID, 										LinkedBlockingQueue<MemorySegment> returnQueue) 	throws IOException;1411473561;Creates a block channel reader that reads blocks from the given channel. The reader reads asynchronously,_such that a read request is accepted, carried out at some (close) point in time, and the full segment_is pushed to the given queue.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the full buffers into._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BlockChannelReader createBlockChannelReader(Channel.ID channelID,_										LinkedBlockingQueue<MemorySegment> returnQueue)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, returnQueue, 1)__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,reads,asynchronously,such,that,a,read,request,is,accepted,carried,out,at,some,close,point,in,time,and,the,full,segment,is,pushed,to,the,given,queue,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,full,buffers,into,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,block,channel,reader,create,block,channel,reader,channel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,return,queue,1
IOManager -> public BulkBlockChannelReader createBulkBlockChannelReader(Channel.ID channelID, 			List<MemorySegment> targetSegments,	int numBlocks) 	throws IOException;1404155775;Creates a block channel reader that reads all blocks from the given channel directly in one bulk._The reader draws segments to read the blocks into from a supplied list, which must contain as many_segments as the channel has blocks. After the reader is done, the list with the full segments can be_obtained from the reader._<p>_If a channel is not to be read in one bulk, but in multiple smaller batches, a_{@link BlockChannelReader} should be used.__@param channelID The descriptor for the channel to write to._@param targetSegments The list to take the segments from into which to read the data._@param numBlocks The number of blocks in the channel to read._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BulkBlockChannelReader createBulkBlockChannelReader(Channel.ID channelID,_			List<MemorySegment> targetSegments,	int numBlocks)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BulkBlockChannelReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, targetSegments, numBlocks)__	};creates,a,block,channel,reader,that,reads,all,blocks,from,the,given,channel,directly,in,one,bulk,the,reader,draws,segments,to,read,the,blocks,into,from,a,supplied,list,which,must,contain,as,many,segments,as,the,channel,has,blocks,after,the,reader,is,done,the,list,with,the,full,segments,can,be,obtained,from,the,reader,p,if,a,channel,is,not,to,be,read,in,one,bulk,but,in,multiple,smaller,batches,a,link,block,channel,reader,should,be,used,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,target,segments,the,list,to,take,the,segments,from,into,which,to,read,the,data,param,num,blocks,the,number,of,blocks,in,the,channel,to,read,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,bulk,block,channel,reader,create,bulk,block,channel,reader,channel,id,channel,id,list,memory,segment,target,segments,int,num,blocks,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,bulk,block,channel,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,target,segments,num,blocks
IOManager -> public BulkBlockChannelReader createBulkBlockChannelReader(Channel.ID channelID, 			List<MemorySegment> targetSegments,	int numBlocks) 	throws IOException;1404986750;Creates a block channel reader that reads all blocks from the given channel directly in one bulk._The reader draws segments to read the blocks into from a supplied list, which must contain as many_segments as the channel has blocks. After the reader is done, the list with the full segments can be_obtained from the reader._<p>_If a channel is not to be read in one bulk, but in multiple smaller batches, a_{@link BlockChannelReader} should be used.__@param channelID The descriptor for the channel to write to._@param targetSegments The list to take the segments from into which to read the data._@param numBlocks The number of blocks in the channel to read._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BulkBlockChannelReader createBulkBlockChannelReader(Channel.ID channelID,_			List<MemorySegment> targetSegments,	int numBlocks)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BulkBlockChannelReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, targetSegments, numBlocks)__	};creates,a,block,channel,reader,that,reads,all,blocks,from,the,given,channel,directly,in,one,bulk,the,reader,draws,segments,to,read,the,blocks,into,from,a,supplied,list,which,must,contain,as,many,segments,as,the,channel,has,blocks,after,the,reader,is,done,the,list,with,the,full,segments,can,be,obtained,from,the,reader,p,if,a,channel,is,not,to,be,read,in,one,bulk,but,in,multiple,smaller,batches,a,link,block,channel,reader,should,be,used,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,target,segments,the,list,to,take,the,segments,from,into,which,to,read,the,data,param,num,blocks,the,number,of,blocks,in,the,channel,to,read,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,bulk,block,channel,reader,create,bulk,block,channel,reader,channel,id,channel,id,list,memory,segment,target,segments,int,num,blocks,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,bulk,block,channel,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,target,segments,num,blocks
IOManager -> public BulkBlockChannelReader createBulkBlockChannelReader(Channel.ID channelID, 			List<MemorySegment> targetSegments,	int numBlocks) 	throws IOException;1405088715;Creates a block channel reader that reads all blocks from the given channel directly in one bulk._The reader draws segments to read the blocks into from a supplied list, which must contain as many_segments as the channel has blocks. After the reader is done, the list with the full segments can be_obtained from the reader._<p>_If a channel is not to be read in one bulk, but in multiple smaller batches, a_{@link BlockChannelReader} should be used.__@param channelID The descriptor for the channel to write to._@param targetSegments The list to take the segments from into which to read the data._@param numBlocks The number of blocks in the channel to read._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BulkBlockChannelReader createBulkBlockChannelReader(Channel.ID channelID,_			List<MemorySegment> targetSegments,	int numBlocks)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BulkBlockChannelReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, targetSegments, numBlocks)__	};creates,a,block,channel,reader,that,reads,all,blocks,from,the,given,channel,directly,in,one,bulk,the,reader,draws,segments,to,read,the,blocks,into,from,a,supplied,list,which,must,contain,as,many,segments,as,the,channel,has,blocks,after,the,reader,is,done,the,list,with,the,full,segments,can,be,obtained,from,the,reader,p,if,a,channel,is,not,to,be,read,in,one,bulk,but,in,multiple,smaller,batches,a,link,block,channel,reader,should,be,used,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,target,segments,the,list,to,take,the,segments,from,into,which,to,read,the,data,param,num,blocks,the,number,of,blocks,in,the,channel,to,read,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,bulk,block,channel,reader,create,bulk,block,channel,reader,channel,id,channel,id,list,memory,segment,target,segments,int,num,blocks,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,bulk,block,channel,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,target,segments,num,blocks
IOManager -> public BulkBlockChannelReader createBulkBlockChannelReader(Channel.ID channelID, 			List<MemorySegment> targetSegments,	int numBlocks) 	throws IOException;1409222213;Creates a block channel reader that reads all blocks from the given channel directly in one bulk._The reader draws segments to read the blocks into from a supplied list, which must contain as many_segments as the channel has blocks. After the reader is done, the list with the full segments can be_obtained from the reader._<p>_If a channel is not to be read in one bulk, but in multiple smaller batches, a_{@link BlockChannelReader} should be used.__@param channelID The descriptor for the channel to write to._@param targetSegments The list to take the segments from into which to read the data._@param numBlocks The number of blocks in the channel to read._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BulkBlockChannelReader createBulkBlockChannelReader(Channel.ID channelID,_			List<MemorySegment> targetSegments,	int numBlocks)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BulkBlockChannelReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, targetSegments, numBlocks)__	};creates,a,block,channel,reader,that,reads,all,blocks,from,the,given,channel,directly,in,one,bulk,the,reader,draws,segments,to,read,the,blocks,into,from,a,supplied,list,which,must,contain,as,many,segments,as,the,channel,has,blocks,after,the,reader,is,done,the,list,with,the,full,segments,can,be,obtained,from,the,reader,p,if,a,channel,is,not,to,be,read,in,one,bulk,but,in,multiple,smaller,batches,a,link,block,channel,reader,should,be,used,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,target,segments,the,list,to,take,the,segments,from,into,which,to,read,the,data,param,num,blocks,the,number,of,blocks,in,the,channel,to,read,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,bulk,block,channel,reader,create,bulk,block,channel,reader,channel,id,channel,id,list,memory,segment,target,segments,int,num,blocks,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,bulk,block,channel,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,target,segments,num,blocks
IOManager -> public BulkBlockChannelReader createBulkBlockChannelReader(Channel.ID channelID, 			List<MemorySegment> targetSegments,	int numBlocks) 	throws IOException;1410211782;Creates a block channel reader that reads all blocks from the given channel directly in one bulk._The reader draws segments to read the blocks into from a supplied list, which must contain as many_segments as the channel has blocks. After the reader is done, the list with the full segments can be_obtained from the reader._<p>_If a channel is not to be read in one bulk, but in multiple smaller batches, a_{@link BlockChannelReader} should be used.__@param channelID The descriptor for the channel to write to._@param targetSegments The list to take the segments from into which to read the data._@param numBlocks The number of blocks in the channel to read._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BulkBlockChannelReader createBulkBlockChannelReader(Channel.ID channelID,_			List<MemorySegment> targetSegments,	int numBlocks)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BulkBlockChannelReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, targetSegments, numBlocks)__	};creates,a,block,channel,reader,that,reads,all,blocks,from,the,given,channel,directly,in,one,bulk,the,reader,draws,segments,to,read,the,blocks,into,from,a,supplied,list,which,must,contain,as,many,segments,as,the,channel,has,blocks,after,the,reader,is,done,the,list,with,the,full,segments,can,be,obtained,from,the,reader,p,if,a,channel,is,not,to,be,read,in,one,bulk,but,in,multiple,smaller,batches,a,link,block,channel,reader,should,be,used,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,target,segments,the,list,to,take,the,segments,from,into,which,to,read,the,data,param,num,blocks,the,number,of,blocks,in,the,channel,to,read,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,bulk,block,channel,reader,create,bulk,block,channel,reader,channel,id,channel,id,list,memory,segment,target,segments,int,num,blocks,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,bulk,block,channel,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,target,segments,num,blocks
IOManager -> public BulkBlockChannelReader createBulkBlockChannelReader(Channel.ID channelID, 			List<MemorySegment> targetSegments,	int numBlocks) 	throws IOException;1411473561;Creates a block channel reader that reads all blocks from the given channel directly in one bulk._The reader draws segments to read the blocks into from a supplied list, which must contain as many_segments as the channel has blocks. After the reader is done, the list with the full segments can be_obtained from the reader._<p>_If a channel is not to be read in one bulk, but in multiple smaller batches, a_{@link BlockChannelReader} should be used.__@param channelID The descriptor for the channel to write to._@param targetSegments The list to take the segments from into which to read the data._@param numBlocks The number of blocks in the channel to read._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BulkBlockChannelReader createBulkBlockChannelReader(Channel.ID channelID,_			List<MemorySegment> targetSegments,	int numBlocks)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BulkBlockChannelReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, targetSegments, numBlocks)__	};creates,a,block,channel,reader,that,reads,all,blocks,from,the,given,channel,directly,in,one,bulk,the,reader,draws,segments,to,read,the,blocks,into,from,a,supplied,list,which,must,contain,as,many,segments,as,the,channel,has,blocks,after,the,reader,is,done,the,list,with,the,full,segments,can,be,obtained,from,the,reader,p,if,a,channel,is,not,to,be,read,in,one,bulk,but,in,multiple,smaller,batches,a,link,block,channel,reader,should,be,used,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,target,segments,the,list,to,take,the,segments,from,into,which,to,read,the,data,param,num,blocks,the,number,of,blocks,in,the,channel,to,read,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,bulk,block,channel,reader,create,bulk,block,channel,reader,channel,id,channel,id,list,memory,segment,target,segments,int,num,blocks,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,bulk,block,channel,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,target,segments,num,blocks
IOManager -> protected IOManager(String[] paths);1412761231;Constructs a new IOManager.__@param paths_the basic directory paths for files underlying anonymous channels.;protected IOManager(String[] paths) {_		this.paths = paths__		this.random = new Random()__		this.nextPath = 0__	};constructs,a,new,iomanager,param,paths,the,basic,directory,paths,for,files,underlying,anonymous,channels;protected,iomanager,string,paths,this,paths,paths,this,random,new,random,this,next,path,0
IOManager -> protected IOManager(String[] paths);1415382319;Constructs a new IOManager.__@param paths_the basic directory paths for files underlying anonymous channels.;protected IOManager(String[] paths) {_		this.paths = paths__		this.random = new Random()__		this.nextPath = 0__	};constructs,a,new,iomanager,param,paths,the,basic,directory,paths,for,files,underlying,anonymous,channels;protected,iomanager,string,paths,this,paths,paths,this,random,new,random,this,next,path,0
IOManager -> protected IOManager(String[] paths);1417555226;Constructs a new IOManager.__@param paths_the basic directory paths for files underlying anonymous channels.;protected IOManager(String[] paths) {_		this.paths = paths__		this.random = new Random()__		this.nextPath = 0__	};constructs,a,new,iomanager,param,paths,the,basic,directory,paths,for,files,underlying,anonymous,channels;protected,iomanager,string,paths,this,paths,paths,this,random,new,random,this,next,path,0
IOManager -> protected IOManager(String[] paths);1421771162;Constructs a new IOManager.__@param paths_the basic directory paths for files underlying anonymous channels.;protected IOManager(String[] paths) {_		this.paths = paths__		this.random = new Random()__		this.nextPath = 0__	};constructs,a,new,iomanager,param,paths,the,basic,directory,paths,for,files,underlying,anonymous,channels;protected,iomanager,string,paths,this,paths,paths,this,random,new,random,this,next,path,0
IOManager -> protected IOManager(String[] tempDirs);1420560668;Constructs a new IOManager.__@param tempDirs The basic directories for files underlying anonymous channels.;protected IOManager(String[] tempDirs) {_		if (tempDirs == null || tempDirs.length == 0) {_			throw new IllegalArgumentException("The temporary directories must not be null or empty.")__		}__		this.random = new Random()__		this.nextPath = 0___		this.paths = new File[tempDirs.length]__		for (int i = 0_ i < tempDirs.length_ i++) {_			File baseDir = new File(tempDirs[i])__			String subfolder = String.format("flink-io-%s", UUID.randomUUID().toString())__			File storageDir = new File(baseDir, subfolder)___			if (!storageDir.exists() && !storageDir.mkdirs()) {_				throw new RuntimeException(_						"Could not create storage directory for IOManager: " + storageDir.getAbsolutePath())__			}_			paths[i] = storageDir__			LOG.info("I/O manager uses directory {} for spill files.", storageDir.getAbsolutePath())__		}__		this.shutdownHook = new Thread("I/O manager shutdown hook") {_			@Override_			public void run() {_				shutdown()__			}_		}__		Runtime.getRuntime().addShutdownHook(this.shutdownHook)__	};constructs,a,new,iomanager,param,temp,dirs,the,basic,directories,for,files,underlying,anonymous,channels;protected,iomanager,string,temp,dirs,if,temp,dirs,null,temp,dirs,length,0,throw,new,illegal,argument,exception,the,temporary,directories,must,not,be,null,or,empty,this,random,new,random,this,next,path,0,this,paths,new,file,temp,dirs,length,for,int,i,0,i,temp,dirs,length,i,file,base,dir,new,file,temp,dirs,i,string,subfolder,string,format,flink,io,s,uuid,random,uuid,to,string,file,storage,dir,new,file,base,dir,subfolder,if,storage,dir,exists,storage,dir,mkdirs,throw,new,runtime,exception,could,not,create,storage,directory,for,iomanager,storage,dir,get,absolute,path,paths,i,storage,dir,log,info,i,o,manager,uses,directory,for,spill,files,storage,dir,get,absolute,path,this,shutdown,hook,new,thread,i,o,manager,shutdown,hook,override,public,void,run,shutdown,runtime,get,runtime,add,shutdown,hook,this,shutdown,hook
IOManager -> protected IOManager(String[] tempDirs);1424268205;Constructs a new IOManager.__@param tempDirs The basic directories for files underlying anonymous channels.;protected IOManager(String[] tempDirs) {_		if (tempDirs == null || tempDirs.length == 0) {_			throw new IllegalArgumentException("The temporary directories must not be null or empty.")__		}__		this.random = new Random()__		this.nextPath = 0___		this.paths = new File[tempDirs.length]__		for (int i = 0_ i < tempDirs.length_ i++) {_			File baseDir = new File(tempDirs[i])__			String subfolder = String.format("flink-io-%s", UUID.randomUUID().toString())__			File storageDir = new File(baseDir, subfolder)___			if (!storageDir.exists() && !storageDir.mkdirs()) {_				throw new RuntimeException(_						"Could not create storage directory for IOManager: " + storageDir.getAbsolutePath())__			}_			paths[i] = storageDir__			LOG.info("I/O manager uses directory {} for spill files.", storageDir.getAbsolutePath())__		}__		this.shutdownHook = new Thread("I/O manager shutdown hook") {_			@Override_			public void run() {_				shutdown()__			}_		}__		Runtime.getRuntime().addShutdownHook(this.shutdownHook)__	};constructs,a,new,iomanager,param,temp,dirs,the,basic,directories,for,files,underlying,anonymous,channels;protected,iomanager,string,temp,dirs,if,temp,dirs,null,temp,dirs,length,0,throw,new,illegal,argument,exception,the,temporary,directories,must,not,be,null,or,empty,this,random,new,random,this,next,path,0,this,paths,new,file,temp,dirs,length,for,int,i,0,i,temp,dirs,length,i,file,base,dir,new,file,temp,dirs,i,string,subfolder,string,format,flink,io,s,uuid,random,uuid,to,string,file,storage,dir,new,file,base,dir,subfolder,if,storage,dir,exists,storage,dir,mkdirs,throw,new,runtime,exception,could,not,create,storage,directory,for,iomanager,storage,dir,get,absolute,path,paths,i,storage,dir,log,info,i,o,manager,uses,directory,for,spill,files,storage,dir,get,absolute,path,this,shutdown,hook,new,thread,i,o,manager,shutdown,hook,override,public,void,run,shutdown,runtime,get,runtime,add,shutdown,hook,this,shutdown,hook
IOManager -> protected IOManager(String[] tempDirs);1428680960;Constructs a new IOManager.__@param tempDirs The basic directories for files underlying anonymous channels.;protected IOManager(String[] tempDirs) {_		if (tempDirs == null || tempDirs.length == 0) {_			throw new IllegalArgumentException("The temporary directories must not be null or empty.")__		}__		this.random = new Random()__		this.nextPath = 0___		this.paths = new File[tempDirs.length]__		for (int i = 0_ i < tempDirs.length_ i++) {_			File baseDir = new File(tempDirs[i])__			String subfolder = String.format("flink-io-%s", UUID.randomUUID().toString())__			File storageDir = new File(baseDir, subfolder)___			if (!storageDir.exists() && !storageDir.mkdirs()) {_				throw new RuntimeException(_						"Could not create storage directory for IOManager: " + storageDir.getAbsolutePath())__			}_			paths[i] = storageDir__			LOG.info("I/O manager uses directory {} for spill files.", storageDir.getAbsolutePath())__		}__		this.shutdownHook = new Thread("I/O manager shutdown hook") {_			@Override_			public void run() {_				shutdown()__			}_		}__		try {_			Runtime.getRuntime().addShutdownHook(this.shutdownHook)__		} catch (IllegalStateException e) {_			_			LOG.debug("Unable to add shutdown hook, shutdown already in progress", e)__		} catch (Throwable t) {_			LOG.warn("Error while adding shutdown hook for IOManager", t)__		}_	};constructs,a,new,iomanager,param,temp,dirs,the,basic,directories,for,files,underlying,anonymous,channels;protected,iomanager,string,temp,dirs,if,temp,dirs,null,temp,dirs,length,0,throw,new,illegal,argument,exception,the,temporary,directories,must,not,be,null,or,empty,this,random,new,random,this,next,path,0,this,paths,new,file,temp,dirs,length,for,int,i,0,i,temp,dirs,length,i,file,base,dir,new,file,temp,dirs,i,string,subfolder,string,format,flink,io,s,uuid,random,uuid,to,string,file,storage,dir,new,file,base,dir,subfolder,if,storage,dir,exists,storage,dir,mkdirs,throw,new,runtime,exception,could,not,create,storage,directory,for,iomanager,storage,dir,get,absolute,path,paths,i,storage,dir,log,info,i,o,manager,uses,directory,for,spill,files,storage,dir,get,absolute,path,this,shutdown,hook,new,thread,i,o,manager,shutdown,hook,override,public,void,run,shutdown,try,runtime,get,runtime,add,shutdown,hook,this,shutdown,hook,catch,illegal,state,exception,e,log,debug,unable,to,add,shutdown,hook,shutdown,already,in,progress,e,catch,throwable,t,log,warn,error,while,adding,shutdown,hook,for,iomanager,t
IOManager -> protected IOManager(String[] tempDirs);1437929917;Constructs a new IOManager.__@param tempDirs The basic directories for files underlying anonymous channels.;protected IOManager(String[] tempDirs) {_		if (tempDirs == null || tempDirs.length == 0) {_			throw new IllegalArgumentException("The temporary directories must not be null or empty.")__		}__		this.random = new Random()__		this.nextPath = 0___		this.paths = new File[tempDirs.length]__		for (int i = 0_ i < tempDirs.length_ i++) {_			File baseDir = new File(tempDirs[i])__			String subfolder = String.format("flink-io-%s", UUID.randomUUID().toString())__			File storageDir = new File(baseDir, subfolder)___			if (!storageDir.exists() && !storageDir.mkdirs()) {_				throw new RuntimeException(_						"Could not create storage directory for IOManager: " + storageDir.getAbsolutePath())__			}_			paths[i] = storageDir__			LOG.info("I/O manager uses directory {} for spill files.", storageDir.getAbsolutePath())__		}__		this.shutdownHook = new Thread("I/O manager shutdown hook") {_			@Override_			public void run() {_				shutdown()__			}_		}__		try {_			Runtime.getRuntime().addShutdownHook(this.shutdownHook)__		} catch (IllegalStateException e) {_			_			LOG.debug("Unable to add shutdown hook, shutdown already in progress", e)__		} catch (Throwable t) {_			LOG.warn("Error while adding shutdown hook for IOManager", t)__		}_	};constructs,a,new,iomanager,param,temp,dirs,the,basic,directories,for,files,underlying,anonymous,channels;protected,iomanager,string,temp,dirs,if,temp,dirs,null,temp,dirs,length,0,throw,new,illegal,argument,exception,the,temporary,directories,must,not,be,null,or,empty,this,random,new,random,this,next,path,0,this,paths,new,file,temp,dirs,length,for,int,i,0,i,temp,dirs,length,i,file,base,dir,new,file,temp,dirs,i,string,subfolder,string,format,flink,io,s,uuid,random,uuid,to,string,file,storage,dir,new,file,base,dir,subfolder,if,storage,dir,exists,storage,dir,mkdirs,throw,new,runtime,exception,could,not,create,storage,directory,for,iomanager,storage,dir,get,absolute,path,paths,i,storage,dir,log,info,i,o,manager,uses,directory,for,spill,files,storage,dir,get,absolute,path,this,shutdown,hook,new,thread,i,o,manager,shutdown,hook,override,public,void,run,shutdown,try,runtime,get,runtime,add,shutdown,hook,this,shutdown,hook,catch,illegal,state,exception,e,log,debug,unable,to,add,shutdown,hook,shutdown,already,in,progress,e,catch,throwable,t,log,warn,error,while,adding,shutdown,hook,for,iomanager,t
IOManager -> protected IOManager(String[] tempDirs);1441102230;Constructs a new IOManager.__@param tempDirs The basic directories for files underlying anonymous channels.;protected IOManager(String[] tempDirs) {_		if (tempDirs == null || tempDirs.length == 0) {_			throw new IllegalArgumentException("The temporary directories must not be null or empty.")__		}__		this.random = new Random()__		this.nextPath = 0___		this.paths = new File[tempDirs.length]__		for (int i = 0_ i < tempDirs.length_ i++) {_			File baseDir = new File(tempDirs[i])__			String subfolder = String.format("flink-io-%s", UUID.randomUUID().toString())__			File storageDir = new File(baseDir, subfolder)___			if (!storageDir.exists() && !storageDir.mkdirs()) {_				throw new RuntimeException(_						"Could not create storage directory for IOManager: " + storageDir.getAbsolutePath())__			}_			paths[i] = storageDir__			LOG.info("I/O manager uses directory {} for spill files.", storageDir.getAbsolutePath())__		}_	};constructs,a,new,iomanager,param,temp,dirs,the,basic,directories,for,files,underlying,anonymous,channels;protected,iomanager,string,temp,dirs,if,temp,dirs,null,temp,dirs,length,0,throw,new,illegal,argument,exception,the,temporary,directories,must,not,be,null,or,empty,this,random,new,random,this,next,path,0,this,paths,new,file,temp,dirs,length,for,int,i,0,i,temp,dirs,length,i,file,base,dir,new,file,temp,dirs,i,string,subfolder,string,format,flink,io,s,uuid,random,uuid,to,string,file,storage,dir,new,file,base,dir,subfolder,if,storage,dir,exists,storage,dir,mkdirs,throw,new,runtime,exception,could,not,create,storage,directory,for,iomanager,storage,dir,get,absolute,path,paths,i,storage,dir,log,info,i,o,manager,uses,directory,for,spill,files,storage,dir,get,absolute,path
IOManager -> protected IOManager(String[] tempDirs);1464188671;Constructs a new IOManager.__@param tempDirs The basic directories for files underlying anonymous channels.;protected IOManager(String[] tempDirs) {_		if (tempDirs == null || tempDirs.length == 0) {_			throw new IllegalArgumentException("The temporary directories must not be null or empty.")__		}__		this.random = new Random()__		this.nextPath = 0___		this.paths = new File[tempDirs.length]__		for (int i = 0_ i < tempDirs.length_ i++) {_			File baseDir = new File(tempDirs[i])__			String subfolder = String.format("flink-io-%s", UUID.randomUUID().toString())__			File storageDir = new File(baseDir, subfolder)___			if (!storageDir.exists() && !storageDir.mkdirs()) {_				throw new RuntimeException(_						"Could not create storage directory for IOManager: " + storageDir.getAbsolutePath())__			}_			paths[i] = storageDir__			LOG.info("I/O manager uses directory {} for spill files.", storageDir.getAbsolutePath())__		}_	};constructs,a,new,iomanager,param,temp,dirs,the,basic,directories,for,files,underlying,anonymous,channels;protected,iomanager,string,temp,dirs,if,temp,dirs,null,temp,dirs,length,0,throw,new,illegal,argument,exception,the,temporary,directories,must,not,be,null,or,empty,this,random,new,random,this,next,path,0,this,paths,new,file,temp,dirs,length,for,int,i,0,i,temp,dirs,length,i,file,base,dir,new,file,temp,dirs,i,string,subfolder,string,format,flink,io,s,uuid,random,uuid,to,string,file,storage,dir,new,file,base,dir,subfolder,if,storage,dir,exists,storage,dir,mkdirs,throw,new,runtime,exception,could,not,create,storage,directory,for,iomanager,storage,dir,get,absolute,path,paths,i,storage,dir,log,info,i,o,manager,uses,directory,for,spill,files,storage,dir,get,absolute,path
IOManager -> protected IOManager(String[] tempDirs);1484214553;Constructs a new IOManager.__@param tempDirs The basic directories for files underlying anonymous channels.;protected IOManager(String[] tempDirs) {_		if (tempDirs == null || tempDirs.length == 0) {_			throw new IllegalArgumentException("The temporary directories must not be null or empty.")__		}__		this.random = new Random()__		this.nextPath = 0___		this.paths = new File[tempDirs.length]__		for (int i = 0_ i < tempDirs.length_ i++) {_			File baseDir = new File(tempDirs[i])__			String subfolder = String.format("flink-io-%s", UUID.randomUUID().toString())__			File storageDir = new File(baseDir, subfolder)___			if (!storageDir.exists() && !storageDir.mkdirs()) {_				throw new RuntimeException(_						"Could not create storage directory for IOManager: " + storageDir.getAbsolutePath())__			}_			paths[i] = storageDir__			LOG.info("I/O manager uses directory {} for spill files.", storageDir.getAbsolutePath())__		}_	};constructs,a,new,iomanager,param,temp,dirs,the,basic,directories,for,files,underlying,anonymous,channels;protected,iomanager,string,temp,dirs,if,temp,dirs,null,temp,dirs,length,0,throw,new,illegal,argument,exception,the,temporary,directories,must,not,be,null,or,empty,this,random,new,random,this,next,path,0,this,paths,new,file,temp,dirs,length,for,int,i,0,i,temp,dirs,length,i,file,base,dir,new,file,temp,dirs,i,string,subfolder,string,format,flink,io,s,uuid,random,uuid,to,string,file,storage,dir,new,file,base,dir,subfolder,if,storage,dir,exists,storage,dir,mkdirs,throw,new,runtime,exception,could,not,create,storage,directory,for,iomanager,storage,dir,get,absolute,path,paths,i,storage,dir,log,info,i,o,manager,uses,directory,for,spill,files,storage,dir,get,absolute,path
IOManager -> public abstract BlockChannelWriter<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID, 				LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;1420560668;Creates a block channel writer that writes to the given channel. The writer adds the_written segment to the given queue (to allow for asynchronous implementations).__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the written buffers into._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public abstract BlockChannelWriter<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID,_				LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,adds,the,written,segment,to,the,given,queue,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,written,buffers,into,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,abstract,block,channel,writer,memory,segment,create,block,channel,writer,file,iochannel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception
IOManager -> public abstract BlockChannelWriter<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID, 				LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;1428680960;Creates a block channel writer that writes to the given channel. The writer adds the_written segment to the given queue (to allow for asynchronous implementations).__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the written buffers into._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public abstract BlockChannelWriter<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID,_				LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,adds,the,written,segment,to,the,given,queue,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,written,buffers,into,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,abstract,block,channel,writer,memory,segment,create,block,channel,writer,file,iochannel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception
IOManager -> public abstract BlockChannelWriter<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID, 				LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;1437929917;Creates a block channel writer that writes to the given channel. The writer adds the_written segment to the given queue (to allow for asynchronous implementations).__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the written buffers into._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public abstract BlockChannelWriter<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID,_				LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,adds,the,written,segment,to,the,given,queue,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,written,buffers,into,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,abstract,block,channel,writer,memory,segment,create,block,channel,writer,file,iochannel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception
IOManager -> public abstract BlockChannelWriter<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID, 				LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;1441102230;Creates a block channel writer that writes to the given channel. The writer adds the_written segment to the given queue (to allow for asynchronous implementations).__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the written buffers into._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public abstract BlockChannelWriter<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID,_				LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,adds,the,written,segment,to,the,given,queue,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,written,buffers,into,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,abstract,block,channel,writer,memory,segment,create,block,channel,writer,file,iochannel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception
IOManager -> public abstract BlockChannelWriter<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID, 				LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;1464188671;Creates a block channel writer that writes to the given channel. The writer adds the_written segment to the given queue (to allow for asynchronous implementations).__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the written buffers into._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public abstract BlockChannelWriter<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID,_				LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,adds,the,written,segment,to,the,given,queue,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,written,buffers,into,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,abstract,block,channel,writer,memory,segment,create,block,channel,writer,file,iochannel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception
IOManager -> public abstract BlockChannelWriter<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID, 				LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;1484214553;Creates a block channel writer that writes to the given channel. The writer adds the_written segment to the given queue (to allow for asynchronous implementations).__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the written buffers into._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public abstract BlockChannelWriter<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID,_				LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_;creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,adds,the,written,segment,to,the,given,queue,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,written,buffers,into,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,abstract,block,channel,writer,memory,segment,create,block,channel,writer,file,iochannel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception
IOManager -> public int getNumberOfSpillingDirectories();1437929917;Gets the number of directories across which the I/O manager rotates its files.__@return The number of temporary file directories.;public int getNumberOfSpillingDirectories() {_		return this.paths.length__	};gets,the,number,of,directories,across,which,the,i,o,manager,rotates,its,files,return,the,number,of,temporary,file,directories;public,int,get,number,of,spilling,directories,return,this,paths,length
IOManager -> public int getNumberOfSpillingDirectories();1441102230;Gets the number of directories across which the I/O manager rotates its files.__@return The number of temporary file directories.;public int getNumberOfSpillingDirectories() {_		return this.paths.length__	};gets,the,number,of,directories,across,which,the,i,o,manager,rotates,its,files,return,the,number,of,temporary,file,directories;public,int,get,number,of,spilling,directories,return,this,paths,length
IOManager -> public int getNumberOfSpillingDirectories();1464188671;Gets the number of directories across which the I/O manager rotates its files.__@return The number of temporary file directories.;public int getNumberOfSpillingDirectories() {_		return this.paths.length__	};gets,the,number,of,directories,across,which,the,i,o,manager,rotates,its,files,return,the,number,of,temporary,file,directories;public,int,get,number,of,spilling,directories,return,this,paths,length
IOManager -> public int getNumberOfSpillingDirectories();1484214553;Gets the number of directories across which the I/O manager rotates its files.__@return The number of temporary file directories.;public int getNumberOfSpillingDirectories() {_		return this.paths.length__	};gets,the,number,of,directories,across,which,the,i,o,manager,rotates,its,files,return,the,number,of,temporary,file,directories;public,int,get,number,of,spilling,directories,return,this,paths,length
IOManager -> public BlockChannelReader createBlockChannelReader(FileIOChannel.ID channelID) throws IOException;1412761231;Creates a block channel reader that reads blocks from the given channel. The reader pushed_full memory segments (with the read data) to its "return queue", to allow for asynchronous read_implementations.__@param channelID The descriptor for the channel to write to._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BlockChannelReader createBlockChannelReader(FileIOChannel.ID channelID) throws IOException {_		return createBlockChannelReader(channelID, new LinkedBlockingQueue<MemorySegment>())__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,pushed,full,memory,segments,with,the,read,data,to,its,return,queue,to,allow,for,asynchronous,read,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,block,channel,reader,create,block,channel,reader,file,iochannel,id,channel,id,throws,ioexception,return,create,block,channel,reader,channel,id,new,linked,blocking,queue,memory,segment
IOManager -> public BlockChannelReader createBlockChannelReader(FileIOChannel.ID channelID) throws IOException;1415382319;Creates a block channel reader that reads blocks from the given channel. The reader pushed_full memory segments (with the read data) to its "return queue", to allow for asynchronous read_implementations.__@param channelID The descriptor for the channel to write to._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BlockChannelReader createBlockChannelReader(FileIOChannel.ID channelID) throws IOException {_		return createBlockChannelReader(channelID, new LinkedBlockingQueue<MemorySegment>())__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,pushed,full,memory,segments,with,the,read,data,to,its,return,queue,to,allow,for,asynchronous,read,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,block,channel,reader,create,block,channel,reader,file,iochannel,id,channel,id,throws,ioexception,return,create,block,channel,reader,channel,id,new,linked,blocking,queue,memory,segment
IOManager -> public BlockChannelReader createBlockChannelReader(FileIOChannel.ID channelID) throws IOException;1417555226;Creates a block channel reader that reads blocks from the given channel. The reader pushed_full memory segments (with the read data) to its "return queue", to allow for asynchronous read_implementations.__@param channelID The descriptor for the channel to write to._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BlockChannelReader createBlockChannelReader(FileIOChannel.ID channelID) throws IOException {_		return createBlockChannelReader(channelID, new LinkedBlockingQueue<MemorySegment>())__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,pushed,full,memory,segments,with,the,read,data,to,its,return,queue,to,allow,for,asynchronous,read,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,block,channel,reader,create,block,channel,reader,file,iochannel,id,channel,id,throws,ioexception,return,create,block,channel,reader,channel,id,new,linked,blocking,queue,memory,segment
IOManager -> public BlockChannelReader createBlockChannelReader(FileIOChannel.ID channelID) throws IOException;1421771162;Creates a block channel reader that reads blocks from the given channel. The reader pushed_full memory segments (with the read data) to its "return queue", to allow for asynchronous read_implementations.__@param channelID The descriptor for the channel to write to._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BlockChannelReader createBlockChannelReader(FileIOChannel.ID channelID) throws IOException {_		return createBlockChannelReader(channelID, new LinkedBlockingQueue<MemorySegment>())__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,pushed,full,memory,segments,with,the,read,data,to,its,return,queue,to,allow,for,asynchronous,read,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,block,channel,reader,create,block,channel,reader,file,iochannel,id,channel,id,throws,ioexception,return,create,block,channel,reader,channel,id,new,linked,blocking,queue,memory,segment
IOManager -> public BlockChannelReader createBlockChannelReader(FileIOChannel.ID channelID) throws IOException;1424268205;Creates a block channel reader that reads blocks from the given channel. The reader pushed_full memory segments (with the read data) to its "return queue", to allow for asynchronous read_implementations.__@param channelID The descriptor for the channel to write to._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BlockChannelReader createBlockChannelReader(FileIOChannel.ID channelID) throws IOException {_		return createBlockChannelReader(channelID, new LinkedBlockingQueue<MemorySegment>())__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,pushed,full,memory,segments,with,the,read,data,to,its,return,queue,to,allow,for,asynchronous,read,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,block,channel,reader,create,block,channel,reader,file,iochannel,id,channel,id,throws,ioexception,return,create,block,channel,reader,channel,id,new,linked,blocking,queue,memory,segment
IOManager -> public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID, int numRequestsToCombine) 	throws IOException;1404155775;Creates a block channel writer that writes to the given channel. The writer writes asynchronously (write-behind),_accepting write request, carrying them out at some time and returning the written segment its return queue afterwards._<p>_The writer will collect a specified number of write requests and carry them out_in one, effectively writing one block in the size of multiple memory pages._Note that this means that no memory segment will reach the return queue before_the given number of requests are collected, so the number of buffers used with_the writer should be greater than the number of requests to combine. Ideally,_the number of memory segments used is a multiple of the number of requests to_combine.__@param channelID The descriptor for the channel to write to._@param numRequestsToCombine The number of write requests to combine to one I/O request._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID, int numRequestsToCombine)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelWriter(channelID, this.writers[channelID.getThreadNum()].requestQueue, new LinkedBlockingQueue<MemorySegment>(), numRequestsToCombine)__	};creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,writes,asynchronously,write,behind,accepting,write,request,carrying,them,out,at,some,time,and,returning,the,written,segment,its,return,queue,afterwards,p,the,writer,will,collect,a,specified,number,of,write,requests,and,carry,them,out,in,one,effectively,writing,one,block,in,the,size,of,multiple,memory,pages,note,that,this,means,that,no,memory,segment,will,reach,the,return,queue,before,the,given,number,of,requests,are,collected,so,the,number,of,buffers,used,with,the,writer,should,be,greater,than,the,number,of,requests,to,combine,ideally,the,number,of,memory,segments,used,is,a,multiple,of,the,number,of,requests,to,combine,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,num,requests,to,combine,the,number,of,write,requests,to,combine,to,one,i,o,request,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,block,channel,writer,create,block,channel,writer,channel,id,channel,id,int,num,requests,to,combine,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,writer,channel,id,this,writers,channel,id,get,thread,num,request,queue,new,linked,blocking,queue,memory,segment,num,requests,to,combine
IOManager -> public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID, int numRequestsToCombine) 	throws IOException;1404986750;Creates a block channel writer that writes to the given channel. The writer writes asynchronously (write-behind),_accepting write request, carrying them out at some time and returning the written segment its return queue afterwards._<p>_The writer will collect a specified number of write requests and carry them out_in one, effectively writing one block in the size of multiple memory pages._Note that this means that no memory segment will reach the return queue before_the given number of requests are collected, so the number of buffers used with_the writer should be greater than the number of requests to combine. Ideally,_the number of memory segments used is a multiple of the number of requests to_combine.__@param channelID The descriptor for the channel to write to._@param numRequestsToCombine The number of write requests to combine to one I/O request._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID, int numRequestsToCombine)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelWriter(channelID, this.writers[channelID.getThreadNum()].requestQueue, new LinkedBlockingQueue<MemorySegment>(), numRequestsToCombine)__	};creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,writes,asynchronously,write,behind,accepting,write,request,carrying,them,out,at,some,time,and,returning,the,written,segment,its,return,queue,afterwards,p,the,writer,will,collect,a,specified,number,of,write,requests,and,carry,them,out,in,one,effectively,writing,one,block,in,the,size,of,multiple,memory,pages,note,that,this,means,that,no,memory,segment,will,reach,the,return,queue,before,the,given,number,of,requests,are,collected,so,the,number,of,buffers,used,with,the,writer,should,be,greater,than,the,number,of,requests,to,combine,ideally,the,number,of,memory,segments,used,is,a,multiple,of,the,number,of,requests,to,combine,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,num,requests,to,combine,the,number,of,write,requests,to,combine,to,one,i,o,request,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,block,channel,writer,create,block,channel,writer,channel,id,channel,id,int,num,requests,to,combine,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,writer,channel,id,this,writers,channel,id,get,thread,num,request,queue,new,linked,blocking,queue,memory,segment,num,requests,to,combine
IOManager -> public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID, int numRequestsToCombine) 	throws IOException;1405088715;Creates a block channel writer that writes to the given channel. The writer writes asynchronously (write-behind),_accepting write request, carrying them out at some time and returning the written segment its return queue afterwards._<p>_The writer will collect a specified number of write requests and carry them out_in one, effectively writing one block in the size of multiple memory pages._Note that this means that no memory segment will reach the return queue before_the given number of requests are collected, so the number of buffers used with_the writer should be greater than the number of requests to combine. Ideally,_the number of memory segments used is a multiple of the number of requests to_combine.__@param channelID The descriptor for the channel to write to._@param numRequestsToCombine The number of write requests to combine to one I/O request._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID, int numRequestsToCombine)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelWriter(channelID, this.writers[channelID.getThreadNum()].requestQueue, new LinkedBlockingQueue<MemorySegment>(), numRequestsToCombine)__	};creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,writes,asynchronously,write,behind,accepting,write,request,carrying,them,out,at,some,time,and,returning,the,written,segment,its,return,queue,afterwards,p,the,writer,will,collect,a,specified,number,of,write,requests,and,carry,them,out,in,one,effectively,writing,one,block,in,the,size,of,multiple,memory,pages,note,that,this,means,that,no,memory,segment,will,reach,the,return,queue,before,the,given,number,of,requests,are,collected,so,the,number,of,buffers,used,with,the,writer,should,be,greater,than,the,number,of,requests,to,combine,ideally,the,number,of,memory,segments,used,is,a,multiple,of,the,number,of,requests,to,combine,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,num,requests,to,combine,the,number,of,write,requests,to,combine,to,one,i,o,request,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,block,channel,writer,create,block,channel,writer,channel,id,channel,id,int,num,requests,to,combine,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,writer,channel,id,this,writers,channel,id,get,thread,num,request,queue,new,linked,blocking,queue,memory,segment,num,requests,to,combine
IOManager -> public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID, int numRequestsToCombine) 	throws IOException;1409222213;Creates a block channel writer that writes to the given channel. The writer writes asynchronously (write-behind),_accepting write request, carrying them out at some time and returning the written segment its return queue afterwards._<p>_The writer will collect a specified number of write requests and carry them out_in one, effectively writing one block in the size of multiple memory pages._Note that this means that no memory segment will reach the return queue before_the given number of requests are collected, so the number of buffers used with_the writer should be greater than the number of requests to combine. Ideally,_the number of memory segments used is a multiple of the number of requests to_combine.__@param channelID The descriptor for the channel to write to._@param numRequestsToCombine The number of write requests to combine to one I/O request._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID, int numRequestsToCombine)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelWriter(channelID, this.writers[channelID.getThreadNum()].requestQueue, new LinkedBlockingQueue<MemorySegment>(), numRequestsToCombine)__	};creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,writes,asynchronously,write,behind,accepting,write,request,carrying,them,out,at,some,time,and,returning,the,written,segment,its,return,queue,afterwards,p,the,writer,will,collect,a,specified,number,of,write,requests,and,carry,them,out,in,one,effectively,writing,one,block,in,the,size,of,multiple,memory,pages,note,that,this,means,that,no,memory,segment,will,reach,the,return,queue,before,the,given,number,of,requests,are,collected,so,the,number,of,buffers,used,with,the,writer,should,be,greater,than,the,number,of,requests,to,combine,ideally,the,number,of,memory,segments,used,is,a,multiple,of,the,number,of,requests,to,combine,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,num,requests,to,combine,the,number,of,write,requests,to,combine,to,one,i,o,request,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,block,channel,writer,create,block,channel,writer,channel,id,channel,id,int,num,requests,to,combine,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,writer,channel,id,this,writers,channel,id,get,thread,num,request,queue,new,linked,blocking,queue,memory,segment,num,requests,to,combine
IOManager -> public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID, int numRequestsToCombine) 	throws IOException;1410211782;Creates a block channel writer that writes to the given channel. The writer writes asynchronously (write-behind),_accepting write request, carrying them out at some time and returning the written segment its return queue afterwards._<p>_The writer will collect a specified number of write requests and carry them out_in one, effectively writing one block in the size of multiple memory pages._Note that this means that no memory segment will reach the return queue before_the given number of requests are collected, so the number of buffers used with_the writer should be greater than the number of requests to combine. Ideally,_the number of memory segments used is a multiple of the number of requests to_combine.__@param channelID The descriptor for the channel to write to._@param numRequestsToCombine The number of write requests to combine to one I/O request._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID, int numRequestsToCombine)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelWriter(channelID, this.writers[channelID.getThreadNum()].requestQueue, new LinkedBlockingQueue<MemorySegment>(), numRequestsToCombine)__	};creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,writes,asynchronously,write,behind,accepting,write,request,carrying,them,out,at,some,time,and,returning,the,written,segment,its,return,queue,afterwards,p,the,writer,will,collect,a,specified,number,of,write,requests,and,carry,them,out,in,one,effectively,writing,one,block,in,the,size,of,multiple,memory,pages,note,that,this,means,that,no,memory,segment,will,reach,the,return,queue,before,the,given,number,of,requests,are,collected,so,the,number,of,buffers,used,with,the,writer,should,be,greater,than,the,number,of,requests,to,combine,ideally,the,number,of,memory,segments,used,is,a,multiple,of,the,number,of,requests,to,combine,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,num,requests,to,combine,the,number,of,write,requests,to,combine,to,one,i,o,request,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,block,channel,writer,create,block,channel,writer,channel,id,channel,id,int,num,requests,to,combine,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,writer,channel,id,this,writers,channel,id,get,thread,num,request,queue,new,linked,blocking,queue,memory,segment,num,requests,to,combine
IOManager -> public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID, int numRequestsToCombine) 	throws IOException;1411473561;Creates a block channel writer that writes to the given channel. The writer writes asynchronously (write-behind),_accepting write request, carrying them out at some time and returning the written segment its return queue afterwards._<p>_The writer will collect a specified number of write requests and carry them out_in one, effectively writing one block in the size of multiple memory pages._Note that this means that no memory segment will reach the return queue before_the given number of requests are collected, so the number of buffers used with_the writer should be greater than the number of requests to combine. Ideally,_the number of memory segments used is a multiple of the number of requests to_combine.__@param channelID The descriptor for the channel to write to._@param numRequestsToCombine The number of write requests to combine to one I/O request._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID, int numRequestsToCombine)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelWriter(channelID, this.writers[channelID.getThreadNum()].requestQueue, new LinkedBlockingQueue<MemorySegment>(), numRequestsToCombine)__	};creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,writes,asynchronously,write,behind,accepting,write,request,carrying,them,out,at,some,time,and,returning,the,written,segment,its,return,queue,afterwards,p,the,writer,will,collect,a,specified,number,of,write,requests,and,carry,them,out,in,one,effectively,writing,one,block,in,the,size,of,multiple,memory,pages,note,that,this,means,that,no,memory,segment,will,reach,the,return,queue,before,the,given,number,of,requests,are,collected,so,the,number,of,buffers,used,with,the,writer,should,be,greater,than,the,number,of,requests,to,combine,ideally,the,number,of,memory,segments,used,is,a,multiple,of,the,number,of,requests,to,combine,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,num,requests,to,combine,the,number,of,write,requests,to,combine,to,one,i,o,request,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,block,channel,writer,create,block,channel,writer,channel,id,channel,id,int,num,requests,to,combine,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,writer,channel,id,this,writers,channel,id,get,thread,num,request,queue,new,linked,blocking,queue,memory,segment,num,requests,to,combine
IOManager -> public BlockChannelReader createBlockChannelReader(Channel.ID channelID, int numRequestsToCombine) 	throws IOException;1404155775;Creates a block channel reader that reads blocks from the given channel. The reader reads asynchronously,_such that a read request is accepted, carried out at some (close) point in time, and the full segment_is pushed to the reader's return queue._<p>_The reader will collect a specified number of read requests and carry them out_in one, effectively reading one block in the size of multiple memory pages._Note that this means that no memory segment will reach the return queue before_the given number of requests are collected, so the number of buffers used with_the reader should be greater than the number of requests to combine. Ideally,_the number of memory segments used is a multiple of the number of requests to_combine.__@param channelID The descriptor for the channel to write to._@param numRequestsToCombine The number of write requests to combine to one I/O request._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BlockChannelReader createBlockChannelReader(Channel.ID channelID, int numRequestsToCombine)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, _			new LinkedBlockingQueue<MemorySegment>(), numRequestsToCombine)__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,reads,asynchronously,such,that,a,read,request,is,accepted,carried,out,at,some,close,point,in,time,and,the,full,segment,is,pushed,to,the,reader,s,return,queue,p,the,reader,will,collect,a,specified,number,of,read,requests,and,carry,them,out,in,one,effectively,reading,one,block,in,the,size,of,multiple,memory,pages,note,that,this,means,that,no,memory,segment,will,reach,the,return,queue,before,the,given,number,of,requests,are,collected,so,the,number,of,buffers,used,with,the,reader,should,be,greater,than,the,number,of,requests,to,combine,ideally,the,number,of,memory,segments,used,is,a,multiple,of,the,number,of,requests,to,combine,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,num,requests,to,combine,the,number,of,write,requests,to,combine,to,one,i,o,request,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,block,channel,reader,create,block,channel,reader,channel,id,channel,id,int,num,requests,to,combine,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,new,linked,blocking,queue,memory,segment,num,requests,to,combine
IOManager -> public BlockChannelReader createBlockChannelReader(Channel.ID channelID, int numRequestsToCombine) 	throws IOException;1404986750;Creates a block channel reader that reads blocks from the given channel. The reader reads asynchronously,_such that a read request is accepted, carried out at some (close) point in time, and the full segment_is pushed to the reader's return queue._<p>_The reader will collect a specified number of read requests and carry them out_in one, effectively reading one block in the size of multiple memory pages._Note that this means that no memory segment will reach the return queue before_the given number of requests are collected, so the number of buffers used with_the reader should be greater than the number of requests to combine. Ideally,_the number of memory segments used is a multiple of the number of requests to_combine.__@param channelID The descriptor for the channel to write to._@param numRequestsToCombine The number of write requests to combine to one I/O request._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BlockChannelReader createBlockChannelReader(Channel.ID channelID, int numRequestsToCombine)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, _			new LinkedBlockingQueue<MemorySegment>(), numRequestsToCombine)__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,reads,asynchronously,such,that,a,read,request,is,accepted,carried,out,at,some,close,point,in,time,and,the,full,segment,is,pushed,to,the,reader,s,return,queue,p,the,reader,will,collect,a,specified,number,of,read,requests,and,carry,them,out,in,one,effectively,reading,one,block,in,the,size,of,multiple,memory,pages,note,that,this,means,that,no,memory,segment,will,reach,the,return,queue,before,the,given,number,of,requests,are,collected,so,the,number,of,buffers,used,with,the,reader,should,be,greater,than,the,number,of,requests,to,combine,ideally,the,number,of,memory,segments,used,is,a,multiple,of,the,number,of,requests,to,combine,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,num,requests,to,combine,the,number,of,write,requests,to,combine,to,one,i,o,request,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,block,channel,reader,create,block,channel,reader,channel,id,channel,id,int,num,requests,to,combine,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,new,linked,blocking,queue,memory,segment,num,requests,to,combine
IOManager -> public BlockChannelReader createBlockChannelReader(Channel.ID channelID, int numRequestsToCombine) 	throws IOException;1405088715;Creates a block channel reader that reads blocks from the given channel. The reader reads asynchronously,_such that a read request is accepted, carried out at some (close) point in time, and the full segment_is pushed to the reader's return queue._<p>_The reader will collect a specified number of read requests and carry them out_in one, effectively reading one block in the size of multiple memory pages._Note that this means that no memory segment will reach the return queue before_the given number of requests are collected, so the number of buffers used with_the reader should be greater than the number of requests to combine. Ideally,_the number of memory segments used is a multiple of the number of requests to_combine.__@param channelID The descriptor for the channel to write to._@param numRequestsToCombine The number of write requests to combine to one I/O request._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BlockChannelReader createBlockChannelReader(Channel.ID channelID, int numRequestsToCombine)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, _			new LinkedBlockingQueue<MemorySegment>(), numRequestsToCombine)__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,reads,asynchronously,such,that,a,read,request,is,accepted,carried,out,at,some,close,point,in,time,and,the,full,segment,is,pushed,to,the,reader,s,return,queue,p,the,reader,will,collect,a,specified,number,of,read,requests,and,carry,them,out,in,one,effectively,reading,one,block,in,the,size,of,multiple,memory,pages,note,that,this,means,that,no,memory,segment,will,reach,the,return,queue,before,the,given,number,of,requests,are,collected,so,the,number,of,buffers,used,with,the,reader,should,be,greater,than,the,number,of,requests,to,combine,ideally,the,number,of,memory,segments,used,is,a,multiple,of,the,number,of,requests,to,combine,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,num,requests,to,combine,the,number,of,write,requests,to,combine,to,one,i,o,request,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,block,channel,reader,create,block,channel,reader,channel,id,channel,id,int,num,requests,to,combine,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,new,linked,blocking,queue,memory,segment,num,requests,to,combine
IOManager -> public BlockChannelReader createBlockChannelReader(Channel.ID channelID, int numRequestsToCombine) 	throws IOException;1409222213;Creates a block channel reader that reads blocks from the given channel. The reader reads asynchronously,_such that a read request is accepted, carried out at some (close) point in time, and the full segment_is pushed to the reader's return queue._<p>_The reader will collect a specified number of read requests and carry them out_in one, effectively reading one block in the size of multiple memory pages._Note that this means that no memory segment will reach the return queue before_the given number of requests are collected, so the number of buffers used with_the reader should be greater than the number of requests to combine. Ideally,_the number of memory segments used is a multiple of the number of requests to_combine.__@param channelID The descriptor for the channel to write to._@param numRequestsToCombine The number of write requests to combine to one I/O request._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BlockChannelReader createBlockChannelReader(Channel.ID channelID, int numRequestsToCombine)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, _			new LinkedBlockingQueue<MemorySegment>(), numRequestsToCombine)__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,reads,asynchronously,such,that,a,read,request,is,accepted,carried,out,at,some,close,point,in,time,and,the,full,segment,is,pushed,to,the,reader,s,return,queue,p,the,reader,will,collect,a,specified,number,of,read,requests,and,carry,them,out,in,one,effectively,reading,one,block,in,the,size,of,multiple,memory,pages,note,that,this,means,that,no,memory,segment,will,reach,the,return,queue,before,the,given,number,of,requests,are,collected,so,the,number,of,buffers,used,with,the,reader,should,be,greater,than,the,number,of,requests,to,combine,ideally,the,number,of,memory,segments,used,is,a,multiple,of,the,number,of,requests,to,combine,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,num,requests,to,combine,the,number,of,write,requests,to,combine,to,one,i,o,request,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,block,channel,reader,create,block,channel,reader,channel,id,channel,id,int,num,requests,to,combine,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,new,linked,blocking,queue,memory,segment,num,requests,to,combine
IOManager -> public BlockChannelReader createBlockChannelReader(Channel.ID channelID, int numRequestsToCombine) 	throws IOException;1410211782;Creates a block channel reader that reads blocks from the given channel. The reader reads asynchronously,_such that a read request is accepted, carried out at some (close) point in time, and the full segment_is pushed to the reader's return queue._<p>_The reader will collect a specified number of read requests and carry them out_in one, effectively reading one block in the size of multiple memory pages._Note that this means that no memory segment will reach the return queue before_the given number of requests are collected, so the number of buffers used with_the reader should be greater than the number of requests to combine. Ideally,_the number of memory segments used is a multiple of the number of requests to_combine.__@param channelID The descriptor for the channel to write to._@param numRequestsToCombine The number of write requests to combine to one I/O request._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BlockChannelReader createBlockChannelReader(Channel.ID channelID, int numRequestsToCombine)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, _			new LinkedBlockingQueue<MemorySegment>(), numRequestsToCombine)__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,reads,asynchronously,such,that,a,read,request,is,accepted,carried,out,at,some,close,point,in,time,and,the,full,segment,is,pushed,to,the,reader,s,return,queue,p,the,reader,will,collect,a,specified,number,of,read,requests,and,carry,them,out,in,one,effectively,reading,one,block,in,the,size,of,multiple,memory,pages,note,that,this,means,that,no,memory,segment,will,reach,the,return,queue,before,the,given,number,of,requests,are,collected,so,the,number,of,buffers,used,with,the,reader,should,be,greater,than,the,number,of,requests,to,combine,ideally,the,number,of,memory,segments,used,is,a,multiple,of,the,number,of,requests,to,combine,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,num,requests,to,combine,the,number,of,write,requests,to,combine,to,one,i,o,request,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,block,channel,reader,create,block,channel,reader,channel,id,channel,id,int,num,requests,to,combine,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,new,linked,blocking,queue,memory,segment,num,requests,to,combine
IOManager -> public BlockChannelReader createBlockChannelReader(Channel.ID channelID, int numRequestsToCombine) 	throws IOException;1411473561;Creates a block channel reader that reads blocks from the given channel. The reader reads asynchronously,_such that a read request is accepted, carried out at some (close) point in time, and the full segment_is pushed to the reader's return queue._<p>_The reader will collect a specified number of read requests and carry them out_in one, effectively reading one block in the size of multiple memory pages._Note that this means that no memory segment will reach the return queue before_the given number of requests are collected, so the number of buffers used with_the reader should be greater than the number of requests to combine. Ideally,_the number of memory segments used is a multiple of the number of requests to_combine.__@param channelID The descriptor for the channel to write to._@param numRequestsToCombine The number of write requests to combine to one I/O request._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BlockChannelReader createBlockChannelReader(Channel.ID channelID, int numRequestsToCombine)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, _			new LinkedBlockingQueue<MemorySegment>(), numRequestsToCombine)__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,reads,asynchronously,such,that,a,read,request,is,accepted,carried,out,at,some,close,point,in,time,and,the,full,segment,is,pushed,to,the,reader,s,return,queue,p,the,reader,will,collect,a,specified,number,of,read,requests,and,carry,them,out,in,one,effectively,reading,one,block,in,the,size,of,multiple,memory,pages,note,that,this,means,that,no,memory,segment,will,reach,the,return,queue,before,the,given,number,of,requests,are,collected,so,the,number,of,buffers,used,with,the,reader,should,be,greater,than,the,number,of,requests,to,combine,ideally,the,number,of,memory,segments,used,is,a,multiple,of,the,number,of,requests,to,combine,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,num,requests,to,combine,the,number,of,write,requests,to,combine,to,one,i,o,request,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,block,channel,reader,create,block,channel,reader,channel,id,channel,id,int,num,requests,to,combine,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,new,linked,blocking,queue,memory,segment,num,requests,to,combine
IOManager -> public Channel.Enumerator createChannelEnumerator();1404155775;Creates a new {@link Channel.Enumerator}, spreading the channels in a round-robin fashion_across the temporary file directories.__@return An enumerator for channels.;public Channel.Enumerator createChannelEnumerator()_	{_		return new Channel.Enumerator(this.paths, this.random)__	};creates,a,new,link,channel,enumerator,spreading,the,channels,in,a,round,robin,fashion,across,the,temporary,file,directories,return,an,enumerator,for,channels;public,channel,enumerator,create,channel,enumerator,return,new,channel,enumerator,this,paths,this,random
IOManager -> public Channel.Enumerator createChannelEnumerator();1404986750;Creates a new {@link Channel.Enumerator}, spreading the channels in a round-robin fashion_across the temporary file directories.__@return An enumerator for channels.;public Channel.Enumerator createChannelEnumerator()_	{_		return new Channel.Enumerator(this.paths, this.random)__	};creates,a,new,link,channel,enumerator,spreading,the,channels,in,a,round,robin,fashion,across,the,temporary,file,directories,return,an,enumerator,for,channels;public,channel,enumerator,create,channel,enumerator,return,new,channel,enumerator,this,paths,this,random
IOManager -> public Channel.Enumerator createChannelEnumerator();1405088715;Creates a new {@link Channel.Enumerator}, spreading the channels in a round-robin fashion_across the temporary file directories.__@return An enumerator for channels.;public Channel.Enumerator createChannelEnumerator()_	{_		return new Channel.Enumerator(this.paths, this.random)__	};creates,a,new,link,channel,enumerator,spreading,the,channels,in,a,round,robin,fashion,across,the,temporary,file,directories,return,an,enumerator,for,channels;public,channel,enumerator,create,channel,enumerator,return,new,channel,enumerator,this,paths,this,random
IOManager -> public Channel.Enumerator createChannelEnumerator();1409222213;Creates a new {@link Channel.Enumerator}, spreading the channels in a round-robin fashion_across the temporary file directories.__@return An enumerator for channels.;public Channel.Enumerator createChannelEnumerator()_	{_		return new Channel.Enumerator(this.paths, this.random)__	};creates,a,new,link,channel,enumerator,spreading,the,channels,in,a,round,robin,fashion,across,the,temporary,file,directories,return,an,enumerator,for,channels;public,channel,enumerator,create,channel,enumerator,return,new,channel,enumerator,this,paths,this,random
IOManager -> public Channel.Enumerator createChannelEnumerator();1410211782;Creates a new {@link Channel.Enumerator}, spreading the channels in a round-robin fashion_across the temporary file directories.__@return An enumerator for channels.;public Channel.Enumerator createChannelEnumerator()_	{_		return new Channel.Enumerator(this.paths, this.random)__	};creates,a,new,link,channel,enumerator,spreading,the,channels,in,a,round,robin,fashion,across,the,temporary,file,directories,return,an,enumerator,for,channels;public,channel,enumerator,create,channel,enumerator,return,new,channel,enumerator,this,paths,this,random
IOManager -> public Channel.Enumerator createChannelEnumerator();1411473561;Creates a new {@link Channel.Enumerator}, spreading the channels in a round-robin fashion_across the temporary file directories.__@return An enumerator for channels.;public Channel.Enumerator createChannelEnumerator()_	{_		return new Channel.Enumerator(this.paths, this.random)__	};creates,a,new,link,channel,enumerator,spreading,the,channels,in,a,round,robin,fashion,across,the,temporary,file,directories,return,an,enumerator,for,channels;public,channel,enumerator,create,channel,enumerator,return,new,channel,enumerator,this,paths,this,random
IOManager -> public FileIOChannel.ID createChannel();1412761231;Creates a new {@link FileIOChannel.ID} in one of the temp directories. Multiple_invocations of this method spread the channels evenly across the different directories.__@return A channel to a temporary directory.;public FileIOChannel.ID createChannel() {_		final int num = getNextPathNum()__		return new FileIOChannel.ID(this.paths[num], num, this.random)__	};creates,a,new,link,file,iochannel,id,in,one,of,the,temp,directories,multiple,invocations,of,this,method,spread,the,channels,evenly,across,the,different,directories,return,a,channel,to,a,temporary,directory;public,file,iochannel,id,create,channel,final,int,num,get,next,path,num,return,new,file,iochannel,id,this,paths,num,num,this,random
IOManager -> public FileIOChannel.ID createChannel();1415382319;Creates a new {@link FileIOChannel.ID} in one of the temp directories. Multiple_invocations of this method spread the channels evenly across the different directories.__@return A channel to a temporary directory.;public FileIOChannel.ID createChannel() {_		final int num = getNextPathNum()__		return new FileIOChannel.ID(this.paths[num], num, this.random)__	};creates,a,new,link,file,iochannel,id,in,one,of,the,temp,directories,multiple,invocations,of,this,method,spread,the,channels,evenly,across,the,different,directories,return,a,channel,to,a,temporary,directory;public,file,iochannel,id,create,channel,final,int,num,get,next,path,num,return,new,file,iochannel,id,this,paths,num,num,this,random
IOManager -> public FileIOChannel.ID createChannel();1417555226;Creates a new {@link FileIOChannel.ID} in one of the temp directories. Multiple_invocations of this method spread the channels evenly across the different directories.__@return A channel to a temporary directory.;public FileIOChannel.ID createChannel() {_		final int num = getNextPathNum()__		return new FileIOChannel.ID(this.paths[num], num, this.random)__	};creates,a,new,link,file,iochannel,id,in,one,of,the,temp,directories,multiple,invocations,of,this,method,spread,the,channels,evenly,across,the,different,directories,return,a,channel,to,a,temporary,directory;public,file,iochannel,id,create,channel,final,int,num,get,next,path,num,return,new,file,iochannel,id,this,paths,num,num,this,random
IOManager -> public FileIOChannel.ID createChannel();1420560668;Creates a new {@link FileIOChannel.ID} in one of the temp directories. Multiple_invocations of this method spread the channels evenly across the different directories.__@return A channel to a temporary directory.;public FileIOChannel.ID createChannel() {_		final int num = getNextPathNum()__		return new FileIOChannel.ID(this.paths[num], num, this.random)__	};creates,a,new,link,file,iochannel,id,in,one,of,the,temp,directories,multiple,invocations,of,this,method,spread,the,channels,evenly,across,the,different,directories,return,a,channel,to,a,temporary,directory;public,file,iochannel,id,create,channel,final,int,num,get,next,path,num,return,new,file,iochannel,id,this,paths,num,num,this,random
IOManager -> public FileIOChannel.ID createChannel();1421771162;Creates a new {@link FileIOChannel.ID} in one of the temp directories. Multiple_invocations of this method spread the channels evenly across the different directories.__@return A channel to a temporary directory.;public FileIOChannel.ID createChannel() {_		final int num = getNextPathNum()__		return new FileIOChannel.ID(this.paths[num], num, this.random)__	};creates,a,new,link,file,iochannel,id,in,one,of,the,temp,directories,multiple,invocations,of,this,method,spread,the,channels,evenly,across,the,different,directories,return,a,channel,to,a,temporary,directory;public,file,iochannel,id,create,channel,final,int,num,get,next,path,num,return,new,file,iochannel,id,this,paths,num,num,this,random
IOManager -> public FileIOChannel.ID createChannel();1424268205;Creates a new {@link FileIOChannel.ID} in one of the temp directories. Multiple_invocations of this method spread the channels evenly across the different directories.__@return A channel to a temporary directory.;public FileIOChannel.ID createChannel() {_		final int num = getNextPathNum()__		return new FileIOChannel.ID(this.paths[num], num, this.random)__	};creates,a,new,link,file,iochannel,id,in,one,of,the,temp,directories,multiple,invocations,of,this,method,spread,the,channels,evenly,across,the,different,directories,return,a,channel,to,a,temporary,directory;public,file,iochannel,id,create,channel,final,int,num,get,next,path,num,return,new,file,iochannel,id,this,paths,num,num,this,random
IOManager -> public FileIOChannel.ID createChannel();1428680960;Creates a new {@link FileIOChannel.ID} in one of the temp directories. Multiple_invocations of this method spread the channels evenly across the different directories.__@return A channel to a temporary directory.;public FileIOChannel.ID createChannel() {_		final int num = getNextPathNum()__		return new FileIOChannel.ID(this.paths[num], num, this.random)__	};creates,a,new,link,file,iochannel,id,in,one,of,the,temp,directories,multiple,invocations,of,this,method,spread,the,channels,evenly,across,the,different,directories,return,a,channel,to,a,temporary,directory;public,file,iochannel,id,create,channel,final,int,num,get,next,path,num,return,new,file,iochannel,id,this,paths,num,num,this,random
IOManager -> public FileIOChannel.ID createChannel();1437929917;Creates a new {@link FileIOChannel.ID} in one of the temp directories. Multiple_invocations of this method spread the channels evenly across the different directories.__@return A channel to a temporary directory.;public FileIOChannel.ID createChannel() {_		final int num = getNextPathNum()__		return new FileIOChannel.ID(this.paths[num], num, this.random)__	};creates,a,new,link,file,iochannel,id,in,one,of,the,temp,directories,multiple,invocations,of,this,method,spread,the,channels,evenly,across,the,different,directories,return,a,channel,to,a,temporary,directory;public,file,iochannel,id,create,channel,final,int,num,get,next,path,num,return,new,file,iochannel,id,this,paths,num,num,this,random
IOManager -> public FileIOChannel.ID createChannel();1441102230;Creates a new {@link FileIOChannel.ID} in one of the temp directories. Multiple_invocations of this method spread the channels evenly across the different directories.__@return A channel to a temporary directory.;public FileIOChannel.ID createChannel() {_		final int num = getNextPathNum()__		return new FileIOChannel.ID(this.paths[num], num, this.random)__	};creates,a,new,link,file,iochannel,id,in,one,of,the,temp,directories,multiple,invocations,of,this,method,spread,the,channels,evenly,across,the,different,directories,return,a,channel,to,a,temporary,directory;public,file,iochannel,id,create,channel,final,int,num,get,next,path,num,return,new,file,iochannel,id,this,paths,num,num,this,random
IOManager -> public FileIOChannel.ID createChannel();1464188671;Creates a new {@link FileIOChannel.ID} in one of the temp directories. Multiple_invocations of this method spread the channels evenly across the different directories.__@return A channel to a temporary directory.;public FileIOChannel.ID createChannel() {_		final int num = getNextPathNum()__		return new FileIOChannel.ID(this.paths[num], num, this.random)__	};creates,a,new,link,file,iochannel,id,in,one,of,the,temp,directories,multiple,invocations,of,this,method,spread,the,channels,evenly,across,the,different,directories,return,a,channel,to,a,temporary,directory;public,file,iochannel,id,create,channel,final,int,num,get,next,path,num,return,new,file,iochannel,id,this,paths,num,num,this,random
IOManager -> public FileIOChannel.ID createChannel();1484214553;Creates a new {@link FileIOChannel.ID} in one of the temp directories. Multiple_invocations of this method spread the channels evenly across the different directories.__@return A channel to a temporary directory.;public FileIOChannel.ID createChannel() {_		final int num = getNextPathNum()__		return new FileIOChannel.ID(this.paths[num], num, this.random)__	};creates,a,new,link,file,iochannel,id,in,one,of,the,temp,directories,multiple,invocations,of,this,method,spread,the,channels,evenly,across,the,different,directories,return,a,channel,to,a,temporary,directory;public,file,iochannel,id,create,channel,final,int,num,get,next,path,num,return,new,file,iochannel,id,this,paths,num,num,this,random
IOManager -> public File[] getSpillingDirectories();1437929917;Gets the directories that the I/O manager spills to.__@return The directories that the I/O manager spills to.;public File[] getSpillingDirectories() {_		return this.paths__	};gets,the,directories,that,the,i,o,manager,spills,to,return,the,directories,that,the,i,o,manager,spills,to;public,file,get,spilling,directories,return,this,paths
IOManager -> public File[] getSpillingDirectories();1441102230;Gets the directories that the I/O manager spills to.__@return The directories that the I/O manager spills to.;public File[] getSpillingDirectories() {_		return this.paths__	};gets,the,directories,that,the,i,o,manager,spills,to,return,the,directories,that,the,i,o,manager,spills,to;public,file,get,spilling,directories,return,this,paths
IOManager -> public File[] getSpillingDirectories();1464188671;Gets the directories that the I/O manager spills to.__@return The directories that the I/O manager spills to.;public File[] getSpillingDirectories() {_		return this.paths__	};gets,the,directories,that,the,i,o,manager,spills,to,return,the,directories,that,the,i,o,manager,spills,to;public,file,get,spilling,directories,return,this,paths
IOManager -> public File[] getSpillingDirectories();1484214553;Gets the directories that the I/O manager spills to.__@return The directories that the I/O manager spills to.;public File[] getSpillingDirectories() {_		return this.paths__	};gets,the,directories,that,the,i,o,manager,spills,to,return,the,directories,that,the,i,o,manager,spills,to;public,file,get,spilling,directories,return,this,paths
IOManager -> public String[] getSpillingDirectoriesPaths();1464188671;Gets the directories that the I/O manager spills to, as path strings.__@return The directories that the I/O manager spills to, as path strings.;public String[] getSpillingDirectoriesPaths() {_		String[] strings = new String[this.paths.length]__		for (int i = 0_ i < strings.length_ i++) {_			strings[i] = paths[i].getAbsolutePath()__		}_		return strings__	};gets,the,directories,that,the,i,o,manager,spills,to,as,path,strings,return,the,directories,that,the,i,o,manager,spills,to,as,path,strings;public,string,get,spilling,directories,paths,string,strings,new,string,this,paths,length,for,int,i,0,i,strings,length,i,strings,i,paths,i,get,absolute,path,return,strings
IOManager -> public String[] getSpillingDirectoriesPaths();1484214553;Gets the directories that the I/O manager spills to, as path strings.__@return The directories that the I/O manager spills to, as path strings.;public String[] getSpillingDirectoriesPaths() {_		String[] strings = new String[this.paths.length]__		for (int i = 0_ i < strings.length_ i++) {_			strings[i] = paths[i].getAbsolutePath()__		}_		return strings__	};gets,the,directories,that,the,i,o,manager,spills,to,as,path,strings,return,the,directories,that,the,i,o,manager,spills,to,as,path,strings;public,string,get,spilling,directories,paths,string,strings,new,string,this,paths,length,for,int,i,0,i,strings,length,i,strings,i,paths,i,get,absolute,path,return,strings
IOManager -> public BlockChannelReader createBlockChannelReader(Channel.ID channelID) 	throws IOException;1404155775;Creates a block channel reader that reads blocks from the given channel. The reader reads asynchronously,_such that a read request is accepted, carried out at some (close) point in time, and the full segment_is pushed to the reader's return queue.__@param channelID The descriptor for the channel to write to._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BlockChannelReader createBlockChannelReader(Channel.ID channelID)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, new LinkedBlockingQueue<MemorySegment>(), 1)__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,reads,asynchronously,such,that,a,read,request,is,accepted,carried,out,at,some,close,point,in,time,and,the,full,segment,is,pushed,to,the,reader,s,return,queue,param,channel,id,the,descriptor,for,the,channel,to,write,to,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,block,channel,reader,create,block,channel,reader,channel,id,channel,id,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,new,linked,blocking,queue,memory,segment,1
IOManager -> public BlockChannelReader createBlockChannelReader(Channel.ID channelID) 	throws IOException;1404986750;Creates a block channel reader that reads blocks from the given channel. The reader reads asynchronously,_such that a read request is accepted, carried out at some (close) point in time, and the full segment_is pushed to the reader's return queue.__@param channelID The descriptor for the channel to write to._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BlockChannelReader createBlockChannelReader(Channel.ID channelID)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, new LinkedBlockingQueue<MemorySegment>(), 1)__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,reads,asynchronously,such,that,a,read,request,is,accepted,carried,out,at,some,close,point,in,time,and,the,full,segment,is,pushed,to,the,reader,s,return,queue,param,channel,id,the,descriptor,for,the,channel,to,write,to,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,block,channel,reader,create,block,channel,reader,channel,id,channel,id,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,new,linked,blocking,queue,memory,segment,1
IOManager -> public BlockChannelReader createBlockChannelReader(Channel.ID channelID) 	throws IOException;1405088715;Creates a block channel reader that reads blocks from the given channel. The reader reads asynchronously,_such that a read request is accepted, carried out at some (close) point in time, and the full segment_is pushed to the reader's return queue.__@param channelID The descriptor for the channel to write to._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BlockChannelReader createBlockChannelReader(Channel.ID channelID)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, new LinkedBlockingQueue<MemorySegment>(), 1)__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,reads,asynchronously,such,that,a,read,request,is,accepted,carried,out,at,some,close,point,in,time,and,the,full,segment,is,pushed,to,the,reader,s,return,queue,param,channel,id,the,descriptor,for,the,channel,to,write,to,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,block,channel,reader,create,block,channel,reader,channel,id,channel,id,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,new,linked,blocking,queue,memory,segment,1
IOManager -> public BlockChannelReader createBlockChannelReader(Channel.ID channelID) 	throws IOException;1409222213;Creates a block channel reader that reads blocks from the given channel. The reader reads asynchronously,_such that a read request is accepted, carried out at some (close) point in time, and the full segment_is pushed to the reader's return queue.__@param channelID The descriptor for the channel to write to._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BlockChannelReader createBlockChannelReader(Channel.ID channelID)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, new LinkedBlockingQueue<MemorySegment>(), 1)__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,reads,asynchronously,such,that,a,read,request,is,accepted,carried,out,at,some,close,point,in,time,and,the,full,segment,is,pushed,to,the,reader,s,return,queue,param,channel,id,the,descriptor,for,the,channel,to,write,to,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,block,channel,reader,create,block,channel,reader,channel,id,channel,id,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,new,linked,blocking,queue,memory,segment,1
IOManager -> public BlockChannelReader createBlockChannelReader(Channel.ID channelID) 	throws IOException;1410211782;Creates a block channel reader that reads blocks from the given channel. The reader reads asynchronously,_such that a read request is accepted, carried out at some (close) point in time, and the full segment_is pushed to the reader's return queue.__@param channelID The descriptor for the channel to write to._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BlockChannelReader createBlockChannelReader(Channel.ID channelID)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, new LinkedBlockingQueue<MemorySegment>(), 1)__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,reads,asynchronously,such,that,a,read,request,is,accepted,carried,out,at,some,close,point,in,time,and,the,full,segment,is,pushed,to,the,reader,s,return,queue,param,channel,id,the,descriptor,for,the,channel,to,write,to,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,block,channel,reader,create,block,channel,reader,channel,id,channel,id,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,new,linked,blocking,queue,memory,segment,1
IOManager -> public BlockChannelReader createBlockChannelReader(Channel.ID channelID) 	throws IOException;1411473561;Creates a block channel reader that reads blocks from the given channel. The reader reads asynchronously,_such that a read request is accepted, carried out at some (close) point in time, and the full segment_is pushed to the reader's return queue.__@param channelID The descriptor for the channel to write to._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BlockChannelReader createBlockChannelReader(Channel.ID channelID)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, new LinkedBlockingQueue<MemorySegment>(), 1)__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,reads,asynchronously,such,that,a,read,request,is,accepted,carried,out,at,some,close,point,in,time,and,the,full,segment,is,pushed,to,the,reader,s,return,queue,param,channel,id,the,descriptor,for,the,channel,to,write,to,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,block,channel,reader,create,block,channel,reader,channel,id,channel,id,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,new,linked,blocking,queue,memory,segment,1
IOManager -> WriterThread -> protected void shutdown();1404155775;Shuts the thread down. This operation does not wait for all pending requests to be served, halts the thread_immediately. All buffers of pending requests are handed back to their channel writers and an exception is_reported to them, declaring their request queue as closed.;protected void shutdown()_		{_			if (this.alive) {_				_				try {_					this.alive = false__					this.requestQueue.close()__					this.interrupt()__				}_				catch (Throwable t) {}_				_				_				IOException ioex = new IOException("Writer thread has been closed.")__				_				while (!this.requestQueue.isEmpty())_				{_					WriteRequest request = this.requestQueue.poll()__					request.requestDone(ioex)__				}_			}_		};shuts,the,thread,down,this,operation,does,not,wait,for,all,pending,requests,to,be,served,halts,the,thread,immediately,all,buffers,of,pending,requests,are,handed,back,to,their,channel,writers,and,an,exception,is,reported,to,them,declaring,their,request,queue,as,closed;protected,void,shutdown,if,this,alive,try,this,alive,false,this,request,queue,close,this,interrupt,catch,throwable,t,ioexception,ioex,new,ioexception,writer,thread,has,been,closed,while,this,request,queue,is,empty,write,request,request,this,request,queue,poll,request,request,done,ioex
IOManager -> WriterThread -> protected void shutdown();1404986750;Shuts the thread down. This operation does not wait for all pending requests to be served, halts the thread_immediately. All buffers of pending requests are handed back to their channel writers and an exception is_reported to them, declaring their request queue as closed.;protected void shutdown()_		{_			if (this.alive) {_				_				try {_					this.alive = false__					this.requestQueue.close()__					this.interrupt()__				}_				catch (Throwable t) {}_				_				_				IOException ioex = new IOException("Writer thread has been closed.")__				_				while (!this.requestQueue.isEmpty())_				{_					WriteRequest request = this.requestQueue.poll()__					request.requestDone(ioex)__				}_			}_		};shuts,the,thread,down,this,operation,does,not,wait,for,all,pending,requests,to,be,served,halts,the,thread,immediately,all,buffers,of,pending,requests,are,handed,back,to,their,channel,writers,and,an,exception,is,reported,to,them,declaring,their,request,queue,as,closed;protected,void,shutdown,if,this,alive,try,this,alive,false,this,request,queue,close,this,interrupt,catch,throwable,t,ioexception,ioex,new,ioexception,writer,thread,has,been,closed,while,this,request,queue,is,empty,write,request,request,this,request,queue,poll,request,request,done,ioex
IOManager -> WriterThread -> protected void shutdown();1405088715;Shuts the thread down. This operation does not wait for all pending requests to be served, halts the thread_immediately. All buffers of pending requests are handed back to their channel writers and an exception is_reported to them, declaring their request queue as closed.;protected void shutdown()_		{_			if (this.alive) {_				_				try {_					this.alive = false__					this.requestQueue.close()__					this.interrupt()__				}_				catch (Throwable t) {}_				_				_				IOException ioex = new IOException("Writer thread has been closed.")__				_				while (!this.requestQueue.isEmpty())_				{_					WriteRequest request = this.requestQueue.poll()__					request.requestDone(ioex)__				}_			}_		};shuts,the,thread,down,this,operation,does,not,wait,for,all,pending,requests,to,be,served,halts,the,thread,immediately,all,buffers,of,pending,requests,are,handed,back,to,their,channel,writers,and,an,exception,is,reported,to,them,declaring,their,request,queue,as,closed;protected,void,shutdown,if,this,alive,try,this,alive,false,this,request,queue,close,this,interrupt,catch,throwable,t,ioexception,ioex,new,ioexception,writer,thread,has,been,closed,while,this,request,queue,is,empty,write,request,request,this,request,queue,poll,request,request,done,ioex
IOManager -> WriterThread -> protected void shutdown();1409222213;Shuts the thread down. This operation does not wait for all pending requests to be served, halts the thread_immediately. All buffers of pending requests are handed back to their channel writers and an exception is_reported to them, declaring their request queue as closed.;protected void shutdown()_		{_			if (this.alive) {_				_				try {_					this.alive = false__					this.requestQueue.close()__					this.interrupt()__				}_				catch (Throwable t) {}_				_				_				IOException ioex = new IOException("Writer thread has been closed.")__				_				while (!this.requestQueue.isEmpty())_				{_					WriteRequest request = this.requestQueue.poll()__					request.requestDone(ioex)__				}_			}_		};shuts,the,thread,down,this,operation,does,not,wait,for,all,pending,requests,to,be,served,halts,the,thread,immediately,all,buffers,of,pending,requests,are,handed,back,to,their,channel,writers,and,an,exception,is,reported,to,them,declaring,their,request,queue,as,closed;protected,void,shutdown,if,this,alive,try,this,alive,false,this,request,queue,close,this,interrupt,catch,throwable,t,ioexception,ioex,new,ioexception,writer,thread,has,been,closed,while,this,request,queue,is,empty,write,request,request,this,request,queue,poll,request,request,done,ioex
IOManager -> WriterThread -> protected void shutdown();1410211782;Shuts the thread down. This operation does not wait for all pending requests to be served, halts the thread_immediately. All buffers of pending requests are handed back to their channel writers and an exception is_reported to them, declaring their request queue as closed.;protected void shutdown()_		{_			if (this.alive) {_				_				try {_					this.alive = false__					this.requestQueue.close()__					this.interrupt()__				}_				catch (Throwable t) {}_				_				_				IOException ioex = new IOException("Writer thread has been closed.")__				_				while (!this.requestQueue.isEmpty())_				{_					WriteRequest request = this.requestQueue.poll()__					request.requestDone(ioex)__				}_			}_		};shuts,the,thread,down,this,operation,does,not,wait,for,all,pending,requests,to,be,served,halts,the,thread,immediately,all,buffers,of,pending,requests,are,handed,back,to,their,channel,writers,and,an,exception,is,reported,to,them,declaring,their,request,queue,as,closed;protected,void,shutdown,if,this,alive,try,this,alive,false,this,request,queue,close,this,interrupt,catch,throwable,t,ioexception,ioex,new,ioexception,writer,thread,has,been,closed,while,this,request,queue,is,empty,write,request,request,this,request,queue,poll,request,request,done,ioex
IOManager -> WriterThread -> protected void shutdown();1411473561;Shuts the thread down. This operation does not wait for all pending requests to be served, halts the thread_immediately. All buffers of pending requests are handed back to their channel writers and an exception is_reported to them, declaring their request queue as closed.;protected void shutdown()_		{_			if (this.alive) {_				_				try {_					this.alive = false__					this.requestQueue.close()__					this.interrupt()__				}_				catch (Throwable t) {}_				_				_				IOException ioex = new IOException("Writer thread has been closed.")__				_				while (!this.requestQueue.isEmpty())_				{_					WriteRequest request = this.requestQueue.poll()__					request.requestDone(ioex)__				}_			}_		};shuts,the,thread,down,this,operation,does,not,wait,for,all,pending,requests,to,be,served,halts,the,thread,immediately,all,buffers,of,pending,requests,are,handed,back,to,their,channel,writers,and,an,exception,is,reported,to,them,declaring,their,request,queue,as,closed;protected,void,shutdown,if,this,alive,try,this,alive,false,this,request,queue,close,this,interrupt,catch,throwable,t,ioexception,ioex,new,ioexception,writer,thread,has,been,closed,while,this,request,queue,is,empty,write,request,request,this,request,queue,poll,request,request,done,ioex
IOManager -> public abstract BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID, 			List<MemorySegment> targetSegments, int numBlocks) throws IOException_;1412761231;Creates a block channel reader that reads all blocks from the given channel directly in one bulk._The reader draws segments to read the blocks into from a supplied list, which must contain as many_segments as the channel has blocks. After the reader is done, the list with the full segments can be_obtained from the reader._<p>_If a channel is not to be read in one bulk, but in multiple smaller batches, a_{@link BlockChannelReader} should be used.__@param channelID The descriptor for the channel to write to._@param targetSegments The list to take the segments from into which to read the data._@param numBlocks The number of blocks in the channel to read._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public abstract BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID,_			List<MemorySegment> targetSegments, int numBlocks) throws IOException_;creates,a,block,channel,reader,that,reads,all,blocks,from,the,given,channel,directly,in,one,bulk,the,reader,draws,segments,to,read,the,blocks,into,from,a,supplied,list,which,must,contain,as,many,segments,as,the,channel,has,blocks,after,the,reader,is,done,the,list,with,the,full,segments,can,be,obtained,from,the,reader,p,if,a,channel,is,not,to,be,read,in,one,bulk,but,in,multiple,smaller,batches,a,link,block,channel,reader,should,be,used,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,target,segments,the,list,to,take,the,segments,from,into,which,to,read,the,data,param,num,blocks,the,number,of,blocks,in,the,channel,to,read,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,abstract,bulk,block,channel,reader,create,bulk,block,channel,reader,file,iochannel,id,channel,id,list,memory,segment,target,segments,int,num,blocks,throws,ioexception
IOManager -> public abstract BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID, 			List<MemorySegment> targetSegments, int numBlocks) throws IOException_;1417555226;Creates a block channel reader that reads all blocks from the given channel directly in one bulk._The reader draws segments to read the blocks into from a supplied list, which must contain as many_segments as the channel has blocks. After the reader is done, the list with the full segments can be_obtained from the reader._<p>_If a channel is not to be read in one bulk, but in multiple smaller batches, a_{@link BlockChannelReader} should be used.__@param channelID The descriptor for the channel to write to._@param targetSegments The list to take the segments from into which to read the data._@param numBlocks The number of blocks in the channel to read._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public abstract BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID,_			List<MemorySegment> targetSegments, int numBlocks) throws IOException_;creates,a,block,channel,reader,that,reads,all,blocks,from,the,given,channel,directly,in,one,bulk,the,reader,draws,segments,to,read,the,blocks,into,from,a,supplied,list,which,must,contain,as,many,segments,as,the,channel,has,blocks,after,the,reader,is,done,the,list,with,the,full,segments,can,be,obtained,from,the,reader,p,if,a,channel,is,not,to,be,read,in,one,bulk,but,in,multiple,smaller,batches,a,link,block,channel,reader,should,be,used,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,target,segments,the,list,to,take,the,segments,from,into,which,to,read,the,data,param,num,blocks,the,number,of,blocks,in,the,channel,to,read,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,abstract,bulk,block,channel,reader,create,bulk,block,channel,reader,file,iochannel,id,channel,id,list,memory,segment,target,segments,int,num,blocks,throws,ioexception
IOManager -> public abstract BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID, 			List<MemorySegment> targetSegments, int numBlocks) throws IOException_;1420560668;Creates a block channel reader that reads all blocks from the given channel directly in one bulk._The reader draws segments to read the blocks into from a supplied list, which must contain as many_segments as the channel has blocks. After the reader is done, the list with the full segments can be_obtained from the reader._<p>_If a channel is not to be read in one bulk, but in multiple smaller batches, a_{@link BlockChannelReader} should be used.__@param channelID The descriptor for the channel to write to._@param targetSegments The list to take the segments from into which to read the data._@param numBlocks The number of blocks in the channel to read._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public abstract BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID,_			List<MemorySegment> targetSegments, int numBlocks) throws IOException_;creates,a,block,channel,reader,that,reads,all,blocks,from,the,given,channel,directly,in,one,bulk,the,reader,draws,segments,to,read,the,blocks,into,from,a,supplied,list,which,must,contain,as,many,segments,as,the,channel,has,blocks,after,the,reader,is,done,the,list,with,the,full,segments,can,be,obtained,from,the,reader,p,if,a,channel,is,not,to,be,read,in,one,bulk,but,in,multiple,smaller,batches,a,link,block,channel,reader,should,be,used,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,target,segments,the,list,to,take,the,segments,from,into,which,to,read,the,data,param,num,blocks,the,number,of,blocks,in,the,channel,to,read,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,abstract,bulk,block,channel,reader,create,bulk,block,channel,reader,file,iochannel,id,channel,id,list,memory,segment,target,segments,int,num,blocks,throws,ioexception
IOManager -> public abstract BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID, 			List<MemorySegment> targetSegments, int numBlocks) throws IOException_;1421771162;Creates a block channel reader that reads all blocks from the given channel directly in one bulk._The reader draws segments to read the blocks into from a supplied list, which must contain as many_segments as the channel has blocks. After the reader is done, the list with the full segments can be_obtained from the reader._<p>_If a channel is not to be read in one bulk, but in multiple smaller batches, a_{@link BlockChannelReader} should be used.__@param channelID The descriptor for the channel to write to._@param targetSegments The list to take the segments from into which to read the data._@param numBlocks The number of blocks in the channel to read._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public abstract BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID,_			List<MemorySegment> targetSegments, int numBlocks) throws IOException_;creates,a,block,channel,reader,that,reads,all,blocks,from,the,given,channel,directly,in,one,bulk,the,reader,draws,segments,to,read,the,blocks,into,from,a,supplied,list,which,must,contain,as,many,segments,as,the,channel,has,blocks,after,the,reader,is,done,the,list,with,the,full,segments,can,be,obtained,from,the,reader,p,if,a,channel,is,not,to,be,read,in,one,bulk,but,in,multiple,smaller,batches,a,link,block,channel,reader,should,be,used,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,target,segments,the,list,to,take,the,segments,from,into,which,to,read,the,data,param,num,blocks,the,number,of,blocks,in,the,channel,to,read,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,abstract,bulk,block,channel,reader,create,bulk,block,channel,reader,file,iochannel,id,channel,id,list,memory,segment,target,segments,int,num,blocks,throws,ioexception
IOManager -> public abstract BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID, 			List<MemorySegment> targetSegments, int numBlocks) throws IOException_;1424268205;Creates a block channel reader that reads all blocks from the given channel directly in one bulk._The reader draws segments to read the blocks into from a supplied list, which must contain as many_segments as the channel has blocks. After the reader is done, the list with the full segments can be_obtained from the reader._<p>_If a channel is not to be read in one bulk, but in multiple smaller batches, a_{@link BlockChannelReader} should be used.__@param channelID The descriptor for the channel to write to._@param targetSegments The list to take the segments from into which to read the data._@param numBlocks The number of blocks in the channel to read._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public abstract BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID,_			List<MemorySegment> targetSegments, int numBlocks) throws IOException_;creates,a,block,channel,reader,that,reads,all,blocks,from,the,given,channel,directly,in,one,bulk,the,reader,draws,segments,to,read,the,blocks,into,from,a,supplied,list,which,must,contain,as,many,segments,as,the,channel,has,blocks,after,the,reader,is,done,the,list,with,the,full,segments,can,be,obtained,from,the,reader,p,if,a,channel,is,not,to,be,read,in,one,bulk,but,in,multiple,smaller,batches,a,link,block,channel,reader,should,be,used,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,target,segments,the,list,to,take,the,segments,from,into,which,to,read,the,data,param,num,blocks,the,number,of,blocks,in,the,channel,to,read,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,abstract,bulk,block,channel,reader,create,bulk,block,channel,reader,file,iochannel,id,channel,id,list,memory,segment,target,segments,int,num,blocks,throws,ioexception
IOManager -> public abstract BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID, 			List<MemorySegment> targetSegments, int numBlocks) throws IOException_;1428680960;Creates a block channel reader that reads all blocks from the given channel directly in one bulk._The reader draws segments to read the blocks into from a supplied list, which must contain as many_segments as the channel has blocks. After the reader is done, the list with the full segments can be_obtained from the reader._<p>_If a channel is not to be read in one bulk, but in multiple smaller batches, a_{@link BlockChannelReader} should be used.__@param channelID The descriptor for the channel to write to._@param targetSegments The list to take the segments from into which to read the data._@param numBlocks The number of blocks in the channel to read._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public abstract BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID,_			List<MemorySegment> targetSegments, int numBlocks) throws IOException_;creates,a,block,channel,reader,that,reads,all,blocks,from,the,given,channel,directly,in,one,bulk,the,reader,draws,segments,to,read,the,blocks,into,from,a,supplied,list,which,must,contain,as,many,segments,as,the,channel,has,blocks,after,the,reader,is,done,the,list,with,the,full,segments,can,be,obtained,from,the,reader,p,if,a,channel,is,not,to,be,read,in,one,bulk,but,in,multiple,smaller,batches,a,link,block,channel,reader,should,be,used,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,target,segments,the,list,to,take,the,segments,from,into,which,to,read,the,data,param,num,blocks,the,number,of,blocks,in,the,channel,to,read,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,abstract,bulk,block,channel,reader,create,bulk,block,channel,reader,file,iochannel,id,channel,id,list,memory,segment,target,segments,int,num,blocks,throws,ioexception
IOManager -> public abstract BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID, 			List<MemorySegment> targetSegments, int numBlocks) throws IOException_;1437929917;Creates a block channel reader that reads all blocks from the given channel directly in one bulk._The reader draws segments to read the blocks into from a supplied list, which must contain as many_segments as the channel has blocks. After the reader is done, the list with the full segments can be_obtained from the reader._<p>_If a channel is not to be read in one bulk, but in multiple smaller batches, a_{@link BlockChannelReader} should be used.__@param channelID The descriptor for the channel to write to._@param targetSegments The list to take the segments from into which to read the data._@param numBlocks The number of blocks in the channel to read._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public abstract BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID,_			List<MemorySegment> targetSegments, int numBlocks) throws IOException_;creates,a,block,channel,reader,that,reads,all,blocks,from,the,given,channel,directly,in,one,bulk,the,reader,draws,segments,to,read,the,blocks,into,from,a,supplied,list,which,must,contain,as,many,segments,as,the,channel,has,blocks,after,the,reader,is,done,the,list,with,the,full,segments,can,be,obtained,from,the,reader,p,if,a,channel,is,not,to,be,read,in,one,bulk,but,in,multiple,smaller,batches,a,link,block,channel,reader,should,be,used,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,target,segments,the,list,to,take,the,segments,from,into,which,to,read,the,data,param,num,blocks,the,number,of,blocks,in,the,channel,to,read,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,abstract,bulk,block,channel,reader,create,bulk,block,channel,reader,file,iochannel,id,channel,id,list,memory,segment,target,segments,int,num,blocks,throws,ioexception
IOManager -> public abstract BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID, 			List<MemorySegment> targetSegments, int numBlocks) throws IOException_;1441102230;Creates a block channel reader that reads all blocks from the given channel directly in one bulk._The reader draws segments to read the blocks into from a supplied list, which must contain as many_segments as the channel has blocks. After the reader is done, the list with the full segments can be_obtained from the reader._<p>_If a channel is not to be read in one bulk, but in multiple smaller batches, a_{@link BlockChannelReader} should be used.__@param channelID The descriptor for the channel to write to._@param targetSegments The list to take the segments from into which to read the data._@param numBlocks The number of blocks in the channel to read._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public abstract BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID,_			List<MemorySegment> targetSegments, int numBlocks) throws IOException_;creates,a,block,channel,reader,that,reads,all,blocks,from,the,given,channel,directly,in,one,bulk,the,reader,draws,segments,to,read,the,blocks,into,from,a,supplied,list,which,must,contain,as,many,segments,as,the,channel,has,blocks,after,the,reader,is,done,the,list,with,the,full,segments,can,be,obtained,from,the,reader,p,if,a,channel,is,not,to,be,read,in,one,bulk,but,in,multiple,smaller,batches,a,link,block,channel,reader,should,be,used,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,target,segments,the,list,to,take,the,segments,from,into,which,to,read,the,data,param,num,blocks,the,number,of,blocks,in,the,channel,to,read,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,abstract,bulk,block,channel,reader,create,bulk,block,channel,reader,file,iochannel,id,channel,id,list,memory,segment,target,segments,int,num,blocks,throws,ioexception
IOManager -> public abstract BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID, 			List<MemorySegment> targetSegments, int numBlocks) throws IOException_;1464188671;Creates a block channel reader that reads all blocks from the given channel directly in one bulk._The reader draws segments to read the blocks into from a supplied list, which must contain as many_segments as the channel has blocks. After the reader is done, the list with the full segments can be_obtained from the reader._<p>_If a channel is not to be read in one bulk, but in multiple smaller batches, a_{@link BlockChannelReader} should be used.__@param channelID The descriptor for the channel to write to._@param targetSegments The list to take the segments from into which to read the data._@param numBlocks The number of blocks in the channel to read._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public abstract BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID,_			List<MemorySegment> targetSegments, int numBlocks) throws IOException_;creates,a,block,channel,reader,that,reads,all,blocks,from,the,given,channel,directly,in,one,bulk,the,reader,draws,segments,to,read,the,blocks,into,from,a,supplied,list,which,must,contain,as,many,segments,as,the,channel,has,blocks,after,the,reader,is,done,the,list,with,the,full,segments,can,be,obtained,from,the,reader,p,if,a,channel,is,not,to,be,read,in,one,bulk,but,in,multiple,smaller,batches,a,link,block,channel,reader,should,be,used,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,target,segments,the,list,to,take,the,segments,from,into,which,to,read,the,data,param,num,blocks,the,number,of,blocks,in,the,channel,to,read,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,abstract,bulk,block,channel,reader,create,bulk,block,channel,reader,file,iochannel,id,channel,id,list,memory,segment,target,segments,int,num,blocks,throws,ioexception
IOManager -> public abstract BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID, 			List<MemorySegment> targetSegments, int numBlocks) throws IOException_;1484214553;Creates a block channel reader that reads all blocks from the given channel directly in one bulk._The reader draws segments to read the blocks into from a supplied list, which must contain as many_segments as the channel has blocks. After the reader is done, the list with the full segments can be_obtained from the reader._<p>_If a channel is not to be read in one bulk, but in multiple smaller batches, a_{@link BlockChannelReader} should be used.__@param channelID The descriptor for the channel to write to._@param targetSegments The list to take the segments from into which to read the data._@param numBlocks The number of blocks in the channel to read._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public abstract BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID,_			List<MemorySegment> targetSegments, int numBlocks) throws IOException_;creates,a,block,channel,reader,that,reads,all,blocks,from,the,given,channel,directly,in,one,bulk,the,reader,draws,segments,to,read,the,blocks,into,from,a,supplied,list,which,must,contain,as,many,segments,as,the,channel,has,blocks,after,the,reader,is,done,the,list,with,the,full,segments,can,be,obtained,from,the,reader,p,if,a,channel,is,not,to,be,read,in,one,bulk,but,in,multiple,smaller,batches,a,link,block,channel,reader,should,be,used,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,target,segments,the,list,to,take,the,segments,from,into,which,to,read,the,data,param,num,blocks,the,number,of,blocks,in,the,channel,to,read,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,abstract,bulk,block,channel,reader,create,bulk,block,channel,reader,file,iochannel,id,channel,id,list,memory,segment,target,segments,int,num,blocks,throws,ioexception
IOManager -> public int getNumberOfTempDirs();1417555226;Gets the number of directories across which the I/O manager rotates its files.__@return The number of temporary file directories.;public int getNumberOfTempDirs() {_		return this.paths.length__	};gets,the,number,of,directories,across,which,the,i,o,manager,rotates,its,files,return,the,number,of,temporary,file,directories;public,int,get,number,of,temp,dirs,return,this,paths,length
IOManager -> public int getNumberOfTempDirs();1420560668;Gets the number of directories across which the I/O manager rotates its files.__@return The number of temporary file directories.;public int getNumberOfTempDirs() {_		return this.paths.length__	};gets,the,number,of,directories,across,which,the,i,o,manager,rotates,its,files,return,the,number,of,temporary,file,directories;public,int,get,number,of,temp,dirs,return,this,paths,length
IOManager -> public int getNumberOfTempDirs();1421771162;Gets the number of directories across which the I/O manager rotates its files.__@return The number of temporary file directories.;public int getNumberOfTempDirs() {_		return this.paths.length__	};gets,the,number,of,directories,across,which,the,i,o,manager,rotates,its,files,return,the,number,of,temporary,file,directories;public,int,get,number,of,temp,dirs,return,this,paths,length
IOManager -> public int getNumberOfTempDirs();1424268205;Gets the number of directories across which the I/O manager rotates its files.__@return The number of temporary file directories.;public int getNumberOfTempDirs() {_		return this.paths.length__	};gets,the,number,of,directories,across,which,the,i,o,manager,rotates,its,files,return,the,number,of,temporary,file,directories;public,int,get,number,of,temp,dirs,return,this,paths,length
IOManager -> public int getNumberOfTempDirs();1428680960;Gets the number of directories across which the I/O manager rotates its files.__@return The number of temporary file directories.;public int getNumberOfTempDirs() {_		return this.paths.length__	};gets,the,number,of,directories,across,which,the,i,o,manager,rotates,its,files,return,the,number,of,temporary,file,directories;public,int,get,number,of,temp,dirs,return,this,paths,length
IOManager -> public final boolean isProperlyShutDown();1404155775;Utility method to check whether the IO manager has been properly shut down. The IO manager is considered_to be properly shut down when it is closed and its threads have ceased operation.__@return True, if the IO manager has properly shut down, false otherwise.;public final boolean isProperlyShutDown()_	{_		boolean readersShutDown = true__		for (int i = 0_ i < this.readers.length_ i++) {_			readersShutDown &= this.readers[i].getState() == Thread.State.TERMINATED__		}_		_		boolean writersShutDown = true__		for (int i = 0_ i < this.writers.length_ i++) {_			readersShutDown &= this.writers[i].getState() == Thread.State.TERMINATED__		}_		_		return this.isClosed && writersShutDown && readersShutDown__	};utility,method,to,check,whether,the,io,manager,has,been,properly,shut,down,the,io,manager,is,considered,to,be,properly,shut,down,when,it,is,closed,and,its,threads,have,ceased,operation,return,true,if,the,io,manager,has,properly,shut,down,false,otherwise;public,final,boolean,is,properly,shut,down,boolean,readers,shut,down,true,for,int,i,0,i,this,readers,length,i,readers,shut,down,this,readers,i,get,state,thread,state,terminated,boolean,writers,shut,down,true,for,int,i,0,i,this,writers,length,i,readers,shut,down,this,writers,i,get,state,thread,state,terminated,return,this,is,closed,writers,shut,down,readers,shut,down
IOManager -> public final boolean isProperlyShutDown();1404986750;Utility method to check whether the IO manager has been properly shut down. The IO manager is considered_to be properly shut down when it is closed and its threads have ceased operation.__@return True, if the IO manager has properly shut down, false otherwise.;public final boolean isProperlyShutDown()_	{_		boolean readersShutDown = true__		for (int i = 0_ i < this.readers.length_ i++) {_			readersShutDown &= this.readers[i].getState() == Thread.State.TERMINATED__		}_		_		boolean writersShutDown = true__		for (int i = 0_ i < this.writers.length_ i++) {_			readersShutDown &= this.writers[i].getState() == Thread.State.TERMINATED__		}_		_		return this.isClosed && writersShutDown && readersShutDown__	};utility,method,to,check,whether,the,io,manager,has,been,properly,shut,down,the,io,manager,is,considered,to,be,properly,shut,down,when,it,is,closed,and,its,threads,have,ceased,operation,return,true,if,the,io,manager,has,properly,shut,down,false,otherwise;public,final,boolean,is,properly,shut,down,boolean,readers,shut,down,true,for,int,i,0,i,this,readers,length,i,readers,shut,down,this,readers,i,get,state,thread,state,terminated,boolean,writers,shut,down,true,for,int,i,0,i,this,writers,length,i,readers,shut,down,this,writers,i,get,state,thread,state,terminated,return,this,is,closed,writers,shut,down,readers,shut,down
IOManager -> public final boolean isProperlyShutDown();1405088715;Utility method to check whether the IO manager has been properly shut down. The IO manager is considered_to be properly shut down when it is closed and its threads have ceased operation.__@return True, if the IO manager has properly shut down, false otherwise.;public final boolean isProperlyShutDown()_	{_		boolean readersShutDown = true__		for (int i = 0_ i < this.readers.length_ i++) {_			readersShutDown &= this.readers[i].getState() == Thread.State.TERMINATED__		}_		_		boolean writersShutDown = true__		for (int i = 0_ i < this.writers.length_ i++) {_			readersShutDown &= this.writers[i].getState() == Thread.State.TERMINATED__		}_		_		return this.isClosed && writersShutDown && readersShutDown__	};utility,method,to,check,whether,the,io,manager,has,been,properly,shut,down,the,io,manager,is,considered,to,be,properly,shut,down,when,it,is,closed,and,its,threads,have,ceased,operation,return,true,if,the,io,manager,has,properly,shut,down,false,otherwise;public,final,boolean,is,properly,shut,down,boolean,readers,shut,down,true,for,int,i,0,i,this,readers,length,i,readers,shut,down,this,readers,i,get,state,thread,state,terminated,boolean,writers,shut,down,true,for,int,i,0,i,this,writers,length,i,readers,shut,down,this,writers,i,get,state,thread,state,terminated,return,this,is,closed,writers,shut,down,readers,shut,down
IOManager -> public final boolean isProperlyShutDown();1409222213;Utility method to check whether the IO manager has been properly shut down. The IO manager is considered_to be properly shut down when it is closed and its threads have ceased operation.__@return True, if the IO manager has properly shut down, false otherwise.;public final boolean isProperlyShutDown()_	{_		boolean readersShutDown = true__		for (int i = 0_ i < this.readers.length_ i++) {_			readersShutDown &= this.readers[i].getState() == Thread.State.TERMINATED__		}_		_		boolean writersShutDown = true__		for (int i = 0_ i < this.writers.length_ i++) {_			readersShutDown &= this.writers[i].getState() == Thread.State.TERMINATED__		}_		_		return this.isClosed && writersShutDown && readersShutDown__	};utility,method,to,check,whether,the,io,manager,has,been,properly,shut,down,the,io,manager,is,considered,to,be,properly,shut,down,when,it,is,closed,and,its,threads,have,ceased,operation,return,true,if,the,io,manager,has,properly,shut,down,false,otherwise;public,final,boolean,is,properly,shut,down,boolean,readers,shut,down,true,for,int,i,0,i,this,readers,length,i,readers,shut,down,this,readers,i,get,state,thread,state,terminated,boolean,writers,shut,down,true,for,int,i,0,i,this,writers,length,i,readers,shut,down,this,writers,i,get,state,thread,state,terminated,return,this,is,closed,writers,shut,down,readers,shut,down
IOManager -> public final boolean isProperlyShutDown();1410211782;Utility method to check whether the IO manager has been properly shut down. The IO manager is considered_to be properly shut down when it is closed and its threads have ceased operation.__@return True, if the IO manager has properly shut down, false otherwise.;public final boolean isProperlyShutDown()_	{_		boolean readersShutDown = true__		for (int i = 0_ i < this.readers.length_ i++) {_			readersShutDown &= this.readers[i].getState() == Thread.State.TERMINATED__		}_		_		boolean writersShutDown = true__		for (int i = 0_ i < this.writers.length_ i++) {_			readersShutDown &= this.writers[i].getState() == Thread.State.TERMINATED__		}_		_		return this.isClosed && writersShutDown && readersShutDown__	};utility,method,to,check,whether,the,io,manager,has,been,properly,shut,down,the,io,manager,is,considered,to,be,properly,shut,down,when,it,is,closed,and,its,threads,have,ceased,operation,return,true,if,the,io,manager,has,properly,shut,down,false,otherwise;public,final,boolean,is,properly,shut,down,boolean,readers,shut,down,true,for,int,i,0,i,this,readers,length,i,readers,shut,down,this,readers,i,get,state,thread,state,terminated,boolean,writers,shut,down,true,for,int,i,0,i,this,writers,length,i,readers,shut,down,this,writers,i,get,state,thread,state,terminated,return,this,is,closed,writers,shut,down,readers,shut,down
IOManager -> public final boolean isProperlyShutDown();1411473561;Utility method to check whether the IO manager has been properly shut down. The IO manager is considered_to be properly shut down when it is closed and its threads have ceased operation.__@return True, if the IO manager has properly shut down, false otherwise.;public final boolean isProperlyShutDown()_	{_		boolean readersShutDown = true__		for (int i = 0_ i < this.readers.length_ i++) {_			readersShutDown &= this.readers[i].getState() == Thread.State.TERMINATED__		}_		_		boolean writersShutDown = true__		for (int i = 0_ i < this.writers.length_ i++) {_			readersShutDown &= this.writers[i].getState() == Thread.State.TERMINATED__		}_		_		return this.isClosed && writersShutDown && readersShutDown__	};utility,method,to,check,whether,the,io,manager,has,been,properly,shut,down,the,io,manager,is,considered,to,be,properly,shut,down,when,it,is,closed,and,its,threads,have,ceased,operation,return,true,if,the,io,manager,has,properly,shut,down,false,otherwise;public,final,boolean,is,properly,shut,down,boolean,readers,shut,down,true,for,int,i,0,i,this,readers,length,i,readers,shut,down,this,readers,i,get,state,thread,state,terminated,boolean,writers,shut,down,true,for,int,i,0,i,this,writers,length,i,readers,shut,down,this,writers,i,get,state,thread,state,terminated,return,this,is,closed,writers,shut,down,readers,shut,down
IOManager -> public IOManager();1404155775;Constructs a new IOManager, writing channels to the system directory.;public IOManager() {_		this(System.getProperty("java.io.tmpdir"))__	};constructs,a,new,iomanager,writing,channels,to,the,system,directory;public,iomanager,this,system,get,property,java,io,tmpdir
IOManager -> public IOManager();1404986750;Constructs a new IOManager, writing channels to the system directory.;public IOManager() {_		this(System.getProperty("java.io.tmpdir"))__	};constructs,a,new,iomanager,writing,channels,to,the,system,directory;public,iomanager,this,system,get,property,java,io,tmpdir
IOManager -> public IOManager();1405088715;Constructs a new IOManager, writing channels to the system directory.;public IOManager() {_		this(System.getProperty("java.io.tmpdir"))__	};constructs,a,new,iomanager,writing,channels,to,the,system,directory;public,iomanager,this,system,get,property,java,io,tmpdir
IOManager -> public IOManager();1409222213;Constructs a new IOManager, writing channels to the system directory.;public IOManager() {_		this(System.getProperty("java.io.tmpdir"))__	};constructs,a,new,iomanager,writing,channels,to,the,system,directory;public,iomanager,this,system,get,property,java,io,tmpdir
IOManager -> public IOManager();1410211782;Constructs a new IOManager, writing channels to the system directory.;public IOManager() {_		this(System.getProperty("java.io.tmpdir"))__	};constructs,a,new,iomanager,writing,channels,to,the,system,directory;public,iomanager,this,system,get,property,java,io,tmpdir
IOManager -> public IOManager();1411473561;Constructs a new IOManager, writing channels to the system directory.;public IOManager() {_		this(System.getProperty("java.io.tmpdir"))__	};constructs,a,new,iomanager,writing,channels,to,the,system,directory;public,iomanager,this,system,get,property,java,io,tmpdir
IOManager -> public FileIOChannel.Enumerator createChannelEnumerator();1412761231;Creates a new {@link FileIOChannel.Enumerator}, spreading the channels in a round-robin fashion_across the temporary file directories.__@return An enumerator for channels.;public FileIOChannel.Enumerator createChannelEnumerator() {_		return new FileIOChannel.Enumerator(this.paths, this.random)__	};creates,a,new,link,file,iochannel,enumerator,spreading,the,channels,in,a,round,robin,fashion,across,the,temporary,file,directories,return,an,enumerator,for,channels;public,file,iochannel,enumerator,create,channel,enumerator,return,new,file,iochannel,enumerator,this,paths,this,random
IOManager -> public FileIOChannel.Enumerator createChannelEnumerator();1415382319;Creates a new {@link FileIOChannel.Enumerator}, spreading the channels in a round-robin fashion_across the temporary file directories.__@return An enumerator for channels.;public FileIOChannel.Enumerator createChannelEnumerator() {_		return new FileIOChannel.Enumerator(this.paths, this.random)__	};creates,a,new,link,file,iochannel,enumerator,spreading,the,channels,in,a,round,robin,fashion,across,the,temporary,file,directories,return,an,enumerator,for,channels;public,file,iochannel,enumerator,create,channel,enumerator,return,new,file,iochannel,enumerator,this,paths,this,random
IOManager -> public FileIOChannel.Enumerator createChannelEnumerator();1417555226;Creates a new {@link FileIOChannel.Enumerator}, spreading the channels in a round-robin fashion_across the temporary file directories.__@return An enumerator for channels.;public FileIOChannel.Enumerator createChannelEnumerator() {_		return new FileIOChannel.Enumerator(this.paths, this.random)__	};creates,a,new,link,file,iochannel,enumerator,spreading,the,channels,in,a,round,robin,fashion,across,the,temporary,file,directories,return,an,enumerator,for,channels;public,file,iochannel,enumerator,create,channel,enumerator,return,new,file,iochannel,enumerator,this,paths,this,random
IOManager -> public FileIOChannel.Enumerator createChannelEnumerator();1420560668;Creates a new {@link FileIOChannel.Enumerator}, spreading the channels in a round-robin fashion_across the temporary file directories.__@return An enumerator for channels.;public FileIOChannel.Enumerator createChannelEnumerator() {_		return new FileIOChannel.Enumerator(this.paths, this.random)__	};creates,a,new,link,file,iochannel,enumerator,spreading,the,channels,in,a,round,robin,fashion,across,the,temporary,file,directories,return,an,enumerator,for,channels;public,file,iochannel,enumerator,create,channel,enumerator,return,new,file,iochannel,enumerator,this,paths,this,random
IOManager -> public FileIOChannel.Enumerator createChannelEnumerator();1421771162;Creates a new {@link FileIOChannel.Enumerator}, spreading the channels in a round-robin fashion_across the temporary file directories.__@return An enumerator for channels.;public FileIOChannel.Enumerator createChannelEnumerator() {_		return new FileIOChannel.Enumerator(this.paths, this.random)__	};creates,a,new,link,file,iochannel,enumerator,spreading,the,channels,in,a,round,robin,fashion,across,the,temporary,file,directories,return,an,enumerator,for,channels;public,file,iochannel,enumerator,create,channel,enumerator,return,new,file,iochannel,enumerator,this,paths,this,random
IOManager -> public FileIOChannel.Enumerator createChannelEnumerator();1424268205;Creates a new {@link FileIOChannel.Enumerator}, spreading the channels in a round-robin fashion_across the temporary file directories.__@return An enumerator for channels.;public FileIOChannel.Enumerator createChannelEnumerator() {_		return new FileIOChannel.Enumerator(this.paths, this.random)__	};creates,a,new,link,file,iochannel,enumerator,spreading,the,channels,in,a,round,robin,fashion,across,the,temporary,file,directories,return,an,enumerator,for,channels;public,file,iochannel,enumerator,create,channel,enumerator,return,new,file,iochannel,enumerator,this,paths,this,random
IOManager -> public FileIOChannel.Enumerator createChannelEnumerator();1428680960;Creates a new {@link FileIOChannel.Enumerator}, spreading the channels in a round-robin fashion_across the temporary file directories.__@return An enumerator for channels.;public FileIOChannel.Enumerator createChannelEnumerator() {_		return new FileIOChannel.Enumerator(this.paths, this.random)__	};creates,a,new,link,file,iochannel,enumerator,spreading,the,channels,in,a,round,robin,fashion,across,the,temporary,file,directories,return,an,enumerator,for,channels;public,file,iochannel,enumerator,create,channel,enumerator,return,new,file,iochannel,enumerator,this,paths,this,random
IOManager -> public FileIOChannel.Enumerator createChannelEnumerator();1437929917;Creates a new {@link FileIOChannel.Enumerator}, spreading the channels in a round-robin fashion_across the temporary file directories.__@return An enumerator for channels.;public FileIOChannel.Enumerator createChannelEnumerator() {_		return new FileIOChannel.Enumerator(this.paths, this.random)__	};creates,a,new,link,file,iochannel,enumerator,spreading,the,channels,in,a,round,robin,fashion,across,the,temporary,file,directories,return,an,enumerator,for,channels;public,file,iochannel,enumerator,create,channel,enumerator,return,new,file,iochannel,enumerator,this,paths,this,random
IOManager -> public FileIOChannel.Enumerator createChannelEnumerator();1441102230;Creates a new {@link FileIOChannel.Enumerator}, spreading the channels in a round-robin fashion_across the temporary file directories.__@return An enumerator for channels.;public FileIOChannel.Enumerator createChannelEnumerator() {_		return new FileIOChannel.Enumerator(this.paths, this.random)__	};creates,a,new,link,file,iochannel,enumerator,spreading,the,channels,in,a,round,robin,fashion,across,the,temporary,file,directories,return,an,enumerator,for,channels;public,file,iochannel,enumerator,create,channel,enumerator,return,new,file,iochannel,enumerator,this,paths,this,random
IOManager -> public FileIOChannel.Enumerator createChannelEnumerator();1464188671;Creates a new {@link FileIOChannel.Enumerator}, spreading the channels in a round-robin fashion_across the temporary file directories.__@return An enumerator for channels.;public FileIOChannel.Enumerator createChannelEnumerator() {_		return new FileIOChannel.Enumerator(this.paths, this.random)__	};creates,a,new,link,file,iochannel,enumerator,spreading,the,channels,in,a,round,robin,fashion,across,the,temporary,file,directories,return,an,enumerator,for,channels;public,file,iochannel,enumerator,create,channel,enumerator,return,new,file,iochannel,enumerator,this,paths,this,random
IOManager -> public FileIOChannel.Enumerator createChannelEnumerator();1484214553;Creates a new {@link FileIOChannel.Enumerator}, spreading the channels in a round-robin fashion_across the temporary file directories.__@return An enumerator for channels.;public FileIOChannel.Enumerator createChannelEnumerator() {_		return new FileIOChannel.Enumerator(this.paths, this.random)__	};creates,a,new,link,file,iochannel,enumerator,spreading,the,channels,in,a,round,robin,fashion,across,the,temporary,file,directories,return,an,enumerator,for,channels;public,file,iochannel,enumerator,create,channel,enumerator,return,new,file,iochannel,enumerator,this,paths,this,random
IOManager -> public IOManager(String[] paths);1404155775;Constructs a new IOManager.__@param paths_the basic directory paths for files underlying anonymous channels.;public IOManager(String[] paths) {_		this.paths = paths__		this.random = new Random()__		this.nextPath = 0__		_		_		this.writers = new WriterThread[paths.length]__		for (int i = 0_ i < this.writers.length_ i++) {_			final WriterThread t = new WriterThread()__			this.writers[i] = t__			t.setName("IOManager writer thread #" + (i + 1))__			t.setDaemon(true)__			t.setUncaughtExceptionHandler(this)__			t.start()__		}__		_		this.readers = new ReaderThread[paths.length]__		for (int i = 0_ i < this.readers.length_ i++) {_			final ReaderThread t = new ReaderThread()__			this.readers[i] = t__			t.setName("IOManager reader thread #" + (i + 1))__			t.setDaemon(true)__			t.setUncaughtExceptionHandler(this)__			t.start()__		}_	};constructs,a,new,iomanager,param,paths,the,basic,directory,paths,for,files,underlying,anonymous,channels;public,iomanager,string,paths,this,paths,paths,this,random,new,random,this,next,path,0,this,writers,new,writer,thread,paths,length,for,int,i,0,i,this,writers,length,i,final,writer,thread,t,new,writer,thread,this,writers,i,t,t,set,name,iomanager,writer,thread,i,1,t,set,daemon,true,t,set,uncaught,exception,handler,this,t,start,this,readers,new,reader,thread,paths,length,for,int,i,0,i,this,readers,length,i,final,reader,thread,t,new,reader,thread,this,readers,i,t,t,set,name,iomanager,reader,thread,i,1,t,set,daemon,true,t,set,uncaught,exception,handler,this,t,start
IOManager -> public IOManager(String[] paths);1404986750;Constructs a new IOManager.__@param path_the basic directory path for files underlying anonymous_channels.;public IOManager(String[] paths)_	{_		this.paths = paths__		this.random = new Random()__		this.nextPath = 0__		_		_		this.writers = new WriterThread[paths.length]__		for (int i = 0_ i < this.writers.length_ i++) {_			final WriterThread t = new WriterThread()__			this.writers[i] = t__			t.setName("IOManager writer thread #" + (i + 1))__			t.setDaemon(true)__			t.setUncaughtExceptionHandler(this)__			t.start()__		}__		_		this.readers = new ReaderThread[paths.length]__		for (int i = 0_ i < this.readers.length_ i++) {_			final ReaderThread t = new ReaderThread()__			this.readers[i] = t__			t.setName("IOManager reader thread #" + (i + 1))__			t.setDaemon(true)__			t.setUncaughtExceptionHandler(this)__			t.start()__		}_	};constructs,a,new,iomanager,param,path,the,basic,directory,path,for,files,underlying,anonymous,channels;public,iomanager,string,paths,this,paths,paths,this,random,new,random,this,next,path,0,this,writers,new,writer,thread,paths,length,for,int,i,0,i,this,writers,length,i,final,writer,thread,t,new,writer,thread,this,writers,i,t,t,set,name,iomanager,writer,thread,i,1,t,set,daemon,true,t,set,uncaught,exception,handler,this,t,start,this,readers,new,reader,thread,paths,length,for,int,i,0,i,this,readers,length,i,final,reader,thread,t,new,reader,thread,this,readers,i,t,t,set,name,iomanager,reader,thread,i,1,t,set,daemon,true,t,set,uncaught,exception,handler,this,t,start
IOManager -> public IOManager(String[] paths);1405088715;Constructs a new IOManager.__@param path_the basic directory path for files underlying anonymous_channels.;public IOManager(String[] paths)_	{_		this.paths = paths__		this.random = new Random()__		this.nextPath = 0__		_		_		this.writers = new WriterThread[paths.length]__		for (int i = 0_ i < this.writers.length_ i++) {_			final WriterThread t = new WriterThread()__			this.writers[i] = t__			t.setName("IOManager writer thread #" + (i + 1))__			t.setDaemon(true)__			t.setUncaughtExceptionHandler(this)__			t.start()__		}__		_		this.readers = new ReaderThread[paths.length]__		for (int i = 0_ i < this.readers.length_ i++) {_			final ReaderThread t = new ReaderThread()__			this.readers[i] = t__			t.setName("IOManager reader thread #" + (i + 1))__			t.setDaemon(true)__			t.setUncaughtExceptionHandler(this)__			t.start()__		}_	};constructs,a,new,iomanager,param,path,the,basic,directory,path,for,files,underlying,anonymous,channels;public,iomanager,string,paths,this,paths,paths,this,random,new,random,this,next,path,0,this,writers,new,writer,thread,paths,length,for,int,i,0,i,this,writers,length,i,final,writer,thread,t,new,writer,thread,this,writers,i,t,t,set,name,iomanager,writer,thread,i,1,t,set,daemon,true,t,set,uncaught,exception,handler,this,t,start,this,readers,new,reader,thread,paths,length,for,int,i,0,i,this,readers,length,i,final,reader,thread,t,new,reader,thread,this,readers,i,t,t,set,name,iomanager,reader,thread,i,1,t,set,daemon,true,t,set,uncaught,exception,handler,this,t,start
IOManager -> public IOManager(String[] paths);1409222213;Constructs a new IOManager.__@param path_the basic directory path for files underlying anonymous_channels.;public IOManager(String[] paths)_	{_		this.paths = paths__		this.random = new Random()__		this.nextPath = 0__		_		_		this.writers = new WriterThread[paths.length]__		for (int i = 0_ i < this.writers.length_ i++) {_			final WriterThread t = new WriterThread()__			this.writers[i] = t__			t.setName("IOManager writer thread #" + (i + 1))__			t.setDaemon(true)__			t.setUncaughtExceptionHandler(this)__			t.start()__		}__		_		this.readers = new ReaderThread[paths.length]__		for (int i = 0_ i < this.readers.length_ i++) {_			final ReaderThread t = new ReaderThread()__			this.readers[i] = t__			t.setName("IOManager reader thread #" + (i + 1))__			t.setDaemon(true)__			t.setUncaughtExceptionHandler(this)__			t.start()__		}_	};constructs,a,new,iomanager,param,path,the,basic,directory,path,for,files,underlying,anonymous,channels;public,iomanager,string,paths,this,paths,paths,this,random,new,random,this,next,path,0,this,writers,new,writer,thread,paths,length,for,int,i,0,i,this,writers,length,i,final,writer,thread,t,new,writer,thread,this,writers,i,t,t,set,name,iomanager,writer,thread,i,1,t,set,daemon,true,t,set,uncaught,exception,handler,this,t,start,this,readers,new,reader,thread,paths,length,for,int,i,0,i,this,readers,length,i,final,reader,thread,t,new,reader,thread,this,readers,i,t,t,set,name,iomanager,reader,thread,i,1,t,set,daemon,true,t,set,uncaught,exception,handler,this,t,start
IOManager -> public IOManager(String[] paths);1410211782;Constructs a new IOManager.__@param paths_the basic directory paths for files underlying anonymous channels.;public IOManager(String[] paths) {_		this.paths = paths__		this.random = new Random()__		this.nextPath = 0__		_		_		this.writers = new WriterThread[paths.length]__		for (int i = 0_ i < this.writers.length_ i++) {_			final WriterThread t = new WriterThread()__			this.writers[i] = t__			t.setName("IOManager writer thread #" + (i + 1))__			t.setDaemon(true)__			t.setUncaughtExceptionHandler(this)__			t.start()__		}__		_		this.readers = new ReaderThread[paths.length]__		for (int i = 0_ i < this.readers.length_ i++) {_			final ReaderThread t = new ReaderThread()__			this.readers[i] = t__			t.setName("IOManager reader thread #" + (i + 1))__			t.setDaemon(true)__			t.setUncaughtExceptionHandler(this)__			t.start()__		}_	};constructs,a,new,iomanager,param,paths,the,basic,directory,paths,for,files,underlying,anonymous,channels;public,iomanager,string,paths,this,paths,paths,this,random,new,random,this,next,path,0,this,writers,new,writer,thread,paths,length,for,int,i,0,i,this,writers,length,i,final,writer,thread,t,new,writer,thread,this,writers,i,t,t,set,name,iomanager,writer,thread,i,1,t,set,daemon,true,t,set,uncaught,exception,handler,this,t,start,this,readers,new,reader,thread,paths,length,for,int,i,0,i,this,readers,length,i,final,reader,thread,t,new,reader,thread,this,readers,i,t,t,set,name,iomanager,reader,thread,i,1,t,set,daemon,true,t,set,uncaught,exception,handler,this,t,start
IOManager -> public IOManager(String[] paths);1411473561;Constructs a new IOManager.__@param paths_the basic directory paths for files underlying anonymous channels.;public IOManager(String[] paths) {_		this.paths = paths__		this.random = new Random()__		this.nextPath = 0__		_		_		this.writers = new WriterThread[paths.length]__		for (int i = 0_ i < this.writers.length_ i++) {_			final WriterThread t = new WriterThread()__			this.writers[i] = t__			t.setName("IOManager writer thread #" + (i + 1))__			t.setDaemon(true)__			t.setUncaughtExceptionHandler(this)__			t.start()__		}__		_		this.readers = new ReaderThread[paths.length]__		for (int i = 0_ i < this.readers.length_ i++) {_			final ReaderThread t = new ReaderThread()__			this.readers[i] = t__			t.setName("IOManager reader thread #" + (i + 1))__			t.setDaemon(true)__			t.setUncaughtExceptionHandler(this)__			t.start()__		}_	};constructs,a,new,iomanager,param,paths,the,basic,directory,paths,for,files,underlying,anonymous,channels;public,iomanager,string,paths,this,paths,paths,this,random,new,random,this,next,path,0,this,writers,new,writer,thread,paths,length,for,int,i,0,i,this,writers,length,i,final,writer,thread,t,new,writer,thread,this,writers,i,t,t,set,name,iomanager,writer,thread,i,1,t,set,daemon,true,t,set,uncaught,exception,handler,this,t,start,this,readers,new,reader,thread,paths,length,for,int,i,0,i,this,readers,length,i,final,reader,thread,t,new,reader,thread,this,readers,i,t,t,set,name,iomanager,reader,thread,i,1,t,set,daemon,true,t,set,uncaught,exception,handler,this,t,start
IOManager -> public BlockChannelReader createBlockChannelReader(Channel.ID channelID, 					LinkedBlockingQueue<MemorySegment> returnQueue, int numRequestsToCombine) 	throws IOException;1404155775;Creates a block channel reader that reads blocks from the given channel. The reader reads asynchronously,_such that a read request is accepted, carried out at some (close) point in time, and the full segment_is pushed to the given queue._<p>_The reader will collect a specified number of read requests and carry them out_in one, effectively reading one block in the size of multiple memory pages._Note that this means that no memory segment will reach the return queue before_the given number of requests are collected, so the number of buffers used with_the reader should be greater than the number of requests to combine. Ideally,_the number of memory segments used is a multiple of the number of requests to_combine.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the full buffers into._@param numRequestsToCombine The number of read requests to combine to one I/O request._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BlockChannelReader createBlockChannelReader(Channel.ID channelID,_					LinkedBlockingQueue<MemorySegment> returnQueue, int numRequestsToCombine)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, returnQueue, numRequestsToCombine)__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,reads,asynchronously,such,that,a,read,request,is,accepted,carried,out,at,some,close,point,in,time,and,the,full,segment,is,pushed,to,the,given,queue,p,the,reader,will,collect,a,specified,number,of,read,requests,and,carry,them,out,in,one,effectively,reading,one,block,in,the,size,of,multiple,memory,pages,note,that,this,means,that,no,memory,segment,will,reach,the,return,queue,before,the,given,number,of,requests,are,collected,so,the,number,of,buffers,used,with,the,reader,should,be,greater,than,the,number,of,requests,to,combine,ideally,the,number,of,memory,segments,used,is,a,multiple,of,the,number,of,requests,to,combine,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,full,buffers,into,param,num,requests,to,combine,the,number,of,read,requests,to,combine,to,one,i,o,request,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,block,channel,reader,create,block,channel,reader,channel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,int,num,requests,to,combine,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,return,queue,num,requests,to,combine
IOManager -> public BlockChannelReader createBlockChannelReader(Channel.ID channelID, 					LinkedBlockingQueue<MemorySegment> returnQueue, int numRequestsToCombine) 	throws IOException;1404986750;Creates a block channel reader that reads blocks from the given channel. The reader reads asynchronously,_such that a read request is accepted, carried out at some (close) point in time, and the full segment_is pushed to the given queue._<p>_The reader will collect a specified number of read requests and carry them out_in one, effectively reading one block in the size of multiple memory pages._Note that this means that no memory segment will reach the return queue before_the given number of requests are collected, so the number of buffers used with_the reader should be greater than the number of requests to combine. Ideally,_the number of memory segments used is a multiple of the number of requests to_combine.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the full buffers into._@param numRequestsToCombine The number of read requests to combine to one I/O request._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BlockChannelReader createBlockChannelReader(Channel.ID channelID,_					LinkedBlockingQueue<MemorySegment> returnQueue, int numRequestsToCombine)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, returnQueue, numRequestsToCombine)__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,reads,asynchronously,such,that,a,read,request,is,accepted,carried,out,at,some,close,point,in,time,and,the,full,segment,is,pushed,to,the,given,queue,p,the,reader,will,collect,a,specified,number,of,read,requests,and,carry,them,out,in,one,effectively,reading,one,block,in,the,size,of,multiple,memory,pages,note,that,this,means,that,no,memory,segment,will,reach,the,return,queue,before,the,given,number,of,requests,are,collected,so,the,number,of,buffers,used,with,the,reader,should,be,greater,than,the,number,of,requests,to,combine,ideally,the,number,of,memory,segments,used,is,a,multiple,of,the,number,of,requests,to,combine,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,full,buffers,into,param,num,requests,to,combine,the,number,of,read,requests,to,combine,to,one,i,o,request,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,block,channel,reader,create,block,channel,reader,channel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,int,num,requests,to,combine,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,return,queue,num,requests,to,combine
IOManager -> public BlockChannelReader createBlockChannelReader(Channel.ID channelID, 					LinkedBlockingQueue<MemorySegment> returnQueue, int numRequestsToCombine) 	throws IOException;1405088715;Creates a block channel reader that reads blocks from the given channel. The reader reads asynchronously,_such that a read request is accepted, carried out at some (close) point in time, and the full segment_is pushed to the given queue._<p>_The reader will collect a specified number of read requests and carry them out_in one, effectively reading one block in the size of multiple memory pages._Note that this means that no memory segment will reach the return queue before_the given number of requests are collected, so the number of buffers used with_the reader should be greater than the number of requests to combine. Ideally,_the number of memory segments used is a multiple of the number of requests to_combine.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the full buffers into._@param numRequestsToCombine The number of read requests to combine to one I/O request._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BlockChannelReader createBlockChannelReader(Channel.ID channelID,_					LinkedBlockingQueue<MemorySegment> returnQueue, int numRequestsToCombine)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, returnQueue, numRequestsToCombine)__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,reads,asynchronously,such,that,a,read,request,is,accepted,carried,out,at,some,close,point,in,time,and,the,full,segment,is,pushed,to,the,given,queue,p,the,reader,will,collect,a,specified,number,of,read,requests,and,carry,them,out,in,one,effectively,reading,one,block,in,the,size,of,multiple,memory,pages,note,that,this,means,that,no,memory,segment,will,reach,the,return,queue,before,the,given,number,of,requests,are,collected,so,the,number,of,buffers,used,with,the,reader,should,be,greater,than,the,number,of,requests,to,combine,ideally,the,number,of,memory,segments,used,is,a,multiple,of,the,number,of,requests,to,combine,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,full,buffers,into,param,num,requests,to,combine,the,number,of,read,requests,to,combine,to,one,i,o,request,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,block,channel,reader,create,block,channel,reader,channel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,int,num,requests,to,combine,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,return,queue,num,requests,to,combine
IOManager -> public BlockChannelReader createBlockChannelReader(Channel.ID channelID, 					LinkedBlockingQueue<MemorySegment> returnQueue, int numRequestsToCombine) 	throws IOException;1409222213;Creates a block channel reader that reads blocks from the given channel. The reader reads asynchronously,_such that a read request is accepted, carried out at some (close) point in time, and the full segment_is pushed to the given queue._<p>_The reader will collect a specified number of read requests and carry them out_in one, effectively reading one block in the size of multiple memory pages._Note that this means that no memory segment will reach the return queue before_the given number of requests are collected, so the number of buffers used with_the reader should be greater than the number of requests to combine. Ideally,_the number of memory segments used is a multiple of the number of requests to_combine.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the full buffers into._@param numRequestsToCombine The number of read requests to combine to one I/O request._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BlockChannelReader createBlockChannelReader(Channel.ID channelID,_					LinkedBlockingQueue<MemorySegment> returnQueue, int numRequestsToCombine)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, returnQueue, numRequestsToCombine)__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,reads,asynchronously,such,that,a,read,request,is,accepted,carried,out,at,some,close,point,in,time,and,the,full,segment,is,pushed,to,the,given,queue,p,the,reader,will,collect,a,specified,number,of,read,requests,and,carry,them,out,in,one,effectively,reading,one,block,in,the,size,of,multiple,memory,pages,note,that,this,means,that,no,memory,segment,will,reach,the,return,queue,before,the,given,number,of,requests,are,collected,so,the,number,of,buffers,used,with,the,reader,should,be,greater,than,the,number,of,requests,to,combine,ideally,the,number,of,memory,segments,used,is,a,multiple,of,the,number,of,requests,to,combine,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,full,buffers,into,param,num,requests,to,combine,the,number,of,read,requests,to,combine,to,one,i,o,request,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,block,channel,reader,create,block,channel,reader,channel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,int,num,requests,to,combine,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,return,queue,num,requests,to,combine
IOManager -> public BlockChannelReader createBlockChannelReader(Channel.ID channelID, 					LinkedBlockingQueue<MemorySegment> returnQueue, int numRequestsToCombine) 	throws IOException;1410211782;Creates a block channel reader that reads blocks from the given channel. The reader reads asynchronously,_such that a read request is accepted, carried out at some (close) point in time, and the full segment_is pushed to the given queue._<p>_The reader will collect a specified number of read requests and carry them out_in one, effectively reading one block in the size of multiple memory pages._Note that this means that no memory segment will reach the return queue before_the given number of requests are collected, so the number of buffers used with_the reader should be greater than the number of requests to combine. Ideally,_the number of memory segments used is a multiple of the number of requests to_combine.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the full buffers into._@param numRequestsToCombine The number of read requests to combine to one I/O request._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BlockChannelReader createBlockChannelReader(Channel.ID channelID,_					LinkedBlockingQueue<MemorySegment> returnQueue, int numRequestsToCombine)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, returnQueue, numRequestsToCombine)__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,reads,asynchronously,such,that,a,read,request,is,accepted,carried,out,at,some,close,point,in,time,and,the,full,segment,is,pushed,to,the,given,queue,p,the,reader,will,collect,a,specified,number,of,read,requests,and,carry,them,out,in,one,effectively,reading,one,block,in,the,size,of,multiple,memory,pages,note,that,this,means,that,no,memory,segment,will,reach,the,return,queue,before,the,given,number,of,requests,are,collected,so,the,number,of,buffers,used,with,the,reader,should,be,greater,than,the,number,of,requests,to,combine,ideally,the,number,of,memory,segments,used,is,a,multiple,of,the,number,of,requests,to,combine,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,full,buffers,into,param,num,requests,to,combine,the,number,of,read,requests,to,combine,to,one,i,o,request,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,block,channel,reader,create,block,channel,reader,channel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,int,num,requests,to,combine,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,return,queue,num,requests,to,combine
IOManager -> public BlockChannelReader createBlockChannelReader(Channel.ID channelID, 					LinkedBlockingQueue<MemorySegment> returnQueue, int numRequestsToCombine) 	throws IOException;1411473561;Creates a block channel reader that reads blocks from the given channel. The reader reads asynchronously,_such that a read request is accepted, carried out at some (close) point in time, and the full segment_is pushed to the given queue._<p>_The reader will collect a specified number of read requests and carry them out_in one, effectively reading one block in the size of multiple memory pages._Note that this means that no memory segment will reach the return queue before_the given number of requests are collected, so the number of buffers used with_the reader should be greater than the number of requests to combine. Ideally,_the number of memory segments used is a multiple of the number of requests to_combine.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the full buffers into._@param numRequestsToCombine The number of read requests to combine to one I/O request._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BlockChannelReader createBlockChannelReader(Channel.ID channelID,_					LinkedBlockingQueue<MemorySegment> returnQueue, int numRequestsToCombine)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, returnQueue, numRequestsToCombine)__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,reads,asynchronously,such,that,a,read,request,is,accepted,carried,out,at,some,close,point,in,time,and,the,full,segment,is,pushed,to,the,given,queue,p,the,reader,will,collect,a,specified,number,of,read,requests,and,carry,them,out,in,one,effectively,reading,one,block,in,the,size,of,multiple,memory,pages,note,that,this,means,that,no,memory,segment,will,reach,the,return,queue,before,the,given,number,of,requests,are,collected,so,the,number,of,buffers,used,with,the,reader,should,be,greater,than,the,number,of,requests,to,combine,ideally,the,number,of,memory,segments,used,is,a,multiple,of,the,number,of,requests,to,combine,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,full,buffers,into,param,num,requests,to,combine,the,number,of,read,requests,to,combine,to,one,i,o,request,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,block,channel,reader,create,block,channel,reader,channel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,int,num,requests,to,combine,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,return,queue,num,requests,to,combine
IOManager -> public BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID) throws IOException;1420560668;Creates a block channel reader that reads blocks from the given channel. The reader pushed_full memory segments (with the read data) to its "return queue", to allow for asynchronous read_implementations.__@param channelID The descriptor for the channel to write to._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID) throws IOException {_		return createBlockChannelReader(channelID, new LinkedBlockingQueue<MemorySegment>())__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,pushed,full,memory,segments,with,the,read,data,to,its,return,queue,to,allow,for,asynchronous,read,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,block,channel,reader,memory,segment,create,block,channel,reader,file,iochannel,id,channel,id,throws,ioexception,return,create,block,channel,reader,channel,id,new,linked,blocking,queue,memory,segment
IOManager -> public BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID) throws IOException;1428680960;Creates a block channel reader that reads blocks from the given channel. The reader pushed_full memory segments (with the read data) to its "return queue", to allow for asynchronous read_implementations.__@param channelID The descriptor for the channel to write to._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID) throws IOException {_		return createBlockChannelReader(channelID, new LinkedBlockingQueue<MemorySegment>())__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,pushed,full,memory,segments,with,the,read,data,to,its,return,queue,to,allow,for,asynchronous,read,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,block,channel,reader,memory,segment,create,block,channel,reader,file,iochannel,id,channel,id,throws,ioexception,return,create,block,channel,reader,channel,id,new,linked,blocking,queue,memory,segment
IOManager -> public BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID) throws IOException;1437929917;Creates a block channel reader that reads blocks from the given channel. The reader pushed_full memory segments (with the read data) to its "return queue", to allow for asynchronous read_implementations.__@param channelID The descriptor for the channel to write to._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID) throws IOException {_		return createBlockChannelReader(channelID, new LinkedBlockingQueue<MemorySegment>())__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,pushed,full,memory,segments,with,the,read,data,to,its,return,queue,to,allow,for,asynchronous,read,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,block,channel,reader,memory,segment,create,block,channel,reader,file,iochannel,id,channel,id,throws,ioexception,return,create,block,channel,reader,channel,id,new,linked,blocking,queue,memory,segment
IOManager -> public BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID) throws IOException;1441102230;Creates a block channel reader that reads blocks from the given channel. The reader pushed_full memory segments (with the read data) to its "return queue", to allow for asynchronous read_implementations.__@param channelID The descriptor for the channel to write to._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID) throws IOException {_		return createBlockChannelReader(channelID, new LinkedBlockingQueue<MemorySegment>())__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,pushed,full,memory,segments,with,the,read,data,to,its,return,queue,to,allow,for,asynchronous,read,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,block,channel,reader,memory,segment,create,block,channel,reader,file,iochannel,id,channel,id,throws,ioexception,return,create,block,channel,reader,channel,id,new,linked,blocking,queue,memory,segment
IOManager -> public BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID) throws IOException;1464188671;Creates a block channel reader that reads blocks from the given channel. The reader pushed_full memory segments (with the read data) to its "return queue", to allow for asynchronous read_implementations.__@param channelID The descriptor for the channel to write to._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID) throws IOException {_		return createBlockChannelReader(channelID, new LinkedBlockingQueue<MemorySegment>())__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,pushed,full,memory,segments,with,the,read,data,to,its,return,queue,to,allow,for,asynchronous,read,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,block,channel,reader,memory,segment,create,block,channel,reader,file,iochannel,id,channel,id,throws,ioexception,return,create,block,channel,reader,channel,id,new,linked,blocking,queue,memory,segment
IOManager -> public BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID) throws IOException;1484214553;Creates a block channel reader that reads blocks from the given channel. The reader pushed_full memory segments (with the read data) to its "return queue", to allow for asynchronous read_implementations.__@param channelID The descriptor for the channel to write to._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;public BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID) throws IOException {_		return createBlockChannelReader(channelID, new LinkedBlockingQueue<MemorySegment>())__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,pushed,full,memory,segments,with,the,read,data,to,its,return,queue,to,allow,for,asynchronous,read,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;public,block,channel,reader,memory,segment,create,block,channel,reader,file,iochannel,id,channel,id,throws,ioexception,return,create,block,channel,reader,channel,id,new,linked,blocking,queue,memory,segment
IOManager -> public IOManager(String tempDir);1404155775;Constructs a new IOManager.__@param tempDir The base directory path for files underlying channels.;public IOManager(String tempDir) {_		this(new String[] {tempDir})__	};constructs,a,new,iomanager,param,temp,dir,the,base,directory,path,for,files,underlying,channels;public,iomanager,string,temp,dir,this,new,string,temp,dir
IOManager -> public IOManager(String tempDir);1404986750;Constructs a new IOManager.__@param path The base directory path for files underlying channels.;public IOManager(String tempDir) {_		this(new String[] {tempDir})__	};constructs,a,new,iomanager,param,path,the,base,directory,path,for,files,underlying,channels;public,iomanager,string,temp,dir,this,new,string,temp,dir
IOManager -> public IOManager(String tempDir);1405088715;Constructs a new IOManager.__@param path The base directory path for files underlying channels.;public IOManager(String tempDir) {_		this(new String[] {tempDir})__	};constructs,a,new,iomanager,param,path,the,base,directory,path,for,files,underlying,channels;public,iomanager,string,temp,dir,this,new,string,temp,dir
IOManager -> public IOManager(String tempDir);1409222213;Constructs a new IOManager.__@param path The base directory path for files underlying channels.;public IOManager(String tempDir) {_		this(new String[] {tempDir})__	};constructs,a,new,iomanager,param,path,the,base,directory,path,for,files,underlying,channels;public,iomanager,string,temp,dir,this,new,string,temp,dir
IOManager -> public IOManager(String tempDir);1410211782;Constructs a new IOManager.__@param tempDir The base directory path for files underlying channels.;public IOManager(String tempDir) {_		this(new String[] {tempDir})__	};constructs,a,new,iomanager,param,temp,dir,the,base,directory,path,for,files,underlying,channels;public,iomanager,string,temp,dir,this,new,string,temp,dir
IOManager -> public IOManager(String tempDir);1411473561;Constructs a new IOManager.__@param tempDir The base directory path for files underlying channels.;public IOManager(String tempDir) {_		this(new String[] {tempDir})__	};constructs,a,new,iomanager,param,temp,dir,the,base,directory,path,for,files,underlying,channels;public,iomanager,string,temp,dir,this,new,string,temp,dir
IOManager -> public abstract boolean isProperlyShutDown()_;1412761231;Utility method to check whether the IO manager has been properly shut down.__@return True, if the IO manager has properly shut down, false otherwise.;public abstract boolean isProperlyShutDown()_;utility,method,to,check,whether,the,io,manager,has,been,properly,shut,down,return,true,if,the,io,manager,has,properly,shut,down,false,otherwise;public,abstract,boolean,is,properly,shut,down
IOManager -> public abstract boolean isProperlyShutDown()_;1415382319;Utility method to check whether the IO manager has been properly shut down.__@return True, if the IO manager has properly shut down, false otherwise.;public abstract boolean isProperlyShutDown()_;utility,method,to,check,whether,the,io,manager,has,been,properly,shut,down,return,true,if,the,io,manager,has,properly,shut,down,false,otherwise;public,abstract,boolean,is,properly,shut,down
IOManager -> public abstract boolean isProperlyShutDown()_;1417555226;Utility method to check whether the IO manager has been properly shut down.__@return True, if the IO manager has properly shut down, false otherwise.;public abstract boolean isProperlyShutDown()_;utility,method,to,check,whether,the,io,manager,has,been,properly,shut,down,return,true,if,the,io,manager,has,properly,shut,down,false,otherwise;public,abstract,boolean,is,properly,shut,down
IOManager -> public abstract boolean isProperlyShutDown()_;1421771162;Utility method to check whether the IO manager has been properly shut down.__@return True, if the IO manager has properly shut down, false otherwise.;public abstract boolean isProperlyShutDown()_;utility,method,to,check,whether,the,io,manager,has,been,properly,shut,down,return,true,if,the,io,manager,has,properly,shut,down,false,otherwise;public,abstract,boolean,is,properly,shut,down
IOManager -> public abstract BlockChannelWriterWithCallback<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID, RequestDoneCallback<MemorySegment> callback) throws IOException_;1420560668;Creates a block channel writer that writes to the given channel. The writer calls the given callback_after the I/O operation has been performed (successfully or unsuccessfully), to allow_for asynchronous implementations.__@param channelID The descriptor for the channel to write to._@param callback The callback to be called for_@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public abstract BlockChannelWriterWithCallback<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID, RequestDoneCallback<MemorySegment> callback) throws IOException_;creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,calls,the,given,callback,after,the,i,o,operation,has,been,performed,successfully,or,unsuccessfully,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,callback,the,callback,to,be,called,for,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,abstract,block,channel,writer,with,callback,memory,segment,create,block,channel,writer,file,iochannel,id,channel,id,request,done,callback,memory,segment,callback,throws,ioexception
IOManager -> public abstract BlockChannelWriterWithCallback<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID, RequestDoneCallback<MemorySegment> callback) throws IOException_;1428680960;Creates a block channel writer that writes to the given channel. The writer calls the given callback_after the I/O operation has been performed (successfully or unsuccessfully), to allow_for asynchronous implementations.__@param channelID The descriptor for the channel to write to._@param callback The callback to be called for_@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public abstract BlockChannelWriterWithCallback<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID, RequestDoneCallback<MemorySegment> callback) throws IOException_;creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,calls,the,given,callback,after,the,i,o,operation,has,been,performed,successfully,or,unsuccessfully,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,callback,the,callback,to,be,called,for,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,abstract,block,channel,writer,with,callback,memory,segment,create,block,channel,writer,file,iochannel,id,channel,id,request,done,callback,memory,segment,callback,throws,ioexception
IOManager -> public abstract BlockChannelWriterWithCallback<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID, RequestDoneCallback<MemorySegment> callback) throws IOException_;1437929917;Creates a block channel writer that writes to the given channel. The writer calls the given callback_after the I/O operation has been performed (successfully or unsuccessfully), to allow_for asynchronous implementations.__@param channelID The descriptor for the channel to write to._@param callback The callback to be called for_@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public abstract BlockChannelWriterWithCallback<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID, RequestDoneCallback<MemorySegment> callback) throws IOException_;creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,calls,the,given,callback,after,the,i,o,operation,has,been,performed,successfully,or,unsuccessfully,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,callback,the,callback,to,be,called,for,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,abstract,block,channel,writer,with,callback,memory,segment,create,block,channel,writer,file,iochannel,id,channel,id,request,done,callback,memory,segment,callback,throws,ioexception
IOManager -> public abstract BlockChannelWriterWithCallback<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID, RequestDoneCallback<MemorySegment> callback) throws IOException_;1441102230;Creates a block channel writer that writes to the given channel. The writer calls the given callback_after the I/O operation has been performed (successfully or unsuccessfully), to allow_for asynchronous implementations.__@param channelID The descriptor for the channel to write to._@param callback The callback to be called for_@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public abstract BlockChannelWriterWithCallback<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID, RequestDoneCallback<MemorySegment> callback) throws IOException_;creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,calls,the,given,callback,after,the,i,o,operation,has,been,performed,successfully,or,unsuccessfully,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,callback,the,callback,to,be,called,for,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,abstract,block,channel,writer,with,callback,memory,segment,create,block,channel,writer,file,iochannel,id,channel,id,request,done,callback,memory,segment,callback,throws,ioexception
IOManager -> public abstract BlockChannelWriterWithCallback<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID, RequestDoneCallback<MemorySegment> callback) throws IOException_;1464188671;Creates a block channel writer that writes to the given channel. The writer calls the given callback_after the I/O operation has been performed (successfully or unsuccessfully), to allow_for asynchronous implementations.__@param channelID The descriptor for the channel to write to._@param callback The callback to be called for_@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public abstract BlockChannelWriterWithCallback<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID, RequestDoneCallback<MemorySegment> callback) throws IOException_;creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,calls,the,given,callback,after,the,i,o,operation,has,been,performed,successfully,or,unsuccessfully,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,callback,the,callback,to,be,called,for,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,abstract,block,channel,writer,with,callback,memory,segment,create,block,channel,writer,file,iochannel,id,channel,id,request,done,callback,memory,segment,callback,throws,ioexception
IOManager -> public abstract BlockChannelWriterWithCallback<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID, RequestDoneCallback<MemorySegment> callback) throws IOException_;1484214553;Creates a block channel writer that writes to the given channel. The writer calls the given callback_after the I/O operation has been performed (successfully or unsuccessfully), to allow_for asynchronous implementations.__@param channelID The descriptor for the channel to write to._@param callback The callback to be called for_@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public abstract BlockChannelWriterWithCallback<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID, RequestDoneCallback<MemorySegment> callback) throws IOException_;creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,calls,the,given,callback,after,the,i,o,operation,has,been,performed,successfully,or,unsuccessfully,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,callback,the,callback,to,be,called,for,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,abstract,block,channel,writer,with,callback,memory,segment,create,block,channel,writer,file,iochannel,id,channel,id,request,done,callback,memory,segment,callback,throws,ioexception
IOManager -> public BlockChannelWriter<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID) throws IOException;1420560668;Creates a block channel writer that writes to the given channel. The writer adds the_written segment to its return-queue afterwards (to allow for asynchronous implementations).__@param channelID The descriptor for the channel to write to._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public BlockChannelWriter<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID) throws IOException {_		return createBlockChannelWriter(channelID, new LinkedBlockingQueue<MemorySegment>())__	};creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,adds,the,written,segment,to,its,return,queue,afterwards,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,block,channel,writer,memory,segment,create,block,channel,writer,file,iochannel,id,channel,id,throws,ioexception,return,create,block,channel,writer,channel,id,new,linked,blocking,queue,memory,segment
IOManager -> public BlockChannelWriter<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID) throws IOException;1428680960;Creates a block channel writer that writes to the given channel. The writer adds the_written segment to its return-queue afterwards (to allow for asynchronous implementations).__@param channelID The descriptor for the channel to write to._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public BlockChannelWriter<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID) throws IOException {_		return createBlockChannelWriter(channelID, new LinkedBlockingQueue<MemorySegment>())__	};creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,adds,the,written,segment,to,its,return,queue,afterwards,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,block,channel,writer,memory,segment,create,block,channel,writer,file,iochannel,id,channel,id,throws,ioexception,return,create,block,channel,writer,channel,id,new,linked,blocking,queue,memory,segment
IOManager -> public BlockChannelWriter<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID) throws IOException;1437929917;Creates a block channel writer that writes to the given channel. The writer adds the_written segment to its return-queue afterwards (to allow for asynchronous implementations).__@param channelID The descriptor for the channel to write to._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public BlockChannelWriter<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID) throws IOException {_		return createBlockChannelWriter(channelID, new LinkedBlockingQueue<MemorySegment>())__	};creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,adds,the,written,segment,to,its,return,queue,afterwards,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,block,channel,writer,memory,segment,create,block,channel,writer,file,iochannel,id,channel,id,throws,ioexception,return,create,block,channel,writer,channel,id,new,linked,blocking,queue,memory,segment
IOManager -> public BlockChannelWriter<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID) throws IOException;1441102230;Creates a block channel writer that writes to the given channel. The writer adds the_written segment to its return-queue afterwards (to allow for asynchronous implementations).__@param channelID The descriptor for the channel to write to._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public BlockChannelWriter<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID) throws IOException {_		return createBlockChannelWriter(channelID, new LinkedBlockingQueue<MemorySegment>())__	};creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,adds,the,written,segment,to,its,return,queue,afterwards,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,block,channel,writer,memory,segment,create,block,channel,writer,file,iochannel,id,channel,id,throws,ioexception,return,create,block,channel,writer,channel,id,new,linked,blocking,queue,memory,segment
IOManager -> public BlockChannelWriter<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID) throws IOException;1464188671;Creates a block channel writer that writes to the given channel. The writer adds the_written segment to its return-queue afterwards (to allow for asynchronous implementations).__@param channelID The descriptor for the channel to write to._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public BlockChannelWriter<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID) throws IOException {_		return createBlockChannelWriter(channelID, new LinkedBlockingQueue<MemorySegment>())__	};creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,adds,the,written,segment,to,its,return,queue,afterwards,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,block,channel,writer,memory,segment,create,block,channel,writer,file,iochannel,id,channel,id,throws,ioexception,return,create,block,channel,writer,channel,id,new,linked,blocking,queue,memory,segment
IOManager -> public BlockChannelWriter<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID) throws IOException;1484214553;Creates a block channel writer that writes to the given channel. The writer adds the_written segment to its return-queue afterwards (to allow for asynchronous implementations).__@param channelID The descriptor for the channel to write to._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public BlockChannelWriter<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID) throws IOException {_		return createBlockChannelWriter(channelID, new LinkedBlockingQueue<MemorySegment>())__	};creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,adds,the,written,segment,to,its,return,queue,afterwards,to,allow,for,asynchronous,implementations,param,channel,id,the,descriptor,for,the,channel,to,write,to,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,block,channel,writer,memory,segment,create,block,channel,writer,file,iochannel,id,channel,id,throws,ioexception,return,create,block,channel,writer,channel,id,new,linked,blocking,queue,memory,segment
IOManager -> public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID, 								LinkedBlockingQueue<MemorySegment> returnQueue) 	throws IOException;1404155775;Creates a block channel writer that writes to the given channel. The writer writes asynchronously (write-behind),_accepting write request, carrying them out at some time and returning the written segment to the given queue_afterwards.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the written buffers into._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID,_								LinkedBlockingQueue<MemorySegment> returnQueue)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelWriter(channelID, this.writers[channelID.getThreadNum()].requestQueue, returnQueue, 1)__	};creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,writes,asynchronously,write,behind,accepting,write,request,carrying,them,out,at,some,time,and,returning,the,written,segment,to,the,given,queue,afterwards,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,written,buffers,into,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,block,channel,writer,create,block,channel,writer,channel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,writer,channel,id,this,writers,channel,id,get,thread,num,request,queue,return,queue,1
IOManager -> public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID, 								LinkedBlockingQueue<MemorySegment> returnQueue) 	throws IOException;1404986750;Creates a block channel writer that writes to the given channel. The writer writes asynchronously (write-behind),_accepting write request, carrying them out at some time and returning the written segment to the given queue_afterwards.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the written buffers into._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID,_								LinkedBlockingQueue<MemorySegment> returnQueue)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelWriter(channelID, this.writers[channelID.getThreadNum()].requestQueue, returnQueue, 1)__	};creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,writes,asynchronously,write,behind,accepting,write,request,carrying,them,out,at,some,time,and,returning,the,written,segment,to,the,given,queue,afterwards,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,written,buffers,into,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,block,channel,writer,create,block,channel,writer,channel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,writer,channel,id,this,writers,channel,id,get,thread,num,request,queue,return,queue,1
IOManager -> public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID, 								LinkedBlockingQueue<MemorySegment> returnQueue) 	throws IOException;1405088715;Creates a block channel writer that writes to the given channel. The writer writes asynchronously (write-behind),_accepting write request, carrying them out at some time and returning the written segment to the given queue_afterwards.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the written buffers into._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID,_								LinkedBlockingQueue<MemorySegment> returnQueue)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelWriter(channelID, this.writers[channelID.getThreadNum()].requestQueue, returnQueue, 1)__	};creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,writes,asynchronously,write,behind,accepting,write,request,carrying,them,out,at,some,time,and,returning,the,written,segment,to,the,given,queue,afterwards,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,written,buffers,into,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,block,channel,writer,create,block,channel,writer,channel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,writer,channel,id,this,writers,channel,id,get,thread,num,request,queue,return,queue,1
IOManager -> public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID, 								LinkedBlockingQueue<MemorySegment> returnQueue) 	throws IOException;1409222213;Creates a block channel writer that writes to the given channel. The writer writes asynchronously (write-behind),_accepting write request, carrying them out at some time and returning the written segment to the given queue_afterwards.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the written buffers into._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID,_								LinkedBlockingQueue<MemorySegment> returnQueue)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelWriter(channelID, this.writers[channelID.getThreadNum()].requestQueue, returnQueue, 1)__	};creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,writes,asynchronously,write,behind,accepting,write,request,carrying,them,out,at,some,time,and,returning,the,written,segment,to,the,given,queue,afterwards,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,written,buffers,into,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,block,channel,writer,create,block,channel,writer,channel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,writer,channel,id,this,writers,channel,id,get,thread,num,request,queue,return,queue,1
IOManager -> public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID, 								LinkedBlockingQueue<MemorySegment> returnQueue) 	throws IOException;1410211782;Creates a block channel writer that writes to the given channel. The writer writes asynchronously (write-behind),_accepting write request, carrying them out at some time and returning the written segment to the given queue_afterwards.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the written buffers into._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID,_								LinkedBlockingQueue<MemorySegment> returnQueue)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelWriter(channelID, this.writers[channelID.getThreadNum()].requestQueue, returnQueue, 1)__	};creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,writes,asynchronously,write,behind,accepting,write,request,carrying,them,out,at,some,time,and,returning,the,written,segment,to,the,given,queue,afterwards,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,written,buffers,into,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,block,channel,writer,create,block,channel,writer,channel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,writer,channel,id,this,writers,channel,id,get,thread,num,request,queue,return,queue,1
IOManager -> public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID, 								LinkedBlockingQueue<MemorySegment> returnQueue) 	throws IOException;1411473561;Creates a block channel writer that writes to the given channel. The writer writes asynchronously (write-behind),_accepting write request, carrying them out at some time and returning the written segment to the given queue_afterwards.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the written buffers into._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID,_								LinkedBlockingQueue<MemorySegment> returnQueue)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelWriter(channelID, this.writers[channelID.getThreadNum()].requestQueue, returnQueue, 1)__	};creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,writes,asynchronously,write,behind,accepting,write,request,carrying,them,out,at,some,time,and,returning,the,written,segment,to,the,given,queue,afterwards,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,written,buffers,into,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,block,channel,writer,create,block,channel,writer,channel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,writer,channel,id,this,writers,channel,id,get,thread,num,request,queue,return,queue,1
IOManager -> public void shutdown();1420560668;Close method, marks the I/O manager as closed_and removed all temporary files.;public void shutdown() {_		_		for (File path : paths) {_			try {_				if (path != null) {_					if (path.exists()) {_						FileUtils.deleteDirectory(path)__						LOG.info("I/O manager removed spill file directory {}", path.getAbsolutePath())__					}_				}_			} catch (Throwable t) {_				LOG.error("IOManager failed to properly clean up temp file directory: " + path, t)__			}_		}__		_		if (shutdownHook != Thread.currentThread()) {_			try {_				Runtime.getRuntime().removeShutdownHook(shutdownHook)__			}_			catch (IllegalStateException e) {_				_			}_			catch (Throwable t) {_				LOG.warn("Exception while unregistering IOManager's shutdown hook.", t)__			}_		}_	};close,method,marks,the,i,o,manager,as,closed,and,removed,all,temporary,files;public,void,shutdown,for,file,path,paths,try,if,path,null,if,path,exists,file,utils,delete,directory,path,log,info,i,o,manager,removed,spill,file,directory,path,get,absolute,path,catch,throwable,t,log,error,iomanager,failed,to,properly,clean,up,temp,file,directory,path,t,if,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,e,catch,throwable,t,log,warn,exception,while,unregistering,iomanager,s,shutdown,hook,t
IOManager -> public void shutdown();1424268205;Close method, marks the I/O manager as closed_and removed all temporary files.;public void shutdown() {_		_		for (File path : paths) {_			try {_				if (path != null) {_					if (path.exists()) {_						FileUtils.deleteDirectory(path)__						LOG.info("I/O manager removed spill file directory {}", path.getAbsolutePath())__					}_				}_			} catch (Throwable t) {_				LOG.error("IOManager failed to properly clean up temp file directory: " + path, t)__			}_		}__		_		if (shutdownHook != Thread.currentThread()) {_			try {_				Runtime.getRuntime().removeShutdownHook(shutdownHook)__			}_			catch (IllegalStateException e) {_				_			}_			catch (Throwable t) {_				LOG.warn("Exception while unregistering IOManager's shutdown hook.", t)__			}_		}_	};close,method,marks,the,i,o,manager,as,closed,and,removed,all,temporary,files;public,void,shutdown,for,file,path,paths,try,if,path,null,if,path,exists,file,utils,delete,directory,path,log,info,i,o,manager,removed,spill,file,directory,path,get,absolute,path,catch,throwable,t,log,error,iomanager,failed,to,properly,clean,up,temp,file,directory,path,t,if,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,e,catch,throwable,t,log,warn,exception,while,unregistering,iomanager,s,shutdown,hook,t
IOManager -> public void shutdown();1428680960;Close method, marks the I/O manager as closed_and removed all temporary files.;public void shutdown() {_		_		for (File path : paths) {_			try {_				if (path != null) {_					if (path.exists()) {_						FileUtils.deleteDirectory(path)__						LOG.info("I/O manager removed spill file directory {}", path.getAbsolutePath())__					}_				}_			} catch (Throwable t) {_				LOG.error("IOManager failed to properly clean up temp file directory: " + path, t)__			}_		}__		_		if (shutdownHook != Thread.currentThread()) {_			try {_				Runtime.getRuntime().removeShutdownHook(shutdownHook)__			}_			catch (IllegalStateException e) {_				_				LOG.debug("Unable to remove shutdown hook, shutdown already in progress", e)__			}_			catch (Throwable t) {_				LOG.warn("Exception while unregistering IOManager's shutdown hook.", t)__			}_		}_	};close,method,marks,the,i,o,manager,as,closed,and,removed,all,temporary,files;public,void,shutdown,for,file,path,paths,try,if,path,null,if,path,exists,file,utils,delete,directory,path,log,info,i,o,manager,removed,spill,file,directory,path,get,absolute,path,catch,throwable,t,log,error,iomanager,failed,to,properly,clean,up,temp,file,directory,path,t,if,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,e,log,debug,unable,to,remove,shutdown,hook,shutdown,already,in,progress,e,catch,throwable,t,log,warn,exception,while,unregistering,iomanager,s,shutdown,hook,t
IOManager -> public void shutdown();1437929917;Close method, marks the I/O manager as closed_and removed all temporary files.;public void shutdown() {_		_		for (File path : paths) {_			try {_				if (path != null) {_					if (path.exists()) {_						FileUtils.deleteDirectory(path)__						LOG.info("I/O manager removed spill file directory {}", path.getAbsolutePath())__					}_				}_			} catch (Throwable t) {_				LOG.error("IOManager failed to properly clean up temp file directory: " + path, t)__			}_		}__		_		if (shutdownHook != Thread.currentThread()) {_			try {_				Runtime.getRuntime().removeShutdownHook(shutdownHook)__			}_			catch (IllegalStateException e) {_				_				LOG.debug("Unable to remove shutdown hook, shutdown already in progress", e)__			}_			catch (Throwable t) {_				LOG.warn("Exception while unregistering IOManager's shutdown hook.", t)__			}_		}_	};close,method,marks,the,i,o,manager,as,closed,and,removed,all,temporary,files;public,void,shutdown,for,file,path,paths,try,if,path,null,if,path,exists,file,utils,delete,directory,path,log,info,i,o,manager,removed,spill,file,directory,path,get,absolute,path,catch,throwable,t,log,error,iomanager,failed,to,properly,clean,up,temp,file,directory,path,t,if,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,e,log,debug,unable,to,remove,shutdown,hook,shutdown,already,in,progress,e,catch,throwable,t,log,warn,exception,while,unregistering,iomanager,s,shutdown,hook,t
IOManager -> public void shutdown();1441102230;Close method, marks the I/O manager as closed_and removed all temporary files.;public void shutdown() {_		_		for (File path : paths) {_			try {_				if (path != null) {_					if (path.exists()) {_						FileUtils.deleteDirectory(path)__						LOG.info("I/O manager removed spill file directory {}", path.getAbsolutePath())__					}_				}_			} catch (Throwable t) {_				LOG.error("IOManager failed to properly clean up temp file directory: " + path, t)__			}_		}_	};close,method,marks,the,i,o,manager,as,closed,and,removed,all,temporary,files;public,void,shutdown,for,file,path,paths,try,if,path,null,if,path,exists,file,utils,delete,directory,path,log,info,i,o,manager,removed,spill,file,directory,path,get,absolute,path,catch,throwable,t,log,error,iomanager,failed,to,properly,clean,up,temp,file,directory,path,t
IOManager -> public void shutdown();1464188671;Close method, marks the I/O manager as closed_and removed all temporary files.;public void shutdown() {_		_		for (File path : paths) {_			try {_				if (path != null) {_					if (path.exists()) {_						FileUtils.deleteDirectory(path)__						LOG.info("I/O manager removed spill file directory {}", path.getAbsolutePath())__					}_				}_			} catch (Throwable t) {_				LOG.error("IOManager failed to properly clean up temp file directory: " + path, t)__			}_		}_	};close,method,marks,the,i,o,manager,as,closed,and,removed,all,temporary,files;public,void,shutdown,for,file,path,paths,try,if,path,null,if,path,exists,file,utils,delete,directory,path,log,info,i,o,manager,removed,spill,file,directory,path,get,absolute,path,catch,throwable,t,log,error,iomanager,failed,to,properly,clean,up,temp,file,directory,path,t
IOManager -> public void shutdown();1484214553;Close method, marks the I/O manager as closed_and removed all temporary files.;public void shutdown() {_		_		for (File path : paths) {_			try {_				if (path != null) {_					if (path.exists()) {_						FileUtils.deleteDirectory(path)__						LOG.info("I/O manager removed spill file directory {}", path.getAbsolutePath())__					}_				}_			} catch (Throwable t) {_				LOG.error("IOManager failed to properly clean up temp file directory: " + path, t)__			}_		}_	};close,method,marks,the,i,o,manager,as,closed,and,removed,all,temporary,files;public,void,shutdown,for,file,path,paths,try,if,path,null,if,path,exists,file,utils,delete,directory,path,log,info,i,o,manager,removed,spill,file,directory,path,get,absolute,path,catch,throwable,t,log,error,iomanager,failed,to,properly,clean,up,temp,file,directory,path,t
IOManager -> public synchronized final void shutdown();1404155775;Close method. Shuts down the reader and writer threads immediately, not waiting for their_pending requests to be served. This method waits until the threads have actually ceased their_operation.;public synchronized final void shutdown()_	{_		if (!this.isClosed) {_			this.isClosed = true___			_			_			_			for (int i = 0_ i < this.readers.length_ i++) {_				try {_					this.writers[i].shutdown()__				}_				catch (Throwable t) {_					LOG.error("Error while shutting down IO Manager writer thread.", t)__				}_			}__			_			for (int i = 0_ i < this.readers.length_ i++) {_				try {_					this.readers[i].shutdown()__				}_				catch (Throwable t) {_					LOG.error("Error while shutting down IO Manager reader thread.", t)__				}_			}_			_			_			try {_				for (int i = 0_ i < this.readers.length_ i++) {_					this.writers[i].join()__				}_				for (int i = 0_ i < this.readers.length_ i++) {_					this.readers[i].join()__				}_			}_			catch (InterruptedException iex) {}_		}_	};close,method,shuts,down,the,reader,and,writer,threads,immediately,not,waiting,for,their,pending,requests,to,be,served,this,method,waits,until,the,threads,have,actually,ceased,their,operation;public,synchronized,final,void,shutdown,if,this,is,closed,this,is,closed,true,for,int,i,0,i,this,readers,length,i,try,this,writers,i,shutdown,catch,throwable,t,log,error,error,while,shutting,down,io,manager,writer,thread,t,for,int,i,0,i,this,readers,length,i,try,this,readers,i,shutdown,catch,throwable,t,log,error,error,while,shutting,down,io,manager,reader,thread,t,try,for,int,i,0,i,this,readers,length,i,this,writers,i,join,for,int,i,0,i,this,readers,length,i,this,readers,i,join,catch,interrupted,exception,iex
IOManager -> public synchronized final void shutdown();1404986750;Close method. Shuts down the reader and writer threads immediately, not waiting for their_pending requests to be served. This method waits until the threads have actually ceased their_operation.;public synchronized final void shutdown()_	{_		if (!this.isClosed) {_			this.isClosed = true___			_			_			_			for (int i = 0_ i < this.readers.length_ i++) {_				try {_					this.writers[i].shutdown()__				}_				catch (Throwable t) {_					LOG.error("Error while shutting down IO Manager writer thread.", t)__				}_			}__			_			for (int i = 0_ i < this.readers.length_ i++) {_				try {_					this.readers[i].shutdown()__				}_				catch (Throwable t) {_					LOG.error("Error while shutting down IO Manager reader thread.", t)__				}_			}_			_			_			try {_				for (int i = 0_ i < this.readers.length_ i++) {_					this.writers[i].join()__				}_				for (int i = 0_ i < this.readers.length_ i++) {_					this.readers[i].join()__				}_			}_			catch (InterruptedException iex) {}_		}_	};close,method,shuts,down,the,reader,and,writer,threads,immediately,not,waiting,for,their,pending,requests,to,be,served,this,method,waits,until,the,threads,have,actually,ceased,their,operation;public,synchronized,final,void,shutdown,if,this,is,closed,this,is,closed,true,for,int,i,0,i,this,readers,length,i,try,this,writers,i,shutdown,catch,throwable,t,log,error,error,while,shutting,down,io,manager,writer,thread,t,for,int,i,0,i,this,readers,length,i,try,this,readers,i,shutdown,catch,throwable,t,log,error,error,while,shutting,down,io,manager,reader,thread,t,try,for,int,i,0,i,this,readers,length,i,this,writers,i,join,for,int,i,0,i,this,readers,length,i,this,readers,i,join,catch,interrupted,exception,iex
IOManager -> public synchronized final void shutdown();1405088715;Close method. Shuts down the reader and writer threads immediately, not waiting for their_pending requests to be served. This method waits until the threads have actually ceased their_operation.;public synchronized final void shutdown()_	{_		if (!this.isClosed) {_			this.isClosed = true___			_			_			_			for (int i = 0_ i < this.readers.length_ i++) {_				try {_					this.writers[i].shutdown()__				}_				catch (Throwable t) {_					LOG.error("Error while shutting down IO Manager writer thread.", t)__				}_			}__			_			for (int i = 0_ i < this.readers.length_ i++) {_				try {_					this.readers[i].shutdown()__				}_				catch (Throwable t) {_					LOG.error("Error while shutting down IO Manager reader thread.", t)__				}_			}_			_			_			try {_				for (int i = 0_ i < this.readers.length_ i++) {_					this.writers[i].join()__				}_				for (int i = 0_ i < this.readers.length_ i++) {_					this.readers[i].join()__				}_			}_			catch (InterruptedException iex) {}_		}_	};close,method,shuts,down,the,reader,and,writer,threads,immediately,not,waiting,for,their,pending,requests,to,be,served,this,method,waits,until,the,threads,have,actually,ceased,their,operation;public,synchronized,final,void,shutdown,if,this,is,closed,this,is,closed,true,for,int,i,0,i,this,readers,length,i,try,this,writers,i,shutdown,catch,throwable,t,log,error,error,while,shutting,down,io,manager,writer,thread,t,for,int,i,0,i,this,readers,length,i,try,this,readers,i,shutdown,catch,throwable,t,log,error,error,while,shutting,down,io,manager,reader,thread,t,try,for,int,i,0,i,this,readers,length,i,this,writers,i,join,for,int,i,0,i,this,readers,length,i,this,readers,i,join,catch,interrupted,exception,iex
IOManager -> public synchronized final void shutdown();1409222213;Close method. Shuts down the reader and writer threads immediately, not waiting for their_pending requests to be served. This method waits until the threads have actually ceased their_operation.;public synchronized final void shutdown()_	{_		if (!this.isClosed) {_			this.isClosed = true___			_			_			_			for (int i = 0_ i < this.readers.length_ i++) {_				try {_					this.writers[i].shutdown()__				}_				catch (Throwable t) {_					LOG.error("Error while shutting down IO Manager writer thread.", t)__				}_			}__			_			for (int i = 0_ i < this.readers.length_ i++) {_				try {_					this.readers[i].shutdown()__				}_				catch (Throwable t) {_					LOG.error("Error while shutting down IO Manager reader thread.", t)__				}_			}_			_			_			try {_				for (int i = 0_ i < this.readers.length_ i++) {_					this.writers[i].join()__				}_				for (int i = 0_ i < this.readers.length_ i++) {_					this.readers[i].join()__				}_			}_			catch (InterruptedException iex) {}_		}_	};close,method,shuts,down,the,reader,and,writer,threads,immediately,not,waiting,for,their,pending,requests,to,be,served,this,method,waits,until,the,threads,have,actually,ceased,their,operation;public,synchronized,final,void,shutdown,if,this,is,closed,this,is,closed,true,for,int,i,0,i,this,readers,length,i,try,this,writers,i,shutdown,catch,throwable,t,log,error,error,while,shutting,down,io,manager,writer,thread,t,for,int,i,0,i,this,readers,length,i,try,this,readers,i,shutdown,catch,throwable,t,log,error,error,while,shutting,down,io,manager,reader,thread,t,try,for,int,i,0,i,this,readers,length,i,this,writers,i,join,for,int,i,0,i,this,readers,length,i,this,readers,i,join,catch,interrupted,exception,iex
IOManager -> public synchronized final void shutdown();1410211782;Close method. Shuts down the reader and writer threads immediately, not waiting for their_pending requests to be served. This method waits until the threads have actually ceased their_operation.;public synchronized final void shutdown()_	{_		if (!this.isClosed) {_			this.isClosed = true___			_			_			_			for (int i = 0_ i < this.readers.length_ i++) {_				try {_					this.writers[i].shutdown()__				}_				catch (Throwable t) {_					LOG.error("Error while shutting down IO Manager writer thread.", t)__				}_			}__			_			for (int i = 0_ i < this.readers.length_ i++) {_				try {_					this.readers[i].shutdown()__				}_				catch (Throwable t) {_					LOG.error("Error while shutting down IO Manager reader thread.", t)__				}_			}_			_			_			try {_				for (int i = 0_ i < this.readers.length_ i++) {_					this.writers[i].join()__				}_				for (int i = 0_ i < this.readers.length_ i++) {_					this.readers[i].join()__				}_			}_			catch (InterruptedException iex) {}_		}_	};close,method,shuts,down,the,reader,and,writer,threads,immediately,not,waiting,for,their,pending,requests,to,be,served,this,method,waits,until,the,threads,have,actually,ceased,their,operation;public,synchronized,final,void,shutdown,if,this,is,closed,this,is,closed,true,for,int,i,0,i,this,readers,length,i,try,this,writers,i,shutdown,catch,throwable,t,log,error,error,while,shutting,down,io,manager,writer,thread,t,for,int,i,0,i,this,readers,length,i,try,this,readers,i,shutdown,catch,throwable,t,log,error,error,while,shutting,down,io,manager,reader,thread,t,try,for,int,i,0,i,this,readers,length,i,this,writers,i,join,for,int,i,0,i,this,readers,length,i,this,readers,i,join,catch,interrupted,exception,iex
IOManager -> public synchronized final void shutdown();1411473561;Close method. Shuts down the reader and writer threads immediately, not waiting for their_pending requests to be served. This method waits until the threads have actually ceased their_operation.;public synchronized final void shutdown()_	{_		if (!this.isClosed) {_			this.isClosed = true___			_			_			_			for (int i = 0_ i < this.readers.length_ i++) {_				try {_					this.writers[i].shutdown()__				}_				catch (Throwable t) {_					LOG.error("Error while shutting down IO Manager writer thread.", t)__				}_			}__			_			for (int i = 0_ i < this.readers.length_ i++) {_				try {_					this.readers[i].shutdown()__				}_				catch (Throwable t) {_					LOG.error("Error while shutting down IO Manager reader thread.", t)__				}_			}_			_			_			try {_				for (int i = 0_ i < this.readers.length_ i++) {_					this.writers[i].join()__				}_				for (int i = 0_ i < this.readers.length_ i++) {_					this.readers[i].join()__				}_			}_			catch (InterruptedException iex) {}_		}_	};close,method,shuts,down,the,reader,and,writer,threads,immediately,not,waiting,for,their,pending,requests,to,be,served,this,method,waits,until,the,threads,have,actually,ceased,their,operation;public,synchronized,final,void,shutdown,if,this,is,closed,this,is,closed,true,for,int,i,0,i,this,readers,length,i,try,this,writers,i,shutdown,catch,throwable,t,log,error,error,while,shutting,down,io,manager,writer,thread,t,for,int,i,0,i,this,readers,length,i,try,this,readers,i,shutdown,catch,throwable,t,log,error,error,while,shutting,down,io,manager,reader,thread,t,try,for,int,i,0,i,this,readers,length,i,this,writers,i,join,for,int,i,0,i,this,readers,length,i,this,readers,i,join,catch,interrupted,exception,iex
IOManager -> public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID) 	throws IOException;1404155775;Creates a block channel writer that writes to the given channel. The writer writes asynchronously (write-behind),_accepting write request, carrying them out at some time and returning the written segment its return queue afterwards.__@param channelID The descriptor for the channel to write to._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelWriter(channelID, this.writers[channelID.getThreadNum()].requestQueue, new LinkedBlockingQueue<MemorySegment>(), 1)__	};creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,writes,asynchronously,write,behind,accepting,write,request,carrying,them,out,at,some,time,and,returning,the,written,segment,its,return,queue,afterwards,param,channel,id,the,descriptor,for,the,channel,to,write,to,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,block,channel,writer,create,block,channel,writer,channel,id,channel,id,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,writer,channel,id,this,writers,channel,id,get,thread,num,request,queue,new,linked,blocking,queue,memory,segment,1
IOManager -> public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID) 	throws IOException;1404986750;Creates a block channel writer that writes to the given channel. The writer writes asynchronously (write-behind),_accepting write request, carrying them out at some time and returning the written segment its return queue afterwards.__@param channelID The descriptor for the channel to write to._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelWriter(channelID, this.writers[channelID.getThreadNum()].requestQueue, new LinkedBlockingQueue<MemorySegment>(), 1)__	};creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,writes,asynchronously,write,behind,accepting,write,request,carrying,them,out,at,some,time,and,returning,the,written,segment,its,return,queue,afterwards,param,channel,id,the,descriptor,for,the,channel,to,write,to,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,block,channel,writer,create,block,channel,writer,channel,id,channel,id,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,writer,channel,id,this,writers,channel,id,get,thread,num,request,queue,new,linked,blocking,queue,memory,segment,1
IOManager -> public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID) 	throws IOException;1405088715;Creates a block channel writer that writes to the given channel. The writer writes asynchronously (write-behind),_accepting write request, carrying them out at some time and returning the written segment its return queue afterwards.__@param channelID The descriptor for the channel to write to._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelWriter(channelID, this.writers[channelID.getThreadNum()].requestQueue, new LinkedBlockingQueue<MemorySegment>(), 1)__	};creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,writes,asynchronously,write,behind,accepting,write,request,carrying,them,out,at,some,time,and,returning,the,written,segment,its,return,queue,afterwards,param,channel,id,the,descriptor,for,the,channel,to,write,to,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,block,channel,writer,create,block,channel,writer,channel,id,channel,id,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,writer,channel,id,this,writers,channel,id,get,thread,num,request,queue,new,linked,blocking,queue,memory,segment,1
IOManager -> public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID) 	throws IOException;1409222213;Creates a block channel writer that writes to the given channel. The writer writes asynchronously (write-behind),_accepting write request, carrying them out at some time and returning the written segment its return queue afterwards.__@param channelID The descriptor for the channel to write to._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelWriter(channelID, this.writers[channelID.getThreadNum()].requestQueue, new LinkedBlockingQueue<MemorySegment>(), 1)__	};creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,writes,asynchronously,write,behind,accepting,write,request,carrying,them,out,at,some,time,and,returning,the,written,segment,its,return,queue,afterwards,param,channel,id,the,descriptor,for,the,channel,to,write,to,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,block,channel,writer,create,block,channel,writer,channel,id,channel,id,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,writer,channel,id,this,writers,channel,id,get,thread,num,request,queue,new,linked,blocking,queue,memory,segment,1
IOManager -> public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID) 	throws IOException;1410211782;Creates a block channel writer that writes to the given channel. The writer writes asynchronously (write-behind),_accepting write request, carrying them out at some time and returning the written segment its return queue afterwards.__@param channelID The descriptor for the channel to write to._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelWriter(channelID, this.writers[channelID.getThreadNum()].requestQueue, new LinkedBlockingQueue<MemorySegment>(), 1)__	};creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,writes,asynchronously,write,behind,accepting,write,request,carrying,them,out,at,some,time,and,returning,the,written,segment,its,return,queue,afterwards,param,channel,id,the,descriptor,for,the,channel,to,write,to,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,block,channel,writer,create,block,channel,writer,channel,id,channel,id,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,writer,channel,id,this,writers,channel,id,get,thread,num,request,queue,new,linked,blocking,queue,memory,segment,1
IOManager -> public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID) 	throws IOException;1411473561;Creates a block channel writer that writes to the given channel. The writer writes asynchronously (write-behind),_accepting write request, carrying them out at some time and returning the written segment its return queue afterwards.__@param channelID The descriptor for the channel to write to._@return A block channel writer that writes to the given channel._@throws IOException Thrown, if the channel for the writer could not be opened.;public BlockChannelWriter createBlockChannelWriter(Channel.ID channelID)_	throws IOException_	{_		if (this.isClosed) {_			throw new IllegalStateException("I/O-Manger is closed.")__		}_		_		return new BlockChannelWriter(channelID, this.writers[channelID.getThreadNum()].requestQueue, new LinkedBlockingQueue<MemorySegment>(), 1)__	};creates,a,block,channel,writer,that,writes,to,the,given,channel,the,writer,writes,asynchronously,write,behind,accepting,write,request,carrying,them,out,at,some,time,and,returning,the,written,segment,its,return,queue,afterwards,param,channel,id,the,descriptor,for,the,channel,to,write,to,return,a,block,channel,writer,that,writes,to,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,writer,could,not,be,opened;public,block,channel,writer,create,block,channel,writer,channel,id,channel,id,throws,ioexception,if,this,is,closed,throw,new,illegal,state,exception,i,o,manger,is,closed,return,new,block,channel,writer,channel,id,this,writers,channel,id,get,thread,num,request,queue,new,linked,blocking,queue,memory,segment,1
