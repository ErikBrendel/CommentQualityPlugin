# id;timestamp;commentText;codeText;commentWords;codeWords
Scheduler -> protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, Iterable<Instance> requestedLocations, boolean localOnly);1416317653;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, Iterable<Instance> requestedLocations, boolean localOnly) {_		_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)___			if (instanceLocalityPair == null){_				return null__			}__			Instance instanceToUse = instanceLocalityPair.getLeft()__			Locality locality = instanceLocalityPair.getRight()___			if (LOG.isDebugEnabled()){_				if(locality == Locality.LOCAL){_					LOG.debug("Local assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__				}else if(locality == Locality.NON_LOCAL){_					LOG.debug("Non-local assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__				}else if(locality == Locality.UNCONSTRAINED) {_					LOG.debug("Unconstrained assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__				}_			}__			try {_				SimpleSlot slot = instanceToUse.allocateSimpleSlot(vertex.getJobId(), vertex.getJobvertexId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.add(instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,simple,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,instance,requested,locations,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,instance,instance,to,use,instance,locality,pair,get,left,locality,locality,instance,locality,pair,get,right,if,log,is,debug,enabled,if,locality,locality,local,log,debug,local,assignment,vertex,get,simple,name,instance,to,use,else,if,locality,locality,log,debug,non,local,assignment,vertex,get,simple,name,instance,to,use,else,if,locality,locality,unconstrained,log,debug,unconstrained,assignment,vertex,get,simple,name,instance,to,use,try,simple,slot,slot,instance,to,use,allocate,simple,slot,vertex,get,job,id,vertex,get,jobvertex,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,add,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, Iterable<Instance> requestedLocations, boolean localOnly);1423157292;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, Iterable<Instance> requestedLocations, boolean localOnly) {_		_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)___			if (instanceLocalityPair == null){_				return null__			}__			Instance instanceToUse = instanceLocalityPair.getLeft()__			Locality locality = instanceLocalityPair.getRight()___			if (LOG.isDebugEnabled()){_				if(locality == Locality.LOCAL){_					LOG.debug("Local assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__				}else if(locality == Locality.NON_LOCAL){_					LOG.debug("Non-local assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__				}else if(locality == Locality.UNCONSTRAINED) {_					LOG.debug("Unconstrained assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__				}_			}__			try {_				SimpleSlot slot = instanceToUse.allocateSimpleSlot(vertex.getJobId(), vertex.getJobvertexId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.add(instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				this.allInstances.remove(instanceToUse)__				this.instancesWithAvailableResources.remove(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,simple,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,instance,requested,locations,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,instance,instance,to,use,instance,locality,pair,get,left,locality,locality,instance,locality,pair,get,right,if,log,is,debug,enabled,if,locality,locality,local,log,debug,local,assignment,vertex,get,simple,name,instance,to,use,else,if,locality,locality,log,debug,non,local,assignment,vertex,get,simple,name,instance,to,use,else,if,locality,locality,unconstrained,log,debug,unconstrained,assignment,vertex,get,simple,name,instance,to,use,try,simple,slot,slot,instance,to,use,allocate,simple,slot,vertex,get,job,id,vertex,get,jobvertex,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,add,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,this,all,instances,remove,instance,to,use,this,instances,with,available,resources,remove,instance,to,use
Scheduler -> protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, Iterable<Instance> requestedLocations, boolean localOnly);1423419464;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, Iterable<Instance> requestedLocations, boolean localOnly) {_		_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)___			if (instanceLocalityPair == null){_				return null__			}__			Instance instanceToUse = instanceLocalityPair.getLeft()__			Locality locality = instanceLocalityPair.getRight()___			if (LOG.isDebugEnabled()){_				if(locality == Locality.LOCAL){_					LOG.debug("Local assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__				}else if(locality == Locality.NON_LOCAL){_					LOG.debug("Non-local assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__				}else if(locality == Locality.UNCONSTRAINED) {_					LOG.debug("Unconstrained assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__				}_			}__			try {_				SimpleSlot slot = instanceToUse.allocateSimpleSlot(vertex.getJobId(), vertex.getJobvertexId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.add(instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,simple,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,instance,requested,locations,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,instance,instance,to,use,instance,locality,pair,get,left,locality,locality,instance,locality,pair,get,right,if,log,is,debug,enabled,if,locality,locality,local,log,debug,local,assignment,vertex,get,simple,name,instance,to,use,else,if,locality,locality,log,debug,non,local,assignment,vertex,get,simple,name,instance,to,use,else,if,locality,locality,unconstrained,log,debug,unconstrained,assignment,vertex,get,simple,name,instance,to,use,try,simple,slot,slot,instance,to,use,allocate,simple,slot,vertex,get,job,id,vertex,get,jobvertex,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,add,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, Iterable<Instance> requestedLocations, boolean localOnly);1423749105;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, Iterable<Instance> requestedLocations, boolean localOnly) {_		_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)___			if (instanceLocalityPair == null){_				return null__			}__			Instance instanceToUse = instanceLocalityPair.getLeft()__			Locality locality = instanceLocalityPair.getRight()___			if (LOG.isDebugEnabled()){_				if(locality == Locality.LOCAL){_					LOG.debug("Local assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__				}else if(locality == Locality.NON_LOCAL){_					LOG.debug("Non-local assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__				}else if(locality == Locality.UNCONSTRAINED) {_					LOG.debug("Unconstrained assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__				}_			}__			try {_				SimpleSlot slot = instanceToUse.allocateSimpleSlot(vertex.getJobId(), vertex.getJobvertexId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.add(instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,simple,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,instance,requested,locations,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,instance,instance,to,use,instance,locality,pair,get,left,locality,locality,instance,locality,pair,get,right,if,log,is,debug,enabled,if,locality,locality,local,log,debug,local,assignment,vertex,get,simple,name,instance,to,use,else,if,locality,locality,log,debug,non,local,assignment,vertex,get,simple,name,instance,to,use,else,if,locality,locality,unconstrained,log,debug,unconstrained,assignment,vertex,get,simple,name,instance,to,use,try,simple,slot,slot,instance,to,use,allocate,simple,slot,vertex,get,job,id,vertex,get,jobvertex,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,add,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, Iterable<Instance> requestedLocations, boolean localOnly);1423931937;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, Iterable<Instance> requestedLocations, boolean localOnly) {_		_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)___			if (instanceLocalityPair == null){_				return null__			}__			Instance instanceToUse = instanceLocalityPair.getLeft()__			Locality locality = instanceLocalityPair.getRight()___			if (LOG.isDebugEnabled()){_				if(locality == Locality.LOCAL){_					LOG.debug("Local assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__				}else if(locality == Locality.NON_LOCAL){_					LOG.debug("Non-local assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__				}else if(locality == Locality.UNCONSTRAINED) {_					LOG.debug("Unconstrained assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__				}_			}__			try {_				SimpleSlot slot = instanceToUse.allocateSimpleSlot(vertex.getJobId(), vertex.getJobvertexId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.add(instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,simple,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,instance,requested,locations,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,instance,instance,to,use,instance,locality,pair,get,left,locality,locality,instance,locality,pair,get,right,if,log,is,debug,enabled,if,locality,locality,local,log,debug,local,assignment,vertex,get,simple,name,instance,to,use,else,if,locality,locality,log,debug,non,local,assignment,vertex,get,simple,name,instance,to,use,else,if,locality,locality,unconstrained,log,debug,unconstrained,assignment,vertex,get,simple,name,instance,to,use,try,simple,slot,slot,instance,to,use,allocate,simple,slot,vertex,get,job,id,vertex,get,jobvertex,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,add,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> private Pair<Instance, Locality> findInstance(Iterable<Instance> requestedLocations, boolean localOnly);1416317653;NOTE: This method is not thread-safe, it needs to be synchronized by the caller.__Tries to find a requested instance. If no such instance is available it will return a non-_local instance. If no such instance exists (all slots occupied), then return null.__@param requestedLocations;private Pair<Instance, Locality> findInstance(Iterable<Instance> requestedLocations, boolean localOnly){_		_		if (this.instancesWithAvailableResources.isEmpty()) {_			_			Instance queuedInstance = this.newlyAvailableInstances.poll()__			if (queuedInstance == null) {_				return null__			} else {_				this.instancesWithAvailableResources.add(queuedInstance)__			}_		}__		Iterator<Instance> locations = requestedLocations == null ? null : requestedLocations.iterator()___		Instance instanceToUse = null__		Locality locality = Locality.UNCONSTRAINED___		if (locations != null && locations.hasNext()) {_			__			while (locations.hasNext()) {_				Instance location = locations.next()___				if (location != null && this.instancesWithAvailableResources.remove(location)) {_					instanceToUse = location__					locality = Locality.LOCAL__					break__				}_			}__			if (instanceToUse == null) {_				if (localOnly) {_					return null__				}_				else {_					instanceToUse = this.instancesWithAvailableResources.poll()__					locality = Locality.NON_LOCAL__				}_			}_		}_		else {_			instanceToUse = this.instancesWithAvailableResources.poll()__		}__		return new ImmutablePair<Instance, Locality>(instanceToUse, locality)__	};note,this,method,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,tries,to,find,a,requested,instance,if,no,such,instance,is,available,it,will,return,a,non,local,instance,if,no,such,instance,exists,all,slots,occupied,then,return,null,param,requested,locations;private,pair,instance,locality,find,instance,iterable,instance,requested,locations,boolean,local,only,if,this,instances,with,available,resources,is,empty,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,return,null,else,this,instances,with,available,resources,add,queued,instance,iterator,instance,locations,requested,locations,null,null,requested,locations,iterator,instance,instance,to,use,null,locality,locality,locality,unconstrained,if,locations,null,locations,has,next,while,locations,has,next,instance,location,locations,next,if,location,null,this,instances,with,available,resources,remove,location,instance,to,use,location,locality,locality,local,break,if,instance,to,use,null,if,local,only,return,null,else,instance,to,use,this,instances,with,available,resources,poll,locality,locality,else,instance,to,use,this,instances,with,available,resources,poll,return,new,immutable,pair,instance,locality,instance,to,use,locality
Scheduler -> private Pair<Instance, Locality> findInstance(Iterable<Instance> requestedLocations, boolean localOnly);1423157292;NOTE: This method is not thread-safe, it needs to be synchronized by the caller.__Tries to find a requested instance. If no such instance is available it will return a non-_local instance. If no such instance exists (all slots occupied), then return null.__@param requestedLocations;private Pair<Instance, Locality> findInstance(Iterable<Instance> requestedLocations, boolean localOnly){_		_		if (this.instancesWithAvailableResources.isEmpty()) {_			_			Instance queuedInstance = this.newlyAvailableInstances.poll()__			if (queuedInstance == null) {_				return null__			} else {_				this.instancesWithAvailableResources.add(queuedInstance)__			}_		}__		Iterator<Instance> locations = requestedLocations == null ? null : requestedLocations.iterator()___		Instance instanceToUse = null__		Locality locality = Locality.UNCONSTRAINED___		if (locations != null && locations.hasNext()) {_			__			while (locations.hasNext()) {_				Instance location = locations.next()___				if (location != null && this.instancesWithAvailableResources.remove(location)) {_					instanceToUse = location__					locality = Locality.LOCAL__					break__				}_			}__			if (instanceToUse == null) {_				if (localOnly) {_					return null__				}_				else {_					instanceToUse = this.instancesWithAvailableResources.poll()__					locality = Locality.NON_LOCAL__				}_			}_		}_		else {_			instanceToUse = this.instancesWithAvailableResources.poll()__		}__		return new ImmutablePair<Instance, Locality>(instanceToUse, locality)__	};note,this,method,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,tries,to,find,a,requested,instance,if,no,such,instance,is,available,it,will,return,a,non,local,instance,if,no,such,instance,exists,all,slots,occupied,then,return,null,param,requested,locations;private,pair,instance,locality,find,instance,iterable,instance,requested,locations,boolean,local,only,if,this,instances,with,available,resources,is,empty,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,return,null,else,this,instances,with,available,resources,add,queued,instance,iterator,instance,locations,requested,locations,null,null,requested,locations,iterator,instance,instance,to,use,null,locality,locality,locality,unconstrained,if,locations,null,locations,has,next,while,locations,has,next,instance,location,locations,next,if,location,null,this,instances,with,available,resources,remove,location,instance,to,use,location,locality,locality,local,break,if,instance,to,use,null,if,local,only,return,null,else,instance,to,use,this,instances,with,available,resources,poll,locality,locality,else,instance,to,use,this,instances,with,available,resources,poll,return,new,immutable,pair,instance,locality,instance,to,use,locality
Scheduler -> private Pair<Instance, Locality> findInstance(Iterable<Instance> requestedLocations, boolean localOnly);1423419464;NOTE: This method is not thread-safe, it needs to be synchronized by the caller.__Tries to find a requested instance. If no such instance is available it will return a non-_local instance. If no such instance exists (all slots occupied), then return null.__@param requestedLocations;private Pair<Instance, Locality> findInstance(Iterable<Instance> requestedLocations, boolean localOnly){_		_		if (this.instancesWithAvailableResources.isEmpty()) {_			_			Instance queuedInstance = this.newlyAvailableInstances.poll()__			if (queuedInstance == null) {_				return null__			} else {_				this.instancesWithAvailableResources.add(queuedInstance)__			}_		}__		Iterator<Instance> locations = requestedLocations == null ? null : requestedLocations.iterator()___		Instance instanceToUse = null__		Locality locality = Locality.UNCONSTRAINED___		if (locations != null && locations.hasNext()) {_			__			while (locations.hasNext()) {_				Instance location = locations.next()___				if (location != null && this.instancesWithAvailableResources.remove(location)) {_					instanceToUse = location__					locality = Locality.LOCAL__					break__				}_			}__			if (instanceToUse == null) {_				if (localOnly) {_					return null__				}_				else {_					instanceToUse = this.instancesWithAvailableResources.poll()__					locality = Locality.NON_LOCAL__				}_			}_		}_		else {_			instanceToUse = this.instancesWithAvailableResources.poll()__		}__		return new ImmutablePair<Instance, Locality>(instanceToUse, locality)__	};note,this,method,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,tries,to,find,a,requested,instance,if,no,such,instance,is,available,it,will,return,a,non,local,instance,if,no,such,instance,exists,all,slots,occupied,then,return,null,param,requested,locations;private,pair,instance,locality,find,instance,iterable,instance,requested,locations,boolean,local,only,if,this,instances,with,available,resources,is,empty,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,return,null,else,this,instances,with,available,resources,add,queued,instance,iterator,instance,locations,requested,locations,null,null,requested,locations,iterator,instance,instance,to,use,null,locality,locality,locality,unconstrained,if,locations,null,locations,has,next,while,locations,has,next,instance,location,locations,next,if,location,null,this,instances,with,available,resources,remove,location,instance,to,use,location,locality,locality,local,break,if,instance,to,use,null,if,local,only,return,null,else,instance,to,use,this,instances,with,available,resources,poll,locality,locality,else,instance,to,use,this,instances,with,available,resources,poll,return,new,immutable,pair,instance,locality,instance,to,use,locality
Scheduler -> private Pair<Instance, Locality> findInstance(Iterable<Instance> requestedLocations, boolean localOnly);1423749105;NOTE: This method is not thread-safe, it needs to be synchronized by the caller.__Tries to find a requested instance. If no such instance is available it will return a non-_local instance. If no such instance exists (all slots occupied), then return null.__@param requestedLocations;private Pair<Instance, Locality> findInstance(Iterable<Instance> requestedLocations, boolean localOnly){_		_		if (this.instancesWithAvailableResources.isEmpty()) {_			_			Instance queuedInstance = this.newlyAvailableInstances.poll()__			if (queuedInstance == null) {_				return null__			} else {_				this.instancesWithAvailableResources.add(queuedInstance)__			}_		}__		Iterator<Instance> locations = requestedLocations == null ? null : requestedLocations.iterator()___		Instance instanceToUse = null__		Locality locality = Locality.UNCONSTRAINED___		if (locations != null && locations.hasNext()) {_			__			while (locations.hasNext()) {_				Instance location = locations.next()___				if (location != null && this.instancesWithAvailableResources.remove(location)) {_					instanceToUse = location__					locality = Locality.LOCAL__					break__				}_			}__			if (instanceToUse == null) {_				if (localOnly) {_					return null__				}_				else {_					instanceToUse = this.instancesWithAvailableResources.poll()__					locality = Locality.NON_LOCAL__				}_			}_		}_		else {_			instanceToUse = this.instancesWithAvailableResources.poll()__		}__		return new ImmutablePair<Instance, Locality>(instanceToUse, locality)__	};note,this,method,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,tries,to,find,a,requested,instance,if,no,such,instance,is,available,it,will,return,a,non,local,instance,if,no,such,instance,exists,all,slots,occupied,then,return,null,param,requested,locations;private,pair,instance,locality,find,instance,iterable,instance,requested,locations,boolean,local,only,if,this,instances,with,available,resources,is,empty,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,return,null,else,this,instances,with,available,resources,add,queued,instance,iterator,instance,locations,requested,locations,null,null,requested,locations,iterator,instance,instance,to,use,null,locality,locality,locality,unconstrained,if,locations,null,locations,has,next,while,locations,has,next,instance,location,locations,next,if,location,null,this,instances,with,available,resources,remove,location,instance,to,use,location,locality,locality,local,break,if,instance,to,use,null,if,local,only,return,null,else,instance,to,use,this,instances,with,available,resources,poll,locality,locality,else,instance,to,use,this,instances,with,available,resources,poll,return,new,immutable,pair,instance,locality,instance,to,use,locality
Scheduler -> private Pair<Instance, Locality> findInstance(Iterable<Instance> requestedLocations, boolean localOnly);1423931937;NOTE: This method is not thread-safe, it needs to be synchronized by the caller.__Tries to find a requested instance. If no such instance is available it will return a non-_local instance. If no such instance exists (all slots occupied), then return null.__@param requestedLocations;private Pair<Instance, Locality> findInstance(Iterable<Instance> requestedLocations, boolean localOnly){_		_		if (this.instancesWithAvailableResources.isEmpty()) {_			_			Instance queuedInstance = this.newlyAvailableInstances.poll()__			if (queuedInstance == null) {_				return null__			} else {_				this.instancesWithAvailableResources.add(queuedInstance)__			}_		}__		Iterator<Instance> locations = requestedLocations == null ? null : requestedLocations.iterator()___		Instance instanceToUse = null__		Locality locality = Locality.UNCONSTRAINED___		if (locations != null && locations.hasNext()) {_			__			while (locations.hasNext()) {_				Instance location = locations.next()___				if (location != null && this.instancesWithAvailableResources.remove(location)) {_					instanceToUse = location__					locality = Locality.LOCAL__					break__				}_			}__			if (instanceToUse == null) {_				if (localOnly) {_					return null__				}_				else {_					instanceToUse = this.instancesWithAvailableResources.poll()__					locality = Locality.NON_LOCAL__				}_			}_		}_		else {_			instanceToUse = this.instancesWithAvailableResources.poll()__		}__		return new ImmutablePair<Instance, Locality>(instanceToUse, locality)__	};note,this,method,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,tries,to,find,a,requested,instance,if,no,such,instance,is,available,it,will,return,a,non,local,instance,if,no,such,instance,exists,all,slots,occupied,then,return,null,param,requested,locations;private,pair,instance,locality,find,instance,iterable,instance,requested,locations,boolean,local,only,if,this,instances,with,available,resources,is,empty,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,return,null,else,this,instances,with,available,resources,add,queued,instance,iterator,instance,locations,requested,locations,null,null,requested,locations,iterator,instance,instance,to,use,null,locality,locality,locality,unconstrained,if,locations,null,locations,has,next,while,locations,has,next,instance,location,locations,next,if,location,null,this,instances,with,available,resources,remove,location,instance,to,use,location,locality,locality,local,break,if,instance,to,use,null,if,local,only,return,null,else,instance,to,use,this,instances,with,available,resources,poll,locality,locality,else,instance,to,use,this,instances,with,available,resources,poll,return,new,immutable,pair,instance,locality,instance,to,use,locality
Scheduler -> private Pair<Instance, Locality> findInstance(Iterable<Instance> requestedLocations, boolean localOnly);1432114676;Tries to find a requested instance. If no such instance is available it will return a non-_local instance. If no such instance exists (all slots occupied), then return null.__<p><b>NOTE:</b> This method is not thread-safe, it needs to be synchronized by the caller.</p>__@param requestedLocations The list of preferred instances. May be null or empty, which indicates that_no locality preference exists._@param localOnly Flag to indicate whether only one of the exact local instances can be chosen.;private Pair<Instance, Locality> findInstance(Iterable<Instance> requestedLocations, boolean localOnly){_		_		_		while (this.newlyAvailableInstances.size() > 0) {_			Instance queuedInstance = this.newlyAvailableInstances.poll()__			if (queuedInstance != null) {_				this.instancesWithAvailableResources.add(queuedInstance)__			}_		}_		_		_		if (this.instancesWithAvailableResources.isEmpty()) {_			return null__		}__		Iterator<Instance> locations = requestedLocations == null ? null : requestedLocations.iterator()___		if (locations != null && locations.hasNext()) {_			__			while (locations.hasNext()) {_				Instance location = locations.next()__				if (location != null && this.instancesWithAvailableResources.remove(location)) {_					return new ImmutablePair<Instance, Locality>(location, Locality.LOCAL)__				}_			}_			_			_			if (localOnly) {_				return null__			}_			else {_				Instance instanceToUse = this.instancesWithAvailableResources.poll()__				return new ImmutablePair<Instance, Locality>(instanceToUse, Locality.NON_LOCAL)__			}_		}_		else {_			_			Instance instanceToUse = this.instancesWithAvailableResources.poll()__			return new ImmutablePair<Instance, Locality>(instanceToUse, Locality.UNCONSTRAINED)__		}_	};tries,to,find,a,requested,instance,if,no,such,instance,is,available,it,will,return,a,non,local,instance,if,no,such,instance,exists,all,slots,occupied,then,return,null,p,b,note,b,this,method,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,p,param,requested,locations,the,list,of,preferred,instances,may,be,null,or,empty,which,indicates,that,no,locality,preference,exists,param,local,only,flag,to,indicate,whether,only,one,of,the,exact,local,instances,can,be,chosen;private,pair,instance,locality,find,instance,iterable,instance,requested,locations,boolean,local,only,while,this,newly,available,instances,size,0,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,this,instances,with,available,resources,add,queued,instance,if,this,instances,with,available,resources,is,empty,return,null,iterator,instance,locations,requested,locations,null,null,requested,locations,iterator,if,locations,null,locations,has,next,while,locations,has,next,instance,location,locations,next,if,location,null,this,instances,with,available,resources,remove,location,return,new,immutable,pair,instance,locality,location,locality,local,if,local,only,return,null,else,instance,instance,to,use,this,instances,with,available,resources,poll,return,new,immutable,pair,instance,locality,instance,to,use,locality,else,instance,instance,to,use,this,instances,with,available,resources,poll,return,new,immutable,pair,instance,locality,instance,to,use,locality,unconstrained
Scheduler -> private Pair<Instance, Locality> findInstance(Iterable<Instance> requestedLocations, boolean localOnly);1434450422;Tries to find a requested instance. If no such instance is available it will return a non-_local instance. If no such instance exists (all slots occupied), then return null.__<p><b>NOTE:</b> This method is not thread-safe, it needs to be synchronized by the caller.</p>__@param requestedLocations The list of preferred instances. May be null or empty, which indicates that_no locality preference exists._@param localOnly Flag to indicate whether only one of the exact local instances can be chosen.;private Pair<Instance, Locality> findInstance(Iterable<Instance> requestedLocations, boolean localOnly){_		_		_		while (this.newlyAvailableInstances.size() > 0) {_			Instance queuedInstance = this.newlyAvailableInstances.poll()__			if (queuedInstance != null) {_				this.instancesWithAvailableResources.add(queuedInstance)__			}_		}_		_		_		if (this.instancesWithAvailableResources.isEmpty()) {_			return null__		}__		Iterator<Instance> locations = requestedLocations == null ? null : requestedLocations.iterator()___		if (locations != null && locations.hasNext()) {_			__			while (locations.hasNext()) {_				Instance location = locations.next()__				if (location != null && this.instancesWithAvailableResources.remove(location)) {_					return new ImmutablePair<Instance, Locality>(location, Locality.LOCAL)__				}_			}_			_			_			if (localOnly) {_				return null__			}_			else {_				Instance instanceToUse = this.instancesWithAvailableResources.poll()__				return new ImmutablePair<Instance, Locality>(instanceToUse, Locality.NON_LOCAL)__			}_		}_		else {_			_			Instance instanceToUse = this.instancesWithAvailableResources.poll()__			return new ImmutablePair<Instance, Locality>(instanceToUse, Locality.UNCONSTRAINED)__		}_	};tries,to,find,a,requested,instance,if,no,such,instance,is,available,it,will,return,a,non,local,instance,if,no,such,instance,exists,all,slots,occupied,then,return,null,p,b,note,b,this,method,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,p,param,requested,locations,the,list,of,preferred,instances,may,be,null,or,empty,which,indicates,that,no,locality,preference,exists,param,local,only,flag,to,indicate,whether,only,one,of,the,exact,local,instances,can,be,chosen;private,pair,instance,locality,find,instance,iterable,instance,requested,locations,boolean,local,only,while,this,newly,available,instances,size,0,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,this,instances,with,available,resources,add,queued,instance,if,this,instances,with,available,resources,is,empty,return,null,iterator,instance,locations,requested,locations,null,null,requested,locations,iterator,if,locations,null,locations,has,next,while,locations,has,next,instance,location,locations,next,if,location,null,this,instances,with,available,resources,remove,location,return,new,immutable,pair,instance,locality,location,locality,local,if,local,only,return,null,else,instance,instance,to,use,this,instances,with,available,resources,poll,return,new,immutable,pair,instance,locality,instance,to,use,locality,else,instance,instance,to,use,this,instances,with,available,resources,poll,return,new,immutable,pair,instance,locality,instance,to,use,locality,unconstrained
Scheduler -> private Pair<Instance, Locality> findInstance(Iterable<Instance> requestedLocations, boolean localOnly);1436262104;Tries to find a requested instance. If no such instance is available it will return a non-_local instance. If no such instance exists (all slots occupied), then return null.__<p><b>NOTE:</b> This method is not thread-safe, it needs to be synchronized by the caller.</p>__@param requestedLocations The list of preferred instances. May be null or empty, which indicates that_no locality preference exists._@param localOnly Flag to indicate whether only one of the exact local instances can be chosen.;private Pair<Instance, Locality> findInstance(Iterable<Instance> requestedLocations, boolean localOnly){_		_		_		while (this.newlyAvailableInstances.size() > 0) {_			Instance queuedInstance = this.newlyAvailableInstances.poll()__			if (queuedInstance != null) {_				this.instancesWithAvailableResources.add(queuedInstance)__			}_		}_		_		_		if (this.instancesWithAvailableResources.isEmpty()) {_			return null__		}__		Iterator<Instance> locations = requestedLocations == null ? null : requestedLocations.iterator()___		if (locations != null && locations.hasNext()) {_			__			while (locations.hasNext()) {_				Instance location = locations.next()__				if (location != null && this.instancesWithAvailableResources.remove(location)) {_					return new ImmutablePair<Instance, Locality>(location, Locality.LOCAL)__				}_			}_			_			_			if (localOnly) {_				return null__			}_			else {_				Instance instanceToUse = this.instancesWithAvailableResources.poll()__				return new ImmutablePair<Instance, Locality>(instanceToUse, Locality.NON_LOCAL)__			}_		}_		else {_			_			Instance instanceToUse = this.instancesWithAvailableResources.poll()__			return new ImmutablePair<Instance, Locality>(instanceToUse, Locality.UNCONSTRAINED)__		}_	};tries,to,find,a,requested,instance,if,no,such,instance,is,available,it,will,return,a,non,local,instance,if,no,such,instance,exists,all,slots,occupied,then,return,null,p,b,note,b,this,method,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,p,param,requested,locations,the,list,of,preferred,instances,may,be,null,or,empty,which,indicates,that,no,locality,preference,exists,param,local,only,flag,to,indicate,whether,only,one,of,the,exact,local,instances,can,be,chosen;private,pair,instance,locality,find,instance,iterable,instance,requested,locations,boolean,local,only,while,this,newly,available,instances,size,0,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,this,instances,with,available,resources,add,queued,instance,if,this,instances,with,available,resources,is,empty,return,null,iterator,instance,locations,requested,locations,null,null,requested,locations,iterator,if,locations,null,locations,has,next,while,locations,has,next,instance,location,locations,next,if,location,null,this,instances,with,available,resources,remove,location,return,new,immutable,pair,instance,locality,location,locality,local,if,local,only,return,null,else,instance,instance,to,use,this,instances,with,available,resources,poll,return,new,immutable,pair,instance,locality,instance,to,use,locality,else,instance,instance,to,use,this,instances,with,available,resources,poll,return,new,immutable,pair,instance,locality,instance,to,use,locality,unconstrained
Scheduler -> private Pair<Instance, Locality> findInstance(Iterable<Instance> requestedLocations, boolean localOnly);1445550685;Tries to find a requested instance. If no such instance is available it will return a non-_local instance. If no such instance exists (all slots occupied), then return null.__<p><b>NOTE:</b> This method is not thread-safe, it needs to be synchronized by the caller.</p>__@param requestedLocations The list of preferred instances. May be null or empty, which indicates that_no locality preference exists._@param localOnly Flag to indicate whether only one of the exact local instances can be chosen.;private Pair<Instance, Locality> findInstance(Iterable<Instance> requestedLocations, boolean localOnly){_		_		_		while (this.newlyAvailableInstances.size() > 0) {_			Instance queuedInstance = this.newlyAvailableInstances.poll()__			if (queuedInstance != null) {_				this.instancesWithAvailableResources.add(queuedInstance)__			}_		}_		_		_		if (this.instancesWithAvailableResources.isEmpty()) {_			return null__		}__		Iterator<Instance> locations = requestedLocations == null ? null : requestedLocations.iterator()___		if (locations != null && locations.hasNext()) {_			__			while (locations.hasNext()) {_				Instance location = locations.next()__				if (location != null && this.instancesWithAvailableResources.remove(location)) {_					return new ImmutablePair<Instance, Locality>(location, Locality.LOCAL)__				}_			}_			_			_			if (localOnly) {_				return null__			}_			else {_				Instance instanceToUse = this.instancesWithAvailableResources.poll()__				return new ImmutablePair<Instance, Locality>(instanceToUse, Locality.NON_LOCAL)__			}_		}_		else {_			_			Instance instanceToUse = this.instancesWithAvailableResources.poll()__			return new ImmutablePair<Instance, Locality>(instanceToUse, Locality.UNCONSTRAINED)__		}_	};tries,to,find,a,requested,instance,if,no,such,instance,is,available,it,will,return,a,non,local,instance,if,no,such,instance,exists,all,slots,occupied,then,return,null,p,b,note,b,this,method,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,p,param,requested,locations,the,list,of,preferred,instances,may,be,null,or,empty,which,indicates,that,no,locality,preference,exists,param,local,only,flag,to,indicate,whether,only,one,of,the,exact,local,instances,can,be,chosen;private,pair,instance,locality,find,instance,iterable,instance,requested,locations,boolean,local,only,while,this,newly,available,instances,size,0,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,this,instances,with,available,resources,add,queued,instance,if,this,instances,with,available,resources,is,empty,return,null,iterator,instance,locations,requested,locations,null,null,requested,locations,iterator,if,locations,null,locations,has,next,while,locations,has,next,instance,location,locations,next,if,location,null,this,instances,with,available,resources,remove,location,return,new,immutable,pair,instance,locality,location,locality,local,if,local,only,return,null,else,instance,instance,to,use,this,instances,with,available,resources,poll,return,new,immutable,pair,instance,locality,instance,to,use,locality,else,instance,instance,to,use,this,instances,with,available,resources,poll,return,new,immutable,pair,instance,locality,instance,to,use,locality,unconstrained
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException;1410445910;Returns either an {@link AllocatedSlot}, or an {@link SlotAllocationFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException {_		if (task == null) {_			throw new IllegalArgumentException()__		}_		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}_		_		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__	_		synchronized (globalLock) {_			_________		_			_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			if (sharingUnit != null) {_				_				SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				AllocatedSlot slot = assignment.getSlotForTask(vertex.getJobvertexId(), vertex)__				if (slot != null) {_					return slot__				}_			}_		_			_			_			_			_			while (true) {_				_				_				Instance instanceToUse = getFreeInstanceForTask(task.getTaskToExecute().getVertex())__			_				if (instanceToUse != null) {_					try {_						AllocatedSlot slot = instanceToUse.allocateSlot(vertex.getJobId())__						_						_						if (instanceToUse.hasResourcesAvailable()) {_							this.instancesWithAvailableResources.add(instanceToUse)__						}_						_						if (slot != null) {_							_							_							_							if (sharingUnit != null) {_								slot = sharingUnit.getTaskAssignment().addSlotWithTask(slot, task.getJobVertexId())__							}_							_							return slot__						}_					}_					catch (InstanceDiedException e) {_						_						_						this.allInstances.remove(instanceToUse)__						this.instancesWithAvailableResources.remove(instanceToUse)__					}_				}_				else {_					_					if (queueIfNoResource) {_						SlotAllocationFuture future = new SlotAllocationFuture()__						this.taskQueue.add(new QueuedTask(task, future))__						return future__					}_					else {_						throw new NoResourceAvailableException(task)__					}_				}_			}_		}_	};returns,either,an,link,allocated,slot,or,an,link,slot,allocation,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,throws,no,resource,available,exception,if,task,null,throw,new,illegal,argument,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,allocated,slot,slot,assignment,get,slot,for,task,vertex,get,jobvertex,id,vertex,if,slot,null,return,slot,while,true,instance,instance,to,use,get,free,instance,for,task,task,get,task,to,execute,get,vertex,if,instance,to,use,null,try,allocated,slot,slot,instance,to,use,allocate,slot,vertex,get,job,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,add,instance,to,use,if,slot,null,if,sharing,unit,null,slot,sharing,unit,get,task,assignment,add,slot,with,task,slot,task,get,job,vertex,id,return,slot,catch,instance,died,exception,e,this,all,instances,remove,instance,to,use,this,instances,with,available,resources,remove,instance,to,use,else,if,queue,if,no,resource,slot,allocation,future,future,new,slot,allocation,future,this,task,queue,add,new,queued,task,task,future,return,future,else,throw,new,no,resource,available,exception,task
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException;1410722608;Returns either an {@link AllocatedSlot}, or an {@link SlotAllocationFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException {_		if (task == null) {_			throw new IllegalArgumentException()__		}_		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}_		_		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__	_		synchronized (globalLock) {_			__		_			_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			if (sharingUnit != null) {_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				_				AllocatedSlot newSlot = null__				AllocatedSlot slotFromGroup = assignment.getSlotForTask(vertex.getJobvertexId(), vertex, true)__				_				try {_					if (slotFromGroup != null) {_						_						if (slotFromGroup.getLocality() != Locality.NON_LOCAL) {_							updateLocalityCounters(slotFromGroup.getLocality())__							return slotFromGroup__						}_					}_					_					_					_					newSlot = getFreeSlotForTask(vertex)__					AllocatedSlot toUse__					_					if (newSlot == null) {_						if (slotFromGroup == null) {_							throw new NoResourceAvailableException()__						} else {_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || newSlot.getLocality() == Locality.LOCAL) {_						toUse = sharingUnit.getTaskAssignment().addSlotWithTask(newSlot, task.getJobVertexId())__					} else {_						toUse = slotFromGroup__					}_					_					updateLocalityCounters(toUse.getLocality())__					return toUse__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}_				}_			}_		_			_			_			AllocatedSlot slot = getFreeSlotForTask(vertex)__			if (slot != null) {_				updateLocalityCounters(slot.getLocality())__				return slot__			}_			else {_				_				if (queueIfNoResource) {_					SlotAllocationFuture future = new SlotAllocationFuture()__					this.taskQueue.add(new QueuedTask(task, future))__					return future__				}_				else {_					throw new NoResourceAvailableException(task)__				}_			}_		}_	};returns,either,an,link,allocated,slot,or,an,link,slot,allocation,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,throws,no,resource,available,exception,if,task,null,throw,new,illegal,argument,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,allocated,slot,new,slot,null,allocated,slot,slot,from,group,assignment,get,slot,for,task,vertex,get,jobvertex,id,vertex,true,try,if,slot,from,group,null,if,slot,from,group,get,locality,locality,update,locality,counters,slot,from,group,get,locality,return,slot,from,group,new,slot,get,free,slot,for,task,vertex,allocated,slot,to,use,if,new,slot,null,if,slot,from,group,null,throw,new,no,resource,available,exception,else,to,use,slot,from,group,else,if,slot,from,group,null,new,slot,get,locality,locality,local,to,use,sharing,unit,get,task,assignment,add,slot,with,task,new,slot,task,get,job,vertex,id,else,to,use,slot,from,group,update,locality,counters,to,use,get,locality,return,to,use,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,allocated,slot,slot,get,free,slot,for,task,vertex,if,slot,null,update,locality,counters,slot,get,locality,return,slot,else,if,queue,if,no,resource,slot,allocation,future,future,new,slot,allocation,future,this,task,queue,add,new,queued,task,task,future,return,future,else,throw,new,no,resource,available,exception,task
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException;1410734340;Returns either an {@link AllocatedSlot}, or an {@link SlotAllocationFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException {_		if (task == null) {_			throw new IllegalArgumentException()__		}_		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}_		_		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__	_		synchronized (globalLock) {_			_			_			_			CoLocationConstraint locationConstraint = task.getLocationConstraint()__			if (locationConstraint != null) {_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException("A task with a location constraint was scheduled in a queued fashion.")__				}_				_				_				_				_				_				if (locationConstraint.isUnassigned()) {_					_					AllocatedSlot newSlot = getFreeSlotForTask(vertex)__					if (newSlot == null) {_						throw new NoResourceAvailableException()__					}_					SharedSlot sl = locationConstraint.swapInNewSlot(newSlot)__					SubSlot slot = sl.allocateSubSlot(vertex.getJobvertexId())__					_					updateLocalityCounters(newSlot.getLocality())__					return slot__				}_				else {_					_					_					SubSlot slot = locationConstraint.allocateSubSlot(vertex.getJobvertexId())__					if (slot == null) {_						_						Instance location = locationConstraint.getSlot().getAllocatedSlot().getInstance()__						AllocatedSlot newSlot__						try {_							newSlot = location.allocateSlot(vertex.getJobId())__						} catch (InstanceDiedException e) {_							throw new NoResourceAvailableException("The instance of the required location died.")__						}_						if (newSlot == null) {_							throw new NoResourceAvailableException()__						}_						SharedSlot sharedSlot = locationConstraint.swapInNewSlot(newSlot)__						slot = sharedSlot.allocateSubSlot(vertex.getJobvertexId())__					}_					_					updateLocalityCounters(Locality.LOCAL)__					return slot__				}_			}_		_			_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			if (sharingUnit != null) {_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException("A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				_				AllocatedSlot newSlot = null__				AllocatedSlot slotFromGroup = assignment.getSlotForTask(vertex.getJobvertexId(), vertex, true)__				_				try {_					if (slotFromGroup != null) {_						_						if (slotFromGroup.getLocality() != Locality.NON_LOCAL) {_							updateLocalityCounters(slotFromGroup.getLocality())__							return slotFromGroup__						}_					}_					_					_					_					newSlot = getFreeSlotForTask(vertex)__					AllocatedSlot toUse__					_					if (newSlot == null) {_						if (slotFromGroup == null) {_							throw new NoResourceAvailableException()__						} else {_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || newSlot.getLocality() == Locality.LOCAL) {_						toUse = sharingUnit.getTaskAssignment().addSlotWithTask(newSlot, task.getJobVertexId())__					} else {_						toUse = slotFromGroup__					}_					_					updateLocalityCounters(toUse.getLocality())__					return toUse__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}_				}_			}_		_			_			_			AllocatedSlot slot = getFreeSlotForTask(vertex)__			if (slot != null) {_				updateLocalityCounters(slot.getLocality())__				return slot__			}_			else {_				_				if (queueIfNoResource) {_					SlotAllocationFuture future = new SlotAllocationFuture()__					this.taskQueue.add(new QueuedTask(task, future))__					return future__				}_				else {_					throw new NoResourceAvailableException(task)__				}_			}_		}_	};returns,either,an,link,allocated,slot,or,an,link,slot,allocation,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,throws,no,resource,available,exception,if,task,null,throw,new,illegal,argument,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,synchronized,global,lock,co,location,constraint,location,constraint,task,get,location,constraint,if,location,constraint,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,location,constraint,was,scheduled,in,a,queued,fashion,if,location,constraint,is,unassigned,allocated,slot,new,slot,get,free,slot,for,task,vertex,if,new,slot,null,throw,new,no,resource,available,exception,shared,slot,sl,location,constraint,swap,in,new,slot,new,slot,sub,slot,slot,sl,allocate,sub,slot,vertex,get,jobvertex,id,update,locality,counters,new,slot,get,locality,return,slot,else,sub,slot,slot,location,constraint,allocate,sub,slot,vertex,get,jobvertex,id,if,slot,null,instance,location,location,constraint,get,slot,get,allocated,slot,get,instance,allocated,slot,new,slot,try,new,slot,location,allocate,slot,vertex,get,job,id,catch,instance,died,exception,e,throw,new,no,resource,available,exception,the,instance,of,the,required,location,died,if,new,slot,null,throw,new,no,resource,available,exception,shared,slot,shared,slot,location,constraint,swap,in,new,slot,new,slot,slot,shared,slot,allocate,sub,slot,vertex,get,jobvertex,id,update,locality,counters,locality,local,return,slot,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,allocated,slot,new,slot,null,allocated,slot,slot,from,group,assignment,get,slot,for,task,vertex,get,jobvertex,id,vertex,true,try,if,slot,from,group,null,if,slot,from,group,get,locality,locality,update,locality,counters,slot,from,group,get,locality,return,slot,from,group,new,slot,get,free,slot,for,task,vertex,allocated,slot,to,use,if,new,slot,null,if,slot,from,group,null,throw,new,no,resource,available,exception,else,to,use,slot,from,group,else,if,slot,from,group,null,new,slot,get,locality,locality,local,to,use,sharing,unit,get,task,assignment,add,slot,with,task,new,slot,task,get,job,vertex,id,else,to,use,slot,from,group,update,locality,counters,to,use,get,locality,return,to,use,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,allocated,slot,slot,get,free,slot,for,task,vertex,if,slot,null,update,locality,counters,slot,get,locality,return,slot,else,if,queue,if,no,resource,slot,allocation,future,future,new,slot,allocation,future,this,task,queue,add,new,queued,task,task,future,return,future,else,throw,new,no,resource,available,exception,task
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException;1410808507;Returns either an {@link AllocatedSlot}, or an {@link SlotAllocationFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException {_		if (task == null) {_			throw new IllegalArgumentException()__		}_		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}_		_		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__	_		synchronized (globalLock) {_			__________________________________________________		_			_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			if (sharingUnit != null) {_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException("A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				AllocatedSlot newSlot = null__				_				_				AllocatedSlot slotFromGroup__				if (constraint == null || constraint.isUnassigned()) {_					slotFromGroup = assignment.getSlotForTask(vertex.getJobvertexId(), vertex)__				}_				else {_					_					slotFromGroup = assignment.getSlotForTask(vertex.getJobvertexId(), constraint)__				}_				_				_				try {_					_					_					if (slotFromGroup != null) {_						_						if (slotFromGroup.getLocality() != Locality.NON_LOCAL) {_							_							_							if (constraint != null && constraint.isUnassigned()) {_								constraint.setLocation(slotFromGroup.getInstance())__							}_							_							updateLocalityCounters(slotFromGroup.getLocality())__							return slotFromGroup__						}_					}_					_					final Iterable<Instance> locations = (constraint == null || constraint.isUnassigned()) ?_							vertex.getPreferredLocations() : Collections.singleton(constraint.getLocation())__					_					_					newSlot = getFreeSlotForTask(vertex, locations)__					_					AllocatedSlot toUse__					_					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							throw new NoResourceAvailableException()__						} else {_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || newSlot.getLocality() == Locality.LOCAL) {_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot()__						}_						_						toUse = sharingUnit.getTaskAssignment().addSlotWithTask(newSlot, task.getJobVertexId())__					}_					else {_						_						newSlot.releaseSlot()__						toUse = slotFromGroup__					}_					_					_					if (constraint != null && constraint.isUnassigned()) {_						constraint.setLocation(toUse.getInstance())__					}_					_					updateLocalityCounters(toUse.getLocality())__					return toUse__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}_					_					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}_			}_		_			_			_			AllocatedSlot slot = getFreeSlotForTask(vertex, vertex.getPreferredLocations())__			if (slot != null) {_				updateLocalityCounters(slot.getLocality())__				return slot__			}_			else {_				_				if (queueIfNoResource) {_					SlotAllocationFuture future = new SlotAllocationFuture()__					this.taskQueue.add(new QueuedTask(task, future))__					return future__				}_				else {_					throw new NoResourceAvailableException(task)__				}_			}_		}_	};returns,either,an,link,allocated,slot,or,an,link,slot,allocation,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,throws,no,resource,available,exception,if,task,null,throw,new,illegal,argument,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,allocated,slot,new,slot,null,allocated,slot,slot,from,group,if,constraint,null,constraint,is,unassigned,slot,from,group,assignment,get,slot,for,task,vertex,get,jobvertex,id,vertex,else,slot,from,group,assignment,get,slot,for,task,vertex,get,jobvertex,id,constraint,try,if,slot,from,group,null,if,slot,from,group,get,locality,locality,if,constraint,null,constraint,is,unassigned,constraint,set,location,slot,from,group,get,instance,update,locality,counters,slot,from,group,get,locality,return,slot,from,group,final,iterable,instance,locations,constraint,null,constraint,is,unassigned,vertex,get,preferred,locations,collections,singleton,constraint,get,location,new,slot,get,free,slot,for,task,vertex,locations,allocated,slot,to,use,if,new,slot,null,if,slot,from,group,null,throw,new,no,resource,available,exception,else,to,use,slot,from,group,else,if,slot,from,group,null,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,to,use,sharing,unit,get,task,assignment,add,slot,with,task,new,slot,task,get,job,vertex,id,else,new,slot,release,slot,to,use,slot,from,group,if,constraint,null,constraint,is,unassigned,constraint,set,location,to,use,get,instance,update,locality,counters,to,use,get,locality,return,to,use,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,allocated,slot,slot,get,free,slot,for,task,vertex,vertex,get,preferred,locations,if,slot,null,update,locality,counters,slot,get,locality,return,slot,else,if,queue,if,no,resource,slot,allocation,future,future,new,slot,allocation,future,this,task,queue,add,new,queued,task,task,future,return,future,else,throw,new,no,resource,available,exception,task
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException;1410924144;Returns either an {@link AllocatedSlot}, or an {@link SlotAllocationFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException {_		if (task == null) {_			throw new IllegalArgumentException()__		}_		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}_		_		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__	_		synchronized (globalLock) {_		_			_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			if (sharingUnit != null) {_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException("A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				_				SubSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(vertex, constraint)__				}_				_				AllocatedSlot newSlot = null__				_				_				try {_					_					_					if (slotFromGroup != null) {_						_						if (slotFromGroup.getLocality() != Locality.NON_LOCAL) {_							updateLocalityCounters(slotFromGroup.getLocality())__							return slotFromGroup__						}_					}_					_					final Iterable<Instance> locations = (constraint == null || constraint.isUnassigned()) ?_							vertex.getPreferredLocations() : Collections.singleton(constraint.getLocation())__					_					_					newSlot = getFreeSlotForTask(vertex, locations)__					_					SubSlot toUse__					_					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							if (constraint == null || constraint.isUnassigned()) {_								throw new NoResourceAvailableException()__							} else {_								throw new NoResourceAvailableException("Could not allocate a slot on instance " + _											constraint.getLocation() + ", as required by the co-location constraint.")__							}_						} else {_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || newSlot.getLocality() == Locality.LOCAL) {_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot()__						}_						_						if (constraint == null) {_							toUse = assignment.addNewSlotWithTask(newSlot, vertex)__						} else {_							toUse = assignment.addNewSlotWithTask(newSlot, vertex, constraint)__						}_					}_					else {_						_						newSlot.releaseSlot()__						toUse = slotFromGroup__					}_					_					_					_					if (constraint != null) {_						if (constraint.isUnassigned() || toUse.getLocality() == Locality.LOCAL) {_							constraint.setSharedSlot(toUse.getSharedSlot())__						} else {_							_							throw new NoResourceAvailableException("Could not allocate a slot on instance " + _									constraint.getLocation() + ", as required by the co-location constraint.")__						}_					}_					_					updateLocalityCounters(toUse.getLocality())__					return toUse__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}_					_					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}_			}_		_			_			_			AllocatedSlot slot = getFreeSlotForTask(vertex, vertex.getPreferredLocations())__			if (slot != null) {_				updateLocalityCounters(slot.getLocality())__				return slot__			}_			else {_				_				if (queueIfNoResource) {_					SlotAllocationFuture future = new SlotAllocationFuture()__					this.taskQueue.add(new QueuedTask(task, future))__					return future__				}_				else {_					throw new NoResourceAvailableException(task)__				}_			}_		}_	};returns,either,an,link,allocated,slot,or,an,link,slot,allocation,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,throws,no,resource,available,exception,if,task,null,throw,new,illegal,argument,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,sub,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,else,slot,from,group,assignment,get,slot,for,task,vertex,constraint,allocated,slot,new,slot,null,try,if,slot,from,group,null,if,slot,from,group,get,locality,locality,update,locality,counters,slot,from,group,get,locality,return,slot,from,group,final,iterable,instance,locations,constraint,null,constraint,is,unassigned,vertex,get,preferred,locations,collections,singleton,constraint,get,location,new,slot,get,free,slot,for,task,vertex,locations,sub,slot,to,use,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,unassigned,throw,new,no,resource,available,exception,else,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,to,use,slot,from,group,else,if,slot,from,group,null,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,if,constraint,null,to,use,assignment,add,new,slot,with,task,new,slot,vertex,else,to,use,assignment,add,new,slot,with,task,new,slot,vertex,constraint,else,new,slot,release,slot,to,use,slot,from,group,if,constraint,null,if,constraint,is,unassigned,to,use,get,locality,locality,local,constraint,set,shared,slot,to,use,get,shared,slot,else,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,update,locality,counters,to,use,get,locality,return,to,use,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,allocated,slot,slot,get,free,slot,for,task,vertex,vertex,get,preferred,locations,if,slot,null,update,locality,counters,slot,get,locality,return,slot,else,if,queue,if,no,resource,slot,allocation,future,future,new,slot,allocation,future,this,task,queue,add,new,queued,task,task,future,return,future,else,throw,new,no,resource,available,exception,task
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException;1411473561;Returns either an {@link AllocatedSlot}, or an {@link SlotAllocationFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException {_		if (task == null) {_			throw new IllegalArgumentException()__		}_		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}_		_		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__	_		synchronized (globalLock) {_		_			_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			if (sharingUnit != null) {_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException("A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				_				SubSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(vertex, constraint)__				}_				_				AllocatedSlot newSlot = null__				_				_				try {_					_					_					if (slotFromGroup != null) {_						_						if (slotFromGroup.getLocality() != Locality.NON_LOCAL) {_							updateLocalityCounters(slotFromGroup.getLocality())__							return slotFromGroup__						}_					}_					_					final Iterable<Instance> locations = (constraint == null || constraint.isUnassigned()) ?_							vertex.getPreferredLocations() : Collections.singleton(constraint.getLocation())__					_					_					newSlot = getFreeSlotForTask(vertex, locations)__					_					SubSlot toUse__					_					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							if (constraint == null || constraint.isUnassigned()) {_								throw new NoResourceAvailableException()__							} else {_								throw new NoResourceAvailableException("Could not allocate a slot on instance " + _											constraint.getLocation() + ", as required by the co-location constraint.")__							}_						} else {_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || newSlot.getLocality() == Locality.LOCAL) {_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot()__						}_						_						if (constraint == null) {_							toUse = assignment.addNewSlotWithTask(newSlot, vertex)__						} else {_							toUse = assignment.addNewSlotWithTask(newSlot, vertex, constraint)__						}_					}_					else {_						_						newSlot.releaseSlot()__						toUse = slotFromGroup__					}_					_					_					_					if (constraint != null) {_						if (constraint.isUnassigned() || toUse.getLocality() == Locality.LOCAL) {_							constraint.setSharedSlot(toUse.getSharedSlot())__						} else {_							_							throw new NoResourceAvailableException("Could not allocate a slot on instance " + _									constraint.getLocation() + ", as required by the co-location constraint.")__						}_					}_					_					updateLocalityCounters(toUse.getLocality())__					return toUse__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}_					_					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}_			}_		_			_			_			AllocatedSlot slot = getFreeSlotForTask(vertex, vertex.getPreferredLocations())__			if (slot != null) {_				updateLocalityCounters(slot.getLocality())__				return slot__			}_			else {_				_				if (queueIfNoResource) {_					SlotAllocationFuture future = new SlotAllocationFuture()__					this.taskQueue.add(new QueuedTask(task, future))__					return future__				}_				else {_					throw new NoResourceAvailableException(task)__				}_			}_		}_	};returns,either,an,link,allocated,slot,or,an,link,slot,allocation,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,throws,no,resource,available,exception,if,task,null,throw,new,illegal,argument,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,sub,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,else,slot,from,group,assignment,get,slot,for,task,vertex,constraint,allocated,slot,new,slot,null,try,if,slot,from,group,null,if,slot,from,group,get,locality,locality,update,locality,counters,slot,from,group,get,locality,return,slot,from,group,final,iterable,instance,locations,constraint,null,constraint,is,unassigned,vertex,get,preferred,locations,collections,singleton,constraint,get,location,new,slot,get,free,slot,for,task,vertex,locations,sub,slot,to,use,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,unassigned,throw,new,no,resource,available,exception,else,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,to,use,slot,from,group,else,if,slot,from,group,null,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,if,constraint,null,to,use,assignment,add,new,slot,with,task,new,slot,vertex,else,to,use,assignment,add,new,slot,with,task,new,slot,vertex,constraint,else,new,slot,release,slot,to,use,slot,from,group,if,constraint,null,if,constraint,is,unassigned,to,use,get,locality,locality,local,constraint,set,shared,slot,to,use,get,shared,slot,else,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,update,locality,counters,to,use,get,locality,return,to,use,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,allocated,slot,slot,get,free,slot,for,task,vertex,vertex,get,preferred,locations,if,slot,null,update,locality,counters,slot,get,locality,return,slot,else,if,queue,if,no,resource,slot,allocation,future,future,new,slot,allocation,future,this,task,queue,add,new,queued,task,task,future,return,future,else,throw,new,no,resource,available,exception,task
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException;1411494841;Returns either an {@link AllocatedSlot}, or an {@link SlotAllocationFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException {_		if (task == null) {_			throw new IllegalArgumentException()__		}_		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}_		_		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__	_		synchronized (globalLock) {_		_			_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			if (sharingUnit != null) {_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException("A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				_				SubSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(vertex, constraint)__				}_				_				AllocatedSlot newSlot = null__				_				_				try {_					_					_					if (slotFromGroup != null) {_						_						if (slotFromGroup.getLocality() != Locality.NON_LOCAL) {_							updateLocalityCounters(slotFromGroup.getLocality())__							return slotFromGroup__						}_					}_					_					final Iterable<Instance> locations = (constraint == null || constraint.isUnassigned()) ?_							vertex.getPreferredLocations() : Collections.singleton(constraint.getLocation())__					_					_					newSlot = getFreeSlotForTask(vertex, locations)__					_					SubSlot toUse__					_					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							if (constraint == null || constraint.isUnassigned()) {_								throw new NoResourceAvailableException(getNumberOfAvailableInstances(), getTotalNumberOfSlots())__							} else {_								throw new NoResourceAvailableException("Could not allocate a slot on instance " + _											constraint.getLocation() + ", as required by the co-location constraint.")__							}_						} else {_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || newSlot.getLocality() == Locality.LOCAL) {_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot()__						}_						_						if (constraint == null) {_							toUse = assignment.addNewSlotWithTask(newSlot, vertex)__						} else {_							toUse = assignment.addNewSlotWithTask(newSlot, vertex, constraint)__						}_					}_					else {_						_						newSlot.releaseSlot()__						toUse = slotFromGroup__					}_					_					_					_					if (constraint != null) {_						if (constraint.isUnassigned() || toUse.getLocality() == Locality.LOCAL) {_							constraint.setSharedSlot(toUse.getSharedSlot())__						} else {_							_							throw new NoResourceAvailableException("Could not allocate a slot on instance " + _									constraint.getLocation() + ", as required by the co-location constraint.")__						}_					}_					_					updateLocalityCounters(toUse.getLocality())__					return toUse__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}_					_					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}_			}_		_			_			_			AllocatedSlot slot = getFreeSlotForTask(vertex, vertex.getPreferredLocations())__			if (slot != null) {_				updateLocalityCounters(slot.getLocality())__				return slot__			}_			else {_				_				if (queueIfNoResource) {_					SlotAllocationFuture future = new SlotAllocationFuture()__					this.taskQueue.add(new QueuedTask(task, future))__					return future__				}_				else {_					throw new NoResourceAvailableException(getNumberOfAvailableInstances(), getTotalNumberOfSlots())__				}_			}_		}_	};returns,either,an,link,allocated,slot,or,an,link,slot,allocation,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,throws,no,resource,available,exception,if,task,null,throw,new,illegal,argument,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,sub,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,else,slot,from,group,assignment,get,slot,for,task,vertex,constraint,allocated,slot,new,slot,null,try,if,slot,from,group,null,if,slot,from,group,get,locality,locality,update,locality,counters,slot,from,group,get,locality,return,slot,from,group,final,iterable,instance,locations,constraint,null,constraint,is,unassigned,vertex,get,preferred,locations,collections,singleton,constraint,get,location,new,slot,get,free,slot,for,task,vertex,locations,sub,slot,to,use,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,unassigned,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,else,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,to,use,slot,from,group,else,if,slot,from,group,null,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,if,constraint,null,to,use,assignment,add,new,slot,with,task,new,slot,vertex,else,to,use,assignment,add,new,slot,with,task,new,slot,vertex,constraint,else,new,slot,release,slot,to,use,slot,from,group,if,constraint,null,if,constraint,is,unassigned,to,use,get,locality,locality,local,constraint,set,shared,slot,to,use,get,shared,slot,else,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,update,locality,counters,to,use,get,locality,return,to,use,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,allocated,slot,slot,get,free,slot,for,task,vertex,vertex,get,preferred,locations,if,slot,null,update,locality,counters,slot,get,locality,return,slot,else,if,queue,if,no,resource,slot,allocation,future,future,new,slot,allocation,future,this,task,queue,add,new,queued,task,task,future,return,future,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException;1411587268;Returns either an {@link AllocatedSlot}, or an {@link SlotAllocationFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException {_		if (task == null) {_			throw new IllegalArgumentException()__		}_		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}_		_		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__	_		synchronized (globalLock) {_		_			_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			if (sharingUnit != null) {_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException("A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				_				SubSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(vertex, constraint)__				}_				_				AllocatedSlot newSlot = null__				_				_				try {_					_					_					if (slotFromGroup != null) {_						_						if (slotFromGroup.getLocality() != Locality.NON_LOCAL) {_							updateLocalityCounters(slotFromGroup.getLocality())__							return slotFromGroup__						}_					}_					_					final Iterable<Instance> locations = (constraint == null || constraint.isUnassigned()) ?_							vertex.getPreferredLocations() : Collections.singleton(constraint.getLocation())__					_					_					newSlot = getFreeSlotForTask(vertex, locations)__					_					SubSlot toUse__					_					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							if (constraint == null || constraint.isUnassigned()) {_								throw new NoResourceAvailableException(getNumberOfAvailableInstances(), getTotalNumberOfSlots())__							} else {_								throw new NoResourceAvailableException("Could not allocate a slot on instance " + _											constraint.getLocation() + ", as required by the co-location constraint.")__							}_						} else {_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || newSlot.getLocality() == Locality.LOCAL) {_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot()__						}_						_						if (constraint == null) {_							toUse = assignment.addNewSlotWithTask(newSlot, vertex)__						} else {_							toUse = assignment.addNewSlotWithTask(newSlot, vertex, constraint)__						}_					}_					else {_						_						newSlot.releaseSlot()__						toUse = slotFromGroup__					}_					_					_					_					if (constraint != null) {_						if (constraint.isUnassigned() || toUse.getLocality() == Locality.LOCAL) {_							constraint.setSharedSlot(toUse.getSharedSlot())__						} else {_							_							throw new NoResourceAvailableException("Could not allocate a slot on instance " + _									constraint.getLocation() + ", as required by the co-location constraint.")__						}_					}_					_					updateLocalityCounters(toUse.getLocality())__					return toUse__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}_					_					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}_			}_		_			_			_			AllocatedSlot slot = getFreeSlotForTask(vertex, vertex.getPreferredLocations())__			if (slot != null) {_				updateLocalityCounters(slot.getLocality())__				return slot__			}_			else {_				_				if (queueIfNoResource) {_					SlotAllocationFuture future = new SlotAllocationFuture()__					this.taskQueue.add(new QueuedTask(task, future))__					return future__				}_				else {_					throw new NoResourceAvailableException(getNumberOfAvailableInstances(), getTotalNumberOfSlots())__				}_			}_		}_	};returns,either,an,link,allocated,slot,or,an,link,slot,allocation,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,throws,no,resource,available,exception,if,task,null,throw,new,illegal,argument,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,sub,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,else,slot,from,group,assignment,get,slot,for,task,vertex,constraint,allocated,slot,new,slot,null,try,if,slot,from,group,null,if,slot,from,group,get,locality,locality,update,locality,counters,slot,from,group,get,locality,return,slot,from,group,final,iterable,instance,locations,constraint,null,constraint,is,unassigned,vertex,get,preferred,locations,collections,singleton,constraint,get,location,new,slot,get,free,slot,for,task,vertex,locations,sub,slot,to,use,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,unassigned,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,else,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,to,use,slot,from,group,else,if,slot,from,group,null,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,if,constraint,null,to,use,assignment,add,new,slot,with,task,new,slot,vertex,else,to,use,assignment,add,new,slot,with,task,new,slot,vertex,constraint,else,new,slot,release,slot,to,use,slot,from,group,if,constraint,null,if,constraint,is,unassigned,to,use,get,locality,locality,local,constraint,set,shared,slot,to,use,get,shared,slot,else,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,update,locality,counters,to,use,get,locality,return,to,use,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,allocated,slot,slot,get,free,slot,for,task,vertex,vertex,get,preferred,locations,if,slot,null,update,locality,counters,slot,get,locality,return,slot,else,if,queue,if,no,resource,slot,allocation,future,future,new,slot,allocation,future,this,task,queue,add,new,queued,task,task,future,return,future,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException;1415641452;Returns either an {@link AllocatedSlot}, or an {@link SlotAllocationFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException {_		if (task == null) {_			throw new IllegalArgumentException()__		}_		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}_		_		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__	_		synchronized (globalLock) {_		_			_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			if (sharingUnit != null) {_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException("A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				_				SubSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(vertex, constraint)__				}_				_				AllocatedSlot newSlot = null__				_				_				try {_					_					_					if (slotFromGroup != null) {_						_						if (slotFromGroup.getLocality() != Locality.NON_LOCAL) {_							updateLocalityCounters(slotFromGroup.getLocality())__							return slotFromGroup__						}_					}_					_					final Iterable<Instance> locations = (constraint == null || constraint.isUnassigned()) ?_							vertex.getPreferredLocations() : Collections.singleton(constraint.getLocation())__					_					_					newSlot = getFreeSlotForTask(vertex, locations)__					_					SubSlot toUse__					_					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							if (constraint == null || constraint.isUnassigned()) {_								throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(), getTotalNumberOfSlots())__							} else {_								throw new NoResourceAvailableException("Could not allocate a slot on instance " + _											constraint.getLocation() + ", as required by the co-location constraint.")__							}_						} else {_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || newSlot.getLocality() == Locality.LOCAL) {_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot()__						}_						_						if (constraint == null) {_							toUse = assignment.addNewSlotWithTask(newSlot, vertex)__						} else {_							toUse = assignment.addNewSlotWithTask(newSlot, vertex, constraint)__						}_					}_					else {_						_						newSlot.releaseSlot()__						toUse = slotFromGroup__					}_					_					_					_					if (constraint != null) {_						if (constraint.isUnassigned() || toUse.getLocality() == Locality.LOCAL) {_							constraint.setSharedSlot(toUse.getSharedSlot())__						} else {_							_							throw new NoResourceAvailableException("Could not allocate a slot on instance " + _									constraint.getLocation() + ", as required by the co-location constraint.")__						}_					}_					_					updateLocalityCounters(toUse.getLocality())__					return toUse__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}_					_					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}_			}_		_			_			_			AllocatedSlot slot = getFreeSlotForTask(vertex, vertex.getPreferredLocations())__			if (slot != null) {_				updateLocalityCounters(slot.getLocality())__				return slot__			}_			else {_				_				if (queueIfNoResource) {_					SlotAllocationFuture future = new SlotAllocationFuture()__					this.taskQueue.add(new QueuedTask(task, future))__					return future__				}_				else {_					throw new NoResourceAvailableException(getNumberOfAvailableInstances(), getTotalNumberOfSlots())__				}_			}_		}_	};returns,either,an,link,allocated,slot,or,an,link,slot,allocation,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,throws,no,resource,available,exception,if,task,null,throw,new,illegal,argument,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,sub,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,else,slot,from,group,assignment,get,slot,for,task,vertex,constraint,allocated,slot,new,slot,null,try,if,slot,from,group,null,if,slot,from,group,get,locality,locality,update,locality,counters,slot,from,group,get,locality,return,slot,from,group,final,iterable,instance,locations,constraint,null,constraint,is,unassigned,vertex,get,preferred,locations,collections,singleton,constraint,get,location,new,slot,get,free,slot,for,task,vertex,locations,sub,slot,to,use,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,unassigned,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,else,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,to,use,slot,from,group,else,if,slot,from,group,null,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,if,constraint,null,to,use,assignment,add,new,slot,with,task,new,slot,vertex,else,to,use,assignment,add,new,slot,with,task,new,slot,vertex,constraint,else,new,slot,release,slot,to,use,slot,from,group,if,constraint,null,if,constraint,is,unassigned,to,use,get,locality,locality,local,constraint,set,shared,slot,to,use,get,shared,slot,else,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,update,locality,counters,to,use,get,locality,return,to,use,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,allocated,slot,slot,get,free,slot,for,task,vertex,vertex,get,preferred,locations,if,slot,null,update,locality,counters,slot,get,locality,return,slot,else,if,queue,if,no,resource,slot,allocation,future,future,new,slot,allocation,future,this,task,queue,add,new,queued,task,task,future,return,future,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException;1416225736;Returns either an {@link AllocatedSlot}, or an {@link SlotAllocationFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException {_		if (task == null) {_			throw new IllegalArgumentException()__		}_		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}_		_		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__	_		synchronized (globalLock) {_		_			_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			if (sharingUnit != null) {_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException("A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				_				SubSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(vertex, constraint)__				}_				_				AllocatedSlot newSlot = null__				_				_				try {_					_					_					if (slotFromGroup != null) {_						_						if (slotFromGroup.getLocality() != Locality.NON_LOCAL) {_							updateLocalityCounters(slotFromGroup.getLocality())__							return slotFromGroup__						}_					}_					_					final Iterable<Instance> locations = (constraint == null || constraint.isUnassigned()) ?_							vertex.getPreferredLocations() : Collections.singleton(constraint.getLocation())__					_					_					newSlot = getFreeSlotForTask(vertex, locations)__					_					SubSlot toUse__					_					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							if (constraint == null || constraint.isUnassigned()) {_								throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(), getTotalNumberOfSlots())__							} else {_								throw new NoResourceAvailableException("Could not allocate a slot on instance " + _											constraint.getLocation() + ", as required by the co-location constraint.")__							}_						} else {_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || newSlot.getLocality() == Locality.LOCAL) {_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot()__						}_						_						if (constraint == null) {_							toUse = assignment.addNewSlotWithTask(newSlot, vertex)__						} else {_							toUse = assignment.addNewSlotWithTask(newSlot, vertex, constraint)__						}_					}_					else {_						_						newSlot.releaseSlot()__						toUse = slotFromGroup__					}_					_					_					_					if (constraint != null) {_						if (constraint.isUnassigned() || toUse.getLocality() == Locality.LOCAL) {_							constraint.setSharedSlot(toUse.getSharedSlot())__						} else {_							_							throw new NoResourceAvailableException("Could not allocate a slot on instance " + _									constraint.getLocation() + ", as required by the co-location constraint.")__						}_					}_					_					updateLocalityCounters(toUse.getLocality())__					return toUse__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}_					_					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}_			}_		_			_			_			AllocatedSlot slot = getFreeSlotForTask(vertex, vertex.getPreferredLocations())__			if (slot != null) {_				updateLocalityCounters(slot.getLocality())__				return slot__			}_			else {_				_				if (queueIfNoResource) {_					SlotAllocationFuture future = new SlotAllocationFuture()__					this.taskQueue.add(new QueuedTask(task, future))__					return future__				}_				else {_					throw new NoResourceAvailableException(getNumberOfAvailableInstances(), getTotalNumberOfSlots())__				}_			}_		}_	};returns,either,an,link,allocated,slot,or,an,link,slot,allocation,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,throws,no,resource,available,exception,if,task,null,throw,new,illegal,argument,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,sub,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,else,slot,from,group,assignment,get,slot,for,task,vertex,constraint,allocated,slot,new,slot,null,try,if,slot,from,group,null,if,slot,from,group,get,locality,locality,update,locality,counters,slot,from,group,get,locality,return,slot,from,group,final,iterable,instance,locations,constraint,null,constraint,is,unassigned,vertex,get,preferred,locations,collections,singleton,constraint,get,location,new,slot,get,free,slot,for,task,vertex,locations,sub,slot,to,use,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,unassigned,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,else,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,to,use,slot,from,group,else,if,slot,from,group,null,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,if,constraint,null,to,use,assignment,add,new,slot,with,task,new,slot,vertex,else,to,use,assignment,add,new,slot,with,task,new,slot,vertex,constraint,else,new,slot,release,slot,to,use,slot,from,group,if,constraint,null,if,constraint,is,unassigned,to,use,get,locality,locality,local,constraint,set,shared,slot,to,use,get,shared,slot,else,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,update,locality,counters,to,use,get,locality,return,to,use,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,allocated,slot,slot,get,free,slot,for,task,vertex,vertex,get,preferred,locations,if,slot,null,update,locality,counters,slot,get,locality,return,slot,else,if,queue,if,no,resource,slot,allocation,future,future,new,slot,allocation,future,this,task,queue,add,new,queued,task,task,future,return,future,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException;1416317653;Returns either an {@link org.apache.flink.runtime.instance.SimpleSlot}, or an {@link SlotAllocationFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException {_		if (task == null) {_			throw new IllegalArgumentException()__		}_		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}__		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__		_		final Iterable<Instance> preferredLocations = vertex.getPreferredLocations()__		final boolean forceExternalLocation = vertex.isScheduleLocalOnly() &&_									preferredLocations != null && preferredLocations.iterator().hasNext()__	_		synchronized (globalLock) {_		_			_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			if (sharingUnit != null) {_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException("A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				_				if (constraint != null && forceExternalLocation) {_					throw new IllegalArgumentException("The scheduling cannot be contrained simultaneously by a "_							+ "co-location constriaint and an external location constraint.")__				}_				_				_				SimpleSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(vertex, constraint)__				}__				SimpleSlot newSlot = null__				SimpleSlot toUse = null___				_				try {_					_					_					if (slotFromGroup != null) {_						_						if (slotFromGroup.getLocality() != Locality.NON_LOCAL) {_							updateLocalityCounters(slotFromGroup.getLocality())__							return slotFromGroup__						}_					}_					_					final Iterable<Instance> locations = (constraint == null || constraint.isUnassigned()) ?_							vertex.getPreferredLocations() : Collections.singleton(constraint.getLocation())__					_					_					newSlot = getFreeSubSlotForTask(vertex, locations, assignment, constraint, forceExternalLocation)___					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							if (constraint == null || constraint.isUnassigned()) {_								if (forceExternalLocation) {_									_									String hosts = getHostnamesFromInstances(preferredLocations)__									throw new NoResourceAvailableException("Could not schedule task " + vertex_											+ " to any of the required hosts: " + hosts)__								}_								else {_									_									throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(),_											getTotalNumberOfSlots(), getNumberOfAvailableSlots())__								}_							}_							else {_								_								throw new NoResourceAvailableException("Could not allocate a slot on instance " + _											constraint.getLocation() + ", as required by the co-location constraint.")__							}_						} else {_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || newSlot.getLocality() == Locality.LOCAL) {_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot()__						}_						_						toUse = newSlot__					}_					else {_						_						newSlot.releaseSlot()__						toUse = slotFromGroup__					}_					_					_					_					if (constraint != null) {_						if (constraint.isUnassigned() || toUse.getLocality() == Locality.LOCAL) {_							constraint.setSharedSlot(toUse.getParent())__						} else {_							_							throw new NoResourceAvailableException("Could not allocate a slot on instance " + _									constraint.getLocation() + ", as required by the co-location constraint.")__						}_					}_					_					updateLocalityCounters(toUse.getLocality())__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}__					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}__				return toUse__			} else {_				_				SimpleSlot slot = getFreeSlotForTask(vertex, preferredLocations, forceExternalLocation)__				if (slot != null) {_					updateLocalityCounters(slot.getLocality())__					return slot__				}_				else {_					_					if (queueIfNoResource) {_						SlotAllocationFuture future = new SlotAllocationFuture()__						this.taskQueue.add(new QueuedTask(task, future))__						return future__					}_					else if (forceExternalLocation) {_						String hosts = getHostnamesFromInstances(preferredLocations)__						throw new NoResourceAvailableException("Could not schedule task " + vertex_								+ " to any of the required hosts: " + hosts)__					}_					else {_						throw new NoResourceAvailableException(getNumberOfAvailableInstances(), getTotalNumberOfSlots(), getNumberOfAvailableSlots())__					}_				}_			}_		}_	};returns,either,an,link,org,apache,flink,runtime,instance,simple,slot,or,an,link,slot,allocation,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,throws,no,resource,available,exception,if,task,null,throw,new,illegal,argument,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,final,iterable,instance,preferred,locations,vertex,get,preferred,locations,final,boolean,force,external,location,vertex,is,schedule,local,only,preferred,locations,null,preferred,locations,iterator,has,next,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,if,constraint,null,force,external,location,throw,new,illegal,argument,exception,the,scheduling,cannot,be,contrained,simultaneously,by,a,co,location,constriaint,and,an,external,location,constraint,simple,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,else,slot,from,group,assignment,get,slot,for,task,vertex,constraint,simple,slot,new,slot,null,simple,slot,to,use,null,try,if,slot,from,group,null,if,slot,from,group,get,locality,locality,update,locality,counters,slot,from,group,get,locality,return,slot,from,group,final,iterable,instance,locations,constraint,null,constraint,is,unassigned,vertex,get,preferred,locations,collections,singleton,constraint,get,location,new,slot,get,free,sub,slot,for,task,vertex,locations,assignment,constraint,force,external,location,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,unassigned,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots,else,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,to,use,slot,from,group,else,if,slot,from,group,null,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,to,use,new,slot,else,new,slot,release,slot,to,use,slot,from,group,if,constraint,null,if,constraint,is,unassigned,to,use,get,locality,locality,local,constraint,set,shared,slot,to,use,get,parent,else,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,update,locality,counters,to,use,get,locality,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,return,to,use,else,simple,slot,slot,get,free,slot,for,task,vertex,preferred,locations,force,external,location,if,slot,null,update,locality,counters,slot,get,locality,return,slot,else,if,queue,if,no,resource,slot,allocation,future,future,new,slot,allocation,future,this,task,queue,add,new,queued,task,task,future,return,future,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException;1416878271;Returns either an {@link AllocatedSlot}, or an {@link SlotAllocationFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException {_		if (task == null) {_			throw new IllegalArgumentException()__		}_		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}_		_		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__	_		synchronized (globalLock) {_		_			_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			if (sharingUnit != null) {_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException("A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				_				SubSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(vertex, constraint)__				}_				_				AllocatedSlot newSlot = null__				_				_				try {_					_					_					if (slotFromGroup != null) {_						_						if (slotFromGroup.getLocality() != Locality.NON_LOCAL) {_							updateLocalityCounters(slotFromGroup.getLocality())__							return slotFromGroup__						}_					}_					_					final Iterable<Instance> locations = (constraint == null || constraint.isUnassigned()) ?_							vertex.getPreferredLocations() : Collections.singleton(constraint.getLocation())__					_					_					newSlot = getFreeSlotForTask(vertex, locations)__					_					SubSlot toUse__					_					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							if (constraint == null || constraint.isUnassigned()) {_								throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(), getTotalNumberOfSlots())__							} else {_								throw new NoResourceAvailableException("Could not allocate a slot on instance " + _											constraint.getLocation() + ", as required by the co-location constraint.")__							}_						} else {_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || newSlot.getLocality() == Locality.LOCAL) {_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot()__						}_						_						if (constraint == null) {_							toUse = assignment.addNewSlotWithTask(newSlot, vertex)__						} else {_							toUse = assignment.addNewSlotWithTask(newSlot, vertex, constraint)__						}_					}_					else {_						_						newSlot.releaseSlot()__						toUse = slotFromGroup__					}_					_					_					_					if (constraint != null) {_						if (constraint.isUnassigned() || toUse.getLocality() == Locality.LOCAL) {_							constraint.setSharedSlot(toUse.getSharedSlot())__						} else {_							_							throw new NoResourceAvailableException("Could not allocate a slot on instance " + _									constraint.getLocation() + ", as required by the co-location constraint.")__						}_					}_					_					updateLocalityCounters(toUse.getLocality())__					return toUse__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}_					_					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}_			}_		_			_			_			AllocatedSlot slot = getFreeSlotForTask(vertex, vertex.getPreferredLocations())__			if (slot != null) {_				updateLocalityCounters(slot.getLocality())__				return slot__			}_			else {_				_				if (queueIfNoResource) {_					SlotAllocationFuture future = new SlotAllocationFuture()__					this.taskQueue.add(new QueuedTask(task, future))__					return future__				}_				else {_					throw new NoResourceAvailableException(getNumberOfAvailableInstances(), getTotalNumberOfSlots())__				}_			}_		}_	};returns,either,an,link,allocated,slot,or,an,link,slot,allocation,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,throws,no,resource,available,exception,if,task,null,throw,new,illegal,argument,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,sub,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,else,slot,from,group,assignment,get,slot,for,task,vertex,constraint,allocated,slot,new,slot,null,try,if,slot,from,group,null,if,slot,from,group,get,locality,locality,update,locality,counters,slot,from,group,get,locality,return,slot,from,group,final,iterable,instance,locations,constraint,null,constraint,is,unassigned,vertex,get,preferred,locations,collections,singleton,constraint,get,location,new,slot,get,free,slot,for,task,vertex,locations,sub,slot,to,use,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,unassigned,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,else,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,to,use,slot,from,group,else,if,slot,from,group,null,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,if,constraint,null,to,use,assignment,add,new,slot,with,task,new,slot,vertex,else,to,use,assignment,add,new,slot,with,task,new,slot,vertex,constraint,else,new,slot,release,slot,to,use,slot,from,group,if,constraint,null,if,constraint,is,unassigned,to,use,get,locality,locality,local,constraint,set,shared,slot,to,use,get,shared,slot,else,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,update,locality,counters,to,use,get,locality,return,to,use,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,allocated,slot,slot,get,free,slot,for,task,vertex,vertex,get,preferred,locations,if,slot,null,update,locality,counters,slot,get,locality,return,slot,else,if,queue,if,no,resource,slot,allocation,future,future,new,slot,allocation,future,this,task,queue,add,new,queued,task,task,future,return,future,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException;1421056725;Returns either an {@link org.apache.flink.runtime.instance.SimpleSlot}, or an {@link SlotAllocationFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException {_		if (task == null) {_			throw new IllegalArgumentException()__		}_		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}__		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__	_		synchronized (globalLock) {_		_			_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			if (sharingUnit != null) {_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException("A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				_				SimpleSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(vertex, constraint)__				}__				SimpleSlot newSlot = null__				_				_				try {_					_					_					if (slotFromGroup != null) {_						_						if (slotFromGroup.getLocality() != Locality.NON_LOCAL) {_							updateLocalityCounters(slotFromGroup.getLocality())__							return slotFromGroup__						}_					}_					_					final Iterable<Instance> locations = (constraint == null || constraint.isUnassigned()) ?_							vertex.getPreferredLocations() : Collections.singleton(constraint.getLocation())__					_					_					newSlot = getFreeSubSlotForTask(vertex, locations, assignment, constraint)___					SimpleSlot toUse__					_					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							if (constraint == null || constraint.isUnassigned()) {_								throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(), getTotalNumberOfSlots(), getNumberOfAvailableSlots())__							} else {_								throw new NoResourceAvailableException("Could not allocate a slot on instance " + _											constraint.getLocation() + ", as required by the co-location constraint.")__							}_						} else {_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || newSlot.getLocality() == Locality.LOCAL) {_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot()__						}_						_						toUse = newSlot__					}_					else {_						_						newSlot.releaseSlot()__						toUse = slotFromGroup__					}_					_					_					_					if (constraint != null) {_						if (constraint.isUnassigned() || toUse.getLocality() == Locality.LOCAL) {_							constraint.setSharedSlot(toUse.getParent())__						} else {_							_							throw new NoResourceAvailableException("Could not allocate a slot on instance " + _									constraint.getLocation() + ", as required by the co-location constraint.")__						}_					}_					_					updateLocalityCounters(toUse.getLocality())__					return toUse__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}_					_					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}_			}_		_			_			_			SimpleSlot slot = getFreeSlotForTask(vertex, vertex.getPreferredLocations())__			if (slot != null) {_				updateLocalityCounters(slot.getLocality())__				return slot__			}_			else {_				_				if (queueIfNoResource) {_					SlotAllocationFuture future = new SlotAllocationFuture()__					this.taskQueue.add(new QueuedTask(task, future))__					return future__				}_				else {_					throw new NoResourceAvailableException(getNumberOfAvailableInstances(), getTotalNumberOfSlots(), getNumberOfAvailableSlots())__				}_			}_		}_	};returns,either,an,link,org,apache,flink,runtime,instance,simple,slot,or,an,link,slot,allocation,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,throws,no,resource,available,exception,if,task,null,throw,new,illegal,argument,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,simple,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,else,slot,from,group,assignment,get,slot,for,task,vertex,constraint,simple,slot,new,slot,null,try,if,slot,from,group,null,if,slot,from,group,get,locality,locality,update,locality,counters,slot,from,group,get,locality,return,slot,from,group,final,iterable,instance,locations,constraint,null,constraint,is,unassigned,vertex,get,preferred,locations,collections,singleton,constraint,get,location,new,slot,get,free,sub,slot,for,task,vertex,locations,assignment,constraint,simple,slot,to,use,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,unassigned,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots,else,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,to,use,slot,from,group,else,if,slot,from,group,null,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,to,use,new,slot,else,new,slot,release,slot,to,use,slot,from,group,if,constraint,null,if,constraint,is,unassigned,to,use,get,locality,locality,local,constraint,set,shared,slot,to,use,get,parent,else,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,update,locality,counters,to,use,get,locality,return,to,use,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,simple,slot,slot,get,free,slot,for,task,vertex,vertex,get,preferred,locations,if,slot,null,update,locality,counters,slot,get,locality,return,slot,else,if,queue,if,no,resource,slot,allocation,future,future,new,slot,allocation,future,this,task,queue,add,new,queued,task,task,future,return,future,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException;1423053613;Returns either an {@link org.apache.flink.runtime.instance.SimpleSlot}, or an {@link SlotAllocationFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException {_		if (task == null) {_			throw new IllegalArgumentException()__		}_		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}__		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__	_		synchronized (globalLock) {_		_			_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			if (sharingUnit != null) {_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException("A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				_				SimpleSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(vertex, constraint)__				}__				SimpleSlot newSlot = null__				_				_				try {_					_					_					if (slotFromGroup != null) {_						_						if (slotFromGroup.getLocality() != Locality.NON_LOCAL) {_							updateLocalityCounters(slotFromGroup.getLocality())__							return slotFromGroup__						}_					}_					_					final Iterable<Instance> locations = (constraint == null || constraint.isUnassigned()) ?_							vertex.getPreferredLocations() : Collections.singleton(constraint.getLocation())__					_					_					newSlot = getFreeSubSlotForTask(vertex, locations, assignment, constraint)___					SimpleSlot toUse__					_					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							if (constraint == null || constraint.isUnassigned()) {_								throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(), getTotalNumberOfSlots(), getNumberOfAvailableSlots())__							} else {_								throw new NoResourceAvailableException("Could not allocate a slot on instance " + _											constraint.getLocation() + ", as required by the co-location constraint.")__							}_						} else {_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || newSlot.getLocality() == Locality.LOCAL) {_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot()__						}_						_						toUse = newSlot__					}_					else {_						_						newSlot.releaseSlot()__						toUse = slotFromGroup__					}_					_					_					_					if (constraint != null) {_						if (constraint.isUnassigned() || toUse.getLocality() == Locality.LOCAL) {_							constraint.setSharedSlot(toUse.getParent())__						} else {_							_							throw new NoResourceAvailableException("Could not allocate a slot on instance " + _									constraint.getLocation() + ", as required by the co-location constraint.")__						}_					}_					_					updateLocalityCounters(toUse.getLocality())__					return toUse__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}_					_					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}_			}_		_			_			_			SimpleSlot slot = getFreeSlotForTask(vertex, vertex.getPreferredLocations())__			if (slot != null) {_				updateLocalityCounters(slot.getLocality())__				return slot__			}_			else {_				_				if (queueIfNoResource) {_					SlotAllocationFuture future = new SlotAllocationFuture()__					this.taskQueue.add(new QueuedTask(task, future))__					return future__				}_				else {_					throw new NoResourceAvailableException(getNumberOfAvailableInstances(), getTotalNumberOfSlots(), getNumberOfAvailableSlots())__				}_			}_		}_	};returns,either,an,link,org,apache,flink,runtime,instance,simple,slot,or,an,link,slot,allocation,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,throws,no,resource,available,exception,if,task,null,throw,new,illegal,argument,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,simple,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,else,slot,from,group,assignment,get,slot,for,task,vertex,constraint,simple,slot,new,slot,null,try,if,slot,from,group,null,if,slot,from,group,get,locality,locality,update,locality,counters,slot,from,group,get,locality,return,slot,from,group,final,iterable,instance,locations,constraint,null,constraint,is,unassigned,vertex,get,preferred,locations,collections,singleton,constraint,get,location,new,slot,get,free,sub,slot,for,task,vertex,locations,assignment,constraint,simple,slot,to,use,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,unassigned,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots,else,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,to,use,slot,from,group,else,if,slot,from,group,null,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,to,use,new,slot,else,new,slot,release,slot,to,use,slot,from,group,if,constraint,null,if,constraint,is,unassigned,to,use,get,locality,locality,local,constraint,set,shared,slot,to,use,get,parent,else,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,update,locality,counters,to,use,get,locality,return,to,use,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,simple,slot,slot,get,free,slot,for,task,vertex,vertex,get,preferred,locations,if,slot,null,update,locality,counters,slot,get,locality,return,slot,else,if,queue,if,no,resource,slot,allocation,future,future,new,slot,allocation,future,this,task,queue,add,new,queued,task,task,future,return,future,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException;1423157292;Returns either an {@link org.apache.flink.runtime.instance.SimpleSlot}, or an {@link SlotAllocationFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException {_		if (task == null) {_			throw new IllegalArgumentException()__		}_		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}__		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__		_		final Iterable<Instance> preferredLocations = vertex.getPreferredLocations()__		final boolean forceExternalLocation = vertex.isScheduleLocalOnly() &&_									preferredLocations != null && preferredLocations.iterator().hasNext()__	_		synchronized (globalLock) {_		_			_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			if (sharingUnit != null) {_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException("A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				_				if (constraint != null && forceExternalLocation) {_					throw new IllegalArgumentException("The scheduling cannot be contrained simultaneously by a "_							+ "co-location constriaint and an external location constraint.")__				}_				_				_				SimpleSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(vertex, constraint)__				}__				SimpleSlot newSlot = null__				_				_				try {_					_					_					if (slotFromGroup != null) {_						_						if (slotFromGroup.getLocality() != Locality.NON_LOCAL) {_							updateLocalityCounters(slotFromGroup.getLocality())__							return slotFromGroup__						}_					}_					_					final Iterable<Instance> locations = (constraint == null || constraint.isUnassigned()) ?_							vertex.getPreferredLocations() : Collections.singleton(constraint.getLocation())__					_					_					newSlot = getFreeSubSlotForTask(vertex, locations, assignment, constraint, forceExternalLocation)___					SimpleSlot toUse__					_					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							if (constraint == null || constraint.isUnassigned()) {_								if (forceExternalLocation) {_									_									String hosts = getHostnamesFromInstances(preferredLocations)__									throw new NoResourceAvailableException("Could not schedule task " + vertex_											+ " to any of the required hosts: " + hosts)__								}_								else {_									_									throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(),_											getTotalNumberOfSlots(), getNumberOfAvailableSlots())__								}_							}_							else {_								_								throw new NoResourceAvailableException("Could not allocate a slot on instance " + _											constraint.getLocation() + ", as required by the co-location constraint.")__							}_						} else {_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || newSlot.getLocality() == Locality.LOCAL) {_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot()__						}_						_						toUse = newSlot__					}_					else {_						_						newSlot.releaseSlot()__						toUse = slotFromGroup__					}_					_					_					_					if (constraint != null) {_						if (constraint.isUnassigned() || toUse.getLocality() == Locality.LOCAL) {_							constraint.setSharedSlot(toUse.getParent())__						} else {_							_							throw new NoResourceAvailableException("Could not allocate a slot on instance " + _									constraint.getLocation() + ", as required by the co-location constraint.")__						}_					}_					_					updateLocalityCounters(toUse.getLocality())__					return toUse__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}_					_					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}_			}_		_			_			{_				SimpleSlot slot = getFreeSlotForTask(vertex, preferredLocations, forceExternalLocation)__				if (slot != null) {_					updateLocalityCounters(slot.getLocality())__					return slot__				}_				else {_					_					if (queueIfNoResource) {_						SlotAllocationFuture future = new SlotAllocationFuture()__						this.taskQueue.add(new QueuedTask(task, future))__						return future__					}_					else if (forceExternalLocation) {_						String hosts = getHostnamesFromInstances(preferredLocations)__						throw new NoResourceAvailableException("Could not schedule task " + vertex_								+ " to any of the required hosts: " + hosts)__					}_					else {_						throw new NoResourceAvailableException(getNumberOfAvailableInstances(), getTotalNumberOfSlots(), getNumberOfAvailableSlots())__					}_				}_			}_		}_	};returns,either,an,link,org,apache,flink,runtime,instance,simple,slot,or,an,link,slot,allocation,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,throws,no,resource,available,exception,if,task,null,throw,new,illegal,argument,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,final,iterable,instance,preferred,locations,vertex,get,preferred,locations,final,boolean,force,external,location,vertex,is,schedule,local,only,preferred,locations,null,preferred,locations,iterator,has,next,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,if,constraint,null,force,external,location,throw,new,illegal,argument,exception,the,scheduling,cannot,be,contrained,simultaneously,by,a,co,location,constriaint,and,an,external,location,constraint,simple,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,else,slot,from,group,assignment,get,slot,for,task,vertex,constraint,simple,slot,new,slot,null,try,if,slot,from,group,null,if,slot,from,group,get,locality,locality,update,locality,counters,slot,from,group,get,locality,return,slot,from,group,final,iterable,instance,locations,constraint,null,constraint,is,unassigned,vertex,get,preferred,locations,collections,singleton,constraint,get,location,new,slot,get,free,sub,slot,for,task,vertex,locations,assignment,constraint,force,external,location,simple,slot,to,use,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,unassigned,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots,else,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,to,use,slot,from,group,else,if,slot,from,group,null,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,to,use,new,slot,else,new,slot,release,slot,to,use,slot,from,group,if,constraint,null,if,constraint,is,unassigned,to,use,get,locality,locality,local,constraint,set,shared,slot,to,use,get,parent,else,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,update,locality,counters,to,use,get,locality,return,to,use,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,simple,slot,slot,get,free,slot,for,task,vertex,preferred,locations,force,external,location,if,slot,null,update,locality,counters,slot,get,locality,return,slot,else,if,queue,if,no,resource,slot,allocation,future,future,new,slot,allocation,future,this,task,queue,add,new,queued,task,task,future,return,future,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException;1423419464;Returns either an {@link org.apache.flink.runtime.instance.SimpleSlot}, or an {@link SlotAllocationFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException {_		if (task == null) {_			throw new IllegalArgumentException()__		}_		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}__		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__		_		final Iterable<Instance> preferredLocations = vertex.getPreferredLocations()__		final boolean forceExternalLocation = vertex.isScheduleLocalOnly() &&_									preferredLocations != null && preferredLocations.iterator().hasNext()__	_		synchronized (globalLock) {_		_			_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			if (sharingUnit != null) {_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException("A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				_				if (constraint != null && forceExternalLocation) {_					throw new IllegalArgumentException("The scheduling cannot be contrained simultaneously by a "_							+ "co-location constriaint and an external location constraint.")__				}_				_				_				SimpleSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(vertex, constraint)__				}__				SimpleSlot newSlot = null__				_				_				try {_					_					_					if (slotFromGroup != null) {_						_						if (slotFromGroup.getLocality() != Locality.NON_LOCAL) {_							updateLocalityCounters(slotFromGroup.getLocality())__							return slotFromGroup__						}_					}_					_					final Iterable<Instance> locations = (constraint == null || constraint.isUnassigned()) ?_							vertex.getPreferredLocations() : Collections.singleton(constraint.getLocation())__					_					_					newSlot = getFreeSubSlotForTask(vertex, locations, assignment, constraint, forceExternalLocation)___					SimpleSlot toUse__					_					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							if (constraint == null || constraint.isUnassigned()) {_								if (forceExternalLocation) {_									_									String hosts = getHostnamesFromInstances(preferredLocations)__									throw new NoResourceAvailableException("Could not schedule task " + vertex_											+ " to any of the required hosts: " + hosts)__								}_								else {_									_									throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(),_											getTotalNumberOfSlots(), getNumberOfAvailableSlots())__								}_							}_							else {_								_								throw new NoResourceAvailableException("Could not allocate a slot on instance " + _											constraint.getLocation() + ", as required by the co-location constraint.")__							}_						} else {_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || newSlot.getLocality() == Locality.LOCAL) {_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot()__						}_						_						toUse = newSlot__					}_					else {_						_						newSlot.releaseSlot()__						toUse = slotFromGroup__					}_					_					_					_					if (constraint != null) {_						if (constraint.isUnassigned() || toUse.getLocality() == Locality.LOCAL) {_							constraint.setSharedSlot(toUse.getParent())__						} else {_							_							throw new NoResourceAvailableException("Could not allocate a slot on instance " + _									constraint.getLocation() + ", as required by the co-location constraint.")__						}_					}_					_					updateLocalityCounters(toUse.getLocality())__					return toUse__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}_					_					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}_			}_		_			_			{_				SimpleSlot slot = getFreeSlotForTask(vertex, preferredLocations, forceExternalLocation)__				if (slot != null) {_					updateLocalityCounters(slot.getLocality())__					return slot__				}_				else {_					_					if (queueIfNoResource) {_						SlotAllocationFuture future = new SlotAllocationFuture()__						this.taskQueue.add(new QueuedTask(task, future))__						return future__					}_					else if (forceExternalLocation) {_						String hosts = getHostnamesFromInstances(preferredLocations)__						throw new NoResourceAvailableException("Could not schedule task " + vertex_								+ " to any of the required hosts: " + hosts)__					}_					else {_						throw new NoResourceAvailableException(getNumberOfAvailableInstances(), getTotalNumberOfSlots(), getNumberOfAvailableSlots())__					}_				}_			}_		}_	};returns,either,an,link,org,apache,flink,runtime,instance,simple,slot,or,an,link,slot,allocation,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,throws,no,resource,available,exception,if,task,null,throw,new,illegal,argument,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,final,iterable,instance,preferred,locations,vertex,get,preferred,locations,final,boolean,force,external,location,vertex,is,schedule,local,only,preferred,locations,null,preferred,locations,iterator,has,next,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,if,constraint,null,force,external,location,throw,new,illegal,argument,exception,the,scheduling,cannot,be,contrained,simultaneously,by,a,co,location,constriaint,and,an,external,location,constraint,simple,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,else,slot,from,group,assignment,get,slot,for,task,vertex,constraint,simple,slot,new,slot,null,try,if,slot,from,group,null,if,slot,from,group,get,locality,locality,update,locality,counters,slot,from,group,get,locality,return,slot,from,group,final,iterable,instance,locations,constraint,null,constraint,is,unassigned,vertex,get,preferred,locations,collections,singleton,constraint,get,location,new,slot,get,free,sub,slot,for,task,vertex,locations,assignment,constraint,force,external,location,simple,slot,to,use,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,unassigned,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots,else,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,to,use,slot,from,group,else,if,slot,from,group,null,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,to,use,new,slot,else,new,slot,release,slot,to,use,slot,from,group,if,constraint,null,if,constraint,is,unassigned,to,use,get,locality,locality,local,constraint,set,shared,slot,to,use,get,parent,else,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,update,locality,counters,to,use,get,locality,return,to,use,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,simple,slot,slot,get,free,slot,for,task,vertex,preferred,locations,force,external,location,if,slot,null,update,locality,counters,slot,get,locality,return,slot,else,if,queue,if,no,resource,slot,allocation,future,future,new,slot,allocation,future,this,task,queue,add,new,queued,task,task,future,return,future,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException;1423749105;Returns either an {@link org.apache.flink.runtime.instance.SimpleSlot}, or an {@link SlotAllocationFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException {_		if (task == null) {_			throw new IllegalArgumentException()__		}_		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}__		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__		_		final Iterable<Instance> preferredLocations = vertex.getPreferredLocations()__		final boolean forceExternalLocation = vertex.isScheduleLocalOnly() &&_									preferredLocations != null && preferredLocations.iterator().hasNext()__	_		synchronized (globalLock) {_		_			_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			if (sharingUnit != null) {_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException("A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				_				if (constraint != null && forceExternalLocation) {_					throw new IllegalArgumentException("The scheduling cannot be contrained simultaneously by a "_							+ "co-location constriaint and an external location constraint.")__				}_				_				_				SimpleSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(vertex, constraint)__				}__				SimpleSlot newSlot = null__				_				_				try {_					_					_					if (slotFromGroup != null) {_						_						if (slotFromGroup.getLocality() != Locality.NON_LOCAL) {_							updateLocalityCounters(slotFromGroup.getLocality())__							return slotFromGroup__						}_					}_					_					final Iterable<Instance> locations = (constraint == null || constraint.isUnassigned()) ?_							vertex.getPreferredLocations() : Collections.singleton(constraint.getLocation())__					_					_					newSlot = getFreeSubSlotForTask(vertex, locations, assignment, constraint, forceExternalLocation)___					SimpleSlot toUse__					_					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							if (constraint == null || constraint.isUnassigned()) {_								if (forceExternalLocation) {_									_									String hosts = getHostnamesFromInstances(preferredLocations)__									throw new NoResourceAvailableException("Could not schedule task " + vertex_											+ " to any of the required hosts: " + hosts)__								}_								else {_									_									throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(),_											getTotalNumberOfSlots(), getNumberOfAvailableSlots())__								}_							}_							else {_								_								throw new NoResourceAvailableException("Could not allocate a slot on instance " + _											constraint.getLocation() + ", as required by the co-location constraint.")__							}_						} else {_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || newSlot.getLocality() == Locality.LOCAL) {_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot()__						}_						_						toUse = newSlot__					}_					else {_						_						newSlot.releaseSlot()__						toUse = slotFromGroup__					}_					_					_					_					if (constraint != null) {_						if (constraint.isUnassigned() || toUse.getLocality() == Locality.LOCAL) {_							constraint.setSharedSlot(toUse.getParent())__						} else {_							_							throw new NoResourceAvailableException("Could not allocate a slot on instance " + _									constraint.getLocation() + ", as required by the co-location constraint.")__						}_					}_					_					updateLocalityCounters(toUse.getLocality())__					return toUse__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}_					_					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}_			}_		_			_			{_				SimpleSlot slot = getFreeSlotForTask(vertex, preferredLocations, forceExternalLocation)__				if (slot != null) {_					updateLocalityCounters(slot.getLocality())__					return slot__				}_				else {_					_					if (queueIfNoResource) {_						SlotAllocationFuture future = new SlotAllocationFuture()__						this.taskQueue.add(new QueuedTask(task, future))__						return future__					}_					else if (forceExternalLocation) {_						String hosts = getHostnamesFromInstances(preferredLocations)__						throw new NoResourceAvailableException("Could not schedule task " + vertex_								+ " to any of the required hosts: " + hosts)__					}_					else {_						throw new NoResourceAvailableException(getNumberOfAvailableInstances(), getTotalNumberOfSlots(), getNumberOfAvailableSlots())__					}_				}_			}_		}_	};returns,either,an,link,org,apache,flink,runtime,instance,simple,slot,or,an,link,slot,allocation,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,throws,no,resource,available,exception,if,task,null,throw,new,illegal,argument,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,final,iterable,instance,preferred,locations,vertex,get,preferred,locations,final,boolean,force,external,location,vertex,is,schedule,local,only,preferred,locations,null,preferred,locations,iterator,has,next,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,if,constraint,null,force,external,location,throw,new,illegal,argument,exception,the,scheduling,cannot,be,contrained,simultaneously,by,a,co,location,constriaint,and,an,external,location,constraint,simple,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,else,slot,from,group,assignment,get,slot,for,task,vertex,constraint,simple,slot,new,slot,null,try,if,slot,from,group,null,if,slot,from,group,get,locality,locality,update,locality,counters,slot,from,group,get,locality,return,slot,from,group,final,iterable,instance,locations,constraint,null,constraint,is,unassigned,vertex,get,preferred,locations,collections,singleton,constraint,get,location,new,slot,get,free,sub,slot,for,task,vertex,locations,assignment,constraint,force,external,location,simple,slot,to,use,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,unassigned,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots,else,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,to,use,slot,from,group,else,if,slot,from,group,null,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,to,use,new,slot,else,new,slot,release,slot,to,use,slot,from,group,if,constraint,null,if,constraint,is,unassigned,to,use,get,locality,locality,local,constraint,set,shared,slot,to,use,get,parent,else,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,update,locality,counters,to,use,get,locality,return,to,use,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,simple,slot,slot,get,free,slot,for,task,vertex,preferred,locations,force,external,location,if,slot,null,update,locality,counters,slot,get,locality,return,slot,else,if,queue,if,no,resource,slot,allocation,future,future,new,slot,allocation,future,this,task,queue,add,new,queued,task,task,future,return,future,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException;1423931937;Returns either an {@link org.apache.flink.runtime.instance.SimpleSlot}, or an {@link SlotAllocationFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException {_		if (task == null) {_			throw new IllegalArgumentException()__		}_		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}__		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__		_		final Iterable<Instance> preferredLocations = vertex.getPreferredLocations()__		final boolean forceExternalLocation = vertex.isScheduleLocalOnly() &&_									preferredLocations != null && preferredLocations.iterator().hasNext()__	_		synchronized (globalLock) {_		_			_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			if (sharingUnit != null) {_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException("A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				_				if (constraint != null && forceExternalLocation) {_					throw new IllegalArgumentException("The scheduling cannot be contrained simultaneously by a "_							+ "co-location constriaint and an external location constraint.")__				}_				_				_				SimpleSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(vertex, constraint)__				}__				SimpleSlot newSlot = null__				SimpleSlot toUse = null___				_				try {_					_					_					if (slotFromGroup != null) {_						_						if (slotFromGroup.getLocality() != Locality.NON_LOCAL) {_							updateLocalityCounters(slotFromGroup.getLocality())__							return slotFromGroup__						}_					}_					_					final Iterable<Instance> locations = (constraint == null || constraint.isUnassigned()) ?_							vertex.getPreferredLocations() : Collections.singleton(constraint.getLocation())__					_					_					newSlot = getFreeSubSlotForTask(vertex, locations, assignment, constraint, forceExternalLocation)___					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							if (constraint == null || constraint.isUnassigned()) {_								if (forceExternalLocation) {_									_									String hosts = getHostnamesFromInstances(preferredLocations)__									throw new NoResourceAvailableException("Could not schedule task " + vertex_											+ " to any of the required hosts: " + hosts)__								}_								else {_									_									throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(),_											getTotalNumberOfSlots(), getNumberOfAvailableSlots())__								}_							}_							else {_								_								throw new NoResourceAvailableException("Could not allocate a slot on instance " + _											constraint.getLocation() + ", as required by the co-location constraint.")__							}_						} else {_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || newSlot.getLocality() == Locality.LOCAL) {_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot()__						}_						_						toUse = newSlot__					}_					else {_						_						newSlot.releaseSlot()__						toUse = slotFromGroup__					}_					_					_					_					if (constraint != null) {_						if (constraint.isUnassigned() || toUse.getLocality() == Locality.LOCAL) {_							constraint.setSharedSlot(toUse.getParent())__						} else {_							_							throw new NoResourceAvailableException("Could not allocate a slot on instance " + _									constraint.getLocation() + ", as required by the co-location constraint.")__						}_					}_					_					updateLocalityCounters(toUse.getLocality())__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}__					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}__				return toUse__			} else {_				_				SimpleSlot slot = getFreeSlotForTask(vertex, preferredLocations, forceExternalLocation)__				if (slot != null) {_					updateLocalityCounters(slot.getLocality())__					return slot__				}_				else {_					_					if (queueIfNoResource) {_						SlotAllocationFuture future = new SlotAllocationFuture()__						this.taskQueue.add(new QueuedTask(task, future))__						return future__					}_					else if (forceExternalLocation) {_						String hosts = getHostnamesFromInstances(preferredLocations)__						throw new NoResourceAvailableException("Could not schedule task " + vertex_								+ " to any of the required hosts: " + hosts)__					}_					else {_						throw new NoResourceAvailableException(getNumberOfAvailableInstances(), getTotalNumberOfSlots(), getNumberOfAvailableSlots())__					}_				}_			}_		}_	};returns,either,an,link,org,apache,flink,runtime,instance,simple,slot,or,an,link,slot,allocation,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,throws,no,resource,available,exception,if,task,null,throw,new,illegal,argument,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,final,iterable,instance,preferred,locations,vertex,get,preferred,locations,final,boolean,force,external,location,vertex,is,schedule,local,only,preferred,locations,null,preferred,locations,iterator,has,next,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,if,constraint,null,force,external,location,throw,new,illegal,argument,exception,the,scheduling,cannot,be,contrained,simultaneously,by,a,co,location,constriaint,and,an,external,location,constraint,simple,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,else,slot,from,group,assignment,get,slot,for,task,vertex,constraint,simple,slot,new,slot,null,simple,slot,to,use,null,try,if,slot,from,group,null,if,slot,from,group,get,locality,locality,update,locality,counters,slot,from,group,get,locality,return,slot,from,group,final,iterable,instance,locations,constraint,null,constraint,is,unassigned,vertex,get,preferred,locations,collections,singleton,constraint,get,location,new,slot,get,free,sub,slot,for,task,vertex,locations,assignment,constraint,force,external,location,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,unassigned,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots,else,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,to,use,slot,from,group,else,if,slot,from,group,null,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,to,use,new,slot,else,new,slot,release,slot,to,use,slot,from,group,if,constraint,null,if,constraint,is,unassigned,to,use,get,locality,locality,local,constraint,set,shared,slot,to,use,get,parent,else,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,update,locality,counters,to,use,get,locality,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,return,to,use,else,simple,slot,slot,get,free,slot,for,task,vertex,preferred,locations,force,external,location,if,slot,null,update,locality,counters,slot,get,locality,return,slot,else,if,queue,if,no,resource,slot,allocation,future,future,new,slot,allocation,future,this,task,queue,add,new,queued,task,task,future,return,future,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException;1432114676;Returns either a {@link org.apache.flink.runtime.instance.SimpleSlot}, or a {@link SlotAllocationFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException {_		if (task == null) {_			throw new NullPointerException()__		}_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}__		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__		_		final Iterable<Instance> preferredLocations = vertex.getPreferredLocations()__		final boolean forceExternalLocation = vertex.isScheduleLocalOnly() &&_									preferredLocations != null && preferredLocations.iterator().hasNext()__	_		synchronized (globalLock) {_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			_			if (sharingUnit != null) {__				_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException(_							"A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				_				if (constraint != null && forceExternalLocation) {_					throw new IllegalArgumentException("The scheduling cannot be constrained simultaneously by a "_							+ "co-location constraint and an external location constraint.")__				}_				_				_				final SimpleSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(vertex, constraint)__				}__				SimpleSlot newSlot = null__				SimpleSlot toUse = null___				_				try {_					_					_					_					if (slotFromGroup != null && slotFromGroup.getLocality() != Locality.NON_LOCAL) {_						_						_						_						if (constraint != null && !constraint.isAssigned()) {_							constraint.lockLocation()__						}_						_						updateLocalityCounters(slotFromGroup.getLocality(), vertex, slotFromGroup.getInstance())__						return slotFromGroup__					}_					_					_					_					_					_					final Iterable<Instance> locations__					final boolean localOnly__					if (constraint != null && constraint.isAssigned()) {_						locations = Collections.singleton(constraint.getLocation())__						localOnly = true__					}_					else {_						locations = vertex.getPreferredLocations()__						localOnly = forceExternalLocation__					}_					_					newSlot = getNewSlotForSharingGroup(vertex, locations, assignment, constraint, localOnly)___					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							_							if (constraint != null && constraint.isAssigned()) {_								_								throw new NoResourceAvailableException("Could not allocate a slot on instance " +_										constraint.getLocation() + ", as required by the co-location constraint.")__							}_							else if (forceExternalLocation) {_								_								String hosts = getHostnamesFromInstances(preferredLocations)__								throw new NoResourceAvailableException("Could not schedule task " + vertex_										+ " to any of the required hosts: " + hosts)__							}_							else {_								_								throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(),_										getTotalNumberOfSlots(), getNumberOfAvailableSlots())__							}_						}_						else {_							_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || !slotFromGroup.isAlive() || newSlot.getLocality() == Locality.LOCAL) {_						_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot()__						}_						toUse = newSlot__					}_					else {_						_						_						_						newSlot.releaseSlot()__						toUse = slotFromGroup__					}__					_					_					if (constraint != null && !constraint.isAssigned()) {_						constraint.lockLocation()__					}_					_					updateLocalityCounters(toUse.getLocality(), vertex, toUse.getInstance())__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}__					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}__				return toUse__			}_			else {_				_				_				_				SimpleSlot slot = getFreeSlotForTask(vertex, preferredLocations, forceExternalLocation)__				if (slot != null) {_					updateLocalityCounters(slot.getLocality(), vertex, slot.getInstance())__					return slot__				}_				else {_					_					if (queueIfNoResource) {_						SlotAllocationFuture future = new SlotAllocationFuture()__						this.taskQueue.add(new QueuedTask(task, future))__						return future__					}_					else if (forceExternalLocation) {_						String hosts = getHostnamesFromInstances(preferredLocations)__						throw new NoResourceAvailableException("Could not schedule task " + vertex_								+ " to any of the required hosts: " + hosts)__					}_					else {_						throw new NoResourceAvailableException(getNumberOfAvailableInstances(),_								getTotalNumberOfSlots(), getNumberOfAvailableSlots())__					}_				}_			}_		}_	};returns,either,a,link,org,apache,flink,runtime,instance,simple,slot,or,a,link,slot,allocation,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,throws,no,resource,available,exception,if,task,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,final,iterable,instance,preferred,locations,vertex,get,preferred,locations,final,boolean,force,external,location,vertex,is,schedule,local,only,preferred,locations,null,preferred,locations,iterator,has,next,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,if,constraint,null,force,external,location,throw,new,illegal,argument,exception,the,scheduling,cannot,be,constrained,simultaneously,by,a,co,location,constraint,and,an,external,location,constraint,final,simple,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,else,slot,from,group,assignment,get,slot,for,task,vertex,constraint,simple,slot,new,slot,null,simple,slot,to,use,null,try,if,slot,from,group,null,slot,from,group,get,locality,locality,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,slot,from,group,get,locality,vertex,slot,from,group,get,instance,return,slot,from,group,final,iterable,instance,locations,final,boolean,local,only,if,constraint,null,constraint,is,assigned,locations,collections,singleton,constraint,get,location,local,only,true,else,locations,vertex,get,preferred,locations,local,only,force,external,location,new,slot,get,new,slot,for,sharing,group,vertex,locations,assignment,constraint,local,only,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,assigned,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots,else,to,use,slot,from,group,else,if,slot,from,group,null,slot,from,group,is,alive,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,to,use,new,slot,else,new,slot,release,slot,to,use,slot,from,group,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,to,use,get,locality,vertex,to,use,get,instance,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,return,to,use,else,simple,slot,slot,get,free,slot,for,task,vertex,preferred,locations,force,external,location,if,slot,null,update,locality,counters,slot,get,locality,vertex,slot,get,instance,return,slot,else,if,queue,if,no,resource,slot,allocation,future,future,new,slot,allocation,future,this,task,queue,add,new,queued,task,task,future,return,future,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException;1434450422;Returns either a {@link org.apache.flink.runtime.instance.SimpleSlot}, or a {@link SlotAllocationFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException {_		if (task == null) {_			throw new NullPointerException()__		}_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}__		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__		_		final Iterable<Instance> preferredLocations = vertex.getPreferredLocations()__		final boolean forceExternalLocation = vertex.isScheduleLocalOnly() &&_									preferredLocations != null && preferredLocations.iterator().hasNext()__	_		synchronized (globalLock) {_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			_			if (sharingUnit != null) {__				_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException(_							"A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				_				if (constraint != null && forceExternalLocation) {_					throw new IllegalArgumentException("The scheduling cannot be constrained simultaneously by a "_							+ "co-location constraint and an external location constraint.")__				}_				_				_				final SimpleSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(vertex, constraint)__				}__				SimpleSlot newSlot = null__				SimpleSlot toUse = null___				_				try {_					_					_					_					if (slotFromGroup != null && slotFromGroup.getLocality() != Locality.NON_LOCAL) {_						_						_						_						if (constraint != null && !constraint.isAssigned()) {_							constraint.lockLocation()__						}_						_						updateLocalityCounters(slotFromGroup, vertex)__						return slotFromGroup__					}_					_					_					_					_					_					final Iterable<Instance> locations__					final boolean localOnly__					if (constraint != null && constraint.isAssigned()) {_						locations = Collections.singleton(constraint.getLocation())__						localOnly = true__					}_					else {_						locations = vertex.getPreferredLocations()__						localOnly = forceExternalLocation__					}_					_					newSlot = getNewSlotForSharingGroup(vertex, locations, assignment, constraint, localOnly)___					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							_							if (constraint != null && constraint.isAssigned()) {_								_								throw new NoResourceAvailableException("Could not allocate a slot on instance " +_										constraint.getLocation() + ", as required by the co-location constraint.")__							}_							else if (forceExternalLocation) {_								_								String hosts = getHostnamesFromInstances(preferredLocations)__								throw new NoResourceAvailableException("Could not schedule task " + vertex_										+ " to any of the required hosts: " + hosts)__							}_							else {_								_								throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(),_										getTotalNumberOfSlots(), getNumberOfAvailableSlots())__							}_						}_						else {_							_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || !slotFromGroup.isAlive() || newSlot.getLocality() == Locality.LOCAL) {_						_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot()__						}_						toUse = newSlot__					}_					else {_						_						_						_						newSlot.releaseSlot()__						toUse = slotFromGroup__					}__					_					_					if (constraint != null && !constraint.isAssigned()) {_						constraint.lockLocation()__					}_					_					updateLocalityCounters(toUse, vertex)__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}__					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}__				return toUse__			}_			else {_				_				_				_				SimpleSlot slot = getFreeSlotForTask(vertex, preferredLocations, forceExternalLocation)__				if (slot != null) {_					updateLocalityCounters(slot, vertex)__					return slot__				}_				else {_					_					if (queueIfNoResource) {_						SlotAllocationFuture future = new SlotAllocationFuture()__						this.taskQueue.add(new QueuedTask(task, future))__						return future__					}_					else if (forceExternalLocation) {_						String hosts = getHostnamesFromInstances(preferredLocations)__						throw new NoResourceAvailableException("Could not schedule task " + vertex_								+ " to any of the required hosts: " + hosts)__					}_					else {_						throw new NoResourceAvailableException(getNumberOfAvailableInstances(),_								getTotalNumberOfSlots(), getNumberOfAvailableSlots())__					}_				}_			}_		}_	};returns,either,a,link,org,apache,flink,runtime,instance,simple,slot,or,a,link,slot,allocation,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,throws,no,resource,available,exception,if,task,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,final,iterable,instance,preferred,locations,vertex,get,preferred,locations,final,boolean,force,external,location,vertex,is,schedule,local,only,preferred,locations,null,preferred,locations,iterator,has,next,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,if,constraint,null,force,external,location,throw,new,illegal,argument,exception,the,scheduling,cannot,be,constrained,simultaneously,by,a,co,location,constraint,and,an,external,location,constraint,final,simple,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,else,slot,from,group,assignment,get,slot,for,task,vertex,constraint,simple,slot,new,slot,null,simple,slot,to,use,null,try,if,slot,from,group,null,slot,from,group,get,locality,locality,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,slot,from,group,vertex,return,slot,from,group,final,iterable,instance,locations,final,boolean,local,only,if,constraint,null,constraint,is,assigned,locations,collections,singleton,constraint,get,location,local,only,true,else,locations,vertex,get,preferred,locations,local,only,force,external,location,new,slot,get,new,slot,for,sharing,group,vertex,locations,assignment,constraint,local,only,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,assigned,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots,else,to,use,slot,from,group,else,if,slot,from,group,null,slot,from,group,is,alive,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,to,use,new,slot,else,new,slot,release,slot,to,use,slot,from,group,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,to,use,vertex,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,return,to,use,else,simple,slot,slot,get,free,slot,for,task,vertex,preferred,locations,force,external,location,if,slot,null,update,locality,counters,slot,vertex,return,slot,else,if,queue,if,no,resource,slot,allocation,future,future,new,slot,allocation,future,this,task,queue,add,new,queued,task,task,future,return,future,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException;1436262104;Returns either a {@link org.apache.flink.runtime.instance.SimpleSlot}, or a {@link SlotAllocationFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException {_		if (task == null) {_			throw new NullPointerException()__		}_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}__		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__		_		final Iterable<Instance> preferredLocations = vertex.getPreferredLocations()__		final boolean forceExternalLocation = vertex.isScheduleLocalOnly() &&_									preferredLocations != null && preferredLocations.iterator().hasNext()__	_		synchronized (globalLock) {_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			_			if (sharingUnit != null) {__				_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException(_							"A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				_				if (constraint != null && forceExternalLocation) {_					throw new IllegalArgumentException("The scheduling cannot be constrained simultaneously by a "_							+ "co-location constraint and an external location constraint.")__				}_				_				_				final SimpleSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(vertex, constraint)__				}__				SimpleSlot newSlot = null__				SimpleSlot toUse = null___				_				try {_					_					_					_					if (slotFromGroup != null && slotFromGroup.getLocality() != Locality.NON_LOCAL) {_						_						_						_						if (constraint != null && !constraint.isAssigned()) {_							constraint.lockLocation()__						}_						_						updateLocalityCounters(slotFromGroup, vertex)__						return slotFromGroup__					}_					_					_					_					_					_					final Iterable<Instance> locations__					final boolean localOnly__					if (constraint != null && constraint.isAssigned()) {_						locations = Collections.singleton(constraint.getLocation())__						localOnly = true__					}_					else {_						locations = vertex.getPreferredLocations()__						localOnly = forceExternalLocation__					}_					_					newSlot = getNewSlotForSharingGroup(vertex, locations, assignment, constraint, localOnly)___					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							_							if (constraint != null && constraint.isAssigned()) {_								_								throw new NoResourceAvailableException("Could not allocate a slot on instance " +_										constraint.getLocation() + ", as required by the co-location constraint.")__							}_							else if (forceExternalLocation) {_								_								String hosts = getHostnamesFromInstances(preferredLocations)__								throw new NoResourceAvailableException("Could not schedule task " + vertex_										+ " to any of the required hosts: " + hosts)__							}_							else {_								_								throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(),_										getTotalNumberOfSlots(), getNumberOfAvailableSlots())__							}_						}_						else {_							_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || !slotFromGroup.isAlive() || newSlot.getLocality() == Locality.LOCAL) {_						_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot()__						}_						toUse = newSlot__					}_					else {_						_						_						_						newSlot.releaseSlot()__						toUse = slotFromGroup__					}__					_					_					if (constraint != null && !constraint.isAssigned()) {_						constraint.lockLocation()__					}_					_					updateLocalityCounters(toUse, vertex)__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}__					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}__				return toUse__			}_			else {_				_				_				_				SimpleSlot slot = getFreeSlotForTask(vertex, preferredLocations, forceExternalLocation)__				if (slot != null) {_					updateLocalityCounters(slot, vertex)__					return slot__				}_				else {_					_					if (queueIfNoResource) {_						SlotAllocationFuture future = new SlotAllocationFuture()__						this.taskQueue.add(new QueuedTask(task, future))__						return future__					}_					else if (forceExternalLocation) {_						String hosts = getHostnamesFromInstances(preferredLocations)__						throw new NoResourceAvailableException("Could not schedule task " + vertex_								+ " to any of the required hosts: " + hosts)__					}_					else {_						throw new NoResourceAvailableException(getNumberOfAvailableInstances(),_								getTotalNumberOfSlots(), getNumberOfAvailableSlots())__					}_				}_			}_		}_	};returns,either,a,link,org,apache,flink,runtime,instance,simple,slot,or,a,link,slot,allocation,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,throws,no,resource,available,exception,if,task,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,final,iterable,instance,preferred,locations,vertex,get,preferred,locations,final,boolean,force,external,location,vertex,is,schedule,local,only,preferred,locations,null,preferred,locations,iterator,has,next,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,if,constraint,null,force,external,location,throw,new,illegal,argument,exception,the,scheduling,cannot,be,constrained,simultaneously,by,a,co,location,constraint,and,an,external,location,constraint,final,simple,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,else,slot,from,group,assignment,get,slot,for,task,vertex,constraint,simple,slot,new,slot,null,simple,slot,to,use,null,try,if,slot,from,group,null,slot,from,group,get,locality,locality,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,slot,from,group,vertex,return,slot,from,group,final,iterable,instance,locations,final,boolean,local,only,if,constraint,null,constraint,is,assigned,locations,collections,singleton,constraint,get,location,local,only,true,else,locations,vertex,get,preferred,locations,local,only,force,external,location,new,slot,get,new,slot,for,sharing,group,vertex,locations,assignment,constraint,local,only,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,assigned,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots,else,to,use,slot,from,group,else,if,slot,from,group,null,slot,from,group,is,alive,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,to,use,new,slot,else,new,slot,release,slot,to,use,slot,from,group,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,to,use,vertex,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,return,to,use,else,simple,slot,slot,get,free,slot,for,task,vertex,preferred,locations,force,external,location,if,slot,null,update,locality,counters,slot,vertex,return,slot,else,if,queue,if,no,resource,slot,allocation,future,future,new,slot,allocation,future,this,task,queue,add,new,queued,task,task,future,return,future,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException;1445550685;Returns either a {@link org.apache.flink.runtime.instance.SimpleSlot}, or a {@link SlotAllocationFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException {_		if (task == null) {_			throw new NullPointerException()__		}_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}__		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__		_		final Iterable<Instance> preferredLocations = vertex.getPreferredLocations()__		final boolean forceExternalLocation = vertex.isScheduleLocalOnly() &&_									preferredLocations != null && preferredLocations.iterator().hasNext()__	_		synchronized (globalLock) {_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			_			if (sharingUnit != null) {__				_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException(_							"A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				_				if (constraint != null && forceExternalLocation) {_					throw new IllegalArgumentException("The scheduling cannot be constrained simultaneously by a "_							+ "co-location constraint and an external location constraint.")__				}_				_				_				final SimpleSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(vertex, constraint)__				}__				SimpleSlot newSlot = null__				SimpleSlot toUse = null___				_				try {_					_					_					_					if (slotFromGroup != null && slotFromGroup.getLocality() != Locality.NON_LOCAL) {_						_						_						_						if (constraint != null && !constraint.isAssigned()) {_							constraint.lockLocation()__						}_						_						updateLocalityCounters(slotFromGroup, vertex)__						return slotFromGroup__					}_					_					_					_					_					_					final Iterable<Instance> locations__					final boolean localOnly__					if (constraint != null && constraint.isAssigned()) {_						locations = Collections.singleton(constraint.getLocation())__						localOnly = true__					}_					else {_						locations = vertex.getPreferredLocations()__						localOnly = forceExternalLocation__					}_					_					newSlot = getNewSlotForSharingGroup(vertex, locations, assignment, constraint, localOnly)___					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							_							if (constraint != null && constraint.isAssigned()) {_								_								throw new NoResourceAvailableException("Could not allocate a slot on instance " +_										constraint.getLocation() + ", as required by the co-location constraint.")__							}_							else if (forceExternalLocation) {_								_								String hosts = getHostnamesFromInstances(preferredLocations)__								throw new NoResourceAvailableException("Could not schedule task " + vertex_										+ " to any of the required hosts: " + hosts)__							}_							else {_								_								throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(),_										getTotalNumberOfSlots(), getNumberOfAvailableSlots())__							}_						}_						else {_							_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || !slotFromGroup.isAlive() || newSlot.getLocality() == Locality.LOCAL) {_						_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot()__						}_						toUse = newSlot__					}_					else {_						_						_						_						newSlot.releaseSlot()__						toUse = slotFromGroup__					}__					_					_					if (constraint != null && !constraint.isAssigned()) {_						constraint.lockLocation()__					}_					_					updateLocalityCounters(toUse, vertex)__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}__					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}__				return toUse__			}_			else {_				_				_				_				SimpleSlot slot = getFreeSlotForTask(vertex, preferredLocations, forceExternalLocation)__				if (slot != null) {_					updateLocalityCounters(slot, vertex)__					return slot__				}_				else {_					_					if (queueIfNoResource) {_						SlotAllocationFuture future = new SlotAllocationFuture()__						this.taskQueue.add(new QueuedTask(task, future))__						return future__					}_					else if (forceExternalLocation) {_						String hosts = getHostnamesFromInstances(preferredLocations)__						throw new NoResourceAvailableException("Could not schedule task " + vertex_								+ " to any of the required hosts: " + hosts)__					}_					else {_						throw new NoResourceAvailableException(getNumberOfAvailableInstances(),_								getTotalNumberOfSlots(), getNumberOfAvailableSlots())__					}_				}_			}_		}_	};returns,either,a,link,org,apache,flink,runtime,instance,simple,slot,or,a,link,slot,allocation,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,throws,no,resource,available,exception,if,task,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,final,iterable,instance,preferred,locations,vertex,get,preferred,locations,final,boolean,force,external,location,vertex,is,schedule,local,only,preferred,locations,null,preferred,locations,iterator,has,next,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,if,constraint,null,force,external,location,throw,new,illegal,argument,exception,the,scheduling,cannot,be,constrained,simultaneously,by,a,co,location,constraint,and,an,external,location,constraint,final,simple,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,else,slot,from,group,assignment,get,slot,for,task,vertex,constraint,simple,slot,new,slot,null,simple,slot,to,use,null,try,if,slot,from,group,null,slot,from,group,get,locality,locality,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,slot,from,group,vertex,return,slot,from,group,final,iterable,instance,locations,final,boolean,local,only,if,constraint,null,constraint,is,assigned,locations,collections,singleton,constraint,get,location,local,only,true,else,locations,vertex,get,preferred,locations,local,only,force,external,location,new,slot,get,new,slot,for,sharing,group,vertex,locations,assignment,constraint,local,only,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,assigned,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots,else,to,use,slot,from,group,else,if,slot,from,group,null,slot,from,group,is,alive,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,to,use,new,slot,else,new,slot,release,slot,to,use,slot,from,group,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,to,use,vertex,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,return,to,use,else,simple,slot,slot,get,free,slot,for,task,vertex,preferred,locations,force,external,location,if,slot,null,update,locality,counters,slot,vertex,return,slot,else,if,queue,if,no,resource,slot,allocation,future,future,new,slot,allocation,future,this,task,queue,add,new,queued,task,task,future,return,future,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException;1472205100;Returns either a {@link org.apache.flink.runtime.instance.SimpleSlot}, or a {@link SlotAllocationFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException {_		if (task == null) {_			throw new NullPointerException()__		}_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}__		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__		_		final Iterable<TaskManagerLocation> preferredLocations = vertex.getPreferredLocations()__		final boolean forceExternalLocation = vertex.isScheduleLocalOnly() &&_									preferredLocations != null && preferredLocations.iterator().hasNext()__	_		synchronized (globalLock) {_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			_			if (sharingUnit != null) {__				_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException(_							"A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				_				if (constraint != null && forceExternalLocation) {_					throw new IllegalArgumentException("The scheduling cannot be constrained simultaneously by a "_							+ "co-location constraint and an external location constraint.")__				}_				_				_				final SimpleSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(vertex, constraint)__				}__				SimpleSlot newSlot = null__				SimpleSlot toUse = null___				_				try {_					_					_					_					if (slotFromGroup != null && slotFromGroup.getLocality() != Locality.NON_LOCAL) {_						_						_						_						if (constraint != null && !constraint.isAssigned()) {_							constraint.lockLocation()__						}_						_						updateLocalityCounters(slotFromGroup, vertex)__						return slotFromGroup__					}_					_					_					_					_					_					final Iterable<TaskManagerLocation> locations__					final boolean localOnly__					if (constraint != null && constraint.isAssigned()) {_						locations = Collections.singleton(constraint.getLocation())__						localOnly = true__					}_					else {_						locations = vertex.getPreferredLocations()__						localOnly = forceExternalLocation__					}_					_					newSlot = getNewSlotForSharingGroup(vertex, locations, assignment, constraint, localOnly)___					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							_							if (constraint != null && constraint.isAssigned()) {_								_								throw new NoResourceAvailableException("Could not allocate a slot on instance " +_										constraint.getLocation() + ", as required by the co-location constraint.")__							}_							else if (forceExternalLocation) {_								_								String hosts = getHostnamesFromInstances(preferredLocations)__								throw new NoResourceAvailableException("Could not schedule task " + vertex_										+ " to any of the required hosts: " + hosts)__							}_							else {_								_								throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(),_										getTotalNumberOfSlots(), getNumberOfAvailableSlots())__							}_						}_						else {_							_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || !slotFromGroup.isAlive() || newSlot.getLocality() == Locality.LOCAL) {_						_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot()__						}_						toUse = newSlot__					}_					else {_						_						_						_						newSlot.releaseSlot()__						toUse = slotFromGroup__					}__					_					_					if (constraint != null && !constraint.isAssigned()) {_						constraint.lockLocation()__					}_					_					updateLocalityCounters(toUse, vertex)__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}__					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}__				return toUse__			}_			else {_				_				_				_				SimpleSlot slot = getFreeSlotForTask(vertex, preferredLocations, forceExternalLocation)__				if (slot != null) {_					updateLocalityCounters(slot, vertex)__					return slot__				}_				else {_					_					if (queueIfNoResource) {_						SlotAllocationFuture future = new SlotAllocationFuture()__						this.taskQueue.add(new QueuedTask(task, future))__						return future__					}_					else if (forceExternalLocation) {_						String hosts = getHostnamesFromInstances(preferredLocations)__						throw new NoResourceAvailableException("Could not schedule task " + vertex_								+ " to any of the required hosts: " + hosts)__					}_					else {_						throw new NoResourceAvailableException(getNumberOfAvailableInstances(),_								getTotalNumberOfSlots(), getNumberOfAvailableSlots())__					}_				}_			}_		}_	};returns,either,a,link,org,apache,flink,runtime,instance,simple,slot,or,a,link,slot,allocation,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,throws,no,resource,available,exception,if,task,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,final,iterable,task,manager,location,preferred,locations,vertex,get,preferred,locations,final,boolean,force,external,location,vertex,is,schedule,local,only,preferred,locations,null,preferred,locations,iterator,has,next,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,if,constraint,null,force,external,location,throw,new,illegal,argument,exception,the,scheduling,cannot,be,constrained,simultaneously,by,a,co,location,constraint,and,an,external,location,constraint,final,simple,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,else,slot,from,group,assignment,get,slot,for,task,vertex,constraint,simple,slot,new,slot,null,simple,slot,to,use,null,try,if,slot,from,group,null,slot,from,group,get,locality,locality,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,slot,from,group,vertex,return,slot,from,group,final,iterable,task,manager,location,locations,final,boolean,local,only,if,constraint,null,constraint,is,assigned,locations,collections,singleton,constraint,get,location,local,only,true,else,locations,vertex,get,preferred,locations,local,only,force,external,location,new,slot,get,new,slot,for,sharing,group,vertex,locations,assignment,constraint,local,only,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,assigned,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots,else,to,use,slot,from,group,else,if,slot,from,group,null,slot,from,group,is,alive,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,to,use,new,slot,else,new,slot,release,slot,to,use,slot,from,group,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,to,use,vertex,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,return,to,use,else,simple,slot,slot,get,free,slot,for,task,vertex,preferred,locations,force,external,location,if,slot,null,update,locality,counters,slot,vertex,return,slot,else,if,queue,if,no,resource,slot,allocation,future,future,new,slot,allocation,future,this,task,queue,add,new,queued,task,task,future,return,future,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException;1472582060;Returns either a {@link org.apache.flink.runtime.instance.SimpleSlot}, or a {@link SlotAllocationFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException {_		if (task == null) {_			throw new NullPointerException()__		}_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}__		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__		_		final Iterable<TaskManagerLocation> preferredLocations = vertex.getPreferredLocations()__		final boolean forceExternalLocation = vertex.isScheduleLocalOnly() &&_									preferredLocations != null && preferredLocations.iterator().hasNext()__	_		synchronized (globalLock) {_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			_			if (sharingUnit != null) {__				_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException(_							"A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				_				if (constraint != null && forceExternalLocation) {_					throw new IllegalArgumentException("The scheduling cannot be constrained simultaneously by a "_							+ "co-location constraint and an external location constraint.")__				}_				_				_				final SimpleSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(vertex, constraint)__				}__				SimpleSlot newSlot = null__				SimpleSlot toUse = null___				_				try {_					_					_					_					if (slotFromGroup != null && slotFromGroup.getLocality() != Locality.NON_LOCAL) {_						_						_						_						if (constraint != null && !constraint.isAssigned()) {_							constraint.lockLocation()__						}_						_						updateLocalityCounters(slotFromGroup, vertex)__						return slotFromGroup__					}_					_					_					_					_					_					final Iterable<TaskManagerLocation> locations__					final boolean localOnly__					if (constraint != null && constraint.isAssigned()) {_						locations = Collections.singleton(constraint.getLocation())__						localOnly = true__					}_					else {_						locations = vertex.getPreferredLocations()__						localOnly = forceExternalLocation__					}_					_					newSlot = getNewSlotForSharingGroup(vertex, locations, assignment, constraint, localOnly)___					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							_							if (constraint != null && constraint.isAssigned()) {_								_								throw new NoResourceAvailableException("Could not allocate a slot on instance " +_										constraint.getLocation() + ", as required by the co-location constraint.")__							}_							else if (forceExternalLocation) {_								_								String hosts = getHostnamesFromInstances(preferredLocations)__								throw new NoResourceAvailableException("Could not schedule task " + vertex_										+ " to any of the required hosts: " + hosts)__							}_							else {_								_								throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(),_										getTotalNumberOfSlots(), getNumberOfAvailableSlots())__							}_						}_						else {_							_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || !slotFromGroup.isAlive() || newSlot.getLocality() == Locality.LOCAL) {_						_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot()__						}_						toUse = newSlot__					}_					else {_						_						_						_						newSlot.releaseSlot()__						toUse = slotFromGroup__					}__					_					_					if (constraint != null && !constraint.isAssigned()) {_						constraint.lockLocation()__					}_					_					updateLocalityCounters(toUse, vertex)__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}__					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}__				return toUse__			}_			else {_				_				_				_				SimpleSlot slot = getFreeSlotForTask(vertex, preferredLocations, forceExternalLocation)__				if (slot != null) {_					updateLocalityCounters(slot, vertex)__					return slot__				}_				else {_					_					if (queueIfNoResource) {_						SlotAllocationFuture future = new SlotAllocationFuture()__						this.taskQueue.add(new QueuedTask(task, future))__						return future__					}_					else if (forceExternalLocation) {_						String hosts = getHostnamesFromInstances(preferredLocations)__						throw new NoResourceAvailableException("Could not schedule task " + vertex_								+ " to any of the required hosts: " + hosts)__					}_					else {_						throw new NoResourceAvailableException(getNumberOfAvailableInstances(),_								getTotalNumberOfSlots(), getNumberOfAvailableSlots())__					}_				}_			}_		}_	};returns,either,a,link,org,apache,flink,runtime,instance,simple,slot,or,a,link,slot,allocation,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,throws,no,resource,available,exception,if,task,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,final,iterable,task,manager,location,preferred,locations,vertex,get,preferred,locations,final,boolean,force,external,location,vertex,is,schedule,local,only,preferred,locations,null,preferred,locations,iterator,has,next,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,if,constraint,null,force,external,location,throw,new,illegal,argument,exception,the,scheduling,cannot,be,constrained,simultaneously,by,a,co,location,constraint,and,an,external,location,constraint,final,simple,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,else,slot,from,group,assignment,get,slot,for,task,vertex,constraint,simple,slot,new,slot,null,simple,slot,to,use,null,try,if,slot,from,group,null,slot,from,group,get,locality,locality,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,slot,from,group,vertex,return,slot,from,group,final,iterable,task,manager,location,locations,final,boolean,local,only,if,constraint,null,constraint,is,assigned,locations,collections,singleton,constraint,get,location,local,only,true,else,locations,vertex,get,preferred,locations,local,only,force,external,location,new,slot,get,new,slot,for,sharing,group,vertex,locations,assignment,constraint,local,only,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,assigned,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots,else,to,use,slot,from,group,else,if,slot,from,group,null,slot,from,group,is,alive,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,to,use,new,slot,else,new,slot,release,slot,to,use,slot,from,group,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,to,use,vertex,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,return,to,use,else,simple,slot,slot,get,free,slot,for,task,vertex,preferred,locations,force,external,location,if,slot,null,update,locality,counters,slot,vertex,return,slot,else,if,queue,if,no,resource,slot,allocation,future,future,new,slot,allocation,future,this,task,queue,add,new,queued,task,task,future,return,future,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException;1472644741;Returns either a {@link org.apache.flink.runtime.instance.SimpleSlot}, or a {@link SlotAllocationFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException {_		if (task == null) {_			throw new NullPointerException()__		}_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}__		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__		_		final Iterable<TaskManagerLocation> preferredLocations = vertex.getPreferredLocations()__		final boolean forceExternalLocation = vertex.isScheduleLocalOnly() &&_									preferredLocations != null && preferredLocations.iterator().hasNext()__	_		synchronized (globalLock) {_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			_			if (sharingUnit != null) {__				_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException(_							"A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				_				if (constraint != null && forceExternalLocation) {_					throw new IllegalArgumentException("The scheduling cannot be constrained simultaneously by a "_							+ "co-location constraint and an external location constraint.")__				}_				_				_				final SimpleSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(vertex, constraint)__				}__				SimpleSlot newSlot = null__				SimpleSlot toUse = null___				_				try {_					_					_					_					if (slotFromGroup != null && slotFromGroup.getLocality() != Locality.NON_LOCAL) {_						_						_						_						if (constraint != null && !constraint.isAssigned()) {_							constraint.lockLocation()__						}_						_						updateLocalityCounters(slotFromGroup, vertex)__						return slotFromGroup__					}_					_					_					_					_					_					final Iterable<TaskManagerLocation> locations__					final boolean localOnly__					if (constraint != null && constraint.isAssigned()) {_						locations = Collections.singleton(constraint.getLocation())__						localOnly = true__					}_					else {_						locations = vertex.getPreferredLocations()__						localOnly = forceExternalLocation__					}_					_					newSlot = getNewSlotForSharingGroup(vertex, locations, assignment, constraint, localOnly)___					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							_							if (constraint != null && constraint.isAssigned()) {_								_								throw new NoResourceAvailableException("Could not allocate a slot on instance " +_										constraint.getLocation() + ", as required by the co-location constraint.")__							}_							else if (forceExternalLocation) {_								_								String hosts = getHostnamesFromInstances(preferredLocations)__								throw new NoResourceAvailableException("Could not schedule task " + vertex_										+ " to any of the required hosts: " + hosts)__							}_							else {_								_								throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(),_										getTotalNumberOfSlots(), getNumberOfAvailableSlots())__							}_						}_						else {_							_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || !slotFromGroup.isAlive() || newSlot.getLocality() == Locality.LOCAL) {_						_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot()__						}_						toUse = newSlot__					}_					else {_						_						_						_						newSlot.releaseSlot()__						toUse = slotFromGroup__					}__					_					_					if (constraint != null && !constraint.isAssigned()) {_						constraint.lockLocation()__					}_					_					updateLocalityCounters(toUse, vertex)__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}__					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}__				return toUse__			}_			else {_				_				_				_				SimpleSlot slot = getFreeSlotForTask(vertex, preferredLocations, forceExternalLocation)__				if (slot != null) {_					updateLocalityCounters(slot, vertex)__					return slot__				}_				else {_					_					if (queueIfNoResource) {_						SlotAllocationFuture future = new SlotAllocationFuture()__						this.taskQueue.add(new QueuedTask(task, future))__						return future__					}_					else if (forceExternalLocation) {_						String hosts = getHostnamesFromInstances(preferredLocations)__						throw new NoResourceAvailableException("Could not schedule task " + vertex_								+ " to any of the required hosts: " + hosts)__					}_					else {_						throw new NoResourceAvailableException(getNumberOfAvailableInstances(),_								getTotalNumberOfSlots(), getNumberOfAvailableSlots())__					}_				}_			}_		}_	};returns,either,a,link,org,apache,flink,runtime,instance,simple,slot,or,a,link,slot,allocation,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,throws,no,resource,available,exception,if,task,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,final,iterable,task,manager,location,preferred,locations,vertex,get,preferred,locations,final,boolean,force,external,location,vertex,is,schedule,local,only,preferred,locations,null,preferred,locations,iterator,has,next,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,if,constraint,null,force,external,location,throw,new,illegal,argument,exception,the,scheduling,cannot,be,constrained,simultaneously,by,a,co,location,constraint,and,an,external,location,constraint,final,simple,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,else,slot,from,group,assignment,get,slot,for,task,vertex,constraint,simple,slot,new,slot,null,simple,slot,to,use,null,try,if,slot,from,group,null,slot,from,group,get,locality,locality,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,slot,from,group,vertex,return,slot,from,group,final,iterable,task,manager,location,locations,final,boolean,local,only,if,constraint,null,constraint,is,assigned,locations,collections,singleton,constraint,get,location,local,only,true,else,locations,vertex,get,preferred,locations,local,only,force,external,location,new,slot,get,new,slot,for,sharing,group,vertex,locations,assignment,constraint,local,only,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,assigned,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots,else,to,use,slot,from,group,else,if,slot,from,group,null,slot,from,group,is,alive,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,to,use,new,slot,else,new,slot,release,slot,to,use,slot,from,group,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,to,use,vertex,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,return,to,use,else,simple,slot,slot,get,free,slot,for,task,vertex,preferred,locations,force,external,location,if,slot,null,update,locality,counters,slot,vertex,return,slot,else,if,queue,if,no,resource,slot,allocation,future,future,new,slot,allocation,future,this,task,queue,add,new,queued,task,task,future,return,future,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException;1473307213;Returns either a {@link SimpleSlot}, or a {@link Future}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException {_		if (task == null) {_			throw new NullPointerException()__		}_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}__		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__		_		final Iterable<TaskManagerLocation> preferredLocations = vertex.getPreferredLocations()__		final boolean forceExternalLocation = vertex.isScheduleLocalOnly() &&_									preferredLocations != null && preferredLocations.iterator().hasNext()__	_		synchronized (globalLock) {_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			_			if (sharingUnit != null) {__				_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException(_							"A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				_				if (constraint != null && forceExternalLocation) {_					throw new IllegalArgumentException("The scheduling cannot be constrained simultaneously by a "_							+ "co-location constraint and an external location constraint.")__				}_				_				_				final SimpleSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(vertex, constraint)__				}__				SimpleSlot newSlot = null__				SimpleSlot toUse = null___				_				try {_					_					_					_					if (slotFromGroup != null && slotFromGroup.getLocality() != Locality.NON_LOCAL) {_						_						_						_						if (constraint != null && !constraint.isAssigned()) {_							constraint.lockLocation()__						}_						_						updateLocalityCounters(slotFromGroup, vertex)__						return slotFromGroup__					}_					_					_					_					_					_					final Iterable<TaskManagerLocation> locations__					final boolean localOnly__					if (constraint != null && constraint.isAssigned()) {_						locations = Collections.singleton(constraint.getLocation())__						localOnly = true__					}_					else {_						locations = vertex.getPreferredLocations()__						localOnly = forceExternalLocation__					}_					_					newSlot = getNewSlotForSharingGroup(vertex, locations, assignment, constraint, localOnly)___					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							_							if (constraint != null && constraint.isAssigned()) {_								_								throw new NoResourceAvailableException("Could not allocate a slot on instance " +_										constraint.getLocation() + ", as required by the co-location constraint.")__							}_							else if (forceExternalLocation) {_								_								String hosts = getHostnamesFromInstances(preferredLocations)__								throw new NoResourceAvailableException("Could not schedule task " + vertex_										+ " to any of the required hosts: " + hosts)__							}_							else {_								_								throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(),_										getTotalNumberOfSlots(), getNumberOfAvailableSlots())__							}_						}_						else {_							_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || !slotFromGroup.isAlive() || newSlot.getLocality() == Locality.LOCAL) {_						_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot()__						}_						toUse = newSlot__					}_					else {_						_						_						_						newSlot.releaseSlot()__						toUse = slotFromGroup__					}__					_					_					if (constraint != null && !constraint.isAssigned()) {_						constraint.lockLocation()__					}_					_					updateLocalityCounters(toUse, vertex)__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}__					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}__				return toUse__			}_			else {_				_				_				_				SimpleSlot slot = getFreeSlotForTask(vertex, preferredLocations, forceExternalLocation)__				if (slot != null) {_					updateLocalityCounters(slot, vertex)__					return slot__				}_				else {_					_					if (queueIfNoResource) {_						CompletableFuture<SimpleSlot> future = new FlinkCompletableFuture<>()__						this.taskQueue.add(new QueuedTask(task, future))__						return future__					}_					else if (forceExternalLocation) {_						String hosts = getHostnamesFromInstances(preferredLocations)__						throw new NoResourceAvailableException("Could not schedule task " + vertex_								+ " to any of the required hosts: " + hosts)__					}_					else {_						throw new NoResourceAvailableException(getNumberOfAvailableInstances(),_								getTotalNumberOfSlots(), getNumberOfAvailableSlots())__					}_				}_			}_		}_	};returns,either,a,link,simple,slot,or,a,link,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,throws,no,resource,available,exception,if,task,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,final,iterable,task,manager,location,preferred,locations,vertex,get,preferred,locations,final,boolean,force,external,location,vertex,is,schedule,local,only,preferred,locations,null,preferred,locations,iterator,has,next,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,if,constraint,null,force,external,location,throw,new,illegal,argument,exception,the,scheduling,cannot,be,constrained,simultaneously,by,a,co,location,constraint,and,an,external,location,constraint,final,simple,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,else,slot,from,group,assignment,get,slot,for,task,vertex,constraint,simple,slot,new,slot,null,simple,slot,to,use,null,try,if,slot,from,group,null,slot,from,group,get,locality,locality,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,slot,from,group,vertex,return,slot,from,group,final,iterable,task,manager,location,locations,final,boolean,local,only,if,constraint,null,constraint,is,assigned,locations,collections,singleton,constraint,get,location,local,only,true,else,locations,vertex,get,preferred,locations,local,only,force,external,location,new,slot,get,new,slot,for,sharing,group,vertex,locations,assignment,constraint,local,only,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,assigned,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots,else,to,use,slot,from,group,else,if,slot,from,group,null,slot,from,group,is,alive,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,to,use,new,slot,else,new,slot,release,slot,to,use,slot,from,group,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,to,use,vertex,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,return,to,use,else,simple,slot,slot,get,free,slot,for,task,vertex,preferred,locations,force,external,location,if,slot,null,update,locality,counters,slot,vertex,return,slot,else,if,queue,if,no,resource,completable,future,simple,slot,future,new,flink,completable,future,this,task,queue,add,new,queued,task,task,future,return,future,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException;1474949408;Returns either a {@link org.apache.flink.runtime.instance.SimpleSlot}, or a {@link Future}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException {_		if (task == null) {_			throw new NullPointerException()__		}_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}__		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__		_		final Iterable<TaskManagerLocation> preferredLocations = vertex.getPreferredLocations()__		final boolean forceExternalLocation = vertex.isScheduleLocalOnly() &&_									preferredLocations != null && preferredLocations.iterator().hasNext()__	_		synchronized (globalLock) {_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			_			if (sharingUnit != null) {__				_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException(_							"A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				_				if (constraint != null && forceExternalLocation) {_					throw new IllegalArgumentException("The scheduling cannot be constrained simultaneously by a "_							+ "co-location constraint and an external location constraint.")__				}_				_				_				final SimpleSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(vertex, constraint)__				}__				SimpleSlot newSlot = null__				SimpleSlot toUse = null___				_				try {_					_					_					_					if (slotFromGroup != null && slotFromGroup.getLocality() != Locality.NON_LOCAL) {_						_						_						_						if (constraint != null && !constraint.isAssigned()) {_							constraint.lockLocation()__						}_						_						updateLocalityCounters(slotFromGroup, vertex)__						return slotFromGroup__					}_					_					_					_					_					_					final Iterable<TaskManagerLocation> locations__					final boolean localOnly__					if (constraint != null && constraint.isAssigned()) {_						locations = Collections.singleton(constraint.getLocation())__						localOnly = true__					}_					else {_						locations = vertex.getPreferredLocations()__						localOnly = forceExternalLocation__					}_					_					newSlot = getNewSlotForSharingGroup(vertex, locations, assignment, constraint, localOnly)___					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							_							if (constraint != null && constraint.isAssigned()) {_								_								throw new NoResourceAvailableException("Could not allocate a slot on instance " +_										constraint.getLocation() + ", as required by the co-location constraint.")__							}_							else if (forceExternalLocation) {_								_								String hosts = getHostnamesFromInstances(preferredLocations)__								throw new NoResourceAvailableException("Could not schedule task " + vertex_										+ " to any of the required hosts: " + hosts)__							}_							else {_								_								throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(),_										getTotalNumberOfSlots(), getNumberOfAvailableSlots())__							}_						}_						else {_							_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || !slotFromGroup.isAlive() || newSlot.getLocality() == Locality.LOCAL) {_						_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot()__						}_						toUse = newSlot__					}_					else {_						_						_						_						newSlot.releaseSlot()__						toUse = slotFromGroup__					}__					_					_					if (constraint != null && !constraint.isAssigned()) {_						constraint.lockLocation()__					}_					_					updateLocalityCounters(toUse, vertex)__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}__					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}__				return toUse__			}_			else {_				_				_				_				SimpleSlot slot = getFreeSlotForTask(vertex, preferredLocations, forceExternalLocation)__				if (slot != null) {_					updateLocalityCounters(slot, vertex)__					return slot__				}_				else {_					_					if (queueIfNoResource) {_						FlinkCompletableFuture<SimpleSlot> future = new FlinkCompletableFuture<>()__						this.taskQueue.add(new QueuedTask(task, future))__						return future__					}_					else if (forceExternalLocation) {_						String hosts = getHostnamesFromInstances(preferredLocations)__						throw new NoResourceAvailableException("Could not schedule task " + vertex_								+ " to any of the required hosts: " + hosts)__					}_					else {_						throw new NoResourceAvailableException(getNumberOfAvailableInstances(),_								getTotalNumberOfSlots(), getNumberOfAvailableSlots())__					}_				}_			}_		}_	};returns,either,a,link,org,apache,flink,runtime,instance,simple,slot,or,a,link,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,throws,no,resource,available,exception,if,task,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,final,iterable,task,manager,location,preferred,locations,vertex,get,preferred,locations,final,boolean,force,external,location,vertex,is,schedule,local,only,preferred,locations,null,preferred,locations,iterator,has,next,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,if,constraint,null,force,external,location,throw,new,illegal,argument,exception,the,scheduling,cannot,be,constrained,simultaneously,by,a,co,location,constraint,and,an,external,location,constraint,final,simple,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,else,slot,from,group,assignment,get,slot,for,task,vertex,constraint,simple,slot,new,slot,null,simple,slot,to,use,null,try,if,slot,from,group,null,slot,from,group,get,locality,locality,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,slot,from,group,vertex,return,slot,from,group,final,iterable,task,manager,location,locations,final,boolean,local,only,if,constraint,null,constraint,is,assigned,locations,collections,singleton,constraint,get,location,local,only,true,else,locations,vertex,get,preferred,locations,local,only,force,external,location,new,slot,get,new,slot,for,sharing,group,vertex,locations,assignment,constraint,local,only,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,assigned,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots,else,to,use,slot,from,group,else,if,slot,from,group,null,slot,from,group,is,alive,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,to,use,new,slot,else,new,slot,release,slot,to,use,slot,from,group,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,to,use,vertex,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,return,to,use,else,simple,slot,slot,get,free,slot,for,task,vertex,preferred,locations,force,external,location,if,slot,null,update,locality,counters,slot,vertex,return,slot,else,if,queue,if,no,resource,flink,completable,future,simple,slot,future,new,flink,completable,future,this,task,queue,add,new,queued,task,task,future,return,future,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException;1474983187;Returns either a {@link SimpleSlot}, or a {@link Future}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException {_		if (task == null) {_			throw new NullPointerException()__		}_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}__		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__		_		final Iterable<TaskManagerLocation> preferredLocations = vertex.getPreferredLocations()__		final boolean forceExternalLocation = vertex.isScheduleLocalOnly() &&_									preferredLocations != null && preferredLocations.iterator().hasNext()__	_		synchronized (globalLock) {_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			_			if (sharingUnit != null) {__				_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException(_							"A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				_				if (constraint != null && forceExternalLocation) {_					throw new IllegalArgumentException("The scheduling cannot be constrained simultaneously by a "_							+ "co-location constraint and an external location constraint.")__				}_				_				_				final SimpleSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(vertex, constraint)__				}__				SimpleSlot newSlot = null__				SimpleSlot toUse = null___				_				try {_					_					_					_					if (slotFromGroup != null && slotFromGroup.getLocality() != Locality.NON_LOCAL) {_						_						_						_						if (constraint != null && !constraint.isAssigned()) {_							constraint.lockLocation()__						}_						_						updateLocalityCounters(slotFromGroup, vertex)__						return slotFromGroup__					}_					_					_					_					_					_					final Iterable<TaskManagerLocation> locations__					final boolean localOnly__					if (constraint != null && constraint.isAssigned()) {_						locations = Collections.singleton(constraint.getLocation())__						localOnly = true__					}_					else {_						locations = vertex.getPreferredLocations()__						localOnly = forceExternalLocation__					}_					_					newSlot = getNewSlotForSharingGroup(vertex, locations, assignment, constraint, localOnly)___					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							_							if (constraint != null && constraint.isAssigned()) {_								_								throw new NoResourceAvailableException("Could not allocate a slot on instance " +_										constraint.getLocation() + ", as required by the co-location constraint.")__							}_							else if (forceExternalLocation) {_								_								String hosts = getHostnamesFromInstances(preferredLocations)__								throw new NoResourceAvailableException("Could not schedule task " + vertex_										+ " to any of the required hosts: " + hosts)__							}_							else {_								_								throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(),_										getTotalNumberOfSlots(), getNumberOfAvailableSlots())__							}_						}_						else {_							_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || !slotFromGroup.isAlive() || newSlot.getLocality() == Locality.LOCAL) {_						_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot()__						}_						toUse = newSlot__					}_					else {_						_						_						_						newSlot.releaseSlot()__						toUse = slotFromGroup__					}__					_					_					if (constraint != null && !constraint.isAssigned()) {_						constraint.lockLocation()__					}_					_					updateLocalityCounters(toUse, vertex)__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}__					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}__				return toUse__			}_			else {_				_				_				_				SimpleSlot slot = getFreeSlotForTask(vertex, preferredLocations, forceExternalLocation)__				if (slot != null) {_					updateLocalityCounters(slot, vertex)__					return slot__				}_				else {_					_					if (queueIfNoResource) {_						CompletableFuture<SimpleSlot> future = new FlinkCompletableFuture<>()__						this.taskQueue.add(new QueuedTask(task, future))__						return future__					}_					else if (forceExternalLocation) {_						String hosts = getHostnamesFromInstances(preferredLocations)__						throw new NoResourceAvailableException("Could not schedule task " + vertex_								+ " to any of the required hosts: " + hosts)__					}_					else {_						throw new NoResourceAvailableException(getNumberOfAvailableInstances(),_								getTotalNumberOfSlots(), getNumberOfAvailableSlots())__					}_				}_			}_		}_	};returns,either,a,link,simple,slot,or,a,link,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,throws,no,resource,available,exception,if,task,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,final,iterable,task,manager,location,preferred,locations,vertex,get,preferred,locations,final,boolean,force,external,location,vertex,is,schedule,local,only,preferred,locations,null,preferred,locations,iterator,has,next,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,if,constraint,null,force,external,location,throw,new,illegal,argument,exception,the,scheduling,cannot,be,constrained,simultaneously,by,a,co,location,constraint,and,an,external,location,constraint,final,simple,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,else,slot,from,group,assignment,get,slot,for,task,vertex,constraint,simple,slot,new,slot,null,simple,slot,to,use,null,try,if,slot,from,group,null,slot,from,group,get,locality,locality,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,slot,from,group,vertex,return,slot,from,group,final,iterable,task,manager,location,locations,final,boolean,local,only,if,constraint,null,constraint,is,assigned,locations,collections,singleton,constraint,get,location,local,only,true,else,locations,vertex,get,preferred,locations,local,only,force,external,location,new,slot,get,new,slot,for,sharing,group,vertex,locations,assignment,constraint,local,only,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,assigned,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots,else,to,use,slot,from,group,else,if,slot,from,group,null,slot,from,group,is,alive,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,to,use,new,slot,else,new,slot,release,slot,to,use,slot,from,group,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,to,use,vertex,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,return,to,use,else,simple,slot,slot,get,free,slot,for,task,vertex,preferred,locations,force,external,location,if,slot,null,update,locality,counters,slot,vertex,return,slot,else,if,queue,if,no,resource,completable,future,simple,slot,future,new,flink,completable,future,this,task,queue,add,new,queued,task,task,future,return,future,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException;1485888959;Returns either a {@link SimpleSlot}, or a {@link Future}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException {_		if (task == null) {_			throw new NullPointerException()__		}_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}__		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__		_		final Iterable<TaskManagerLocation> preferredLocations = vertex.getPreferredLocations()__		final boolean forceExternalLocation = false &&_									preferredLocations != null && preferredLocations.iterator().hasNext()__	_		synchronized (globalLock) {_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			_			if (sharingUnit != null) {__				_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException(_							"A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				_				if (constraint != null && forceExternalLocation) {_					throw new IllegalArgumentException("The scheduling cannot be constrained simultaneously by a "_							+ "co-location constraint and an external location constraint.")__				}_				_				_				final SimpleSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(vertex, constraint)__				}__				SimpleSlot newSlot = null__				SimpleSlot toUse = null___				_				try {_					_					_					_					if (slotFromGroup != null && slotFromGroup.getLocality() != Locality.NON_LOCAL) {_						_						_						_						if (constraint != null && !constraint.isAssigned()) {_							constraint.lockLocation()__						}_						_						updateLocalityCounters(slotFromGroup, vertex)__						return slotFromGroup__					}_					_					_					_					_					_					final Iterable<TaskManagerLocation> locations__					final boolean localOnly__					if (constraint != null && constraint.isAssigned()) {_						locations = Collections.singleton(constraint.getLocation())__						localOnly = true__					}_					else {_						locations = vertex.getPreferredLocations()__						localOnly = forceExternalLocation__					}_					_					newSlot = getNewSlotForSharingGroup(vertex, locations, assignment, constraint, localOnly)___					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							_							if (constraint != null && constraint.isAssigned()) {_								_								throw new NoResourceAvailableException("Could not allocate a slot on instance " +_										constraint.getLocation() + ", as required by the co-location constraint.")__							}_							else if (forceExternalLocation) {_								_								String hosts = getHostnamesFromInstances(preferredLocations)__								throw new NoResourceAvailableException("Could not schedule task " + vertex_										+ " to any of the required hosts: " + hosts)__							}_							else {_								_								throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(),_										getTotalNumberOfSlots(), getNumberOfAvailableSlots())__							}_						}_						else {_							_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || !slotFromGroup.isAlive() || newSlot.getLocality() == Locality.LOCAL) {_						_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot()__						}_						toUse = newSlot__					}_					else {_						_						_						_						newSlot.releaseSlot()__						toUse = slotFromGroup__					}__					_					_					if (constraint != null && !constraint.isAssigned()) {_						constraint.lockLocation()__					}_					_					updateLocalityCounters(toUse, vertex)__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}__					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}__				return toUse__			}_			else {_				_				_				_				SimpleSlot slot = getFreeSlotForTask(vertex, preferredLocations, forceExternalLocation)__				if (slot != null) {_					updateLocalityCounters(slot, vertex)__					return slot__				}_				else {_					_					if (queueIfNoResource) {_						CompletableFuture<SimpleSlot> future = new FlinkCompletableFuture<>()__						this.taskQueue.add(new QueuedTask(task, future))__						return future__					}_					else if (forceExternalLocation) {_						String hosts = getHostnamesFromInstances(preferredLocations)__						throw new NoResourceAvailableException("Could not schedule task " + vertex_								+ " to any of the required hosts: " + hosts)__					}_					else {_						throw new NoResourceAvailableException(getNumberOfAvailableInstances(),_								getTotalNumberOfSlots(), getNumberOfAvailableSlots())__					}_				}_			}_		}_	};returns,either,a,link,simple,slot,or,a,link,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,throws,no,resource,available,exception,if,task,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,final,iterable,task,manager,location,preferred,locations,vertex,get,preferred,locations,final,boolean,force,external,location,false,preferred,locations,null,preferred,locations,iterator,has,next,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,if,constraint,null,force,external,location,throw,new,illegal,argument,exception,the,scheduling,cannot,be,constrained,simultaneously,by,a,co,location,constraint,and,an,external,location,constraint,final,simple,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,else,slot,from,group,assignment,get,slot,for,task,vertex,constraint,simple,slot,new,slot,null,simple,slot,to,use,null,try,if,slot,from,group,null,slot,from,group,get,locality,locality,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,slot,from,group,vertex,return,slot,from,group,final,iterable,task,manager,location,locations,final,boolean,local,only,if,constraint,null,constraint,is,assigned,locations,collections,singleton,constraint,get,location,local,only,true,else,locations,vertex,get,preferred,locations,local,only,force,external,location,new,slot,get,new,slot,for,sharing,group,vertex,locations,assignment,constraint,local,only,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,assigned,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots,else,to,use,slot,from,group,else,if,slot,from,group,null,slot,from,group,is,alive,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,to,use,new,slot,else,new,slot,release,slot,to,use,slot,from,group,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,to,use,vertex,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,return,to,use,else,simple,slot,slot,get,free,slot,for,task,vertex,preferred,locations,force,external,location,if,slot,null,update,locality,counters,slot,vertex,return,slot,else,if,queue,if,no,resource,completable,future,simple,slot,future,new,flink,completable,future,this,task,queue,add,new,queued,task,task,future,return,future,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException;1485891273;Returns either a {@link SimpleSlot}, or a {@link Future}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException {_		if (task == null) {_			throw new NullPointerException()__		}_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}__		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__		_		final Iterable<TaskManagerLocation> preferredLocations = vertex.getPreferredLocationsBasedOnInputs()__		final boolean forceExternalLocation = false &&_									preferredLocations != null && preferredLocations.iterator().hasNext()__	_		synchronized (globalLock) {_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			_			if (sharingUnit != null) {__				_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException(_							"A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				_				if (constraint != null && forceExternalLocation) {_					throw new IllegalArgumentException("The scheduling cannot be constrained simultaneously by a "_							+ "co-location constraint and an external location constraint.")__				}_				_				_				final SimpleSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(vertex, constraint)__				}__				SimpleSlot newSlot = null__				SimpleSlot toUse = null___				_				try {_					_					_					_					if (slotFromGroup != null && slotFromGroup.getLocality() != Locality.NON_LOCAL) {_						_						_						_						if (constraint != null && !constraint.isAssigned()) {_							constraint.lockLocation()__						}_						_						updateLocalityCounters(slotFromGroup, vertex)__						return slotFromGroup__					}_					_					_					_					_					_					final Iterable<TaskManagerLocation> locations__					final boolean localOnly__					if (constraint != null && constraint.isAssigned()) {_						locations = Collections.singleton(constraint.getLocation())__						localOnly = true__					}_					else {_						locations = vertex.getPreferredLocationsBasedOnInputs()__						localOnly = forceExternalLocation__					}_					_					newSlot = getNewSlotForSharingGroup(vertex, locations, assignment, constraint, localOnly)___					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							_							if (constraint != null && constraint.isAssigned()) {_								_								throw new NoResourceAvailableException("Could not allocate a slot on instance " +_										constraint.getLocation() + ", as required by the co-location constraint.")__							}_							else if (forceExternalLocation) {_								_								String hosts = getHostnamesFromInstances(preferredLocations)__								throw new NoResourceAvailableException("Could not schedule task " + vertex_										+ " to any of the required hosts: " + hosts)__							}_							else {_								_								throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(),_										getTotalNumberOfSlots(), getNumberOfAvailableSlots())__							}_						}_						else {_							_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || !slotFromGroup.isAlive() || newSlot.getLocality() == Locality.LOCAL) {_						_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot()__						}_						toUse = newSlot__					}_					else {_						_						_						_						newSlot.releaseSlot()__						toUse = slotFromGroup__					}__					_					_					if (constraint != null && !constraint.isAssigned()) {_						constraint.lockLocation()__					}_					_					updateLocalityCounters(toUse, vertex)__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}__					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}__				return toUse__			}_			else {_				_				_				_				SimpleSlot slot = getFreeSlotForTask(vertex, preferredLocations, forceExternalLocation)__				if (slot != null) {_					updateLocalityCounters(slot, vertex)__					return slot__				}_				else {_					_					if (queueIfNoResource) {_						CompletableFuture<SimpleSlot> future = new FlinkCompletableFuture<>()__						this.taskQueue.add(new QueuedTask(task, future))__						return future__					}_					else if (forceExternalLocation) {_						String hosts = getHostnamesFromInstances(preferredLocations)__						throw new NoResourceAvailableException("Could not schedule task " + vertex_								+ " to any of the required hosts: " + hosts)__					}_					else {_						throw new NoResourceAvailableException(getNumberOfAvailableInstances(),_								getTotalNumberOfSlots(), getNumberOfAvailableSlots())__					}_				}_			}_		}_	};returns,either,a,link,simple,slot,or,a,link,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,throws,no,resource,available,exception,if,task,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,final,iterable,task,manager,location,preferred,locations,vertex,get,preferred,locations,based,on,inputs,final,boolean,force,external,location,false,preferred,locations,null,preferred,locations,iterator,has,next,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,if,constraint,null,force,external,location,throw,new,illegal,argument,exception,the,scheduling,cannot,be,constrained,simultaneously,by,a,co,location,constraint,and,an,external,location,constraint,final,simple,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,else,slot,from,group,assignment,get,slot,for,task,vertex,constraint,simple,slot,new,slot,null,simple,slot,to,use,null,try,if,slot,from,group,null,slot,from,group,get,locality,locality,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,slot,from,group,vertex,return,slot,from,group,final,iterable,task,manager,location,locations,final,boolean,local,only,if,constraint,null,constraint,is,assigned,locations,collections,singleton,constraint,get,location,local,only,true,else,locations,vertex,get,preferred,locations,based,on,inputs,local,only,force,external,location,new,slot,get,new,slot,for,sharing,group,vertex,locations,assignment,constraint,local,only,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,assigned,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots,else,to,use,slot,from,group,else,if,slot,from,group,null,slot,from,group,is,alive,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,to,use,new,slot,else,new,slot,release,slot,to,use,slot,from,group,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,to,use,vertex,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,return,to,use,else,simple,slot,slot,get,free,slot,for,task,vertex,preferred,locations,force,external,location,if,slot,null,update,locality,counters,slot,vertex,return,slot,else,if,queue,if,no,resource,completable,future,simple,slot,future,new,flink,completable,future,this,task,queue,add,new,queued,task,task,future,return,future,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException;1486663952;Returns either a {@link SimpleSlot}, or a {@link Future}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException {_		if (task == null) {_			throw new NullPointerException()__		}_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}__		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__		_		final Iterable<TaskManagerLocation> preferredLocations = vertex.getPreferredLocationsBasedOnInputs()__		final boolean forceExternalLocation = false &&_									preferredLocations != null && preferredLocations.iterator().hasNext()__	_		synchronized (globalLock) {_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			_			if (sharingUnit != null) {__				_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException(_							"A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				_				if (constraint != null && forceExternalLocation) {_					throw new IllegalArgumentException("The scheduling cannot be constrained simultaneously by a "_							+ "co-location constraint and an external location constraint.")__				}_				_				_				final SimpleSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(vertex, constraint)__				}__				SimpleSlot newSlot = null__				SimpleSlot toUse = null___				_				try {_					_					_					_					if (slotFromGroup != null && slotFromGroup.getLocality() != Locality.NON_LOCAL) {_						_						_						_						if (constraint != null && !constraint.isAssigned()) {_							constraint.lockLocation()__						}_						_						updateLocalityCounters(slotFromGroup, vertex)__						return slotFromGroup__					}_					_					_					_					_					_					final Iterable<TaskManagerLocation> locations__					final boolean localOnly__					if (constraint != null && constraint.isAssigned()) {_						locations = Collections.singleton(constraint.getLocation())__						localOnly = true__					}_					else {_						locations = vertex.getPreferredLocationsBasedOnInputs()__						localOnly = forceExternalLocation__					}_					_					newSlot = getNewSlotForSharingGroup(vertex, locations, assignment, constraint, localOnly)___					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							_							if (constraint != null && constraint.isAssigned()) {_								_								throw new NoResourceAvailableException("Could not allocate a slot on instance " +_										constraint.getLocation() + ", as required by the co-location constraint.")__							}_							else if (forceExternalLocation) {_								_								String hosts = getHostnamesFromInstances(preferredLocations)__								throw new NoResourceAvailableException("Could not schedule task " + vertex_										+ " to any of the required hosts: " + hosts)__							}_							else {_								_								throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(),_										getTotalNumberOfSlots(), getNumberOfAvailableSlots())__							}_						}_						else {_							_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || !slotFromGroup.isAlive() || newSlot.getLocality() == Locality.LOCAL) {_						_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot()__						}_						toUse = newSlot__					}_					else {_						_						_						_						newSlot.releaseSlot()__						toUse = slotFromGroup__					}__					_					_					if (constraint != null && !constraint.isAssigned()) {_						constraint.lockLocation()__					}_					_					updateLocalityCounters(toUse, vertex)__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}__					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}__				return toUse__			}_			else {_				_				_				_				SimpleSlot slot = getFreeSlotForTask(vertex, preferredLocations, forceExternalLocation)__				if (slot != null) {_					updateLocalityCounters(slot, vertex)__					return slot__				}_				else {_					_					if (queueIfNoResource) {_						CompletableFuture<SimpleSlot> future = new FlinkCompletableFuture<>()__						this.taskQueue.add(new QueuedTask(task, future))__						return future__					}_					else if (forceExternalLocation) {_						String hosts = getHostnamesFromInstances(preferredLocations)__						throw new NoResourceAvailableException("Could not schedule task " + vertex_								+ " to any of the required hosts: " + hosts)__					}_					else {_						throw new NoResourceAvailableException(getNumberOfAvailableInstances(),_								getTotalNumberOfSlots(), getNumberOfAvailableSlots())__					}_				}_			}_		}_	};returns,either,a,link,simple,slot,or,a,link,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,throws,no,resource,available,exception,if,task,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,final,iterable,task,manager,location,preferred,locations,vertex,get,preferred,locations,based,on,inputs,final,boolean,force,external,location,false,preferred,locations,null,preferred,locations,iterator,has,next,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,if,constraint,null,force,external,location,throw,new,illegal,argument,exception,the,scheduling,cannot,be,constrained,simultaneously,by,a,co,location,constraint,and,an,external,location,constraint,final,simple,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,else,slot,from,group,assignment,get,slot,for,task,vertex,constraint,simple,slot,new,slot,null,simple,slot,to,use,null,try,if,slot,from,group,null,slot,from,group,get,locality,locality,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,slot,from,group,vertex,return,slot,from,group,final,iterable,task,manager,location,locations,final,boolean,local,only,if,constraint,null,constraint,is,assigned,locations,collections,singleton,constraint,get,location,local,only,true,else,locations,vertex,get,preferred,locations,based,on,inputs,local,only,force,external,location,new,slot,get,new,slot,for,sharing,group,vertex,locations,assignment,constraint,local,only,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,assigned,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots,else,to,use,slot,from,group,else,if,slot,from,group,null,slot,from,group,is,alive,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,to,use,new,slot,else,new,slot,release,slot,to,use,slot,from,group,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,to,use,vertex,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,return,to,use,else,simple,slot,slot,get,free,slot,for,task,vertex,preferred,locations,force,external,location,if,slot,null,update,locality,counters,slot,vertex,return,slot,else,if,queue,if,no,resource,completable,future,simple,slot,future,new,flink,completable,future,this,task,queue,add,new,queued,task,task,future,return,future,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException;1488299223;Returns either a {@link SimpleSlot}, or a {@link Future}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException {_		if (task == null) {_			throw new NullPointerException()__		}_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}__		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__		_		final Iterable<TaskManagerLocation> preferredLocations = vertex.getPreferredLocationsBasedOnInputs()__		final boolean forceExternalLocation = false &&_									preferredLocations != null && preferredLocations.iterator().hasNext()__	_		synchronized (globalLock) {_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			_			if (sharingUnit != null) {__				_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException(_							"A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				_				if (constraint != null && forceExternalLocation) {_					throw new IllegalArgumentException("The scheduling cannot be constrained simultaneously by a "_							+ "co-location constraint and an external location constraint.")__				}_				_				_				final SimpleSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(vertex, constraint)__				}__				SimpleSlot newSlot = null__				SimpleSlot toUse = null___				_				try {_					_					_					_					if (slotFromGroup != null && slotFromGroup.getLocality() != Locality.NON_LOCAL) {_						_						_						_						if (constraint != null && !constraint.isAssigned()) {_							constraint.lockLocation()__						}_						_						updateLocalityCounters(slotFromGroup, vertex)__						return slotFromGroup__					}_					_					_					_					_					_					final Iterable<TaskManagerLocation> locations__					final boolean localOnly__					if (constraint != null && constraint.isAssigned()) {_						locations = Collections.singleton(constraint.getLocation())__						localOnly = true__					}_					else {_						locations = vertex.getPreferredLocationsBasedOnInputs()__						localOnly = forceExternalLocation__					}_					_					newSlot = getNewSlotForSharingGroup(vertex, locations, assignment, constraint, localOnly)___					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							_							if (constraint != null && constraint.isAssigned()) {_								_								throw new NoResourceAvailableException("Could not allocate a slot on instance " +_										constraint.getLocation() + ", as required by the co-location constraint.")__							}_							else if (forceExternalLocation) {_								_								String hosts = getHostnamesFromInstances(preferredLocations)__								throw new NoResourceAvailableException("Could not schedule task " + vertex_										+ " to any of the required hosts: " + hosts)__							}_							else {_								_								throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(),_										getTotalNumberOfSlots(), getNumberOfAvailableSlots())__							}_						}_						else {_							_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || !slotFromGroup.isAlive() || newSlot.getLocality() == Locality.LOCAL) {_						_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot()__						}_						toUse = newSlot__					}_					else {_						_						_						_						newSlot.releaseSlot()__						toUse = slotFromGroup__					}__					_					_					if (constraint != null && !constraint.isAssigned()) {_						constraint.lockLocation()__					}_					_					updateLocalityCounters(toUse, vertex)__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}__					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}__				return toUse__			}_			else {_				_				_				_				SimpleSlot slot = getFreeSlotForTask(vertex, preferredLocations, forceExternalLocation)__				if (slot != null) {_					updateLocalityCounters(slot, vertex)__					return slot__				}_				else {_					_					if (queueIfNoResource) {_						CompletableFuture<SimpleSlot> future = new FlinkCompletableFuture<>()__						this.taskQueue.add(new QueuedTask(task, future))__						return future__					}_					else if (forceExternalLocation) {_						String hosts = getHostnamesFromInstances(preferredLocations)__						throw new NoResourceAvailableException("Could not schedule task " + vertex_								+ " to any of the required hosts: " + hosts)__					}_					else {_						throw new NoResourceAvailableException(getNumberOfAvailableInstances(),_								getTotalNumberOfSlots(), getNumberOfAvailableSlots())__					}_				}_			}_		}_	};returns,either,a,link,simple,slot,or,a,link,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,throws,no,resource,available,exception,if,task,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,final,iterable,task,manager,location,preferred,locations,vertex,get,preferred,locations,based,on,inputs,final,boolean,force,external,location,false,preferred,locations,null,preferred,locations,iterator,has,next,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,if,constraint,null,force,external,location,throw,new,illegal,argument,exception,the,scheduling,cannot,be,constrained,simultaneously,by,a,co,location,constraint,and,an,external,location,constraint,final,simple,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,else,slot,from,group,assignment,get,slot,for,task,vertex,constraint,simple,slot,new,slot,null,simple,slot,to,use,null,try,if,slot,from,group,null,slot,from,group,get,locality,locality,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,slot,from,group,vertex,return,slot,from,group,final,iterable,task,manager,location,locations,final,boolean,local,only,if,constraint,null,constraint,is,assigned,locations,collections,singleton,constraint,get,location,local,only,true,else,locations,vertex,get,preferred,locations,based,on,inputs,local,only,force,external,location,new,slot,get,new,slot,for,sharing,group,vertex,locations,assignment,constraint,local,only,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,assigned,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots,else,to,use,slot,from,group,else,if,slot,from,group,null,slot,from,group,is,alive,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,to,use,new,slot,else,new,slot,release,slot,to,use,slot,from,group,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,to,use,vertex,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,return,to,use,else,simple,slot,slot,get,free,slot,for,task,vertex,preferred,locations,force,external,location,if,slot,null,update,locality,counters,slot,vertex,return,slot,else,if,queue,if,no,resource,completable,future,simple,slot,future,new,flink,completable,future,this,task,queue,add,new,queued,task,task,future,return,future,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException;1490819573;Returns either a {@link SimpleSlot}, or a {@link Future}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException {_		if (task == null) {_			throw new NullPointerException()__		}_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}__		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__		_		final Iterable<TaskManagerLocation> preferredLocations = vertex.getPreferredLocationsBasedOnInputs()__		final boolean forceExternalLocation = false &&_									preferredLocations != null && preferredLocations.iterator().hasNext()__	_		synchronized (globalLock) {_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			_			if (sharingUnit != null) {__				_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException(_							"A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				_				if (constraint != null && forceExternalLocation) {_					throw new IllegalArgumentException("The scheduling cannot be constrained simultaneously by a "_							+ "co-location constraint and an external location constraint.")__				}_				_				_				final SimpleSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(vertex, constraint)__				}__				SimpleSlot newSlot = null__				SimpleSlot toUse = null___				_				try {_					_					_					_					if (slotFromGroup != null && slotFromGroup.getLocality() != Locality.NON_LOCAL) {_						_						_						_						if (constraint != null && !constraint.isAssigned()) {_							constraint.lockLocation()__						}_						_						updateLocalityCounters(slotFromGroup, vertex)__						return slotFromGroup__					}_					_					_					_					_					_					final Iterable<TaskManagerLocation> locations__					final boolean localOnly__					if (constraint != null && constraint.isAssigned()) {_						locations = Collections.singleton(constraint.getLocation())__						localOnly = true__					}_					else {_						locations = vertex.getPreferredLocationsBasedOnInputs()__						localOnly = forceExternalLocation__					}_					_					newSlot = getNewSlotForSharingGroup(vertex, locations, assignment, constraint, localOnly)___					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							_							if (constraint != null && constraint.isAssigned()) {_								_								throw new NoResourceAvailableException("Could not allocate a slot on instance " +_										constraint.getLocation() + ", as required by the co-location constraint.")__							}_							else if (forceExternalLocation) {_								_								String hosts = getHostnamesFromInstances(preferredLocations)__								throw new NoResourceAvailableException("Could not schedule task " + vertex_										+ " to any of the required hosts: " + hosts)__							}_							else {_								_								throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(),_										getTotalNumberOfSlots(), getNumberOfAvailableSlots())__							}_						}_						else {_							_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || !slotFromGroup.isAlive() || newSlot.getLocality() == Locality.LOCAL) {_						_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot()__						}_						toUse = newSlot__					}_					else {_						_						_						_						newSlot.releaseSlot()__						toUse = slotFromGroup__					}__					_					_					if (constraint != null && !constraint.isAssigned()) {_						constraint.lockLocation()__					}_					_					updateLocalityCounters(toUse, vertex)__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}__					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}__				return toUse__			}_			else {_				_				_				_				SimpleSlot slot = getFreeSlotForTask(vertex, preferredLocations, forceExternalLocation)__				if (slot != null) {_					updateLocalityCounters(slot, vertex)__					return slot__				}_				else {_					_					if (queueIfNoResource) {_						CompletableFuture<SimpleSlot> future = new FlinkCompletableFuture<>()__						this.taskQueue.add(new QueuedTask(task, future))__						return future__					}_					else if (forceExternalLocation) {_						String hosts = getHostnamesFromInstances(preferredLocations)__						throw new NoResourceAvailableException("Could not schedule task " + vertex_								+ " to any of the required hosts: " + hosts)__					}_					else {_						throw new NoResourceAvailableException(getNumberOfAvailableInstances(),_								getTotalNumberOfSlots(), getNumberOfAvailableSlots())__					}_				}_			}_		}_	};returns,either,a,link,simple,slot,or,a,link,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,throws,no,resource,available,exception,if,task,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,final,iterable,task,manager,location,preferred,locations,vertex,get,preferred,locations,based,on,inputs,final,boolean,force,external,location,false,preferred,locations,null,preferred,locations,iterator,has,next,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,if,constraint,null,force,external,location,throw,new,illegal,argument,exception,the,scheduling,cannot,be,constrained,simultaneously,by,a,co,location,constraint,and,an,external,location,constraint,final,simple,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,else,slot,from,group,assignment,get,slot,for,task,vertex,constraint,simple,slot,new,slot,null,simple,slot,to,use,null,try,if,slot,from,group,null,slot,from,group,get,locality,locality,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,slot,from,group,vertex,return,slot,from,group,final,iterable,task,manager,location,locations,final,boolean,local,only,if,constraint,null,constraint,is,assigned,locations,collections,singleton,constraint,get,location,local,only,true,else,locations,vertex,get,preferred,locations,based,on,inputs,local,only,force,external,location,new,slot,get,new,slot,for,sharing,group,vertex,locations,assignment,constraint,local,only,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,assigned,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots,else,to,use,slot,from,group,else,if,slot,from,group,null,slot,from,group,is,alive,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,to,use,new,slot,else,new,slot,release,slot,to,use,slot,from,group,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,to,use,vertex,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,return,to,use,else,simple,slot,slot,get,free,slot,for,task,vertex,preferred,locations,force,external,location,if,slot,null,update,locality,counters,slot,vertex,return,slot,else,if,queue,if,no,resource,completable,future,simple,slot,future,new,flink,completable,future,this,task,queue,add,new,queued,task,task,future,return,future,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException;1501519020;Returns either a {@link SimpleSlot}, or a {@link CompletableFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource) throws NoResourceAvailableException {_		if (task == null) {_			throw new NullPointerException()__		}_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}__		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__		_		final Iterable<TaskManagerLocation> preferredLocations = vertex.getPreferredLocationsBasedOnInputs()__		final boolean forceExternalLocation = false &&_									preferredLocations != null && preferredLocations.iterator().hasNext()__	_		synchronized (globalLock) {_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			_			if (sharingUnit != null) {__				_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException(_							"A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				_				if (constraint != null && forceExternalLocation) {_					throw new IllegalArgumentException("The scheduling cannot be constrained simultaneously by a "_							+ "co-location constraint and an external location constraint.")__				}_				_				_				final SimpleSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(vertex, constraint)__				}__				SimpleSlot newSlot = null__				SimpleSlot toUse = null___				_				try {_					_					_					_					if (slotFromGroup != null && slotFromGroup.getLocality() != Locality.NON_LOCAL) {_						_						_						_						if (constraint != null && !constraint.isAssigned()) {_							constraint.lockLocation()__						}_						_						updateLocalityCounters(slotFromGroup, vertex)__						return slotFromGroup__					}_					_					_					_					_					_					final Iterable<TaskManagerLocation> locations__					final boolean localOnly__					if (constraint != null && constraint.isAssigned()) {_						locations = Collections.singleton(constraint.getLocation())__						localOnly = true__					}_					else {_						locations = vertex.getPreferredLocationsBasedOnInputs()__						localOnly = forceExternalLocation__					}_					_					newSlot = getNewSlotForSharingGroup(vertex, locations, assignment, constraint, localOnly)___					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							_							if (constraint != null && constraint.isAssigned()) {_								_								throw new NoResourceAvailableException("Could not allocate a slot on instance " +_										constraint.getLocation() + ", as required by the co-location constraint.")__							}_							else if (forceExternalLocation) {_								_								String hosts = getHostnamesFromInstances(preferredLocations)__								throw new NoResourceAvailableException("Could not schedule task " + vertex_										+ " to any of the required hosts: " + hosts)__							}_							else {_								_								throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(),_										getTotalNumberOfSlots(), getNumberOfAvailableSlots())__							}_						}_						else {_							_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || !slotFromGroup.isAlive() || newSlot.getLocality() == Locality.LOCAL) {_						_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot()__						}_						toUse = newSlot__					}_					else {_						_						_						_						newSlot.releaseSlot()__						toUse = slotFromGroup__					}__					_					_					if (constraint != null && !constraint.isAssigned()) {_						constraint.lockLocation()__					}_					_					updateLocalityCounters(toUse, vertex)__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}__					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}__				return toUse__			}_			else {_				_				_				_				SimpleSlot slot = getFreeSlotForTask(vertex, preferredLocations, forceExternalLocation)__				if (slot != null) {_					updateLocalityCounters(slot, vertex)__					return slot__				}_				else {_					_					if (queueIfNoResource) {_						CompletableFuture<SimpleSlot> future = new CompletableFuture<>()__						this.taskQueue.add(new QueuedTask(task, future))__						return future__					}_					else if (forceExternalLocation) {_						String hosts = getHostnamesFromInstances(preferredLocations)__						throw new NoResourceAvailableException("Could not schedule task " + vertex_								+ " to any of the required hosts: " + hosts)__					}_					else {_						throw new NoResourceAvailableException(getNumberOfAvailableInstances(),_								getTotalNumberOfSlots(), getNumberOfAvailableSlots())__					}_				}_			}_		}_	};returns,either,a,link,simple,slot,or,a,link,completable,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,throws,no,resource,available,exception,if,task,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,final,iterable,task,manager,location,preferred,locations,vertex,get,preferred,locations,based,on,inputs,final,boolean,force,external,location,false,preferred,locations,null,preferred,locations,iterator,has,next,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,if,constraint,null,force,external,location,throw,new,illegal,argument,exception,the,scheduling,cannot,be,constrained,simultaneously,by,a,co,location,constraint,and,an,external,location,constraint,final,simple,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,else,slot,from,group,assignment,get,slot,for,task,vertex,constraint,simple,slot,new,slot,null,simple,slot,to,use,null,try,if,slot,from,group,null,slot,from,group,get,locality,locality,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,slot,from,group,vertex,return,slot,from,group,final,iterable,task,manager,location,locations,final,boolean,local,only,if,constraint,null,constraint,is,assigned,locations,collections,singleton,constraint,get,location,local,only,true,else,locations,vertex,get,preferred,locations,based,on,inputs,local,only,force,external,location,new,slot,get,new,slot,for,sharing,group,vertex,locations,assignment,constraint,local,only,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,assigned,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots,else,to,use,slot,from,group,else,if,slot,from,group,null,slot,from,group,is,alive,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,to,use,new,slot,else,new,slot,release,slot,to,use,slot,from,group,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,to,use,vertex,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,return,to,use,else,simple,slot,slot,get,free,slot,for,task,vertex,preferred,locations,force,external,location,if,slot,null,update,locality,counters,slot,vertex,return,slot,else,if,queue,if,no,resource,completable,future,simple,slot,future,new,completable,future,this,task,queue,add,new,queued,task,task,future,return,future,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots
Scheduler -> protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, 											Iterable<TaskManagerLocation> requestedLocations, 											boolean localOnly);1472205100;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex,_											Iterable<TaskManagerLocation> requestedLocations,_											boolean localOnly) {_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)___			if (instanceLocalityPair == null){_				return null__			}__			Instance instanceToUse = instanceLocalityPair.getLeft()__			Locality locality = instanceLocalityPair.getRight()___			try {_				SimpleSlot slot = instanceToUse.allocateSimpleSlot(vertex.getJobId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,simple,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,task,manager,location,requested,locations,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,instance,instance,to,use,instance,locality,pair,get,left,locality,locality,instance,locality,pair,get,right,try,simple,slot,slot,instance,to,use,allocate,simple,slot,vertex,get,job,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, 											Iterable<TaskManagerLocation> requestedLocations, 											boolean localOnly);1472582060;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex,_											Iterable<TaskManagerLocation> requestedLocations,_											boolean localOnly) {_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)___			if (instanceLocalityPair == null){_				return null__			}__			Instance instanceToUse = instanceLocalityPair.getLeft()__			Locality locality = instanceLocalityPair.getRight()___			try {_				SimpleSlot slot = instanceToUse.allocateSimpleSlot(vertex.getJobId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getResourceId(), instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,simple,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,task,manager,location,requested,locations,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,instance,instance,to,use,instance,locality,pair,get,left,locality,locality,instance,locality,pair,get,right,try,simple,slot,slot,instance,to,use,allocate,simple,slot,vertex,get,job,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,resource,id,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, 											Iterable<TaskManagerLocation> requestedLocations, 											boolean localOnly);1472644741;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex,_											Iterable<TaskManagerLocation> requestedLocations,_											boolean localOnly) {_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)___			if (instanceLocalityPair == null){_				return null__			}__			Instance instanceToUse = instanceLocalityPair.getLeft()__			Locality locality = instanceLocalityPair.getRight()___			try {_				SimpleSlot slot = instanceToUse.allocateSimpleSlot(vertex.getJobId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,simple,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,task,manager,location,requested,locations,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,instance,instance,to,use,instance,locality,pair,get,left,locality,locality,instance,locality,pair,get,right,try,simple,slot,slot,instance,to,use,allocate,simple,slot,vertex,get,job,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, 											Iterable<TaskManagerLocation> requestedLocations, 											boolean localOnly);1473307213;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex,_											Iterable<TaskManagerLocation> requestedLocations,_											boolean localOnly) {_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)___			if (instanceLocalityPair == null){_				return null__			}__			Instance instanceToUse = instanceLocalityPair.getLeft()__			Locality locality = instanceLocalityPair.getRight()___			try {_				SimpleSlot slot = instanceToUse.allocateSimpleSlot(vertex.getJobId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,simple,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,task,manager,location,requested,locations,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,instance,instance,to,use,instance,locality,pair,get,left,locality,locality,instance,locality,pair,get,right,try,simple,slot,slot,instance,to,use,allocate,simple,slot,vertex,get,job,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, 											Iterable<TaskManagerLocation> requestedLocations, 											boolean localOnly);1474949408;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex,_											Iterable<TaskManagerLocation> requestedLocations,_											boolean localOnly) {_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)___			if (instanceLocalityPair == null){_				return null__			}__			Instance instanceToUse = instanceLocalityPair.getLeft()__			Locality locality = instanceLocalityPair.getRight()___			try {_				SimpleSlot slot = instanceToUse.allocateSimpleSlot(vertex.getJobId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,simple,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,task,manager,location,requested,locations,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,instance,instance,to,use,instance,locality,pair,get,left,locality,locality,instance,locality,pair,get,right,try,simple,slot,slot,instance,to,use,allocate,simple,slot,vertex,get,job,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, 											Iterable<TaskManagerLocation> requestedLocations, 											boolean localOnly);1474983187;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex,_											Iterable<TaskManagerLocation> requestedLocations,_											boolean localOnly) {_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)___			if (instanceLocalityPair == null){_				return null__			}__			Instance instanceToUse = instanceLocalityPair.getLeft()__			Locality locality = instanceLocalityPair.getRight()___			try {_				SimpleSlot slot = instanceToUse.allocateSimpleSlot(vertex.getJobId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,simple,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,task,manager,location,requested,locations,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,instance,instance,to,use,instance,locality,pair,get,left,locality,locality,instance,locality,pair,get,right,try,simple,slot,slot,instance,to,use,allocate,simple,slot,vertex,get,job,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, 											Iterable<TaskManagerLocation> requestedLocations, 											boolean localOnly);1485888959;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex,_											Iterable<TaskManagerLocation> requestedLocations,_											boolean localOnly) {_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)___			if (instanceLocalityPair == null){_				return null__			}__			Instance instanceToUse = instanceLocalityPair.getLeft()__			Locality locality = instanceLocalityPair.getRight()___			try {_				SimpleSlot slot = instanceToUse.allocateSimpleSlot(vertex.getJobId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,simple,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,task,manager,location,requested,locations,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,instance,instance,to,use,instance,locality,pair,get,left,locality,locality,instance,locality,pair,get,right,try,simple,slot,slot,instance,to,use,allocate,simple,slot,vertex,get,job,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, 											Iterable<TaskManagerLocation> requestedLocations, 											boolean localOnly);1485891273;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex,_											Iterable<TaskManagerLocation> requestedLocations,_											boolean localOnly) {_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)___			if (instanceLocalityPair == null){_				return null__			}__			Instance instanceToUse = instanceLocalityPair.getLeft()__			Locality locality = instanceLocalityPair.getRight()___			try {_				SimpleSlot slot = instanceToUse.allocateSimpleSlot(vertex.getJobId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,simple,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,task,manager,location,requested,locations,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,instance,instance,to,use,instance,locality,pair,get,left,locality,locality,instance,locality,pair,get,right,try,simple,slot,slot,instance,to,use,allocate,simple,slot,vertex,get,job,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, 											Iterable<TaskManagerLocation> requestedLocations, 											boolean localOnly);1486663952;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex,_											Iterable<TaskManagerLocation> requestedLocations,_											boolean localOnly) {_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)___			if (instanceLocalityPair == null){_				return null__			}__			Instance instanceToUse = instanceLocalityPair.getLeft()__			Locality locality = instanceLocalityPair.getRight()___			try {_				SimpleSlot slot = instanceToUse.allocateSimpleSlot(vertex.getJobId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,simple,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,task,manager,location,requested,locations,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,instance,instance,to,use,instance,locality,pair,get,left,locality,locality,instance,locality,pair,get,right,try,simple,slot,slot,instance,to,use,allocate,simple,slot,vertex,get,job,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, 											Iterable<TaskManagerLocation> requestedLocations, 											boolean localOnly);1488299223;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex,_											Iterable<TaskManagerLocation> requestedLocations,_											boolean localOnly) {_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)___			if (instanceLocalityPair == null){_				return null__			}__			Instance instanceToUse = instanceLocalityPair.getLeft()__			Locality locality = instanceLocalityPair.getRight()___			try {_				SimpleSlot slot = instanceToUse.allocateSimpleSlot(vertex.getJobId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,simple,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,task,manager,location,requested,locations,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,instance,instance,to,use,instance,locality,pair,get,left,locality,locality,instance,locality,pair,get,right,try,simple,slot,slot,instance,to,use,allocate,simple,slot,vertex,get,job,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, 											Iterable<TaskManagerLocation> requestedLocations, 											boolean localOnly);1490819573;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex,_											Iterable<TaskManagerLocation> requestedLocations,_											boolean localOnly) {_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)___			if (instanceLocalityPair == null){_				return null__			}__			Instance instanceToUse = instanceLocalityPair.getLeft()__			Locality locality = instanceLocalityPair.getRight()___			try {_				SimpleSlot slot = instanceToUse.allocateSimpleSlot(vertex.getJobId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,simple,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,task,manager,location,requested,locations,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,instance,instance,to,use,instance,locality,pair,get,left,locality,locality,instance,locality,pair,get,right,try,simple,slot,slot,instance,to,use,allocate,simple,slot,vertex,get,job,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, 											Iterable<TaskManagerLocation> requestedLocations, 											boolean localOnly);1501519020;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex,_											Iterable<TaskManagerLocation> requestedLocations,_											boolean localOnly) {_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)___			if (instanceLocalityPair == null){_				return null__			}__			Instance instanceToUse = instanceLocalityPair.getLeft()__			Locality locality = instanceLocalityPair.getRight()___			try {_				SimpleSlot slot = instanceToUse.allocateSimpleSlot(vertex.getJobId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,simple,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,task,manager,location,requested,locations,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,instance,instance,to,use,instance,locality,pair,get,left,locality,locality,instance,locality,pair,get,right,try,simple,slot,slot,instance,to,use,allocate,simple,slot,vertex,get,job,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, 											Iterable<TaskManagerLocation> requestedLocations, 											boolean localOnly);1508155453;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex,_											Iterable<TaskManagerLocation> requestedLocations,_											boolean localOnly) {_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)___			if (instanceLocalityPair == null){_				return null__			}__			Instance instanceToUse = instanceLocalityPair.getLeft()__			Locality locality = instanceLocalityPair.getRight()___			try {_				SimpleSlot slot = instanceToUse.allocateSimpleSlot(vertex.getJobId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,simple,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,task,manager,location,requested,locations,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,instance,instance,to,use,instance,locality,pair,get,left,locality,locality,instance,locality,pair,get,right,try,simple,slot,slot,instance,to,use,allocate,simple,slot,vertex,get,job,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, 											Iterable<TaskManagerLocation> requestedLocations, 											boolean localOnly);1509090423;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex,_											Iterable<TaskManagerLocation> requestedLocations,_											boolean localOnly) {_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)___			if (instanceLocalityPair == null){_				return null__			}__			Instance instanceToUse = instanceLocalityPair.getLeft()__			Locality locality = instanceLocalityPair.getRight()___			try {_				SimpleSlot slot = instanceToUse.allocateSimpleSlot(vertex.getJobId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,simple,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,task,manager,location,requested,locations,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,instance,instance,to,use,instance,locality,pair,get,left,locality,locality,instance,locality,pair,get,right,try,simple,slot,slot,instance,to,use,allocate,simple,slot,vertex,get,job,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, 											Iterable<TaskManagerLocation> requestedLocations, 											boolean localOnly);1510699852;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex,_											Iterable<TaskManagerLocation> requestedLocations,_											boolean localOnly) {_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)___			if (instanceLocalityPair == null){_				return null__			}__			Instance instanceToUse = instanceLocalityPair.getLeft()__			Locality locality = instanceLocalityPair.getRight()___			try {_				SimpleSlot slot = instanceToUse.allocateSimpleSlot(vertex.getJobId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,simple,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,task,manager,location,requested,locations,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,instance,instance,to,use,instance,locality,pair,get,left,locality,locality,instance,locality,pair,get,right,try,simple,slot,slot,instance,to,use,allocate,simple,slot,vertex,get,job,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, 											Iterable<TaskManagerLocation> requestedLocations, 											boolean localOnly);1510752027;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex,_											Iterable<TaskManagerLocation> requestedLocations,_											boolean localOnly) {_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)___			if (instanceLocalityPair == null){_				return null__			}__			Instance instanceToUse = instanceLocalityPair.getLeft()__			Locality locality = instanceLocalityPair.getRight()___			try {_				SimpleSlot slot = instanceToUse.allocateSimpleSlot(vertex.getJobId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,simple,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,task,manager,location,requested,locations,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,instance,instance,to,use,instance,locality,pair,get,left,locality,locality,instance,locality,pair,get,right,try,simple,slot,slot,instance,to,use,allocate,simple,slot,vertex,get,job,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, 											Iterable<TaskManagerLocation> requestedLocations, 											boolean localOnly);1511543029;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex,_											Iterable<TaskManagerLocation> requestedLocations,_											boolean localOnly) {_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)___			if (instanceLocalityPair == null){_				return null__			}__			Instance instanceToUse = instanceLocalityPair.getLeft()__			Locality locality = instanceLocalityPair.getRight()___			try {_				SimpleSlot slot = instanceToUse.allocateSimpleSlot()__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,simple,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,task,manager,location,requested,locations,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,instance,instance,to,use,instance,locality,pair,get,left,locality,locality,instance,locality,pair,get,right,try,simple,slot,slot,instance,to,use,allocate,simple,slot,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, 											Iterable<TaskManagerLocation> requestedLocations, 											boolean localOnly);1513261475;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex,_											Iterable<TaskManagerLocation> requestedLocations,_											boolean localOnly) {_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)___			if (instanceLocalityPair == null){_				return null__			}__			Instance instanceToUse = instanceLocalityPair.getLeft()__			Locality locality = instanceLocalityPair.getRight()___			try {_				SimpleSlot slot = instanceToUse.allocateSimpleSlot()__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,simple,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,task,manager,location,requested,locations,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,instance,instance,to,use,instance,locality,pair,get,left,locality,locality,instance,locality,pair,get,right,try,simple,slot,slot,instance,to,use,allocate,simple,slot,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, 											Iterable<TaskManagerLocation> requestedLocations, 											boolean localOnly);1517497348;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex,_											Iterable<TaskManagerLocation> requestedLocations,_											boolean localOnly) {_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)___			if (instanceLocalityPair == null){_				return null__			}__			Instance instanceToUse = instanceLocalityPair.getLeft()__			Locality locality = instanceLocalityPair.getRight()___			try {_				SimpleSlot slot = instanceToUse.allocateSimpleSlot()__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,simple,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,task,manager,location,requested,locations,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,instance,instance,to,use,instance,locality,pair,get,left,locality,locality,instance,locality,pair,get,right,try,simple,slot,slot,instance,to,use,allocate,simple,slot,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, 											Iterable<TaskManagerLocation> requestedLocations, 											boolean localOnly);1518522104;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex,_											Iterable<TaskManagerLocation> requestedLocations,_											boolean localOnly) {_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)___			if (instanceLocalityPair == null){_				return null__			}__			Instance instanceToUse = instanceLocalityPair.getLeft()__			Locality locality = instanceLocalityPair.getRight()___			try {_				SimpleSlot slot = instanceToUse.allocateSimpleSlot()__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,simple,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,task,manager,location,requested,locations,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,instance,instance,to,use,instance,locality,pair,get,left,locality,locality,instance,locality,pair,get,right,try,simple,slot,slot,instance,to,use,allocate,simple,slot,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, 											Iterable<TaskManagerLocation> requestedLocations, 											boolean localOnly);1519315265;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex,_											Iterable<TaskManagerLocation> requestedLocations,_											boolean localOnly) {_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)___			if (instanceLocalityPair == null){_				return null__			}__			Instance instanceToUse = instanceLocalityPair.getLeft()__			Locality locality = instanceLocalityPair.getRight()___			try {_				SimpleSlot slot = instanceToUse.allocateSimpleSlot()__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,simple,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,task,manager,location,requested,locations,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,instance,instance,to,use,instance,locality,pair,get,left,locality,locality,instance,locality,pair,get,right,try,simple,slot,slot,instance,to,use,allocate,simple,slot,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, 											Iterable<TaskManagerLocation> requestedLocations, 											boolean localOnly);1538764056;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex,_											Iterable<TaskManagerLocation> requestedLocations,_											boolean localOnly) {_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)___			if (instanceLocalityPair == null){_				return null__			}__			Instance instanceToUse = instanceLocalityPair.getLeft()__			Locality locality = instanceLocalityPair.getRight()___			try {_				SimpleSlot slot = instanceToUse.allocateSimpleSlot()__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,simple,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,task,manager,location,requested,locations,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,instance,instance,to,use,instance,locality,pair,get,left,locality,locality,instance,locality,pair,get,right,try,simple,slot,slot,instance,to,use,allocate,simple,slot,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, 											Iterable<TaskManagerLocation> requestedLocations, 											boolean localOnly);1543229263;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex,_											Iterable<TaskManagerLocation> requestedLocations,_											boolean localOnly) {_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)___			if (instanceLocalityPair == null){_				return null__			}__			Instance instanceToUse = instanceLocalityPair.getLeft()__			Locality locality = instanceLocalityPair.getRight()___			try {_				SimpleSlot slot = instanceToUse.allocateSimpleSlot()__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,simple,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,task,manager,location,requested,locations,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,instance,instance,to,use,instance,locality,pair,get,left,locality,locality,instance,locality,pair,get,right,try,simple,slot,slot,instance,to,use,allocate,simple,slot,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> public void shutdown();1410445910;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1410722608;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1410734340;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1410808507;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1410924144;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1411473561;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1411494841;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1411587268;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1415641452;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1416225736;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1416317653;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			allInstancesByHost.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,all,instances,by,host,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1416878271;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1421056725;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1423053613;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1423157292;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1423419464;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			allInstancesByHost.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,all,instances,by,host,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1423749105;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			allInstancesByHost.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,all,instances,by,host,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1423931937;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			allInstancesByHost.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,all,instances,by,host,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1432114676;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			allInstancesByHost.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,all,instances,by,host,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1434450422;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			allInstancesByHost.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,all,instances,by,host,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1436262104;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			allInstancesByHost.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,all,instances,by,host,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1445550685;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			allInstancesByHost.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,all,instances,by,host,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1472205100;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			allInstancesByHost.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,all,instances,by,host,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1472582060;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			allInstancesByHost.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,all,instances,by,host,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1472644741;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			allInstancesByHost.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,all,instances,by,host,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1473307213;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			allInstancesByHost.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,all,instances,by,host,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1474949408;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			allInstancesByHost.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,all,instances,by,host,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1474983187;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			allInstancesByHost.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,all,instances,by,host,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1485888959;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			allInstancesByHost.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,all,instances,by,host,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1485891273;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			allInstancesByHost.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,all,instances,by,host,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1486663952;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			allInstancesByHost.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,all,instances,by,host,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1488299223;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			allInstancesByHost.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,all,instances,by,host,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1490819573;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			allInstancesByHost.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,all,instances,by,host,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1501519020;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			allInstancesByHost.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,all,instances,by,host,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1508155453;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			allInstancesByHost.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,all,instances,by,host,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1509090423;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			allInstancesByHost.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,all,instances,by,host,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1510699852;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			allInstancesByHost.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,all,instances,by,host,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1510752027;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			allInstancesByHost.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,all,instances,by,host,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1511543029;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			allInstancesByHost.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,all,instances,by,host,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1513261475;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			allInstancesByHost.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,all,instances,by,host,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1517497348;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			allInstancesByHost.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,all,instances,by,host,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1518522104;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			allInstancesByHost.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,all,instances,by,host,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1519315265;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			allInstancesByHost.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,all,instances,by,host,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1538764056;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			allInstancesByHost.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,all,instances,by,host,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public void shutdown();1543229263;Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.;public void shutdown() {_		synchronized (globalLock) {_			for (Instance i : allInstances) {_				i.removeSlotListener()__				i.cancelAndReleaseAllSlots()__			}_			allInstances.clear()__			allInstancesByHost.clear()__			instancesWithAvailableResources.clear()__			taskQueue.clear()__		}_	};shuts,the,scheduler,down,after,shut,down,no,more,tasks,can,be,added,to,the,scheduler;public,void,shutdown,synchronized,global,lock,for,instance,i,all,instances,i,remove,slot,listener,i,cancel,and,release,all,slots,all,instances,clear,all,instances,by,host,clear,instances,with,available,resources,clear,task,queue,clear
Scheduler -> public Scheduler(Executor executor);1488299223;Creates a new scheduler.;public Scheduler(Executor executor) {_		this.executor = Preconditions.checkNotNull(executor)__	};creates,a,new,scheduler;public,scheduler,executor,executor,this,executor,preconditions,check,not,null,executor
Scheduler -> public Scheduler(Executor executor);1490819573;Creates a new scheduler.;public Scheduler(Executor executor) {_		this.executor = Preconditions.checkNotNull(executor)__	};creates,a,new,scheduler;public,scheduler,executor,executor,this,executor,preconditions,check,not,null,executor
Scheduler -> public Scheduler(Executor executor);1501519020;Creates a new scheduler.;public Scheduler(Executor executor) {_		this.executor = Preconditions.checkNotNull(executor)__	};creates,a,new,scheduler;public,scheduler,executor,executor,this,executor,preconditions,check,not,null,executor
Scheduler -> public Scheduler(Executor executor);1508155453;Creates a new scheduler.;public Scheduler(Executor executor) {_		this.executor = Preconditions.checkNotNull(executor)__	};creates,a,new,scheduler;public,scheduler,executor,executor,this,executor,preconditions,check,not,null,executor
Scheduler -> public Scheduler(Executor executor);1509090423;Creates a new scheduler.;public Scheduler(Executor executor) {_		this.executor = Preconditions.checkNotNull(executor)__	};creates,a,new,scheduler;public,scheduler,executor,executor,this,executor,preconditions,check,not,null,executor
Scheduler -> public Scheduler(Executor executor);1510699852;Creates a new scheduler.;public Scheduler(Executor executor) {_		this.executor = Preconditions.checkNotNull(executor)__	};creates,a,new,scheduler;public,scheduler,executor,executor,this,executor,preconditions,check,not,null,executor
Scheduler -> public Scheduler(Executor executor);1510752027;Creates a new scheduler.;public Scheduler(Executor executor) {_		this.executor = Preconditions.checkNotNull(executor)__	};creates,a,new,scheduler;public,scheduler,executor,executor,this,executor,preconditions,check,not,null,executor
Scheduler -> public Scheduler(Executor executor);1511543029;Creates a new scheduler.;public Scheduler(Executor executor) {_		this.executor = Preconditions.checkNotNull(executor)__	};creates,a,new,scheduler;public,scheduler,executor,executor,this,executor,preconditions,check,not,null,executor
Scheduler -> public Scheduler(Executor executor);1513261475;Creates a new scheduler.;public Scheduler(Executor executor) {_		this.executor = Preconditions.checkNotNull(executor)__	};creates,a,new,scheduler;public,scheduler,executor,executor,this,executor,preconditions,check,not,null,executor
Scheduler -> public Scheduler(Executor executor);1517497348;Creates a new scheduler.;public Scheduler(Executor executor) {_		this.executor = Preconditions.checkNotNull(executor)__	};creates,a,new,scheduler;public,scheduler,executor,executor,this,executor,preconditions,check,not,null,executor
Scheduler -> public Scheduler(Executor executor);1518522104;Creates a new scheduler.;public Scheduler(Executor executor) {_		this.executor = Preconditions.checkNotNull(executor)__	};creates,a,new,scheduler;public,scheduler,executor,executor,this,executor,preconditions,check,not,null,executor
Scheduler -> public Scheduler(Executor executor);1519315265;Creates a new scheduler.;public Scheduler(Executor executor) {_		this.executor = Preconditions.checkNotNull(executor)__	};creates,a,new,scheduler;public,scheduler,executor,executor,this,executor,preconditions,check,not,null,executor
Scheduler -> public Scheduler(Executor executor);1538764056;Creates a new scheduler.;public Scheduler(Executor executor) {_		this.executor = Preconditions.checkNotNull(executor)__	};creates,a,new,scheduler;public,scheduler,executor,executor,this,executor,preconditions,check,not,null,executor
Scheduler -> public Scheduler(Executor executor);1543229263;Creates a new scheduler.;public Scheduler(Executor executor) {_		this.executor = Preconditions.checkNotNull(executor)__	};creates,a,new,scheduler;public,scheduler,executor,executor,this,executor,preconditions,check,not,null,executor
Scheduler -> protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex, 													Iterable<TaskManagerLocation> requestedLocations, 													SlotSharingGroupAssignment groupAssignment, 													CoLocationConstraint constraint, 													boolean localOnly);1472205100;Tries to allocate a new slot for a vertex that is part of a slot sharing group. If one_of the instances has a slot available, the method will allocate it as a shared slot, add that_shared slot to the sharing group, and allocate a simple slot from that shared slot.__<p>This method will try to allocate a slot from one of the local instances, and fall back to_non-local instances, if permitted.</p>__@param vertex The vertex to allocate the slot for._@param requestedLocations The locations that are considered local. May be null or empty, if the_vertex has no location preferences._@param groupAssignment The slot sharing group of the vertex. Mandatory parameter._@param constraint The co-location constraint of the vertex. May be null._@param localOnly Flag to indicate if non-local choices are acceptable.__@return A sub-slot for the given vertex, or {@code null}, if no slot is available.;protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex,_													Iterable<TaskManagerLocation> requestedLocations,_													SlotSharingGroupAssignment groupAssignment,_													CoLocationConstraint constraint,_													boolean localOnly)_	{_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)__			_			if (instanceLocalityPair == null) {_				_				return null__			}__			final Instance instanceToUse = instanceLocalityPair.getLeft()__			final Locality locality = instanceLocalityPair.getRight()___			try {_				JobVertexID groupID = vertex.getJobvertexId()__				_				_				SharedSlot sharedSlot = instanceToUse.allocateSharedSlot(vertex.getJobId(), groupAssignment)___				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}__				if (sharedSlot != null) {_					_					SimpleSlot slot = constraint == null ?_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, groupID) :_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, constraint)___					if (slot != null) {_						return slot__					}_					else {_						_						sharedSlot.releaseSlot()__					}_				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}__			_		}_	};tries,to,allocate,a,new,slot,for,a,vertex,that,is,part,of,a,slot,sharing,group,if,one,of,the,instances,has,a,slot,available,the,method,will,allocate,it,as,a,shared,slot,add,that,shared,slot,to,the,sharing,group,and,allocate,a,simple,slot,from,that,shared,slot,p,this,method,will,try,to,allocate,a,slot,from,one,of,the,local,instances,and,fall,back,to,non,local,instances,if,permitted,p,param,vertex,the,vertex,to,allocate,the,slot,for,param,requested,locations,the,locations,that,are,considered,local,may,be,null,or,empty,if,the,vertex,has,no,location,preferences,param,group,assignment,the,slot,sharing,group,of,the,vertex,mandatory,parameter,param,constraint,the,co,location,constraint,of,the,vertex,may,be,null,param,local,only,flag,to,indicate,if,non,local,choices,are,acceptable,return,a,sub,slot,for,the,given,vertex,or,code,null,if,no,slot,is,available;protected,simple,slot,get,new,slot,for,sharing,group,execution,vertex,vertex,iterable,task,manager,location,requested,locations,slot,sharing,group,assignment,group,assignment,co,location,constraint,constraint,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,final,instance,instance,to,use,instance,locality,pair,get,left,final,locality,locality,instance,locality,pair,get,right,try,job,vertex,id,group,id,vertex,get,jobvertex,id,shared,slot,shared,slot,instance,to,use,allocate,shared,slot,vertex,get,job,id,group,assignment,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,shared,slot,null,simple,slot,slot,constraint,null,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,group,id,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,constraint,if,slot,null,return,slot,else,shared,slot,release,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex, 													Iterable<TaskManagerLocation> requestedLocations, 													SlotSharingGroupAssignment groupAssignment, 													CoLocationConstraint constraint, 													boolean localOnly);1472582060;Tries to allocate a new slot for a vertex that is part of a slot sharing group. If one_of the instances has a slot available, the method will allocate it as a shared slot, add that_shared slot to the sharing group, and allocate a simple slot from that shared slot.__<p>This method will try to allocate a slot from one of the local instances, and fall back to_non-local instances, if permitted.</p>__@param vertex The vertex to allocate the slot for._@param requestedLocations The locations that are considered local. May be null or empty, if the_vertex has no location preferences._@param groupAssignment The slot sharing group of the vertex. Mandatory parameter._@param constraint The co-location constraint of the vertex. May be null._@param localOnly Flag to indicate if non-local choices are acceptable.__@return A sub-slot for the given vertex, or {@code null}, if no slot is available.;protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex,_													Iterable<TaskManagerLocation> requestedLocations,_													SlotSharingGroupAssignment groupAssignment,_													CoLocationConstraint constraint,_													boolean localOnly)_	{_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)__			_			if (instanceLocalityPair == null) {_				_				return null__			}__			final Instance instanceToUse = instanceLocalityPair.getLeft()__			final Locality locality = instanceLocalityPair.getRight()___			try {_				JobVertexID groupID = vertex.getJobvertexId()__				_				_				SharedSlot sharedSlot = instanceToUse.allocateSharedSlot(vertex.getJobId(), groupAssignment)___				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getResourceId(), instanceToUse)__				}__				if (sharedSlot != null) {_					_					SimpleSlot slot = constraint == null ?_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, groupID) :_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, constraint)___					if (slot != null) {_						return slot__					}_					else {_						_						sharedSlot.releaseSlot()__					}_				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}__			_		}_	};tries,to,allocate,a,new,slot,for,a,vertex,that,is,part,of,a,slot,sharing,group,if,one,of,the,instances,has,a,slot,available,the,method,will,allocate,it,as,a,shared,slot,add,that,shared,slot,to,the,sharing,group,and,allocate,a,simple,slot,from,that,shared,slot,p,this,method,will,try,to,allocate,a,slot,from,one,of,the,local,instances,and,fall,back,to,non,local,instances,if,permitted,p,param,vertex,the,vertex,to,allocate,the,slot,for,param,requested,locations,the,locations,that,are,considered,local,may,be,null,or,empty,if,the,vertex,has,no,location,preferences,param,group,assignment,the,slot,sharing,group,of,the,vertex,mandatory,parameter,param,constraint,the,co,location,constraint,of,the,vertex,may,be,null,param,local,only,flag,to,indicate,if,non,local,choices,are,acceptable,return,a,sub,slot,for,the,given,vertex,or,code,null,if,no,slot,is,available;protected,simple,slot,get,new,slot,for,sharing,group,execution,vertex,vertex,iterable,task,manager,location,requested,locations,slot,sharing,group,assignment,group,assignment,co,location,constraint,constraint,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,final,instance,instance,to,use,instance,locality,pair,get,left,final,locality,locality,instance,locality,pair,get,right,try,job,vertex,id,group,id,vertex,get,jobvertex,id,shared,slot,shared,slot,instance,to,use,allocate,shared,slot,vertex,get,job,id,group,assignment,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,resource,id,instance,to,use,if,shared,slot,null,simple,slot,slot,constraint,null,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,group,id,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,constraint,if,slot,null,return,slot,else,shared,slot,release,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex, 													Iterable<TaskManagerLocation> requestedLocations, 													SlotSharingGroupAssignment groupAssignment, 													CoLocationConstraint constraint, 													boolean localOnly);1472644741;Tries to allocate a new slot for a vertex that is part of a slot sharing group. If one_of the instances has a slot available, the method will allocate it as a shared slot, add that_shared slot to the sharing group, and allocate a simple slot from that shared slot.__<p>This method will try to allocate a slot from one of the local instances, and fall back to_non-local instances, if permitted.</p>__@param vertex The vertex to allocate the slot for._@param requestedLocations The locations that are considered local. May be null or empty, if the_vertex has no location preferences._@param groupAssignment The slot sharing group of the vertex. Mandatory parameter._@param constraint The co-location constraint of the vertex. May be null._@param localOnly Flag to indicate if non-local choices are acceptable.__@return A sub-slot for the given vertex, or {@code null}, if no slot is available.;protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex,_													Iterable<TaskManagerLocation> requestedLocations,_													SlotSharingGroupAssignment groupAssignment,_													CoLocationConstraint constraint,_													boolean localOnly)_	{_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)__			_			if (instanceLocalityPair == null) {_				_				return null__			}__			final Instance instanceToUse = instanceLocalityPair.getLeft()__			final Locality locality = instanceLocalityPair.getRight()___			try {_				JobVertexID groupID = vertex.getJobvertexId()__				_				_				SharedSlot sharedSlot = instanceToUse.allocateSharedSlot(vertex.getJobId(), groupAssignment)___				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}__				if (sharedSlot != null) {_					_					SimpleSlot slot = constraint == null ?_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, groupID) :_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, constraint)___					if (slot != null) {_						return slot__					}_					else {_						_						sharedSlot.releaseSlot()__					}_				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}__			_		}_	};tries,to,allocate,a,new,slot,for,a,vertex,that,is,part,of,a,slot,sharing,group,if,one,of,the,instances,has,a,slot,available,the,method,will,allocate,it,as,a,shared,slot,add,that,shared,slot,to,the,sharing,group,and,allocate,a,simple,slot,from,that,shared,slot,p,this,method,will,try,to,allocate,a,slot,from,one,of,the,local,instances,and,fall,back,to,non,local,instances,if,permitted,p,param,vertex,the,vertex,to,allocate,the,slot,for,param,requested,locations,the,locations,that,are,considered,local,may,be,null,or,empty,if,the,vertex,has,no,location,preferences,param,group,assignment,the,slot,sharing,group,of,the,vertex,mandatory,parameter,param,constraint,the,co,location,constraint,of,the,vertex,may,be,null,param,local,only,flag,to,indicate,if,non,local,choices,are,acceptable,return,a,sub,slot,for,the,given,vertex,or,code,null,if,no,slot,is,available;protected,simple,slot,get,new,slot,for,sharing,group,execution,vertex,vertex,iterable,task,manager,location,requested,locations,slot,sharing,group,assignment,group,assignment,co,location,constraint,constraint,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,final,instance,instance,to,use,instance,locality,pair,get,left,final,locality,locality,instance,locality,pair,get,right,try,job,vertex,id,group,id,vertex,get,jobvertex,id,shared,slot,shared,slot,instance,to,use,allocate,shared,slot,vertex,get,job,id,group,assignment,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,shared,slot,null,simple,slot,slot,constraint,null,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,group,id,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,constraint,if,slot,null,return,slot,else,shared,slot,release,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex, 													Iterable<TaskManagerLocation> requestedLocations, 													SlotSharingGroupAssignment groupAssignment, 													CoLocationConstraint constraint, 													boolean localOnly);1473307213;Tries to allocate a new slot for a vertex that is part of a slot sharing group. If one_of the instances has a slot available, the method will allocate it as a shared slot, add that_shared slot to the sharing group, and allocate a simple slot from that shared slot.__<p>This method will try to allocate a slot from one of the local instances, and fall back to_non-local instances, if permitted.</p>__@param vertex The vertex to allocate the slot for._@param requestedLocations The locations that are considered local. May be null or empty, if the_vertex has no location preferences._@param groupAssignment The slot sharing group of the vertex. Mandatory parameter._@param constraint The co-location constraint of the vertex. May be null._@param localOnly Flag to indicate if non-local choices are acceptable.__@return A sub-slot for the given vertex, or {@code null}, if no slot is available.;protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex,_													Iterable<TaskManagerLocation> requestedLocations,_													SlotSharingGroupAssignment groupAssignment,_													CoLocationConstraint constraint,_													boolean localOnly)_	{_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)__			_			if (instanceLocalityPair == null) {_				_				return null__			}__			final Instance instanceToUse = instanceLocalityPair.getLeft()__			final Locality locality = instanceLocalityPair.getRight()___			try {_				JobVertexID groupID = vertex.getJobvertexId()__				_				_				SharedSlot sharedSlot = instanceToUse.allocateSharedSlot(vertex.getJobId(), groupAssignment)___				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}__				if (sharedSlot != null) {_					_					SimpleSlot slot = constraint == null ?_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, groupID) :_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, constraint)___					if (slot != null) {_						return slot__					}_					else {_						_						sharedSlot.releaseSlot()__					}_				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}__			_		}_	};tries,to,allocate,a,new,slot,for,a,vertex,that,is,part,of,a,slot,sharing,group,if,one,of,the,instances,has,a,slot,available,the,method,will,allocate,it,as,a,shared,slot,add,that,shared,slot,to,the,sharing,group,and,allocate,a,simple,slot,from,that,shared,slot,p,this,method,will,try,to,allocate,a,slot,from,one,of,the,local,instances,and,fall,back,to,non,local,instances,if,permitted,p,param,vertex,the,vertex,to,allocate,the,slot,for,param,requested,locations,the,locations,that,are,considered,local,may,be,null,or,empty,if,the,vertex,has,no,location,preferences,param,group,assignment,the,slot,sharing,group,of,the,vertex,mandatory,parameter,param,constraint,the,co,location,constraint,of,the,vertex,may,be,null,param,local,only,flag,to,indicate,if,non,local,choices,are,acceptable,return,a,sub,slot,for,the,given,vertex,or,code,null,if,no,slot,is,available;protected,simple,slot,get,new,slot,for,sharing,group,execution,vertex,vertex,iterable,task,manager,location,requested,locations,slot,sharing,group,assignment,group,assignment,co,location,constraint,constraint,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,final,instance,instance,to,use,instance,locality,pair,get,left,final,locality,locality,instance,locality,pair,get,right,try,job,vertex,id,group,id,vertex,get,jobvertex,id,shared,slot,shared,slot,instance,to,use,allocate,shared,slot,vertex,get,job,id,group,assignment,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,shared,slot,null,simple,slot,slot,constraint,null,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,group,id,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,constraint,if,slot,null,return,slot,else,shared,slot,release,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex, 													Iterable<TaskManagerLocation> requestedLocations, 													SlotSharingGroupAssignment groupAssignment, 													CoLocationConstraint constraint, 													boolean localOnly);1474949408;Tries to allocate a new slot for a vertex that is part of a slot sharing group. If one_of the instances has a slot available, the method will allocate it as a shared slot, add that_shared slot to the sharing group, and allocate a simple slot from that shared slot.__<p>This method will try to allocate a slot from one of the local instances, and fall back to_non-local instances, if permitted.</p>__@param vertex The vertex to allocate the slot for._@param requestedLocations The locations that are considered local. May be null or empty, if the_vertex has no location preferences._@param groupAssignment The slot sharing group of the vertex. Mandatory parameter._@param constraint The co-location constraint of the vertex. May be null._@param localOnly Flag to indicate if non-local choices are acceptable.__@return A sub-slot for the given vertex, or {@code null}, if no slot is available.;protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex,_													Iterable<TaskManagerLocation> requestedLocations,_													SlotSharingGroupAssignment groupAssignment,_													CoLocationConstraint constraint,_													boolean localOnly)_	{_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)__			_			if (instanceLocalityPair == null) {_				_				return null__			}__			final Instance instanceToUse = instanceLocalityPair.getLeft()__			final Locality locality = instanceLocalityPair.getRight()___			try {_				JobVertexID groupID = vertex.getJobvertexId()__				_				_				SharedSlot sharedSlot = instanceToUse.allocateSharedSlot(vertex.getJobId(), groupAssignment)___				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}__				if (sharedSlot != null) {_					_					SimpleSlot slot = constraint == null ?_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, groupID) :_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, constraint)___					if (slot != null) {_						return slot__					}_					else {_						_						sharedSlot.releaseSlot()__					}_				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}__			_		}_	};tries,to,allocate,a,new,slot,for,a,vertex,that,is,part,of,a,slot,sharing,group,if,one,of,the,instances,has,a,slot,available,the,method,will,allocate,it,as,a,shared,slot,add,that,shared,slot,to,the,sharing,group,and,allocate,a,simple,slot,from,that,shared,slot,p,this,method,will,try,to,allocate,a,slot,from,one,of,the,local,instances,and,fall,back,to,non,local,instances,if,permitted,p,param,vertex,the,vertex,to,allocate,the,slot,for,param,requested,locations,the,locations,that,are,considered,local,may,be,null,or,empty,if,the,vertex,has,no,location,preferences,param,group,assignment,the,slot,sharing,group,of,the,vertex,mandatory,parameter,param,constraint,the,co,location,constraint,of,the,vertex,may,be,null,param,local,only,flag,to,indicate,if,non,local,choices,are,acceptable,return,a,sub,slot,for,the,given,vertex,or,code,null,if,no,slot,is,available;protected,simple,slot,get,new,slot,for,sharing,group,execution,vertex,vertex,iterable,task,manager,location,requested,locations,slot,sharing,group,assignment,group,assignment,co,location,constraint,constraint,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,final,instance,instance,to,use,instance,locality,pair,get,left,final,locality,locality,instance,locality,pair,get,right,try,job,vertex,id,group,id,vertex,get,jobvertex,id,shared,slot,shared,slot,instance,to,use,allocate,shared,slot,vertex,get,job,id,group,assignment,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,shared,slot,null,simple,slot,slot,constraint,null,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,group,id,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,constraint,if,slot,null,return,slot,else,shared,slot,release,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex, 													Iterable<TaskManagerLocation> requestedLocations, 													SlotSharingGroupAssignment groupAssignment, 													CoLocationConstraint constraint, 													boolean localOnly);1474983187;Tries to allocate a new slot for a vertex that is part of a slot sharing group. If one_of the instances has a slot available, the method will allocate it as a shared slot, add that_shared slot to the sharing group, and allocate a simple slot from that shared slot.__<p>This method will try to allocate a slot from one of the local instances, and fall back to_non-local instances, if permitted.</p>__@param vertex The vertex to allocate the slot for._@param requestedLocations The locations that are considered local. May be null or empty, if the_vertex has no location preferences._@param groupAssignment The slot sharing group of the vertex. Mandatory parameter._@param constraint The co-location constraint of the vertex. May be null._@param localOnly Flag to indicate if non-local choices are acceptable.__@return A sub-slot for the given vertex, or {@code null}, if no slot is available.;protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex,_													Iterable<TaskManagerLocation> requestedLocations,_													SlotSharingGroupAssignment groupAssignment,_													CoLocationConstraint constraint,_													boolean localOnly)_	{_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)__			_			if (instanceLocalityPair == null) {_				_				return null__			}__			final Instance instanceToUse = instanceLocalityPair.getLeft()__			final Locality locality = instanceLocalityPair.getRight()___			try {_				JobVertexID groupID = vertex.getJobvertexId()__				_				_				SharedSlot sharedSlot = instanceToUse.allocateSharedSlot(vertex.getJobId(), groupAssignment)___				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}__				if (sharedSlot != null) {_					_					SimpleSlot slot = constraint == null ?_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, groupID) :_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, constraint)___					if (slot != null) {_						return slot__					}_					else {_						_						sharedSlot.releaseSlot()__					}_				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}__			_		}_	};tries,to,allocate,a,new,slot,for,a,vertex,that,is,part,of,a,slot,sharing,group,if,one,of,the,instances,has,a,slot,available,the,method,will,allocate,it,as,a,shared,slot,add,that,shared,slot,to,the,sharing,group,and,allocate,a,simple,slot,from,that,shared,slot,p,this,method,will,try,to,allocate,a,slot,from,one,of,the,local,instances,and,fall,back,to,non,local,instances,if,permitted,p,param,vertex,the,vertex,to,allocate,the,slot,for,param,requested,locations,the,locations,that,are,considered,local,may,be,null,or,empty,if,the,vertex,has,no,location,preferences,param,group,assignment,the,slot,sharing,group,of,the,vertex,mandatory,parameter,param,constraint,the,co,location,constraint,of,the,vertex,may,be,null,param,local,only,flag,to,indicate,if,non,local,choices,are,acceptable,return,a,sub,slot,for,the,given,vertex,or,code,null,if,no,slot,is,available;protected,simple,slot,get,new,slot,for,sharing,group,execution,vertex,vertex,iterable,task,manager,location,requested,locations,slot,sharing,group,assignment,group,assignment,co,location,constraint,constraint,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,final,instance,instance,to,use,instance,locality,pair,get,left,final,locality,locality,instance,locality,pair,get,right,try,job,vertex,id,group,id,vertex,get,jobvertex,id,shared,slot,shared,slot,instance,to,use,allocate,shared,slot,vertex,get,job,id,group,assignment,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,shared,slot,null,simple,slot,slot,constraint,null,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,group,id,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,constraint,if,slot,null,return,slot,else,shared,slot,release,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex, 													Iterable<TaskManagerLocation> requestedLocations, 													SlotSharingGroupAssignment groupAssignment, 													CoLocationConstraint constraint, 													boolean localOnly);1485888959;Tries to allocate a new slot for a vertex that is part of a slot sharing group. If one_of the instances has a slot available, the method will allocate it as a shared slot, add that_shared slot to the sharing group, and allocate a simple slot from that shared slot.__<p>This method will try to allocate a slot from one of the local instances, and fall back to_non-local instances, if permitted.</p>__@param vertex The vertex to allocate the slot for._@param requestedLocations The locations that are considered local. May be null or empty, if the_vertex has no location preferences._@param groupAssignment The slot sharing group of the vertex. Mandatory parameter._@param constraint The co-location constraint of the vertex. May be null._@param localOnly Flag to indicate if non-local choices are acceptable.__@return A sub-slot for the given vertex, or {@code null}, if no slot is available.;protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex,_													Iterable<TaskManagerLocation> requestedLocations,_													SlotSharingGroupAssignment groupAssignment,_													CoLocationConstraint constraint,_													boolean localOnly)_	{_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)__			_			if (instanceLocalityPair == null) {_				_				return null__			}__			final Instance instanceToUse = instanceLocalityPair.getLeft()__			final Locality locality = instanceLocalityPair.getRight()___			try {_				JobVertexID groupID = vertex.getJobvertexId()__				_				_				SharedSlot sharedSlot = instanceToUse.allocateSharedSlot(vertex.getJobId(), groupAssignment)___				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}__				if (sharedSlot != null) {_					_					SimpleSlot slot = constraint == null ?_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, groupID) :_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, constraint)___					if (slot != null) {_						return slot__					}_					else {_						_						sharedSlot.releaseSlot()__					}_				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}__			_		}_	};tries,to,allocate,a,new,slot,for,a,vertex,that,is,part,of,a,slot,sharing,group,if,one,of,the,instances,has,a,slot,available,the,method,will,allocate,it,as,a,shared,slot,add,that,shared,slot,to,the,sharing,group,and,allocate,a,simple,slot,from,that,shared,slot,p,this,method,will,try,to,allocate,a,slot,from,one,of,the,local,instances,and,fall,back,to,non,local,instances,if,permitted,p,param,vertex,the,vertex,to,allocate,the,slot,for,param,requested,locations,the,locations,that,are,considered,local,may,be,null,or,empty,if,the,vertex,has,no,location,preferences,param,group,assignment,the,slot,sharing,group,of,the,vertex,mandatory,parameter,param,constraint,the,co,location,constraint,of,the,vertex,may,be,null,param,local,only,flag,to,indicate,if,non,local,choices,are,acceptable,return,a,sub,slot,for,the,given,vertex,or,code,null,if,no,slot,is,available;protected,simple,slot,get,new,slot,for,sharing,group,execution,vertex,vertex,iterable,task,manager,location,requested,locations,slot,sharing,group,assignment,group,assignment,co,location,constraint,constraint,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,final,instance,instance,to,use,instance,locality,pair,get,left,final,locality,locality,instance,locality,pair,get,right,try,job,vertex,id,group,id,vertex,get,jobvertex,id,shared,slot,shared,slot,instance,to,use,allocate,shared,slot,vertex,get,job,id,group,assignment,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,shared,slot,null,simple,slot,slot,constraint,null,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,group,id,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,constraint,if,slot,null,return,slot,else,shared,slot,release,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex, 													Iterable<TaskManagerLocation> requestedLocations, 													SlotSharingGroupAssignment groupAssignment, 													CoLocationConstraint constraint, 													boolean localOnly);1485891273;Tries to allocate a new slot for a vertex that is part of a slot sharing group. If one_of the instances has a slot available, the method will allocate it as a shared slot, add that_shared slot to the sharing group, and allocate a simple slot from that shared slot.__<p>This method will try to allocate a slot from one of the local instances, and fall back to_non-local instances, if permitted.</p>__@param vertex The vertex to allocate the slot for._@param requestedLocations The locations that are considered local. May be null or empty, if the_vertex has no location preferences._@param groupAssignment The slot sharing group of the vertex. Mandatory parameter._@param constraint The co-location constraint of the vertex. May be null._@param localOnly Flag to indicate if non-local choices are acceptable.__@return A sub-slot for the given vertex, or {@code null}, if no slot is available.;protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex,_													Iterable<TaskManagerLocation> requestedLocations,_													SlotSharingGroupAssignment groupAssignment,_													CoLocationConstraint constraint,_													boolean localOnly)_	{_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)__			_			if (instanceLocalityPair == null) {_				_				return null__			}__			final Instance instanceToUse = instanceLocalityPair.getLeft()__			final Locality locality = instanceLocalityPair.getRight()___			try {_				JobVertexID groupID = vertex.getJobvertexId()__				_				_				SharedSlot sharedSlot = instanceToUse.allocateSharedSlot(vertex.getJobId(), groupAssignment)___				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}__				if (sharedSlot != null) {_					_					SimpleSlot slot = constraint == null ?_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, groupID) :_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, constraint)___					if (slot != null) {_						return slot__					}_					else {_						_						sharedSlot.releaseSlot()__					}_				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}__			_		}_	};tries,to,allocate,a,new,slot,for,a,vertex,that,is,part,of,a,slot,sharing,group,if,one,of,the,instances,has,a,slot,available,the,method,will,allocate,it,as,a,shared,slot,add,that,shared,slot,to,the,sharing,group,and,allocate,a,simple,slot,from,that,shared,slot,p,this,method,will,try,to,allocate,a,slot,from,one,of,the,local,instances,and,fall,back,to,non,local,instances,if,permitted,p,param,vertex,the,vertex,to,allocate,the,slot,for,param,requested,locations,the,locations,that,are,considered,local,may,be,null,or,empty,if,the,vertex,has,no,location,preferences,param,group,assignment,the,slot,sharing,group,of,the,vertex,mandatory,parameter,param,constraint,the,co,location,constraint,of,the,vertex,may,be,null,param,local,only,flag,to,indicate,if,non,local,choices,are,acceptable,return,a,sub,slot,for,the,given,vertex,or,code,null,if,no,slot,is,available;protected,simple,slot,get,new,slot,for,sharing,group,execution,vertex,vertex,iterable,task,manager,location,requested,locations,slot,sharing,group,assignment,group,assignment,co,location,constraint,constraint,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,final,instance,instance,to,use,instance,locality,pair,get,left,final,locality,locality,instance,locality,pair,get,right,try,job,vertex,id,group,id,vertex,get,jobvertex,id,shared,slot,shared,slot,instance,to,use,allocate,shared,slot,vertex,get,job,id,group,assignment,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,shared,slot,null,simple,slot,slot,constraint,null,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,group,id,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,constraint,if,slot,null,return,slot,else,shared,slot,release,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex, 													Iterable<TaskManagerLocation> requestedLocations, 													SlotSharingGroupAssignment groupAssignment, 													CoLocationConstraint constraint, 													boolean localOnly);1486663952;Tries to allocate a new slot for a vertex that is part of a slot sharing group. If one_of the instances has a slot available, the method will allocate it as a shared slot, add that_shared slot to the sharing group, and allocate a simple slot from that shared slot.__<p>This method will try to allocate a slot from one of the local instances, and fall back to_non-local instances, if permitted.</p>__@param vertex The vertex to allocate the slot for._@param requestedLocations The locations that are considered local. May be null or empty, if the_vertex has no location preferences._@param groupAssignment The slot sharing group of the vertex. Mandatory parameter._@param constraint The co-location constraint of the vertex. May be null._@param localOnly Flag to indicate if non-local choices are acceptable.__@return A sub-slot for the given vertex, or {@code null}, if no slot is available.;protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex,_													Iterable<TaskManagerLocation> requestedLocations,_													SlotSharingGroupAssignment groupAssignment,_													CoLocationConstraint constraint,_													boolean localOnly)_	{_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)__			_			if (instanceLocalityPair == null) {_				_				return null__			}__			final Instance instanceToUse = instanceLocalityPair.getLeft()__			final Locality locality = instanceLocalityPair.getRight()___			try {_				JobVertexID groupID = vertex.getJobvertexId()__				_				_				SharedSlot sharedSlot = instanceToUse.allocateSharedSlot(vertex.getJobId(), groupAssignment)___				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}__				if (sharedSlot != null) {_					_					SimpleSlot slot = constraint == null ?_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, groupID) :_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, constraint)___					if (slot != null) {_						return slot__					}_					else {_						_						sharedSlot.releaseSlot()__					}_				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}__			_		}_	};tries,to,allocate,a,new,slot,for,a,vertex,that,is,part,of,a,slot,sharing,group,if,one,of,the,instances,has,a,slot,available,the,method,will,allocate,it,as,a,shared,slot,add,that,shared,slot,to,the,sharing,group,and,allocate,a,simple,slot,from,that,shared,slot,p,this,method,will,try,to,allocate,a,slot,from,one,of,the,local,instances,and,fall,back,to,non,local,instances,if,permitted,p,param,vertex,the,vertex,to,allocate,the,slot,for,param,requested,locations,the,locations,that,are,considered,local,may,be,null,or,empty,if,the,vertex,has,no,location,preferences,param,group,assignment,the,slot,sharing,group,of,the,vertex,mandatory,parameter,param,constraint,the,co,location,constraint,of,the,vertex,may,be,null,param,local,only,flag,to,indicate,if,non,local,choices,are,acceptable,return,a,sub,slot,for,the,given,vertex,or,code,null,if,no,slot,is,available;protected,simple,slot,get,new,slot,for,sharing,group,execution,vertex,vertex,iterable,task,manager,location,requested,locations,slot,sharing,group,assignment,group,assignment,co,location,constraint,constraint,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,final,instance,instance,to,use,instance,locality,pair,get,left,final,locality,locality,instance,locality,pair,get,right,try,job,vertex,id,group,id,vertex,get,jobvertex,id,shared,slot,shared,slot,instance,to,use,allocate,shared,slot,vertex,get,job,id,group,assignment,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,shared,slot,null,simple,slot,slot,constraint,null,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,group,id,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,constraint,if,slot,null,return,slot,else,shared,slot,release,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex, 													Iterable<TaskManagerLocation> requestedLocations, 													SlotSharingGroupAssignment groupAssignment, 													CoLocationConstraint constraint, 													boolean localOnly);1488299223;Tries to allocate a new slot for a vertex that is part of a slot sharing group. If one_of the instances has a slot available, the method will allocate it as a shared slot, add that_shared slot to the sharing group, and allocate a simple slot from that shared slot.__<p>This method will try to allocate a slot from one of the local instances, and fall back to_non-local instances, if permitted.</p>__@param vertex The vertex to allocate the slot for._@param requestedLocations The locations that are considered local. May be null or empty, if the_vertex has no location preferences._@param groupAssignment The slot sharing group of the vertex. Mandatory parameter._@param constraint The co-location constraint of the vertex. May be null._@param localOnly Flag to indicate if non-local choices are acceptable.__@return A sub-slot for the given vertex, or {@code null}, if no slot is available.;protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex,_													Iterable<TaskManagerLocation> requestedLocations,_													SlotSharingGroupAssignment groupAssignment,_													CoLocationConstraint constraint,_													boolean localOnly)_	{_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)__			_			if (instanceLocalityPair == null) {_				_				return null__			}__			final Instance instanceToUse = instanceLocalityPair.getLeft()__			final Locality locality = instanceLocalityPair.getRight()___			try {_				JobVertexID groupID = vertex.getJobvertexId()__				_				_				SharedSlot sharedSlot = instanceToUse.allocateSharedSlot(vertex.getJobId(), groupAssignment)___				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}__				if (sharedSlot != null) {_					_					SimpleSlot slot = constraint == null ?_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, groupID) :_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, constraint)___					if (slot != null) {_						return slot__					}_					else {_						_						sharedSlot.releaseSlot()__					}_				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}__			_		}_	};tries,to,allocate,a,new,slot,for,a,vertex,that,is,part,of,a,slot,sharing,group,if,one,of,the,instances,has,a,slot,available,the,method,will,allocate,it,as,a,shared,slot,add,that,shared,slot,to,the,sharing,group,and,allocate,a,simple,slot,from,that,shared,slot,p,this,method,will,try,to,allocate,a,slot,from,one,of,the,local,instances,and,fall,back,to,non,local,instances,if,permitted,p,param,vertex,the,vertex,to,allocate,the,slot,for,param,requested,locations,the,locations,that,are,considered,local,may,be,null,or,empty,if,the,vertex,has,no,location,preferences,param,group,assignment,the,slot,sharing,group,of,the,vertex,mandatory,parameter,param,constraint,the,co,location,constraint,of,the,vertex,may,be,null,param,local,only,flag,to,indicate,if,non,local,choices,are,acceptable,return,a,sub,slot,for,the,given,vertex,or,code,null,if,no,slot,is,available;protected,simple,slot,get,new,slot,for,sharing,group,execution,vertex,vertex,iterable,task,manager,location,requested,locations,slot,sharing,group,assignment,group,assignment,co,location,constraint,constraint,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,final,instance,instance,to,use,instance,locality,pair,get,left,final,locality,locality,instance,locality,pair,get,right,try,job,vertex,id,group,id,vertex,get,jobvertex,id,shared,slot,shared,slot,instance,to,use,allocate,shared,slot,vertex,get,job,id,group,assignment,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,shared,slot,null,simple,slot,slot,constraint,null,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,group,id,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,constraint,if,slot,null,return,slot,else,shared,slot,release,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex, 													Iterable<TaskManagerLocation> requestedLocations, 													SlotSharingGroupAssignment groupAssignment, 													CoLocationConstraint constraint, 													boolean localOnly);1490819573;Tries to allocate a new slot for a vertex that is part of a slot sharing group. If one_of the instances has a slot available, the method will allocate it as a shared slot, add that_shared slot to the sharing group, and allocate a simple slot from that shared slot.__<p>This method will try to allocate a slot from one of the local instances, and fall back to_non-local instances, if permitted.</p>__@param vertex The vertex to allocate the slot for._@param requestedLocations The locations that are considered local. May be null or empty, if the_vertex has no location preferences._@param groupAssignment The slot sharing group of the vertex. Mandatory parameter._@param constraint The co-location constraint of the vertex. May be null._@param localOnly Flag to indicate if non-local choices are acceptable.__@return A sub-slot for the given vertex, or {@code null}, if no slot is available.;protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex,_													Iterable<TaskManagerLocation> requestedLocations,_													SlotSharingGroupAssignment groupAssignment,_													CoLocationConstraint constraint,_													boolean localOnly)_	{_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)__			_			if (instanceLocalityPair == null) {_				_				return null__			}__			final Instance instanceToUse = instanceLocalityPair.getLeft()__			final Locality locality = instanceLocalityPair.getRight()___			try {_				JobVertexID groupID = vertex.getJobvertexId()__				_				_				SharedSlot sharedSlot = instanceToUse.allocateSharedSlot(vertex.getJobId(), groupAssignment)___				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}__				if (sharedSlot != null) {_					_					SimpleSlot slot = constraint == null ?_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, groupID) :_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, constraint)___					if (slot != null) {_						return slot__					}_					else {_						_						sharedSlot.releaseSlot()__					}_				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}__			_		}_	};tries,to,allocate,a,new,slot,for,a,vertex,that,is,part,of,a,slot,sharing,group,if,one,of,the,instances,has,a,slot,available,the,method,will,allocate,it,as,a,shared,slot,add,that,shared,slot,to,the,sharing,group,and,allocate,a,simple,slot,from,that,shared,slot,p,this,method,will,try,to,allocate,a,slot,from,one,of,the,local,instances,and,fall,back,to,non,local,instances,if,permitted,p,param,vertex,the,vertex,to,allocate,the,slot,for,param,requested,locations,the,locations,that,are,considered,local,may,be,null,or,empty,if,the,vertex,has,no,location,preferences,param,group,assignment,the,slot,sharing,group,of,the,vertex,mandatory,parameter,param,constraint,the,co,location,constraint,of,the,vertex,may,be,null,param,local,only,flag,to,indicate,if,non,local,choices,are,acceptable,return,a,sub,slot,for,the,given,vertex,or,code,null,if,no,slot,is,available;protected,simple,slot,get,new,slot,for,sharing,group,execution,vertex,vertex,iterable,task,manager,location,requested,locations,slot,sharing,group,assignment,group,assignment,co,location,constraint,constraint,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,final,instance,instance,to,use,instance,locality,pair,get,left,final,locality,locality,instance,locality,pair,get,right,try,job,vertex,id,group,id,vertex,get,jobvertex,id,shared,slot,shared,slot,instance,to,use,allocate,shared,slot,vertex,get,job,id,group,assignment,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,shared,slot,null,simple,slot,slot,constraint,null,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,group,id,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,constraint,if,slot,null,return,slot,else,shared,slot,release,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex, 													Iterable<TaskManagerLocation> requestedLocations, 													SlotSharingGroupAssignment groupAssignment, 													CoLocationConstraint constraint, 													boolean localOnly);1501519020;Tries to allocate a new slot for a vertex that is part of a slot sharing group. If one_of the instances has a slot available, the method will allocate it as a shared slot, add that_shared slot to the sharing group, and allocate a simple slot from that shared slot.__<p>This method will try to allocate a slot from one of the local instances, and fall back to_non-local instances, if permitted.</p>__@param vertex The vertex to allocate the slot for._@param requestedLocations The locations that are considered local. May be null or empty, if the_vertex has no location preferences._@param groupAssignment The slot sharing group of the vertex. Mandatory parameter._@param constraint The co-location constraint of the vertex. May be null._@param localOnly Flag to indicate if non-local choices are acceptable.__@return A sub-slot for the given vertex, or {@code null}, if no slot is available.;protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex,_													Iterable<TaskManagerLocation> requestedLocations,_													SlotSharingGroupAssignment groupAssignment,_													CoLocationConstraint constraint,_													boolean localOnly)_	{_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)__			_			if (instanceLocalityPair == null) {_				_				return null__			}__			final Instance instanceToUse = instanceLocalityPair.getLeft()__			final Locality locality = instanceLocalityPair.getRight()___			try {_				JobVertexID groupID = vertex.getJobvertexId()__				_				_				SharedSlot sharedSlot = instanceToUse.allocateSharedSlot(vertex.getJobId(), groupAssignment)___				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}__				if (sharedSlot != null) {_					_					SimpleSlot slot = constraint == null ?_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, groupID) :_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, constraint)___					if (slot != null) {_						return slot__					}_					else {_						_						sharedSlot.releaseSlot()__					}_				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}__			_		}_	};tries,to,allocate,a,new,slot,for,a,vertex,that,is,part,of,a,slot,sharing,group,if,one,of,the,instances,has,a,slot,available,the,method,will,allocate,it,as,a,shared,slot,add,that,shared,slot,to,the,sharing,group,and,allocate,a,simple,slot,from,that,shared,slot,p,this,method,will,try,to,allocate,a,slot,from,one,of,the,local,instances,and,fall,back,to,non,local,instances,if,permitted,p,param,vertex,the,vertex,to,allocate,the,slot,for,param,requested,locations,the,locations,that,are,considered,local,may,be,null,or,empty,if,the,vertex,has,no,location,preferences,param,group,assignment,the,slot,sharing,group,of,the,vertex,mandatory,parameter,param,constraint,the,co,location,constraint,of,the,vertex,may,be,null,param,local,only,flag,to,indicate,if,non,local,choices,are,acceptable,return,a,sub,slot,for,the,given,vertex,or,code,null,if,no,slot,is,available;protected,simple,slot,get,new,slot,for,sharing,group,execution,vertex,vertex,iterable,task,manager,location,requested,locations,slot,sharing,group,assignment,group,assignment,co,location,constraint,constraint,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,final,instance,instance,to,use,instance,locality,pair,get,left,final,locality,locality,instance,locality,pair,get,right,try,job,vertex,id,group,id,vertex,get,jobvertex,id,shared,slot,shared,slot,instance,to,use,allocate,shared,slot,vertex,get,job,id,group,assignment,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,shared,slot,null,simple,slot,slot,constraint,null,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,group,id,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,constraint,if,slot,null,return,slot,else,shared,slot,release,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex, 													Iterable<TaskManagerLocation> requestedLocations, 													SlotSharingGroupAssignment groupAssignment, 													CoLocationConstraint constraint, 													boolean localOnly);1508155453;Tries to allocate a new slot for a vertex that is part of a slot sharing group. If one_of the instances has a slot available, the method will allocate it as a shared slot, add that_shared slot to the sharing group, and allocate a simple slot from that shared slot.__<p>This method will try to allocate a slot from one of the local instances, and fall back to_non-local instances, if permitted.</p>__@param vertex The vertex to allocate the slot for._@param requestedLocations The locations that are considered local. May be null or empty, if the_vertex has no location preferences._@param groupAssignment The slot sharing group of the vertex. Mandatory parameter._@param constraint The co-location constraint of the vertex. May be null._@param localOnly Flag to indicate if non-local choices are acceptable.__@return A sub-slot for the given vertex, or {@code null}, if no slot is available.;protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex,_													Iterable<TaskManagerLocation> requestedLocations,_													SlotSharingGroupAssignment groupAssignment,_													CoLocationConstraint constraint,_													boolean localOnly)_	{_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)__			_			if (instanceLocalityPair == null) {_				_				return null__			}__			final Instance instanceToUse = instanceLocalityPair.getLeft()__			final Locality locality = instanceLocalityPair.getRight()___			try {_				JobVertexID groupID = vertex.getJobvertexId()__				_				_				SharedSlot sharedSlot = instanceToUse.allocateSharedSlot(vertex.getJobId(), groupAssignment)___				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}__				if (sharedSlot != null) {_					_					SimpleSlot slot = constraint == null ?_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, groupID) :_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, constraint)___					if (slot != null) {_						return slot__					}_					else {_						_						sharedSlot.releaseSlot()__					}_				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}__			_		}_	};tries,to,allocate,a,new,slot,for,a,vertex,that,is,part,of,a,slot,sharing,group,if,one,of,the,instances,has,a,slot,available,the,method,will,allocate,it,as,a,shared,slot,add,that,shared,slot,to,the,sharing,group,and,allocate,a,simple,slot,from,that,shared,slot,p,this,method,will,try,to,allocate,a,slot,from,one,of,the,local,instances,and,fall,back,to,non,local,instances,if,permitted,p,param,vertex,the,vertex,to,allocate,the,slot,for,param,requested,locations,the,locations,that,are,considered,local,may,be,null,or,empty,if,the,vertex,has,no,location,preferences,param,group,assignment,the,slot,sharing,group,of,the,vertex,mandatory,parameter,param,constraint,the,co,location,constraint,of,the,vertex,may,be,null,param,local,only,flag,to,indicate,if,non,local,choices,are,acceptable,return,a,sub,slot,for,the,given,vertex,or,code,null,if,no,slot,is,available;protected,simple,slot,get,new,slot,for,sharing,group,execution,vertex,vertex,iterable,task,manager,location,requested,locations,slot,sharing,group,assignment,group,assignment,co,location,constraint,constraint,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,final,instance,instance,to,use,instance,locality,pair,get,left,final,locality,locality,instance,locality,pair,get,right,try,job,vertex,id,group,id,vertex,get,jobvertex,id,shared,slot,shared,slot,instance,to,use,allocate,shared,slot,vertex,get,job,id,group,assignment,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,shared,slot,null,simple,slot,slot,constraint,null,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,group,id,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,constraint,if,slot,null,return,slot,else,shared,slot,release,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex, 													Iterable<TaskManagerLocation> requestedLocations, 													SlotSharingGroupAssignment groupAssignment, 													CoLocationConstraint constraint, 													boolean localOnly);1509090423;Tries to allocate a new slot for a vertex that is part of a slot sharing group. If one_of the instances has a slot available, the method will allocate it as a shared slot, add that_shared slot to the sharing group, and allocate a simple slot from that shared slot.__<p>This method will try to allocate a slot from one of the local instances, and fall back to_non-local instances, if permitted.</p>__@param vertex The vertex to allocate the slot for._@param requestedLocations The locations that are considered local. May be null or empty, if the_vertex has no location preferences._@param groupAssignment The slot sharing group of the vertex. Mandatory parameter._@param constraint The co-location constraint of the vertex. May be null._@param localOnly Flag to indicate if non-local choices are acceptable.__@return A sub-slot for the given vertex, or {@code null}, if no slot is available.;protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex,_													Iterable<TaskManagerLocation> requestedLocations,_													SlotSharingGroupAssignment groupAssignment,_													CoLocationConstraint constraint,_													boolean localOnly)_	{_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)__			_			if (instanceLocalityPair == null) {_				_				return null__			}__			final Instance instanceToUse = instanceLocalityPair.getLeft()__			final Locality locality = instanceLocalityPair.getRight()___			try {_				JobVertexID groupID = vertex.getJobvertexId()__				_				_				SharedSlot sharedSlot = instanceToUse.allocateSharedSlot(vertex.getJobId(), groupAssignment)___				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}__				if (sharedSlot != null) {_					_					SimpleSlot slot = constraint == null ?_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, groupID) :_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, constraint)___					if (slot != null) {_						return slot__					}_					else {_						_						sharedSlot.releaseSlot()__					}_				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}__			_		}_	};tries,to,allocate,a,new,slot,for,a,vertex,that,is,part,of,a,slot,sharing,group,if,one,of,the,instances,has,a,slot,available,the,method,will,allocate,it,as,a,shared,slot,add,that,shared,slot,to,the,sharing,group,and,allocate,a,simple,slot,from,that,shared,slot,p,this,method,will,try,to,allocate,a,slot,from,one,of,the,local,instances,and,fall,back,to,non,local,instances,if,permitted,p,param,vertex,the,vertex,to,allocate,the,slot,for,param,requested,locations,the,locations,that,are,considered,local,may,be,null,or,empty,if,the,vertex,has,no,location,preferences,param,group,assignment,the,slot,sharing,group,of,the,vertex,mandatory,parameter,param,constraint,the,co,location,constraint,of,the,vertex,may,be,null,param,local,only,flag,to,indicate,if,non,local,choices,are,acceptable,return,a,sub,slot,for,the,given,vertex,or,code,null,if,no,slot,is,available;protected,simple,slot,get,new,slot,for,sharing,group,execution,vertex,vertex,iterable,task,manager,location,requested,locations,slot,sharing,group,assignment,group,assignment,co,location,constraint,constraint,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,final,instance,instance,to,use,instance,locality,pair,get,left,final,locality,locality,instance,locality,pair,get,right,try,job,vertex,id,group,id,vertex,get,jobvertex,id,shared,slot,shared,slot,instance,to,use,allocate,shared,slot,vertex,get,job,id,group,assignment,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,shared,slot,null,simple,slot,slot,constraint,null,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,group,id,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,constraint,if,slot,null,return,slot,else,shared,slot,release,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex, 													Iterable<TaskManagerLocation> requestedLocations, 													SlotSharingGroupAssignment groupAssignment, 													CoLocationConstraint constraint, 													boolean localOnly);1510699852;Tries to allocate a new slot for a vertex that is part of a slot sharing group. If one_of the instances has a slot available, the method will allocate it as a shared slot, add that_shared slot to the sharing group, and allocate a simple slot from that shared slot.__<p>This method will try to allocate a slot from one of the local instances, and fall back to_non-local instances, if permitted.</p>__@param vertex The vertex to allocate the slot for._@param requestedLocations The locations that are considered local. May be null or empty, if the_vertex has no location preferences._@param groupAssignment The slot sharing group of the vertex. Mandatory parameter._@param constraint The co-location constraint of the vertex. May be null._@param localOnly Flag to indicate if non-local choices are acceptable.__@return A sub-slot for the given vertex, or {@code null}, if no slot is available.;protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex,_													Iterable<TaskManagerLocation> requestedLocations,_													SlotSharingGroupAssignment groupAssignment,_													CoLocationConstraint constraint,_													boolean localOnly)_	{_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)__			_			if (instanceLocalityPair == null) {_				_				return null__			}__			final Instance instanceToUse = instanceLocalityPair.getLeft()__			final Locality locality = instanceLocalityPair.getRight()___			try {_				JobVertexID groupID = vertex.getJobvertexId()__				_				_				SharedSlot sharedSlot = instanceToUse.allocateSharedSlot(vertex.getJobId(), groupAssignment)___				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}__				if (sharedSlot != null) {_					_					SimpleSlot slot = constraint == null ?_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, groupID) :_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, constraint)___					if (slot != null) {_						return slot__					}_					else {_						_						sharedSlot.releaseSlot()__					}_				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}__			_		}_	};tries,to,allocate,a,new,slot,for,a,vertex,that,is,part,of,a,slot,sharing,group,if,one,of,the,instances,has,a,slot,available,the,method,will,allocate,it,as,a,shared,slot,add,that,shared,slot,to,the,sharing,group,and,allocate,a,simple,slot,from,that,shared,slot,p,this,method,will,try,to,allocate,a,slot,from,one,of,the,local,instances,and,fall,back,to,non,local,instances,if,permitted,p,param,vertex,the,vertex,to,allocate,the,slot,for,param,requested,locations,the,locations,that,are,considered,local,may,be,null,or,empty,if,the,vertex,has,no,location,preferences,param,group,assignment,the,slot,sharing,group,of,the,vertex,mandatory,parameter,param,constraint,the,co,location,constraint,of,the,vertex,may,be,null,param,local,only,flag,to,indicate,if,non,local,choices,are,acceptable,return,a,sub,slot,for,the,given,vertex,or,code,null,if,no,slot,is,available;protected,simple,slot,get,new,slot,for,sharing,group,execution,vertex,vertex,iterable,task,manager,location,requested,locations,slot,sharing,group,assignment,group,assignment,co,location,constraint,constraint,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,final,instance,instance,to,use,instance,locality,pair,get,left,final,locality,locality,instance,locality,pair,get,right,try,job,vertex,id,group,id,vertex,get,jobvertex,id,shared,slot,shared,slot,instance,to,use,allocate,shared,slot,vertex,get,job,id,group,assignment,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,shared,slot,null,simple,slot,slot,constraint,null,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,group,id,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,constraint,if,slot,null,return,slot,else,shared,slot,release,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex, 													Iterable<TaskManagerLocation> requestedLocations, 													SlotSharingGroupAssignment groupAssignment, 													CoLocationConstraint constraint, 													boolean localOnly);1510752027;Tries to allocate a new slot for a vertex that is part of a slot sharing group. If one_of the instances has a slot available, the method will allocate it as a shared slot, add that_shared slot to the sharing group, and allocate a simple slot from that shared slot.__<p>This method will try to allocate a slot from one of the local instances, and fall back to_non-local instances, if permitted.</p>__@param vertex The vertex to allocate the slot for._@param requestedLocations The locations that are considered local. May be null or empty, if the_vertex has no location preferences._@param groupAssignment The slot sharing group of the vertex. Mandatory parameter._@param constraint The co-location constraint of the vertex. May be null._@param localOnly Flag to indicate if non-local choices are acceptable.__@return A sub-slot for the given vertex, or {@code null}, if no slot is available.;protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex,_													Iterable<TaskManagerLocation> requestedLocations,_													SlotSharingGroupAssignment groupAssignment,_													CoLocationConstraint constraint,_													boolean localOnly)_	{_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)__			_			if (instanceLocalityPair == null) {_				_				return null__			}__			final Instance instanceToUse = instanceLocalityPair.getLeft()__			final Locality locality = instanceLocalityPair.getRight()___			try {_				JobVertexID groupID = vertex.getJobvertexId()__				_				_				SharedSlot sharedSlot = instanceToUse.allocateSharedSlot(vertex.getJobId(), groupAssignment)___				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}__				if (sharedSlot != null) {_					_					SimpleSlot slot = constraint == null ?_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, groupID) :_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, constraint)___					if (slot != null) {_						return slot__					}_					else {_						_						sharedSlot.releaseInstanceSlot()__					}_				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}__			_		}_	};tries,to,allocate,a,new,slot,for,a,vertex,that,is,part,of,a,slot,sharing,group,if,one,of,the,instances,has,a,slot,available,the,method,will,allocate,it,as,a,shared,slot,add,that,shared,slot,to,the,sharing,group,and,allocate,a,simple,slot,from,that,shared,slot,p,this,method,will,try,to,allocate,a,slot,from,one,of,the,local,instances,and,fall,back,to,non,local,instances,if,permitted,p,param,vertex,the,vertex,to,allocate,the,slot,for,param,requested,locations,the,locations,that,are,considered,local,may,be,null,or,empty,if,the,vertex,has,no,location,preferences,param,group,assignment,the,slot,sharing,group,of,the,vertex,mandatory,parameter,param,constraint,the,co,location,constraint,of,the,vertex,may,be,null,param,local,only,flag,to,indicate,if,non,local,choices,are,acceptable,return,a,sub,slot,for,the,given,vertex,or,code,null,if,no,slot,is,available;protected,simple,slot,get,new,slot,for,sharing,group,execution,vertex,vertex,iterable,task,manager,location,requested,locations,slot,sharing,group,assignment,group,assignment,co,location,constraint,constraint,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,final,instance,instance,to,use,instance,locality,pair,get,left,final,locality,locality,instance,locality,pair,get,right,try,job,vertex,id,group,id,vertex,get,jobvertex,id,shared,slot,shared,slot,instance,to,use,allocate,shared,slot,vertex,get,job,id,group,assignment,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,shared,slot,null,simple,slot,slot,constraint,null,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,group,id,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,constraint,if,slot,null,return,slot,else,shared,slot,release,instance,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex, 													Iterable<TaskManagerLocation> requestedLocations, 													SlotSharingGroupAssignment groupAssignment, 													CoLocationConstraint constraint, 													boolean localOnly);1511543029;Tries to allocate a new slot for a vertex that is part of a slot sharing group. If one_of the instances has a slot available, the method will allocate it as a shared slot, add that_shared slot to the sharing group, and allocate a simple slot from that shared slot.__<p>This method will try to allocate a slot from one of the local instances, and fall back to_non-local instances, if permitted.</p>__@param vertex The vertex to allocate the slot for._@param requestedLocations The locations that are considered local. May be null or empty, if the_vertex has no location preferences._@param groupAssignment The slot sharing group of the vertex. Mandatory parameter._@param constraint The co-location constraint of the vertex. May be null._@param localOnly Flag to indicate if non-local choices are acceptable.__@return A sub-slot for the given vertex, or {@code null}, if no slot is available.;protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex,_													Iterable<TaskManagerLocation> requestedLocations,_													SlotSharingGroupAssignment groupAssignment,_													CoLocationConstraint constraint,_													boolean localOnly)_	{_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)__			_			if (instanceLocalityPair == null) {_				_				return null__			}__			final Instance instanceToUse = instanceLocalityPair.getLeft()__			final Locality locality = instanceLocalityPair.getRight()___			try {_				JobVertexID groupID = vertex.getJobvertexId()__				_				_				SharedSlot sharedSlot = instanceToUse.allocateSharedSlot(groupAssignment)___				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}__				if (sharedSlot != null) {_					_					SimpleSlot slot = constraint == null ?_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, groupID) :_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, constraint)___					if (slot != null) {_						return slot__					}_					else {_						_						sharedSlot.releaseInstanceSlot()__					}_				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}__			_		}_	};tries,to,allocate,a,new,slot,for,a,vertex,that,is,part,of,a,slot,sharing,group,if,one,of,the,instances,has,a,slot,available,the,method,will,allocate,it,as,a,shared,slot,add,that,shared,slot,to,the,sharing,group,and,allocate,a,simple,slot,from,that,shared,slot,p,this,method,will,try,to,allocate,a,slot,from,one,of,the,local,instances,and,fall,back,to,non,local,instances,if,permitted,p,param,vertex,the,vertex,to,allocate,the,slot,for,param,requested,locations,the,locations,that,are,considered,local,may,be,null,or,empty,if,the,vertex,has,no,location,preferences,param,group,assignment,the,slot,sharing,group,of,the,vertex,mandatory,parameter,param,constraint,the,co,location,constraint,of,the,vertex,may,be,null,param,local,only,flag,to,indicate,if,non,local,choices,are,acceptable,return,a,sub,slot,for,the,given,vertex,or,code,null,if,no,slot,is,available;protected,simple,slot,get,new,slot,for,sharing,group,execution,vertex,vertex,iterable,task,manager,location,requested,locations,slot,sharing,group,assignment,group,assignment,co,location,constraint,constraint,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,final,instance,instance,to,use,instance,locality,pair,get,left,final,locality,locality,instance,locality,pair,get,right,try,job,vertex,id,group,id,vertex,get,jobvertex,id,shared,slot,shared,slot,instance,to,use,allocate,shared,slot,group,assignment,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,shared,slot,null,simple,slot,slot,constraint,null,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,group,id,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,constraint,if,slot,null,return,slot,else,shared,slot,release,instance,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex, 													Iterable<TaskManagerLocation> requestedLocations, 													SlotSharingGroupAssignment groupAssignment, 													CoLocationConstraint constraint, 													boolean localOnly);1513261475;Tries to allocate a new slot for a vertex that is part of a slot sharing group. If one_of the instances has a slot available, the method will allocate it as a shared slot, add that_shared slot to the sharing group, and allocate a simple slot from that shared slot.__<p>This method will try to allocate a slot from one of the local instances, and fall back to_non-local instances, if permitted.</p>__@param vertex The vertex to allocate the slot for._@param requestedLocations The locations that are considered local. May be null or empty, if the_vertex has no location preferences._@param groupAssignment The slot sharing group of the vertex. Mandatory parameter._@param constraint The co-location constraint of the vertex. May be null._@param localOnly Flag to indicate if non-local choices are acceptable.__@return A sub-slot for the given vertex, or {@code null}, if no slot is available.;protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex,_													Iterable<TaskManagerLocation> requestedLocations,_													SlotSharingGroupAssignment groupAssignment,_													CoLocationConstraint constraint,_													boolean localOnly)_	{_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)__			_			if (instanceLocalityPair == null) {_				_				return null__			}__			final Instance instanceToUse = instanceLocalityPair.getLeft()__			final Locality locality = instanceLocalityPair.getRight()___			try {_				JobVertexID groupID = vertex.getJobvertexId()__				_				_				SharedSlot sharedSlot = instanceToUse.allocateSharedSlot(groupAssignment)___				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}__				if (sharedSlot != null) {_					_					SimpleSlot slot = constraint == null ?_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, groupID) :_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, constraint)___					if (slot != null) {_						return slot__					}_					else {_						_						sharedSlot.releaseSlot(new FlinkException("Could not allocate sub-slot."))__					}_				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}__			_		}_	};tries,to,allocate,a,new,slot,for,a,vertex,that,is,part,of,a,slot,sharing,group,if,one,of,the,instances,has,a,slot,available,the,method,will,allocate,it,as,a,shared,slot,add,that,shared,slot,to,the,sharing,group,and,allocate,a,simple,slot,from,that,shared,slot,p,this,method,will,try,to,allocate,a,slot,from,one,of,the,local,instances,and,fall,back,to,non,local,instances,if,permitted,p,param,vertex,the,vertex,to,allocate,the,slot,for,param,requested,locations,the,locations,that,are,considered,local,may,be,null,or,empty,if,the,vertex,has,no,location,preferences,param,group,assignment,the,slot,sharing,group,of,the,vertex,mandatory,parameter,param,constraint,the,co,location,constraint,of,the,vertex,may,be,null,param,local,only,flag,to,indicate,if,non,local,choices,are,acceptable,return,a,sub,slot,for,the,given,vertex,or,code,null,if,no,slot,is,available;protected,simple,slot,get,new,slot,for,sharing,group,execution,vertex,vertex,iterable,task,manager,location,requested,locations,slot,sharing,group,assignment,group,assignment,co,location,constraint,constraint,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,final,instance,instance,to,use,instance,locality,pair,get,left,final,locality,locality,instance,locality,pair,get,right,try,job,vertex,id,group,id,vertex,get,jobvertex,id,shared,slot,shared,slot,instance,to,use,allocate,shared,slot,group,assignment,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,shared,slot,null,simple,slot,slot,constraint,null,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,group,id,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,constraint,if,slot,null,return,slot,else,shared,slot,release,slot,new,flink,exception,could,not,allocate,sub,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex, 													Iterable<TaskManagerLocation> requestedLocations, 													SlotSharingGroupAssignment groupAssignment, 													CoLocationConstraint constraint, 													boolean localOnly);1517497348;Tries to allocate a new slot for a vertex that is part of a slot sharing group. If one_of the instances has a slot available, the method will allocate it as a shared slot, add that_shared slot to the sharing group, and allocate a simple slot from that shared slot.__<p>This method will try to allocate a slot from one of the local instances, and fall back to_non-local instances, if permitted.</p>__@param vertex The vertex to allocate the slot for._@param requestedLocations The locations that are considered local. May be null or empty, if the_vertex has no location preferences._@param groupAssignment The slot sharing group of the vertex. Mandatory parameter._@param constraint The co-location constraint of the vertex. May be null._@param localOnly Flag to indicate if non-local choices are acceptable.__@return A sub-slot for the given vertex, or {@code null}, if no slot is available.;protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex,_													Iterable<TaskManagerLocation> requestedLocations,_													SlotSharingGroupAssignment groupAssignment,_													CoLocationConstraint constraint,_													boolean localOnly)_	{_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)__			_			if (instanceLocalityPair == null) {_				_				return null__			}__			final Instance instanceToUse = instanceLocalityPair.getLeft()__			final Locality locality = instanceLocalityPair.getRight()___			try {_				JobVertexID groupID = vertex.getJobvertexId()__				_				_				SharedSlot sharedSlot = instanceToUse.allocateSharedSlot(groupAssignment)___				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}__				if (sharedSlot != null) {_					_					SimpleSlot slot = constraint == null ?_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, groupID) :_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, constraint)___					if (slot != null) {_						return slot__					}_					else {_						_						sharedSlot.releaseSlot(new FlinkException("Could not allocate sub-slot."))__					}_				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}__			_		}_	};tries,to,allocate,a,new,slot,for,a,vertex,that,is,part,of,a,slot,sharing,group,if,one,of,the,instances,has,a,slot,available,the,method,will,allocate,it,as,a,shared,slot,add,that,shared,slot,to,the,sharing,group,and,allocate,a,simple,slot,from,that,shared,slot,p,this,method,will,try,to,allocate,a,slot,from,one,of,the,local,instances,and,fall,back,to,non,local,instances,if,permitted,p,param,vertex,the,vertex,to,allocate,the,slot,for,param,requested,locations,the,locations,that,are,considered,local,may,be,null,or,empty,if,the,vertex,has,no,location,preferences,param,group,assignment,the,slot,sharing,group,of,the,vertex,mandatory,parameter,param,constraint,the,co,location,constraint,of,the,vertex,may,be,null,param,local,only,flag,to,indicate,if,non,local,choices,are,acceptable,return,a,sub,slot,for,the,given,vertex,or,code,null,if,no,slot,is,available;protected,simple,slot,get,new,slot,for,sharing,group,execution,vertex,vertex,iterable,task,manager,location,requested,locations,slot,sharing,group,assignment,group,assignment,co,location,constraint,constraint,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,final,instance,instance,to,use,instance,locality,pair,get,left,final,locality,locality,instance,locality,pair,get,right,try,job,vertex,id,group,id,vertex,get,jobvertex,id,shared,slot,shared,slot,instance,to,use,allocate,shared,slot,group,assignment,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,shared,slot,null,simple,slot,slot,constraint,null,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,group,id,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,constraint,if,slot,null,return,slot,else,shared,slot,release,slot,new,flink,exception,could,not,allocate,sub,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex, 													Iterable<TaskManagerLocation> requestedLocations, 													SlotSharingGroupAssignment groupAssignment, 													CoLocationConstraint constraint, 													boolean localOnly);1518522104;Tries to allocate a new slot for a vertex that is part of a slot sharing group. If one_of the instances has a slot available, the method will allocate it as a shared slot, add that_shared slot to the sharing group, and allocate a simple slot from that shared slot.__<p>This method will try to allocate a slot from one of the local instances, and fall back to_non-local instances, if permitted.</p>__@param vertex The vertex to allocate the slot for._@param requestedLocations The locations that are considered local. May be null or empty, if the_vertex has no location preferences._@param groupAssignment The slot sharing group of the vertex. Mandatory parameter._@param constraint The co-location constraint of the vertex. May be null._@param localOnly Flag to indicate if non-local choices are acceptable.__@return A sub-slot for the given vertex, or {@code null}, if no slot is available.;protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex,_													Iterable<TaskManagerLocation> requestedLocations,_													SlotSharingGroupAssignment groupAssignment,_													CoLocationConstraint constraint,_													boolean localOnly)_	{_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)__			_			if (instanceLocalityPair == null) {_				_				return null__			}__			final Instance instanceToUse = instanceLocalityPair.getLeft()__			final Locality locality = instanceLocalityPair.getRight()___			try {_				JobVertexID groupID = vertex.getJobvertexId()__				_				_				SharedSlot sharedSlot = instanceToUse.allocateSharedSlot(groupAssignment)___				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}__				if (sharedSlot != null) {_					_					SimpleSlot slot = constraint == null ?_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, groupID) :_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, constraint)___					if (slot != null) {_						return slot__					}_					else {_						_						sharedSlot.releaseSlot(new FlinkException("Could not allocate sub-slot."))__					}_				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}__			_		}_	};tries,to,allocate,a,new,slot,for,a,vertex,that,is,part,of,a,slot,sharing,group,if,one,of,the,instances,has,a,slot,available,the,method,will,allocate,it,as,a,shared,slot,add,that,shared,slot,to,the,sharing,group,and,allocate,a,simple,slot,from,that,shared,slot,p,this,method,will,try,to,allocate,a,slot,from,one,of,the,local,instances,and,fall,back,to,non,local,instances,if,permitted,p,param,vertex,the,vertex,to,allocate,the,slot,for,param,requested,locations,the,locations,that,are,considered,local,may,be,null,or,empty,if,the,vertex,has,no,location,preferences,param,group,assignment,the,slot,sharing,group,of,the,vertex,mandatory,parameter,param,constraint,the,co,location,constraint,of,the,vertex,may,be,null,param,local,only,flag,to,indicate,if,non,local,choices,are,acceptable,return,a,sub,slot,for,the,given,vertex,or,code,null,if,no,slot,is,available;protected,simple,slot,get,new,slot,for,sharing,group,execution,vertex,vertex,iterable,task,manager,location,requested,locations,slot,sharing,group,assignment,group,assignment,co,location,constraint,constraint,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,final,instance,instance,to,use,instance,locality,pair,get,left,final,locality,locality,instance,locality,pair,get,right,try,job,vertex,id,group,id,vertex,get,jobvertex,id,shared,slot,shared,slot,instance,to,use,allocate,shared,slot,group,assignment,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,shared,slot,null,simple,slot,slot,constraint,null,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,group,id,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,constraint,if,slot,null,return,slot,else,shared,slot,release,slot,new,flink,exception,could,not,allocate,sub,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex, 													Iterable<TaskManagerLocation> requestedLocations, 													SlotSharingGroupAssignment groupAssignment, 													CoLocationConstraint constraint, 													boolean localOnly);1519315265;Tries to allocate a new slot for a vertex that is part of a slot sharing group. If one_of the instances has a slot available, the method will allocate it as a shared slot, add that_shared slot to the sharing group, and allocate a simple slot from that shared slot.__<p>This method will try to allocate a slot from one of the local instances, and fall back to_non-local instances, if permitted.</p>__@param vertex The vertex to allocate the slot for._@param requestedLocations The locations that are considered local. May be null or empty, if the_vertex has no location preferences._@param groupAssignment The slot sharing group of the vertex. Mandatory parameter._@param constraint The co-location constraint of the vertex. May be null._@param localOnly Flag to indicate if non-local choices are acceptable.__@return A sub-slot for the given vertex, or {@code null}, if no slot is available.;protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex,_													Iterable<TaskManagerLocation> requestedLocations,_													SlotSharingGroupAssignment groupAssignment,_													CoLocationConstraint constraint,_													boolean localOnly)_	{_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)__			_			if (instanceLocalityPair == null) {_				_				return null__			}__			final Instance instanceToUse = instanceLocalityPair.getLeft()__			final Locality locality = instanceLocalityPair.getRight()___			try {_				JobVertexID groupID = vertex.getJobvertexId()__				_				_				SharedSlot sharedSlot = instanceToUse.allocateSharedSlot(groupAssignment)___				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}__				if (sharedSlot != null) {_					_					SimpleSlot slot = constraint == null ?_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, groupID) :_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, constraint)___					if (slot != null) {_						return slot__					}_					else {_						_						sharedSlot.releaseSlot(new FlinkException("Could not allocate sub-slot."))__					}_				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}__			_		}_	};tries,to,allocate,a,new,slot,for,a,vertex,that,is,part,of,a,slot,sharing,group,if,one,of,the,instances,has,a,slot,available,the,method,will,allocate,it,as,a,shared,slot,add,that,shared,slot,to,the,sharing,group,and,allocate,a,simple,slot,from,that,shared,slot,p,this,method,will,try,to,allocate,a,slot,from,one,of,the,local,instances,and,fall,back,to,non,local,instances,if,permitted,p,param,vertex,the,vertex,to,allocate,the,slot,for,param,requested,locations,the,locations,that,are,considered,local,may,be,null,or,empty,if,the,vertex,has,no,location,preferences,param,group,assignment,the,slot,sharing,group,of,the,vertex,mandatory,parameter,param,constraint,the,co,location,constraint,of,the,vertex,may,be,null,param,local,only,flag,to,indicate,if,non,local,choices,are,acceptable,return,a,sub,slot,for,the,given,vertex,or,code,null,if,no,slot,is,available;protected,simple,slot,get,new,slot,for,sharing,group,execution,vertex,vertex,iterable,task,manager,location,requested,locations,slot,sharing,group,assignment,group,assignment,co,location,constraint,constraint,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,final,instance,instance,to,use,instance,locality,pair,get,left,final,locality,locality,instance,locality,pair,get,right,try,job,vertex,id,group,id,vertex,get,jobvertex,id,shared,slot,shared,slot,instance,to,use,allocate,shared,slot,group,assignment,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,shared,slot,null,simple,slot,slot,constraint,null,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,group,id,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,constraint,if,slot,null,return,slot,else,shared,slot,release,slot,new,flink,exception,could,not,allocate,sub,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex, 													Iterable<TaskManagerLocation> requestedLocations, 													SlotSharingGroupAssignment groupAssignment, 													CoLocationConstraint constraint, 													boolean localOnly);1538764056;Tries to allocate a new slot for a vertex that is part of a slot sharing group. If one_of the instances has a slot available, the method will allocate it as a shared slot, add that_shared slot to the sharing group, and allocate a simple slot from that shared slot.__<p>This method will try to allocate a slot from one of the local instances, and fall back to_non-local instances, if permitted.</p>__@param vertex The vertex to allocate the slot for._@param requestedLocations The locations that are considered local. May be null or empty, if the_vertex has no location preferences._@param groupAssignment The slot sharing group of the vertex. Mandatory parameter._@param constraint The co-location constraint of the vertex. May be null._@param localOnly Flag to indicate if non-local choices are acceptable.__@return A sub-slot for the given vertex, or {@code null}, if no slot is available.;protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex,_													Iterable<TaskManagerLocation> requestedLocations,_													SlotSharingGroupAssignment groupAssignment,_													CoLocationConstraint constraint,_													boolean localOnly)_	{_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)__			_			if (instanceLocalityPair == null) {_				_				return null__			}__			final Instance instanceToUse = instanceLocalityPair.getLeft()__			final Locality locality = instanceLocalityPair.getRight()___			try {_				JobVertexID groupID = vertex.getJobvertexId()__				_				_				SharedSlot sharedSlot = instanceToUse.allocateSharedSlot(groupAssignment)___				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}__				if (sharedSlot != null) {_					_					SimpleSlot slot = constraint == null ?_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, groupID) :_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, constraint)___					if (slot != null) {_						return slot__					}_					else {_						_						sharedSlot.releaseSlot(new FlinkException("Could not allocate sub-slot."))__					}_				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}__			_		}_	};tries,to,allocate,a,new,slot,for,a,vertex,that,is,part,of,a,slot,sharing,group,if,one,of,the,instances,has,a,slot,available,the,method,will,allocate,it,as,a,shared,slot,add,that,shared,slot,to,the,sharing,group,and,allocate,a,simple,slot,from,that,shared,slot,p,this,method,will,try,to,allocate,a,slot,from,one,of,the,local,instances,and,fall,back,to,non,local,instances,if,permitted,p,param,vertex,the,vertex,to,allocate,the,slot,for,param,requested,locations,the,locations,that,are,considered,local,may,be,null,or,empty,if,the,vertex,has,no,location,preferences,param,group,assignment,the,slot,sharing,group,of,the,vertex,mandatory,parameter,param,constraint,the,co,location,constraint,of,the,vertex,may,be,null,param,local,only,flag,to,indicate,if,non,local,choices,are,acceptable,return,a,sub,slot,for,the,given,vertex,or,code,null,if,no,slot,is,available;protected,simple,slot,get,new,slot,for,sharing,group,execution,vertex,vertex,iterable,task,manager,location,requested,locations,slot,sharing,group,assignment,group,assignment,co,location,constraint,constraint,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,final,instance,instance,to,use,instance,locality,pair,get,left,final,locality,locality,instance,locality,pair,get,right,try,job,vertex,id,group,id,vertex,get,jobvertex,id,shared,slot,shared,slot,instance,to,use,allocate,shared,slot,group,assignment,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,shared,slot,null,simple,slot,slot,constraint,null,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,group,id,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,constraint,if,slot,null,return,slot,else,shared,slot,release,slot,new,flink,exception,could,not,allocate,sub,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex, 													Iterable<TaskManagerLocation> requestedLocations, 													SlotSharingGroupAssignment groupAssignment, 													CoLocationConstraint constraint, 													boolean localOnly);1543229263;Tries to allocate a new slot for a vertex that is part of a slot sharing group. If one_of the instances has a slot available, the method will allocate it as a shared slot, add that_shared slot to the sharing group, and allocate a simple slot from that shared slot.__<p>This method will try to allocate a slot from one of the local instances, and fall back to_non-local instances, if permitted.</p>__@param vertex The vertex to allocate the slot for._@param requestedLocations The locations that are considered local. May be null or empty, if the_vertex has no location preferences._@param groupAssignment The slot sharing group of the vertex. Mandatory parameter._@param constraint The co-location constraint of the vertex. May be null._@param localOnly Flag to indicate if non-local choices are acceptable.__@return A sub-slot for the given vertex, or {@code null}, if no slot is available.;protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex,_													Iterable<TaskManagerLocation> requestedLocations,_													SlotSharingGroupAssignment groupAssignment,_													CoLocationConstraint constraint,_													boolean localOnly)_	{_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)__			_			if (instanceLocalityPair == null) {_				_				return null__			}__			final Instance instanceToUse = instanceLocalityPair.getLeft()__			final Locality locality = instanceLocalityPair.getRight()___			try {_				JobVertexID groupID = vertex.getJobvertexId()__				_				_				SharedSlot sharedSlot = instanceToUse.allocateSharedSlot(groupAssignment)___				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse)__				}__				if (sharedSlot != null) {_					_					SimpleSlot slot = constraint == null ?_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, groupID) :_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, constraint)___					if (slot != null) {_						return slot__					}_					else {_						_						sharedSlot.releaseSlot(new FlinkException("Could not allocate sub-slot."))__					}_				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}__			_		}_	};tries,to,allocate,a,new,slot,for,a,vertex,that,is,part,of,a,slot,sharing,group,if,one,of,the,instances,has,a,slot,available,the,method,will,allocate,it,as,a,shared,slot,add,that,shared,slot,to,the,sharing,group,and,allocate,a,simple,slot,from,that,shared,slot,p,this,method,will,try,to,allocate,a,slot,from,one,of,the,local,instances,and,fall,back,to,non,local,instances,if,permitted,p,param,vertex,the,vertex,to,allocate,the,slot,for,param,requested,locations,the,locations,that,are,considered,local,may,be,null,or,empty,if,the,vertex,has,no,location,preferences,param,group,assignment,the,slot,sharing,group,of,the,vertex,mandatory,parameter,param,constraint,the,co,location,constraint,of,the,vertex,may,be,null,param,local,only,flag,to,indicate,if,non,local,choices,are,acceptable,return,a,sub,slot,for,the,given,vertex,or,code,null,if,no,slot,is,available;protected,simple,slot,get,new,slot,for,sharing,group,execution,vertex,vertex,iterable,task,manager,location,requested,locations,slot,sharing,group,assignment,group,assignment,co,location,constraint,constraint,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,final,instance,instance,to,use,instance,locality,pair,get,left,final,locality,locality,instance,locality,pair,get,right,try,job,vertex,id,group,id,vertex,get,jobvertex,id,shared,slot,shared,slot,instance,to,use,allocate,shared,slot,group,assignment,if,instance,to,use,has,resources,available,this,instances,with,available,resources,put,instance,to,use,get,task,manager,id,instance,to,use,if,shared,slot,null,simple,slot,slot,constraint,null,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,group,id,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,constraint,if,slot,null,return,slot,else,shared,slot,release,slot,new,flink,exception,could,not,allocate,sub,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected AllocatedSlot getFreeSlotForTask(ExecutionVertex vertex);1410722608;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected AllocatedSlot getFreeSlotForTask(ExecutionVertex vertex) {_		_		_		_		while (true) {_			if (this.instancesWithAvailableResources.isEmpty()) {_				return null__			}_			_			Iterable<Instance> locationsIterable = vertex.getPreferredLocations()__			Iterator<Instance> locations = locationsIterable == null ? null : locationsIterable.iterator()__			_			Instance instanceToUse = null__			Locality locality = Locality.UNCONSTRAINED__			_			if (locations != null && locations.hasNext()) {_				_				_				while (locations.hasNext()) {_					Instance location = locations.next()__					_					if (location != null && this.instancesWithAvailableResources.remove(location)) {_						instanceToUse = location__						locality = Locality.LOCAL__						_						if (LOG.isDebugEnabled()) {_							LOG.debug("Local assignment: " + vertex.getSimpleName() + " --> " + location)__						}_						_						break__					}_				}_				_				if (instanceToUse == null) {					_					instanceToUse = this.instancesWithAvailableResources.poll()__					locality = Locality.NON_LOCAL__					if (LOG.isDebugEnabled()) {_						LOG.debug("Non-local assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__					}_				}_			}_			else {_				instanceToUse = this.instancesWithAvailableResources.poll()__				if (LOG.isDebugEnabled()) {_					LOG.debug("Unconstrained assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__				}_			}_			_			try {_				AllocatedSlot slot = instanceToUse.allocateSlot(vertex.getJobId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.add(instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				this.allInstances.remove(instanceToUse)__				this.instancesWithAvailableResources.remove(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,allocated,slot,get,free,slot,for,task,execution,vertex,vertex,while,true,if,this,instances,with,available,resources,is,empty,return,null,iterable,instance,locations,iterable,vertex,get,preferred,locations,iterator,instance,locations,locations,iterable,null,null,locations,iterable,iterator,instance,instance,to,use,null,locality,locality,locality,unconstrained,if,locations,null,locations,has,next,while,locations,has,next,instance,location,locations,next,if,location,null,this,instances,with,available,resources,remove,location,instance,to,use,location,locality,locality,local,if,log,is,debug,enabled,log,debug,local,assignment,vertex,get,simple,name,location,break,if,instance,to,use,null,instance,to,use,this,instances,with,available,resources,poll,locality,locality,if,log,is,debug,enabled,log,debug,non,local,assignment,vertex,get,simple,name,instance,to,use,else,instance,to,use,this,instances,with,available,resources,poll,if,log,is,debug,enabled,log,debug,unconstrained,assignment,vertex,get,simple,name,instance,to,use,try,allocated,slot,slot,instance,to,use,allocate,slot,vertex,get,job,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,add,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,this,all,instances,remove,instance,to,use,this,instances,with,available,resources,remove,instance,to,use
Scheduler -> protected AllocatedSlot getFreeSlotForTask(ExecutionVertex vertex);1410734340;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected AllocatedSlot getFreeSlotForTask(ExecutionVertex vertex) {_		_		_		_		while (true) {_			if (this.instancesWithAvailableResources.isEmpty()) {_				return null__			}_			_			Iterable<Instance> locationsIterable = vertex.getPreferredLocations()__			Iterator<Instance> locations = locationsIterable == null ? null : locationsIterable.iterator()__			_			Instance instanceToUse = null__			Locality locality = Locality.UNCONSTRAINED__			_			if (locations != null && locations.hasNext()) {_				_				_				while (locations.hasNext()) {_					Instance location = locations.next()__					_					if (location != null && this.instancesWithAvailableResources.remove(location)) {_						instanceToUse = location__						locality = Locality.LOCAL__						_						if (LOG.isDebugEnabled()) {_							LOG.debug("Local assignment: " + vertex.getSimpleName() + " --> " + location)__						}_						_						break__					}_				}_				_				if (instanceToUse == null) {_					instanceToUse = this.instancesWithAvailableResources.poll()__					locality = Locality.NON_LOCAL__					if (LOG.isDebugEnabled()) {_						LOG.debug("Non-local assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__					}_				}_			}_			else {_				instanceToUse = this.instancesWithAvailableResources.poll()__				if (LOG.isDebugEnabled()) {_					LOG.debug("Unconstrained assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__				}_			}_			_			try {_				AllocatedSlot slot = instanceToUse.allocateSlot(vertex.getJobId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.add(instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				this.allInstances.remove(instanceToUse)__				this.instancesWithAvailableResources.remove(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,allocated,slot,get,free,slot,for,task,execution,vertex,vertex,while,true,if,this,instances,with,available,resources,is,empty,return,null,iterable,instance,locations,iterable,vertex,get,preferred,locations,iterator,instance,locations,locations,iterable,null,null,locations,iterable,iterator,instance,instance,to,use,null,locality,locality,locality,unconstrained,if,locations,null,locations,has,next,while,locations,has,next,instance,location,locations,next,if,location,null,this,instances,with,available,resources,remove,location,instance,to,use,location,locality,locality,local,if,log,is,debug,enabled,log,debug,local,assignment,vertex,get,simple,name,location,break,if,instance,to,use,null,instance,to,use,this,instances,with,available,resources,poll,locality,locality,if,log,is,debug,enabled,log,debug,non,local,assignment,vertex,get,simple,name,instance,to,use,else,instance,to,use,this,instances,with,available,resources,poll,if,log,is,debug,enabled,log,debug,unconstrained,assignment,vertex,get,simple,name,instance,to,use,try,allocated,slot,slot,instance,to,use,allocate,slot,vertex,get,job,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,add,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,this,all,instances,remove,instance,to,use,this,instances,with,available,resources,remove,instance,to,use
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource, Iterable<TaskManagerLocation> preferredLocations) throws NoResourceAvailableException;1508155453;Returns either a {@link SimpleSlot}, or a {@link CompletableFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource, Iterable<TaskManagerLocation> preferredLocations) throws NoResourceAvailableException {_		if (task == null) {_			throw new NullPointerException()__		}_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}__		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__		_		final boolean forceExternalLocation = false &&_									preferredLocations != null && preferredLocations.iterator().hasNext()__	_		synchronized (globalLock) {_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			_			if (sharingUnit != null) {__				_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException(_							"A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				_				if (constraint != null && forceExternalLocation) {_					throw new IllegalArgumentException("The scheduling cannot be constrained simultaneously by a "_							+ "co-location constraint and an external location constraint.")__				}_				_				_				final SimpleSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex.getJobvertexId(), preferredLocations)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(constraint, preferredLocations)__				}__				SimpleSlot newSlot = null__				SimpleSlot toUse = null___				_				try {_					_					_					_					if (slotFromGroup != null && slotFromGroup.getLocality() != Locality.NON_LOCAL) {_						_						_						_						if (constraint != null && !constraint.isAssigned()) {_							constraint.lockLocation()__						}_						_						updateLocalityCounters(slotFromGroup, vertex)__						return slotFromGroup__					}_					_					_					_					_					_					final Iterable<TaskManagerLocation> locations__					final boolean localOnly__					if (constraint != null && constraint.isAssigned()) {_						locations = Collections.singleton(constraint.getLocation())__						localOnly = true__					}_					else {_						locations = preferredLocations__						localOnly = forceExternalLocation__					}_					_					newSlot = getNewSlotForSharingGroup(vertex, locations, assignment, constraint, localOnly)___					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							_							if (constraint != null && constraint.isAssigned()) {_								_								throw new NoResourceAvailableException("Could not allocate a slot on instance " +_										constraint.getLocation() + ", as required by the co-location constraint.")__							}_							else if (forceExternalLocation) {_								_								String hosts = getHostnamesFromInstances(preferredLocations)__								throw new NoResourceAvailableException("Could not schedule task " + vertex_										+ " to any of the required hosts: " + hosts)__							}_							else {_								_								throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(),_										getTotalNumberOfSlots(), getNumberOfAvailableSlots())__							}_						}_						else {_							_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || !slotFromGroup.isAlive() || newSlot.getLocality() == Locality.LOCAL) {_						_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot()__						}_						toUse = newSlot__					}_					else {_						_						_						_						newSlot.releaseSlot()__						toUse = slotFromGroup__					}__					_					_					if (constraint != null && !constraint.isAssigned()) {_						constraint.lockLocation()__					}_					_					updateLocalityCounters(toUse, vertex)__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}__					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}__				return toUse__			}_			else {_				_				_				_				SimpleSlot slot = getFreeSlotForTask(vertex, preferredLocations, forceExternalLocation)__				if (slot != null) {_					updateLocalityCounters(slot, vertex)__					return slot__				}_				else {_					_					if (queueIfNoResource) {_						CompletableFuture<SimpleSlot> future = new CompletableFuture<>()__						this.taskQueue.add(new QueuedTask(task, future))__						return future__					}_					else if (forceExternalLocation) {_						String hosts = getHostnamesFromInstances(preferredLocations)__						throw new NoResourceAvailableException("Could not schedule task " + vertex_								+ " to any of the required hosts: " + hosts)__					}_					else {_						throw new NoResourceAvailableException(getNumberOfAvailableInstances(),_								getTotalNumberOfSlots(), getNumberOfAvailableSlots())__					}_				}_			}_		}_	};returns,either,a,link,simple,slot,or,a,link,completable,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,iterable,task,manager,location,preferred,locations,throws,no,resource,available,exception,if,task,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,final,boolean,force,external,location,false,preferred,locations,null,preferred,locations,iterator,has,next,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,if,constraint,null,force,external,location,throw,new,illegal,argument,exception,the,scheduling,cannot,be,constrained,simultaneously,by,a,co,location,constraint,and,an,external,location,constraint,final,simple,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,get,jobvertex,id,preferred,locations,else,slot,from,group,assignment,get,slot,for,task,constraint,preferred,locations,simple,slot,new,slot,null,simple,slot,to,use,null,try,if,slot,from,group,null,slot,from,group,get,locality,locality,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,slot,from,group,vertex,return,slot,from,group,final,iterable,task,manager,location,locations,final,boolean,local,only,if,constraint,null,constraint,is,assigned,locations,collections,singleton,constraint,get,location,local,only,true,else,locations,preferred,locations,local,only,force,external,location,new,slot,get,new,slot,for,sharing,group,vertex,locations,assignment,constraint,local,only,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,assigned,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots,else,to,use,slot,from,group,else,if,slot,from,group,null,slot,from,group,is,alive,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,to,use,new,slot,else,new,slot,release,slot,to,use,slot,from,group,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,to,use,vertex,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,return,to,use,else,simple,slot,slot,get,free,slot,for,task,vertex,preferred,locations,force,external,location,if,slot,null,update,locality,counters,slot,vertex,return,slot,else,if,queue,if,no,resource,completable,future,simple,slot,future,new,completable,future,this,task,queue,add,new,queued,task,task,future,return,future,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource, Iterable<TaskManagerLocation> preferredLocations) throws NoResourceAvailableException;1509090423;Returns either a {@link SimpleSlot}, or a {@link CompletableFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource, Iterable<TaskManagerLocation> preferredLocations) throws NoResourceAvailableException {_		if (task == null) {_			throw new NullPointerException()__		}_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}__		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__		_		final boolean forceExternalLocation = false &&_									preferredLocations != null && preferredLocations.iterator().hasNext()__	_		synchronized (globalLock) {_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			_			if (sharingUnit != null) {__				_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException(_							"A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				_				if (constraint != null && forceExternalLocation) {_					throw new IllegalArgumentException("The scheduling cannot be constrained simultaneously by a "_							+ "co-location constraint and an external location constraint.")__				}_				_				_				final SimpleSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex.getJobvertexId(), preferredLocations)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(constraint, preferredLocations)__				}__				SimpleSlot newSlot = null__				SimpleSlot toUse = null___				_				try {_					_					_					_					if (slotFromGroup != null && slotFromGroup.getLocality() != Locality.NON_LOCAL) {_						_						_						_						if (constraint != null && !constraint.isAssigned()) {_							constraint.lockLocation()__						}_						_						updateLocalityCounters(slotFromGroup, vertex)__						return slotFromGroup__					}_					_					_					_					_					_					final Iterable<TaskManagerLocation> locations__					final boolean localOnly__					if (constraint != null && constraint.isAssigned()) {_						locations = Collections.singleton(constraint.getLocation())__						localOnly = true__					}_					else {_						locations = preferredLocations__						localOnly = forceExternalLocation__					}_					_					newSlot = getNewSlotForSharingGroup(vertex, locations, assignment, constraint, localOnly)___					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							_							if (constraint != null && constraint.isAssigned()) {_								_								throw new NoResourceAvailableException("Could not allocate a slot on instance " +_										constraint.getLocation() + ", as required by the co-location constraint.")__							}_							else if (forceExternalLocation) {_								_								String hosts = getHostnamesFromInstances(preferredLocations)__								throw new NoResourceAvailableException("Could not schedule task " + vertex_										+ " to any of the required hosts: " + hosts)__							}_							else {_								_								throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(),_										getTotalNumberOfSlots(), getNumberOfAvailableSlots())__							}_						}_						else {_							_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || !slotFromGroup.isAlive() || newSlot.getLocality() == Locality.LOCAL) {_						_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot()__						}_						toUse = newSlot__					}_					else {_						_						_						_						newSlot.releaseSlot()__						toUse = slotFromGroup__					}__					_					_					if (constraint != null && !constraint.isAssigned()) {_						constraint.lockLocation()__					}_					_					updateLocalityCounters(toUse, vertex)__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}__					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}__				return toUse__			}_			else {_				_				_				_				SimpleSlot slot = getFreeSlotForTask(vertex, preferredLocations, forceExternalLocation)__				if (slot != null) {_					updateLocalityCounters(slot, vertex)__					return slot__				}_				else {_					_					if (queueIfNoResource) {_						CompletableFuture<SimpleSlot> future = new CompletableFuture<>()__						this.taskQueue.add(new QueuedTask(task, future))__						return future__					}_					else if (forceExternalLocation) {_						String hosts = getHostnamesFromInstances(preferredLocations)__						throw new NoResourceAvailableException("Could not schedule task " + vertex_								+ " to any of the required hosts: " + hosts)__					}_					else {_						throw new NoResourceAvailableException(getNumberOfAvailableInstances(),_								getTotalNumberOfSlots(), getNumberOfAvailableSlots())__					}_				}_			}_		}_	};returns,either,a,link,simple,slot,or,a,link,completable,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,iterable,task,manager,location,preferred,locations,throws,no,resource,available,exception,if,task,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,final,boolean,force,external,location,false,preferred,locations,null,preferred,locations,iterator,has,next,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,if,constraint,null,force,external,location,throw,new,illegal,argument,exception,the,scheduling,cannot,be,constrained,simultaneously,by,a,co,location,constraint,and,an,external,location,constraint,final,simple,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,get,jobvertex,id,preferred,locations,else,slot,from,group,assignment,get,slot,for,task,constraint,preferred,locations,simple,slot,new,slot,null,simple,slot,to,use,null,try,if,slot,from,group,null,slot,from,group,get,locality,locality,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,slot,from,group,vertex,return,slot,from,group,final,iterable,task,manager,location,locations,final,boolean,local,only,if,constraint,null,constraint,is,assigned,locations,collections,singleton,constraint,get,location,local,only,true,else,locations,preferred,locations,local,only,force,external,location,new,slot,get,new,slot,for,sharing,group,vertex,locations,assignment,constraint,local,only,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,assigned,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots,else,to,use,slot,from,group,else,if,slot,from,group,null,slot,from,group,is,alive,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,to,use,new,slot,else,new,slot,release,slot,to,use,slot,from,group,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,to,use,vertex,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,return,to,use,else,simple,slot,slot,get,free,slot,for,task,vertex,preferred,locations,force,external,location,if,slot,null,update,locality,counters,slot,vertex,return,slot,else,if,queue,if,no,resource,completable,future,simple,slot,future,new,completable,future,this,task,queue,add,new,queued,task,task,future,return,future,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource, Iterable<TaskManagerLocation> preferredLocations) throws NoResourceAvailableException;1510699852;Returns either a {@link SimpleSlot}, or a {@link CompletableFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource, Iterable<TaskManagerLocation> preferredLocations) throws NoResourceAvailableException {_		if (task == null) {_			throw new NullPointerException()__		}_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}__		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__		_		final boolean forceExternalLocation = false &&_									preferredLocations != null && preferredLocations.iterator().hasNext()__	_		synchronized (globalLock) {_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			_			if (sharingUnit != null) {__				_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException(_							"A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				_				if (constraint != null && forceExternalLocation) {_					throw new IllegalArgumentException("The scheduling cannot be constrained simultaneously by a "_							+ "co-location constraint and an external location constraint.")__				}_				_				_				final SimpleSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex.getJobvertexId(), preferredLocations)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(constraint, preferredLocations)__				}__				SimpleSlot newSlot = null__				SimpleSlot toUse = null___				_				try {_					_					_					_					if (slotFromGroup != null && slotFromGroup.getLocality() != Locality.NON_LOCAL) {_						_						_						_						if (constraint != null && !constraint.isAssigned()) {_							constraint.lockLocation()__						}_						_						updateLocalityCounters(slotFromGroup, vertex)__						return slotFromGroup__					}_					_					_					_					_					_					final Iterable<TaskManagerLocation> locations__					final boolean localOnly__					if (constraint != null && constraint.isAssigned()) {_						locations = Collections.singleton(constraint.getLocation())__						localOnly = true__					}_					else {_						locations = preferredLocations__						localOnly = forceExternalLocation__					}_					_					newSlot = getNewSlotForSharingGroup(vertex, locations, assignment, constraint, localOnly)___					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							_							if (constraint != null && constraint.isAssigned()) {_								_								throw new NoResourceAvailableException("Could not allocate a slot on instance " +_										constraint.getLocation() + ", as required by the co-location constraint.")__							}_							else if (forceExternalLocation) {_								_								String hosts = getHostnamesFromInstances(preferredLocations)__								throw new NoResourceAvailableException("Could not schedule task " + vertex_										+ " to any of the required hosts: " + hosts)__							}_							else {_								_								throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(),_										getTotalNumberOfSlots(), getNumberOfAvailableSlots())__							}_						}_						else {_							_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || !slotFromGroup.isAlive() || newSlot.getLocality() == Locality.LOCAL) {_						_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot()__						}_						toUse = newSlot__					}_					else {_						_						_						_						newSlot.releaseSlot()__						toUse = slotFromGroup__					}__					_					_					if (constraint != null && !constraint.isAssigned()) {_						constraint.lockLocation()__					}_					_					updateLocalityCounters(toUse, vertex)__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot()__					}_					if (newSlot != null) {_						newSlot.releaseSlot()__					}__					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}__				return toUse__			}_			else {_				_				_				_				SimpleSlot slot = getFreeSlotForTask(vertex, preferredLocations, forceExternalLocation)__				if (slot != null) {_					updateLocalityCounters(slot, vertex)__					return slot__				}_				else {_					_					if (queueIfNoResource) {_						CompletableFuture<LogicalSlot> future = new CompletableFuture<>()__						this.taskQueue.add(new QueuedTask(task, future))__						return future__					}_					else if (forceExternalLocation) {_						String hosts = getHostnamesFromInstances(preferredLocations)__						throw new NoResourceAvailableException("Could not schedule task " + vertex_								+ " to any of the required hosts: " + hosts)__					}_					else {_						throw new NoResourceAvailableException(getNumberOfAvailableInstances(),_								getTotalNumberOfSlots(), getNumberOfAvailableSlots())__					}_				}_			}_		}_	};returns,either,a,link,simple,slot,or,a,link,completable,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,iterable,task,manager,location,preferred,locations,throws,no,resource,available,exception,if,task,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,final,boolean,force,external,location,false,preferred,locations,null,preferred,locations,iterator,has,next,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,if,constraint,null,force,external,location,throw,new,illegal,argument,exception,the,scheduling,cannot,be,constrained,simultaneously,by,a,co,location,constraint,and,an,external,location,constraint,final,simple,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,get,jobvertex,id,preferred,locations,else,slot,from,group,assignment,get,slot,for,task,constraint,preferred,locations,simple,slot,new,slot,null,simple,slot,to,use,null,try,if,slot,from,group,null,slot,from,group,get,locality,locality,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,slot,from,group,vertex,return,slot,from,group,final,iterable,task,manager,location,locations,final,boolean,local,only,if,constraint,null,constraint,is,assigned,locations,collections,singleton,constraint,get,location,local,only,true,else,locations,preferred,locations,local,only,force,external,location,new,slot,get,new,slot,for,sharing,group,vertex,locations,assignment,constraint,local,only,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,assigned,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots,else,to,use,slot,from,group,else,if,slot,from,group,null,slot,from,group,is,alive,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,to,use,new,slot,else,new,slot,release,slot,to,use,slot,from,group,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,to,use,vertex,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,if,new,slot,null,new,slot,release,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,return,to,use,else,simple,slot,slot,get,free,slot,for,task,vertex,preferred,locations,force,external,location,if,slot,null,update,locality,counters,slot,vertex,return,slot,else,if,queue,if,no,resource,completable,future,logical,slot,future,new,completable,future,this,task,queue,add,new,queued,task,task,future,return,future,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource, Iterable<TaskManagerLocation> preferredLocations) throws NoResourceAvailableException;1510752027;Returns either a {@link SimpleSlot}, or a {@link CompletableFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource, Iterable<TaskManagerLocation> preferredLocations) throws NoResourceAvailableException {_		if (task == null) {_			throw new NullPointerException()__		}_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}__		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__		_		final boolean forceExternalLocation = false &&_									preferredLocations != null && preferredLocations.iterator().hasNext()__	_		synchronized (globalLock) {_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			_			if (sharingUnit != null) {__				_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException(_							"A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				_				if (constraint != null && forceExternalLocation) {_					throw new IllegalArgumentException("The scheduling cannot be constrained simultaneously by a "_							+ "co-location constraint and an external location constraint.")__				}_				_				_				final SimpleSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex.getJobvertexId(), preferredLocations)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(constraint, preferredLocations)__				}__				SimpleSlot newSlot = null__				SimpleSlot toUse = null___				_				try {_					_					_					_					if (slotFromGroup != null && slotFromGroup.getLocality() != Locality.NON_LOCAL) {_						_						_						_						if (constraint != null && !constraint.isAssigned()) {_							constraint.lockLocation()__						}_						_						updateLocalityCounters(slotFromGroup, vertex)__						return slotFromGroup__					}_					_					_					_					_					_					final Iterable<TaskManagerLocation> locations__					final boolean localOnly__					if (constraint != null && constraint.isAssigned()) {_						locations = Collections.singleton(constraint.getLocation())__						localOnly = true__					}_					else {_						locations = preferredLocations__						localOnly = forceExternalLocation__					}_					_					newSlot = getNewSlotForSharingGroup(vertex, locations, assignment, constraint, localOnly)___					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							_							if (constraint != null && constraint.isAssigned()) {_								_								throw new NoResourceAvailableException("Could not allocate a slot on instance " +_										constraint.getLocation() + ", as required by the co-location constraint.")__							}_							else if (forceExternalLocation) {_								_								String hosts = getHostnamesFromInstances(preferredLocations)__								throw new NoResourceAvailableException("Could not schedule task " + vertex_										+ " to any of the required hosts: " + hosts)__							}_							else {_								_								throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(),_										getTotalNumberOfSlots(), getNumberOfAvailableSlots())__							}_						}_						else {_							_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || !slotFromGroup.isAlive() || newSlot.getLocality() == Locality.LOCAL) {_						_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseInstanceSlot()__						}_						toUse = newSlot__					}_					else {_						_						_						_						newSlot.releaseInstanceSlot()__						toUse = slotFromGroup__					}__					_					_					if (constraint != null && !constraint.isAssigned()) {_						constraint.lockLocation()__					}_					_					updateLocalityCounters(toUse, vertex)__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseInstanceSlot()__					}_					if (newSlot != null) {_						newSlot.releaseInstanceSlot()__					}__					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}__				return toUse__			}_			else {_				_				_				_				SimpleSlot slot = getFreeSlotForTask(vertex, preferredLocations, forceExternalLocation)__				if (slot != null) {_					updateLocalityCounters(slot, vertex)__					return slot__				}_				else {_					_					if (queueIfNoResource) {_						CompletableFuture<LogicalSlot> future = new CompletableFuture<>()__						this.taskQueue.add(new QueuedTask(task, future))__						return future__					}_					else if (forceExternalLocation) {_						String hosts = getHostnamesFromInstances(preferredLocations)__						throw new NoResourceAvailableException("Could not schedule task " + vertex_								+ " to any of the required hosts: " + hosts)__					}_					else {_						throw new NoResourceAvailableException(getNumberOfAvailableInstances(),_								getTotalNumberOfSlots(), getNumberOfAvailableSlots())__					}_				}_			}_		}_	};returns,either,a,link,simple,slot,or,a,link,completable,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,iterable,task,manager,location,preferred,locations,throws,no,resource,available,exception,if,task,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,final,boolean,force,external,location,false,preferred,locations,null,preferred,locations,iterator,has,next,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,if,constraint,null,force,external,location,throw,new,illegal,argument,exception,the,scheduling,cannot,be,constrained,simultaneously,by,a,co,location,constraint,and,an,external,location,constraint,final,simple,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,get,jobvertex,id,preferred,locations,else,slot,from,group,assignment,get,slot,for,task,constraint,preferred,locations,simple,slot,new,slot,null,simple,slot,to,use,null,try,if,slot,from,group,null,slot,from,group,get,locality,locality,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,slot,from,group,vertex,return,slot,from,group,final,iterable,task,manager,location,locations,final,boolean,local,only,if,constraint,null,constraint,is,assigned,locations,collections,singleton,constraint,get,location,local,only,true,else,locations,preferred,locations,local,only,force,external,location,new,slot,get,new,slot,for,sharing,group,vertex,locations,assignment,constraint,local,only,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,assigned,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots,else,to,use,slot,from,group,else,if,slot,from,group,null,slot,from,group,is,alive,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,instance,slot,to,use,new,slot,else,new,slot,release,instance,slot,to,use,slot,from,group,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,to,use,vertex,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,instance,slot,if,new,slot,null,new,slot,release,instance,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,return,to,use,else,simple,slot,slot,get,free,slot,for,task,vertex,preferred,locations,force,external,location,if,slot,null,update,locality,counters,slot,vertex,return,slot,else,if,queue,if,no,resource,completable,future,logical,slot,future,new,completable,future,this,task,queue,add,new,queued,task,task,future,return,future,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource, Iterable<TaskManagerLocation> preferredLocations) throws NoResourceAvailableException;1511543029;Returns either a {@link SimpleSlot}, or a {@link CompletableFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource, Iterable<TaskManagerLocation> preferredLocations) throws NoResourceAvailableException {_		if (task == null) {_			throw new NullPointerException()__		}_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}__		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__		_		final boolean forceExternalLocation = false &&_									preferredLocations != null && preferredLocations.iterator().hasNext()__	_		synchronized (globalLock) {_			_			SlotSharingGroup sharingUnit = task.getSlotSharingGroup()__			_			if (sharingUnit != null) {__				_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException(_							"A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getLocationConstraint()__				_				_				if (constraint != null && forceExternalLocation) {_					throw new IllegalArgumentException("The scheduling cannot be constrained simultaneously by a "_							+ "co-location constraint and an external location constraint.")__				}_				_				_				final SimpleSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex.getJobvertexId(), preferredLocations)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(constraint, preferredLocations)__				}__				SimpleSlot newSlot = null__				SimpleSlot toUse = null___				_				try {_					_					_					_					if (slotFromGroup != null && slotFromGroup.getLocality() != Locality.NON_LOCAL) {_						_						_						_						if (constraint != null && !constraint.isAssigned()) {_							constraint.lockLocation()__						}_						_						updateLocalityCounters(slotFromGroup, vertex)__						return slotFromGroup__					}_					_					_					_					_					_					final Iterable<TaskManagerLocation> locations__					final boolean localOnly__					if (constraint != null && constraint.isAssigned()) {_						locations = Collections.singleton(constraint.getLocation())__						localOnly = true__					}_					else {_						locations = preferredLocations__						localOnly = forceExternalLocation__					}_					_					newSlot = getNewSlotForSharingGroup(vertex, locations, assignment, constraint, localOnly)___					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							_							if (constraint != null && constraint.isAssigned()) {_								_								throw new NoResourceAvailableException("Could not allocate a slot on instance " +_										constraint.getLocation() + ", as required by the co-location constraint.")__							}_							else if (forceExternalLocation) {_								_								String hosts = getHostnamesFromInstances(preferredLocations)__								throw new NoResourceAvailableException("Could not schedule task " + vertex_										+ " to any of the required hosts: " + hosts)__							}_							else {_								_								throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(),_										getTotalNumberOfSlots(), getNumberOfAvailableSlots())__							}_						}_						else {_							_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || !slotFromGroup.isAlive() || newSlot.getLocality() == Locality.LOCAL) {_						_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseInstanceSlot()__						}_						toUse = newSlot__					}_					else {_						_						_						_						newSlot.releaseInstanceSlot()__						toUse = slotFromGroup__					}__					_					_					if (constraint != null && !constraint.isAssigned()) {_						constraint.lockLocation()__					}_					_					updateLocalityCounters(toUse, vertex)__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseInstanceSlot()__					}_					if (newSlot != null) {_						newSlot.releaseInstanceSlot()__					}__					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}__				return toUse__			}_			else {_				_				_				_				SimpleSlot slot = getFreeSlotForTask(vertex, preferredLocations, forceExternalLocation)__				if (slot != null) {_					updateLocalityCounters(slot, vertex)__					return slot__				}_				else {_					_					if (queueIfNoResource) {_						CompletableFuture<LogicalSlot> future = new CompletableFuture<>()__						this.taskQueue.add(new QueuedTask(task, future))__						return future__					}_					else if (forceExternalLocation) {_						String hosts = getHostnamesFromInstances(preferredLocations)__						throw new NoResourceAvailableException("Could not schedule task " + vertex_								+ " to any of the required hosts: " + hosts)__					}_					else {_						throw new NoResourceAvailableException(getNumberOfAvailableInstances(),_								getTotalNumberOfSlots(), getNumberOfAvailableSlots())__					}_				}_			}_		}_	};returns,either,a,link,simple,slot,or,a,link,completable,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,iterable,task,manager,location,preferred,locations,throws,no,resource,available,exception,if,task,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,final,boolean,force,external,location,false,preferred,locations,null,preferred,locations,iterator,has,next,synchronized,global,lock,slot,sharing,group,sharing,unit,task,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,location,constraint,if,constraint,null,force,external,location,throw,new,illegal,argument,exception,the,scheduling,cannot,be,constrained,simultaneously,by,a,co,location,constraint,and,an,external,location,constraint,final,simple,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,get,jobvertex,id,preferred,locations,else,slot,from,group,assignment,get,slot,for,task,constraint,preferred,locations,simple,slot,new,slot,null,simple,slot,to,use,null,try,if,slot,from,group,null,slot,from,group,get,locality,locality,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,slot,from,group,vertex,return,slot,from,group,final,iterable,task,manager,location,locations,final,boolean,local,only,if,constraint,null,constraint,is,assigned,locations,collections,singleton,constraint,get,location,local,only,true,else,locations,preferred,locations,local,only,force,external,location,new,slot,get,new,slot,for,sharing,group,vertex,locations,assignment,constraint,local,only,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,assigned,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots,else,to,use,slot,from,group,else,if,slot,from,group,null,slot,from,group,is,alive,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,instance,slot,to,use,new,slot,else,new,slot,release,instance,slot,to,use,slot,from,group,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,to,use,vertex,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,instance,slot,if,new,slot,null,new,slot,release,instance,slot,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,return,to,use,else,simple,slot,slot,get,free,slot,for,task,vertex,preferred,locations,force,external,location,if,slot,null,update,locality,counters,slot,vertex,return,slot,else,if,queue,if,no,resource,completable,future,logical,slot,future,new,completable,future,this,task,queue,add,new,queued,task,task,future,return,future,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource, Iterable<TaskManagerLocation> preferredLocations) throws NoResourceAvailableException;1513261475;Returns either a {@link SimpleSlot}, or a {@link CompletableFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource, Iterable<TaskManagerLocation> preferredLocations) throws NoResourceAvailableException {_		if (task == null) {_			throw new NullPointerException()__		}_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}__		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__		_		final boolean forceExternalLocation = false &&_									preferredLocations != null && preferredLocations.iterator().hasNext()__	_		synchronized (globalLock) {_			_			SlotSharingGroup sharingUnit = vertex.getJobVertex().getSlotSharingGroup()__			_			if (sharingUnit != null) {__				_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException(_							"A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getCoLocationConstraint()__				_				_				if (constraint != null && forceExternalLocation) {_					throw new IllegalArgumentException("The scheduling cannot be constrained simultaneously by a "_							+ "co-location constraint and an external location constraint.")__				}_				_				_				final SimpleSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex.getJobvertexId(), preferredLocations)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(constraint, preferredLocations)__				}__				SimpleSlot newSlot = null__				SimpleSlot toUse = null___				_				try {_					_					_					_					if (slotFromGroup != null && slotFromGroup.getLocality() != Locality.NON_LOCAL) {_						_						_						_						if (constraint != null && !constraint.isAssigned()) {_							constraint.lockLocation()__						}_						_						updateLocalityCounters(slotFromGroup, vertex)__						return slotFromGroup__					}_					_					_					_					_					_					final Iterable<TaskManagerLocation> locations__					final boolean localOnly__					if (constraint != null && constraint.isAssigned()) {_						locations = Collections.singleton(constraint.getLocation())__						localOnly = true__					}_					else {_						locations = preferredLocations__						localOnly = forceExternalLocation__					}_					_					newSlot = getNewSlotForSharingGroup(vertex, locations, assignment, constraint, localOnly)___					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							_							if (constraint != null && constraint.isAssigned()) {_								_								throw new NoResourceAvailableException("Could not allocate a slot on instance " +_										constraint.getLocation() + ", as required by the co-location constraint.")__							}_							else if (forceExternalLocation) {_								_								String hosts = getHostnamesFromInstances(preferredLocations)__								throw new NoResourceAvailableException("Could not schedule task " + vertex_										+ " to any of the required hosts: " + hosts)__							}_							else {_								_								throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(),_										getTotalNumberOfSlots(), getNumberOfAvailableSlots())__							}_						}_						else {_							_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || !slotFromGroup.isAlive() || newSlot.getLocality() == Locality.LOCAL) {_						_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot(null)__						}_						toUse = newSlot__					}_					else {_						_						_						_						newSlot.releaseSlot(null)__						toUse = slotFromGroup__					}__					_					_					if (constraint != null && !constraint.isAssigned()) {_						constraint.lockLocation()__					}_					_					updateLocalityCounters(toUse, vertex)__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot(t)__					}_					if (newSlot != null) {_						newSlot.releaseSlot(t)__					}__					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}__				return toUse__			}_			else {_				_				_				_				SimpleSlot slot = getFreeSlotForTask(vertex, preferredLocations, forceExternalLocation)__				if (slot != null) {_					updateLocalityCounters(slot, vertex)__					return slot__				}_				else {_					_					if (queueIfNoResource) {_						CompletableFuture<LogicalSlot> future = new CompletableFuture<>()__						this.taskQueue.add(new QueuedTask(task, future))__						return future__					}_					else if (forceExternalLocation) {_						String hosts = getHostnamesFromInstances(preferredLocations)__						throw new NoResourceAvailableException("Could not schedule task " + vertex_								+ " to any of the required hosts: " + hosts)__					}_					else {_						throw new NoResourceAvailableException(getNumberOfAvailableInstances(),_								getTotalNumberOfSlots(), getNumberOfAvailableSlots())__					}_				}_			}_		}_	};returns,either,a,link,simple,slot,or,a,link,completable,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,iterable,task,manager,location,preferred,locations,throws,no,resource,available,exception,if,task,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,final,boolean,force,external,location,false,preferred,locations,null,preferred,locations,iterator,has,next,synchronized,global,lock,slot,sharing,group,sharing,unit,vertex,get,job,vertex,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,co,location,constraint,if,constraint,null,force,external,location,throw,new,illegal,argument,exception,the,scheduling,cannot,be,constrained,simultaneously,by,a,co,location,constraint,and,an,external,location,constraint,final,simple,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,get,jobvertex,id,preferred,locations,else,slot,from,group,assignment,get,slot,for,task,constraint,preferred,locations,simple,slot,new,slot,null,simple,slot,to,use,null,try,if,slot,from,group,null,slot,from,group,get,locality,locality,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,slot,from,group,vertex,return,slot,from,group,final,iterable,task,manager,location,locations,final,boolean,local,only,if,constraint,null,constraint,is,assigned,locations,collections,singleton,constraint,get,location,local,only,true,else,locations,preferred,locations,local,only,force,external,location,new,slot,get,new,slot,for,sharing,group,vertex,locations,assignment,constraint,local,only,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,assigned,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots,else,to,use,slot,from,group,else,if,slot,from,group,null,slot,from,group,is,alive,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,null,to,use,new,slot,else,new,slot,release,slot,null,to,use,slot,from,group,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,to,use,vertex,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,t,if,new,slot,null,new,slot,release,slot,t,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,return,to,use,else,simple,slot,slot,get,free,slot,for,task,vertex,preferred,locations,force,external,location,if,slot,null,update,locality,counters,slot,vertex,return,slot,else,if,queue,if,no,resource,completable,future,logical,slot,future,new,completable,future,this,task,queue,add,new,queued,task,task,future,return,future,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource, Iterable<TaskManagerLocation> preferredLocations) throws NoResourceAvailableException;1517497348;Returns either a {@link SimpleSlot}, or a {@link CompletableFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource, Iterable<TaskManagerLocation> preferredLocations) throws NoResourceAvailableException {_		if (task == null) {_			throw new NullPointerException()__		}_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}__		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__		_		final boolean forceExternalLocation = false &&_									preferredLocations != null && preferredLocations.iterator().hasNext()__	_		synchronized (globalLock) {_			_			SlotSharingGroup sharingUnit = vertex.getJobVertex().getSlotSharingGroup()__			_			if (sharingUnit != null) {__				_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException(_							"A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getCoLocationConstraint()__				_				_				if (constraint != null && forceExternalLocation) {_					throw new IllegalArgumentException("The scheduling cannot be constrained simultaneously by a "_							+ "co-location constraint and an external location constraint.")__				}_				_				_				final SimpleSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex.getJobvertexId(), preferredLocations)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(constraint, preferredLocations)__				}__				SimpleSlot newSlot = null__				SimpleSlot toUse = null___				_				try {_					_					_					_					if (slotFromGroup != null && slotFromGroup.getLocality() != Locality.NON_LOCAL) {_						_						_						_						if (constraint != null && !constraint.isAssigned()) {_							constraint.lockLocation()__						}_						_						updateLocalityCounters(slotFromGroup, vertex)__						return slotFromGroup__					}_					_					_					_					_					_					final Iterable<TaskManagerLocation> locations__					final boolean localOnly__					if (constraint != null && constraint.isAssigned()) {_						locations = Collections.singleton(constraint.getLocation())__						localOnly = true__					}_					else {_						locations = preferredLocations__						localOnly = forceExternalLocation__					}_					_					newSlot = getNewSlotForSharingGroup(vertex, locations, assignment, constraint, localOnly)___					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							_							if (constraint != null && constraint.isAssigned()) {_								_								throw new NoResourceAvailableException("Could not allocate a slot on instance " +_										constraint.getLocation() + ", as required by the co-location constraint.")__							}_							else if (forceExternalLocation) {_								_								String hosts = getHostnamesFromInstances(preferredLocations)__								throw new NoResourceAvailableException("Could not schedule task " + vertex_										+ " to any of the required hosts: " + hosts)__							}_							else {_								_								throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(),_										getTotalNumberOfSlots(), getNumberOfAvailableSlots())__							}_						}_						else {_							_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || !slotFromGroup.isAlive() || newSlot.getLocality() == Locality.LOCAL) {_						_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot(null)__						}_						toUse = newSlot__					}_					else {_						_						_						_						newSlot.releaseSlot(null)__						toUse = slotFromGroup__					}__					_					_					if (constraint != null && !constraint.isAssigned()) {_						constraint.lockLocation()__					}_					_					updateLocalityCounters(toUse, vertex)__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot(t)__					}_					if (newSlot != null) {_						newSlot.releaseSlot(t)__					}__					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}__				return toUse__			}_			else {_				_				_				_				SimpleSlot slot = getFreeSlotForTask(vertex, preferredLocations, forceExternalLocation)__				if (slot != null) {_					updateLocalityCounters(slot, vertex)__					return slot__				}_				else {_					_					if (queueIfNoResource) {_						CompletableFuture<LogicalSlot> future = new CompletableFuture<>()__						this.taskQueue.add(new QueuedTask(task, future))__						return future__					}_					else if (forceExternalLocation) {_						String hosts = getHostnamesFromInstances(preferredLocations)__						throw new NoResourceAvailableException("Could not schedule task " + vertex_								+ " to any of the required hosts: " + hosts)__					}_					else {_						throw new NoResourceAvailableException(getNumberOfAvailableInstances(),_								getTotalNumberOfSlots(), getNumberOfAvailableSlots())__					}_				}_			}_		}_	};returns,either,a,link,simple,slot,or,a,link,completable,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,iterable,task,manager,location,preferred,locations,throws,no,resource,available,exception,if,task,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,final,boolean,force,external,location,false,preferred,locations,null,preferred,locations,iterator,has,next,synchronized,global,lock,slot,sharing,group,sharing,unit,vertex,get,job,vertex,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,co,location,constraint,if,constraint,null,force,external,location,throw,new,illegal,argument,exception,the,scheduling,cannot,be,constrained,simultaneously,by,a,co,location,constraint,and,an,external,location,constraint,final,simple,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,get,jobvertex,id,preferred,locations,else,slot,from,group,assignment,get,slot,for,task,constraint,preferred,locations,simple,slot,new,slot,null,simple,slot,to,use,null,try,if,slot,from,group,null,slot,from,group,get,locality,locality,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,slot,from,group,vertex,return,slot,from,group,final,iterable,task,manager,location,locations,final,boolean,local,only,if,constraint,null,constraint,is,assigned,locations,collections,singleton,constraint,get,location,local,only,true,else,locations,preferred,locations,local,only,force,external,location,new,slot,get,new,slot,for,sharing,group,vertex,locations,assignment,constraint,local,only,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,assigned,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots,else,to,use,slot,from,group,else,if,slot,from,group,null,slot,from,group,is,alive,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,null,to,use,new,slot,else,new,slot,release,slot,null,to,use,slot,from,group,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,to,use,vertex,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,t,if,new,slot,null,new,slot,release,slot,t,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,return,to,use,else,simple,slot,slot,get,free,slot,for,task,vertex,preferred,locations,force,external,location,if,slot,null,update,locality,counters,slot,vertex,return,slot,else,if,queue,if,no,resource,completable,future,logical,slot,future,new,completable,future,this,task,queue,add,new,queued,task,task,future,return,future,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource, Iterable<TaskManagerLocation> preferredLocations) throws NoResourceAvailableException;1518522104;Returns either a {@link SimpleSlot}, or a {@link CompletableFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource, Iterable<TaskManagerLocation> preferredLocations) throws NoResourceAvailableException {_		if (task == null) {_			throw new NullPointerException()__		}_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}__		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__		_		final boolean forceExternalLocation = false &&_									preferredLocations != null && preferredLocations.iterator().hasNext()__	_		synchronized (globalLock) {_			_			SlotSharingGroup sharingUnit = vertex.getJobVertex().getSlotSharingGroup()__			_			if (sharingUnit != null) {__				_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException(_							"A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getCoLocationConstraint()__				_				_				if (constraint != null && forceExternalLocation) {_					throw new IllegalArgumentException("The scheduling cannot be constrained simultaneously by a "_							+ "co-location constraint and an external location constraint.")__				}_				_				_				final SimpleSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex.getJobvertexId(), preferredLocations)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(constraint, preferredLocations)__				}__				SimpleSlot newSlot = null__				SimpleSlot toUse = null___				_				try {_					_					_					_					if (slotFromGroup != null && slotFromGroup.getLocality() != Locality.NON_LOCAL) {_						_						_						_						if (constraint != null && !constraint.isAssigned()) {_							constraint.lockLocation()__						}_						_						updateLocalityCounters(slotFromGroup, vertex)__						return slotFromGroup__					}_					_					_					_					_					_					final Iterable<TaskManagerLocation> locations__					final boolean localOnly__					if (constraint != null && constraint.isAssigned()) {_						locations = Collections.singleton(constraint.getLocation())__						localOnly = true__					}_					else {_						locations = preferredLocations__						localOnly = forceExternalLocation__					}_					_					newSlot = getNewSlotForSharingGroup(vertex, locations, assignment, constraint, localOnly)___					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							_							if (constraint != null && constraint.isAssigned()) {_								_								throw new NoResourceAvailableException("Could not allocate a slot on instance " +_										constraint.getLocation() + ", as required by the co-location constraint.")__							}_							else if (forceExternalLocation) {_								_								String hosts = getHostnamesFromInstances(preferredLocations)__								throw new NoResourceAvailableException("Could not schedule task " + vertex_										+ " to any of the required hosts: " + hosts)__							}_							else {_								_								throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(),_										getTotalNumberOfSlots(), getNumberOfAvailableSlots())__							}_						}_						else {_							_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || !slotFromGroup.isAlive() || newSlot.getLocality() == Locality.LOCAL) {_						_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot(null)__						}_						toUse = newSlot__					}_					else {_						_						_						_						newSlot.releaseSlot(null)__						toUse = slotFromGroup__					}__					_					_					if (constraint != null && !constraint.isAssigned()) {_						constraint.lockLocation()__					}_					_					updateLocalityCounters(toUse, vertex)__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot(t)__					}_					if (newSlot != null) {_						newSlot.releaseSlot(t)__					}__					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}__				return toUse__			}_			else {_				_				_				_				SimpleSlot slot = getFreeSlotForTask(vertex, preferredLocations, forceExternalLocation)__				if (slot != null) {_					updateLocalityCounters(slot, vertex)__					return slot__				}_				else {_					_					if (queueIfNoResource) {_						CompletableFuture<LogicalSlot> future = new CompletableFuture<>()__						this.taskQueue.add(new QueuedTask(task, future))__						return future__					}_					else if (forceExternalLocation) {_						String hosts = getHostnamesFromInstances(preferredLocations)__						throw new NoResourceAvailableException("Could not schedule task " + vertex_								+ " to any of the required hosts: " + hosts)__					}_					else {_						throw new NoResourceAvailableException(getNumberOfAvailableInstances(),_								getTotalNumberOfSlots(), getNumberOfAvailableSlots())__					}_				}_			}_		}_	};returns,either,a,link,simple,slot,or,a,link,completable,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,iterable,task,manager,location,preferred,locations,throws,no,resource,available,exception,if,task,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,final,boolean,force,external,location,false,preferred,locations,null,preferred,locations,iterator,has,next,synchronized,global,lock,slot,sharing,group,sharing,unit,vertex,get,job,vertex,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,co,location,constraint,if,constraint,null,force,external,location,throw,new,illegal,argument,exception,the,scheduling,cannot,be,constrained,simultaneously,by,a,co,location,constraint,and,an,external,location,constraint,final,simple,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,get,jobvertex,id,preferred,locations,else,slot,from,group,assignment,get,slot,for,task,constraint,preferred,locations,simple,slot,new,slot,null,simple,slot,to,use,null,try,if,slot,from,group,null,slot,from,group,get,locality,locality,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,slot,from,group,vertex,return,slot,from,group,final,iterable,task,manager,location,locations,final,boolean,local,only,if,constraint,null,constraint,is,assigned,locations,collections,singleton,constraint,get,location,local,only,true,else,locations,preferred,locations,local,only,force,external,location,new,slot,get,new,slot,for,sharing,group,vertex,locations,assignment,constraint,local,only,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,assigned,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots,else,to,use,slot,from,group,else,if,slot,from,group,null,slot,from,group,is,alive,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,null,to,use,new,slot,else,new,slot,release,slot,null,to,use,slot,from,group,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,to,use,vertex,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,t,if,new,slot,null,new,slot,release,slot,t,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,return,to,use,else,simple,slot,slot,get,free,slot,for,task,vertex,preferred,locations,force,external,location,if,slot,null,update,locality,counters,slot,vertex,return,slot,else,if,queue,if,no,resource,completable,future,logical,slot,future,new,completable,future,this,task,queue,add,new,queued,task,task,future,return,future,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource, Iterable<TaskManagerLocation> preferredLocations) throws NoResourceAvailableException;1519315265;Returns either a {@link SimpleSlot}, or a {@link CompletableFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource, Iterable<TaskManagerLocation> preferredLocations) throws NoResourceAvailableException {_		if (task == null) {_			throw new NullPointerException()__		}_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}__		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__		_		final boolean forceExternalLocation = false &&_									preferredLocations != null && preferredLocations.iterator().hasNext()__	_		synchronized (globalLock) {_			_			SlotSharingGroup sharingUnit = vertex.getJobVertex().getSlotSharingGroup()__			_			if (sharingUnit != null) {__				_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException(_							"A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getCoLocationConstraint()__				_				_				if (constraint != null && forceExternalLocation) {_					throw new IllegalArgumentException("The scheduling cannot be constrained simultaneously by a "_							+ "co-location constraint and an external location constraint.")__				}_				_				_				final SimpleSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex.getJobvertexId(), preferredLocations)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(constraint, preferredLocations)__				}__				SimpleSlot newSlot = null__				SimpleSlot toUse = null___				_				try {_					_					_					_					if (slotFromGroup != null && slotFromGroup.getLocality() != Locality.NON_LOCAL) {_						_						_						_						if (constraint != null && !constraint.isAssigned()) {_							constraint.lockLocation()__						}_						_						updateLocalityCounters(slotFromGroup, vertex)__						return slotFromGroup__					}_					_					_					_					_					_					final Iterable<TaskManagerLocation> locations__					final boolean localOnly__					if (constraint != null && constraint.isAssigned()) {_						locations = Collections.singleton(constraint.getLocation())__						localOnly = true__					}_					else {_						locations = preferredLocations__						localOnly = forceExternalLocation__					}_					_					newSlot = getNewSlotForSharingGroup(vertex, locations, assignment, constraint, localOnly)___					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							_							if (constraint != null && constraint.isAssigned()) {_								_								throw new NoResourceAvailableException("Could not allocate a slot on instance " +_										constraint.getLocation() + ", as required by the co-location constraint.")__							}_							else if (forceExternalLocation) {_								_								String hosts = getHostnamesFromInstances(preferredLocations)__								throw new NoResourceAvailableException("Could not schedule task " + vertex_										+ " to any of the required hosts: " + hosts)__							}_							else {_								_								throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(),_										getTotalNumberOfSlots(), getNumberOfAvailableSlots())__							}_						}_						else {_							_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || !slotFromGroup.isAlive() || newSlot.getLocality() == Locality.LOCAL) {_						_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot(null)__						}_						toUse = newSlot__					}_					else {_						_						_						_						newSlot.releaseSlot(null)__						toUse = slotFromGroup__					}__					_					_					if (constraint != null && !constraint.isAssigned()) {_						constraint.lockLocation()__					}_					_					updateLocalityCounters(toUse, vertex)__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot(t)__					}_					if (newSlot != null) {_						newSlot.releaseSlot(t)__					}__					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}__				return toUse__			}_			else {_				_				_				_				SimpleSlot slot = getFreeSlotForTask(vertex, preferredLocations, forceExternalLocation)__				if (slot != null) {_					updateLocalityCounters(slot, vertex)__					return slot__				}_				else {_					_					if (queueIfNoResource) {_						CompletableFuture<LogicalSlot> future = new CompletableFuture<>()__						this.taskQueue.add(new QueuedTask(task, future))__						return future__					}_					else if (forceExternalLocation) {_						String hosts = getHostnamesFromInstances(preferredLocations)__						throw new NoResourceAvailableException("Could not schedule task " + vertex_								+ " to any of the required hosts: " + hosts)__					}_					else {_						throw new NoResourceAvailableException(getNumberOfAvailableInstances(),_								getTotalNumberOfSlots(), getNumberOfAvailableSlots())__					}_				}_			}_		}_	};returns,either,a,link,simple,slot,or,a,link,completable,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,iterable,task,manager,location,preferred,locations,throws,no,resource,available,exception,if,task,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,final,boolean,force,external,location,false,preferred,locations,null,preferred,locations,iterator,has,next,synchronized,global,lock,slot,sharing,group,sharing,unit,vertex,get,job,vertex,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,co,location,constraint,if,constraint,null,force,external,location,throw,new,illegal,argument,exception,the,scheduling,cannot,be,constrained,simultaneously,by,a,co,location,constraint,and,an,external,location,constraint,final,simple,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,get,jobvertex,id,preferred,locations,else,slot,from,group,assignment,get,slot,for,task,constraint,preferred,locations,simple,slot,new,slot,null,simple,slot,to,use,null,try,if,slot,from,group,null,slot,from,group,get,locality,locality,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,slot,from,group,vertex,return,slot,from,group,final,iterable,task,manager,location,locations,final,boolean,local,only,if,constraint,null,constraint,is,assigned,locations,collections,singleton,constraint,get,location,local,only,true,else,locations,preferred,locations,local,only,force,external,location,new,slot,get,new,slot,for,sharing,group,vertex,locations,assignment,constraint,local,only,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,assigned,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots,else,to,use,slot,from,group,else,if,slot,from,group,null,slot,from,group,is,alive,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,null,to,use,new,slot,else,new,slot,release,slot,null,to,use,slot,from,group,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,to,use,vertex,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,t,if,new,slot,null,new,slot,release,slot,t,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,return,to,use,else,simple,slot,slot,get,free,slot,for,task,vertex,preferred,locations,force,external,location,if,slot,null,update,locality,counters,slot,vertex,return,slot,else,if,queue,if,no,resource,completable,future,logical,slot,future,new,completable,future,this,task,queue,add,new,queued,task,task,future,return,future,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource, Iterable<TaskManagerLocation> preferredLocations) throws NoResourceAvailableException;1538764056;Returns either a {@link SimpleSlot}, or a {@link CompletableFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource, Iterable<TaskManagerLocation> preferredLocations) throws NoResourceAvailableException {_		if (task == null) {_			throw new NullPointerException()__		}_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}__		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__		_		final boolean forceExternalLocation = false &&_									preferredLocations != null && preferredLocations.iterator().hasNext()__	_		synchronized (globalLock) {_			_			SlotSharingGroup sharingUnit = vertex.getJobVertex().getSlotSharingGroup()__			_			if (sharingUnit != null) {__				_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException(_							"A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getCoLocationConstraint()__				_				_				if (constraint != null && forceExternalLocation) {_					throw new IllegalArgumentException("The scheduling cannot be constrained simultaneously by a "_							+ "co-location constraint and an external location constraint.")__				}_				_				_				final SimpleSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex.getJobvertexId(), preferredLocations)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(constraint, preferredLocations)__				}__				SimpleSlot newSlot = null__				SimpleSlot toUse = null___				_				try {_					_					_					_					if (slotFromGroup != null && slotFromGroup.getLocality() != Locality.NON_LOCAL) {_						_						_						_						if (constraint != null && !constraint.isAssigned()) {_							constraint.lockLocation()__						}_						_						updateLocalityCounters(slotFromGroup, vertex)__						return slotFromGroup__					}_					_					_					_					_					_					final Iterable<TaskManagerLocation> locations__					final boolean localOnly__					if (constraint != null && constraint.isAssigned()) {_						locations = Collections.singleton(constraint.getLocation())__						localOnly = true__					}_					else {_						locations = preferredLocations__						localOnly = forceExternalLocation__					}_					_					newSlot = getNewSlotForSharingGroup(vertex, locations, assignment, constraint, localOnly)___					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							_							if (constraint != null && constraint.isAssigned()) {_								_								throw new NoResourceAvailableException("Could not allocate a slot on instance " +_										constraint.getLocation() + ", as required by the co-location constraint.")__							}_							else if (forceExternalLocation) {_								_								String hosts = getHostnamesFromInstances(preferredLocations)__								throw new NoResourceAvailableException("Could not schedule task " + vertex_										+ " to any of the required hosts: " + hosts)__							}_							else {_								_								throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(),_										getTotalNumberOfSlots(), getNumberOfAvailableSlots())__							}_						}_						else {_							_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || !slotFromGroup.isAlive() || newSlot.getLocality() == Locality.LOCAL) {_						_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot(null)__						}_						toUse = newSlot__					}_					else {_						_						_						_						newSlot.releaseSlot(null)__						toUse = slotFromGroup__					}__					_					_					if (constraint != null && !constraint.isAssigned()) {_						constraint.lockLocation()__					}_					_					updateLocalityCounters(toUse, vertex)__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot(t)__					}_					if (newSlot != null) {_						newSlot.releaseSlot(t)__					}__					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}__				return toUse__			}_			else {_				_				_				_				SimpleSlot slot = getFreeSlotForTask(vertex, preferredLocations, forceExternalLocation)__				if (slot != null) {_					updateLocalityCounters(slot, vertex)__					return slot__				}_				else {_					_					if (queueIfNoResource) {_						CompletableFuture<LogicalSlot> future = new CompletableFuture<>()__						this.taskQueue.add(new QueuedTask(task, future))__						return future__					}_					else if (forceExternalLocation) {_						String hosts = getHostnamesFromInstances(preferredLocations)__						throw new NoResourceAvailableException("Could not schedule task " + vertex_								+ " to any of the required hosts: " + hosts)__					}_					else {_						throw new NoResourceAvailableException(getNumberOfAvailableInstances(),_								getTotalNumberOfSlots(), getNumberOfAvailableSlots())__					}_				}_			}_		}_	};returns,either,a,link,simple,slot,or,a,link,completable,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,iterable,task,manager,location,preferred,locations,throws,no,resource,available,exception,if,task,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,final,boolean,force,external,location,false,preferred,locations,null,preferred,locations,iterator,has,next,synchronized,global,lock,slot,sharing,group,sharing,unit,vertex,get,job,vertex,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,co,location,constraint,if,constraint,null,force,external,location,throw,new,illegal,argument,exception,the,scheduling,cannot,be,constrained,simultaneously,by,a,co,location,constraint,and,an,external,location,constraint,final,simple,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,get,jobvertex,id,preferred,locations,else,slot,from,group,assignment,get,slot,for,task,constraint,preferred,locations,simple,slot,new,slot,null,simple,slot,to,use,null,try,if,slot,from,group,null,slot,from,group,get,locality,locality,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,slot,from,group,vertex,return,slot,from,group,final,iterable,task,manager,location,locations,final,boolean,local,only,if,constraint,null,constraint,is,assigned,locations,collections,singleton,constraint,get,location,local,only,true,else,locations,preferred,locations,local,only,force,external,location,new,slot,get,new,slot,for,sharing,group,vertex,locations,assignment,constraint,local,only,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,assigned,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots,else,to,use,slot,from,group,else,if,slot,from,group,null,slot,from,group,is,alive,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,null,to,use,new,slot,else,new,slot,release,slot,null,to,use,slot,from,group,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,to,use,vertex,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,t,if,new,slot,null,new,slot,release,slot,t,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,return,to,use,else,simple,slot,slot,get,free,slot,for,task,vertex,preferred,locations,force,external,location,if,slot,null,update,locality,counters,slot,vertex,return,slot,else,if,queue,if,no,resource,completable,future,logical,slot,future,new,completable,future,this,task,queue,add,new,queued,task,task,future,return,future,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots
Scheduler -> private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource, Iterable<TaskManagerLocation> preferredLocations) throws NoResourceAvailableException;1543229263;Returns either a {@link SimpleSlot}, or a {@link CompletableFuture}.;private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource, Iterable<TaskManagerLocation> preferredLocations) throws NoResourceAvailableException {_		if (task == null) {_			throw new NullPointerException()__		}_		if (LOG.isDebugEnabled()) {_			LOG.debug("Scheduling task " + task)__		}__		final ExecutionVertex vertex = task.getTaskToExecute().getVertex()__		_		final boolean forceExternalLocation = false &&_									preferredLocations != null && preferredLocations.iterator().hasNext()__	_		synchronized (globalLock) {_			_			SlotSharingGroup sharingUnit = vertex.getJobVertex().getSlotSharingGroup()__			_			if (sharingUnit != null) {__				_				_				if (queueIfNoResource) {_					throw new IllegalArgumentException(_							"A task with a vertex sharing group was scheduled in a queued fashion.")__				}_				_				final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment()__				final CoLocationConstraint constraint = task.getCoLocationConstraint()__				_				_				if (constraint != null && forceExternalLocation) {_					throw new IllegalArgumentException("The scheduling cannot be constrained simultaneously by a "_							+ "co-location constraint and an external location constraint.")__				}_				_				_				final SimpleSlot slotFromGroup__				if (constraint == null) {_					slotFromGroup = assignment.getSlotForTask(vertex.getJobvertexId(), preferredLocations)__				}_				else {_					slotFromGroup = assignment.getSlotForTask(constraint, preferredLocations)__				}__				SimpleSlot newSlot = null__				SimpleSlot toUse = null___				_				try {_					_					_					_					if (slotFromGroup != null && slotFromGroup.getLocality() != Locality.NON_LOCAL) {_						_						_						_						if (constraint != null && !constraint.isAssigned()) {_							constraint.lockLocation()__						}_						_						updateLocalityCounters(slotFromGroup, vertex)__						return slotFromGroup__					}_					_					_					_					_					_					final Iterable<TaskManagerLocation> locations__					final boolean localOnly__					if (constraint != null && constraint.isAssigned()) {_						locations = Collections.singleton(constraint.getLocation())__						localOnly = true__					}_					else {_						locations = preferredLocations__						localOnly = forceExternalLocation__					}_					_					newSlot = getNewSlotForSharingGroup(vertex, locations, assignment, constraint, localOnly)___					if (newSlot == null) {_						if (slotFromGroup == null) {_							_							_							if (constraint != null && constraint.isAssigned()) {_								_								throw new NoResourceAvailableException("Could not allocate a slot on instance " +_										constraint.getLocation() + ", as required by the co-location constraint.")__							}_							else if (forceExternalLocation) {_								_								String hosts = getHostnamesFromInstances(preferredLocations)__								throw new NoResourceAvailableException("Could not schedule task " + vertex_										+ " to any of the required hosts: " + hosts)__							}_							else {_								_								throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(),_										getTotalNumberOfSlots(), getNumberOfAvailableSlots())__							}_						}_						else {_							_							_							toUse = slotFromGroup__						}_					}_					else if (slotFromGroup == null || !slotFromGroup.isAlive() || newSlot.getLocality() == Locality.LOCAL) {_						_						_						if (slotFromGroup != null) {_							slotFromGroup.releaseSlot(null)__						}_						toUse = newSlot__					}_					else {_						_						_						_						newSlot.releaseSlot(null)__						toUse = slotFromGroup__					}__					_					_					if (constraint != null && !constraint.isAssigned()) {_						constraint.lockLocation()__					}_					_					updateLocalityCounters(toUse, vertex)__				}_				catch (NoResourceAvailableException e) {_					throw e__				}_				catch (Throwable t) {_					if (slotFromGroup != null) {_						slotFromGroup.releaseSlot(t)__					}_					if (newSlot != null) {_						newSlot.releaseSlot(t)__					}__					ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group")__				}__				return toUse__			}_			else {_				_				_				_				SimpleSlot slot = getFreeSlotForTask(vertex, preferredLocations, forceExternalLocation)__				if (slot != null) {_					updateLocalityCounters(slot, vertex)__					return slot__				}_				else {_					_					if (queueIfNoResource) {_						CompletableFuture<LogicalSlot> future = new CompletableFuture<>()__						this.taskQueue.add(new QueuedTask(task, future))__						return future__					}_					else if (forceExternalLocation) {_						String hosts = getHostnamesFromInstances(preferredLocations)__						throw new NoResourceAvailableException("Could not schedule task " + vertex_								+ " to any of the required hosts: " + hosts)__					}_					else {_						throw new NoResourceAvailableException(getNumberOfAvailableInstances(),_								getTotalNumberOfSlots(), getNumberOfAvailableSlots())__					}_				}_			}_		}_	};returns,either,a,link,simple,slot,or,a,link,completable,future;private,object,schedule,task,scheduled,unit,task,boolean,queue,if,no,resource,iterable,task,manager,location,preferred,locations,throws,no,resource,available,exception,if,task,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,scheduling,task,task,final,execution,vertex,vertex,task,get,task,to,execute,get,vertex,final,boolean,force,external,location,false,preferred,locations,null,preferred,locations,iterator,has,next,synchronized,global,lock,slot,sharing,group,sharing,unit,vertex,get,job,vertex,get,slot,sharing,group,if,sharing,unit,null,if,queue,if,no,resource,throw,new,illegal,argument,exception,a,task,with,a,vertex,sharing,group,was,scheduled,in,a,queued,fashion,final,slot,sharing,group,assignment,assignment,sharing,unit,get,task,assignment,final,co,location,constraint,constraint,task,get,co,location,constraint,if,constraint,null,force,external,location,throw,new,illegal,argument,exception,the,scheduling,cannot,be,constrained,simultaneously,by,a,co,location,constraint,and,an,external,location,constraint,final,simple,slot,slot,from,group,if,constraint,null,slot,from,group,assignment,get,slot,for,task,vertex,get,jobvertex,id,preferred,locations,else,slot,from,group,assignment,get,slot,for,task,constraint,preferred,locations,simple,slot,new,slot,null,simple,slot,to,use,null,try,if,slot,from,group,null,slot,from,group,get,locality,locality,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,slot,from,group,vertex,return,slot,from,group,final,iterable,task,manager,location,locations,final,boolean,local,only,if,constraint,null,constraint,is,assigned,locations,collections,singleton,constraint,get,location,local,only,true,else,locations,preferred,locations,local,only,force,external,location,new,slot,get,new,slot,for,sharing,group,vertex,locations,assignment,constraint,local,only,if,new,slot,null,if,slot,from,group,null,if,constraint,null,constraint,is,assigned,throw,new,no,resource,available,exception,could,not,allocate,a,slot,on,instance,constraint,get,location,as,required,by,the,co,location,constraint,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,task,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots,else,to,use,slot,from,group,else,if,slot,from,group,null,slot,from,group,is,alive,new,slot,get,locality,locality,local,if,slot,from,group,null,slot,from,group,release,slot,null,to,use,new,slot,else,new,slot,release,slot,null,to,use,slot,from,group,if,constraint,null,constraint,is,assigned,constraint,lock,location,update,locality,counters,to,use,vertex,catch,no,resource,available,exception,e,throw,e,catch,throwable,t,if,slot,from,group,null,slot,from,group,release,slot,t,if,new,slot,null,new,slot,release,slot,t,exception,utils,rethrow,t,an,error,occurred,while,allocating,a,slot,in,a,sharing,group,return,to,use,else,simple,slot,slot,get,free,slot,for,task,vertex,preferred,locations,force,external,location,if,slot,null,update,locality,counters,slot,vertex,return,slot,else,if,queue,if,no,resource,completable,future,logical,slot,future,new,completable,future,this,task,queue,add,new,queued,task,task,future,return,future,else,if,force,external,location,string,hosts,get,hostnames,from,instances,preferred,locations,throw,new,no,resource,available,exception,could,not,schedule,task,vertex,to,any,of,the,required,hosts,hosts,else,throw,new,no,resource,available,exception,get,number,of,available,instances,get,total,number,of,slots,get,number,of,available,slots
Scheduler -> protected AllocatedSlot getFreeSlotForTask(ExecutionVertex vertex, Iterable<Instance> requestedLocations);1410808507;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected AllocatedSlot getFreeSlotForTask(ExecutionVertex vertex, Iterable<Instance> requestedLocations) {_		_		_		_		while (true) {_			if (this.instancesWithAvailableResources.isEmpty()) {_				return null__			}_			_			Iterator<Instance> locations = requestedLocations == null ? null : requestedLocations.iterator()__			_			Instance instanceToUse = null__			Locality locality = Locality.UNCONSTRAINED__			_			if (locations != null && locations.hasNext()) {_				_				_				while (locations.hasNext()) {_					Instance location = locations.next()__					_					if (location != null && this.instancesWithAvailableResources.remove(location)) {_						instanceToUse = location__						locality = Locality.LOCAL__						_						if (LOG.isDebugEnabled()) {_							LOG.debug("Local assignment: " + vertex.getSimpleName() + " --> " + location)__						}_						_						break__					}_				}_				_				if (instanceToUse == null) {_					instanceToUse = this.instancesWithAvailableResources.poll()__					locality = Locality.NON_LOCAL__					if (LOG.isDebugEnabled()) {_						LOG.debug("Non-local assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__					}_				}_			}_			else {_				instanceToUse = this.instancesWithAvailableResources.poll()__				if (LOG.isDebugEnabled()) {_					LOG.debug("Unconstrained assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__				}_			}_			_			try {_				AllocatedSlot slot = instanceToUse.allocateSlot(vertex.getJobId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.add(instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				this.allInstances.remove(instanceToUse)__				this.instancesWithAvailableResources.remove(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,allocated,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,instance,requested,locations,while,true,if,this,instances,with,available,resources,is,empty,return,null,iterator,instance,locations,requested,locations,null,null,requested,locations,iterator,instance,instance,to,use,null,locality,locality,locality,unconstrained,if,locations,null,locations,has,next,while,locations,has,next,instance,location,locations,next,if,location,null,this,instances,with,available,resources,remove,location,instance,to,use,location,locality,locality,local,if,log,is,debug,enabled,log,debug,local,assignment,vertex,get,simple,name,location,break,if,instance,to,use,null,instance,to,use,this,instances,with,available,resources,poll,locality,locality,if,log,is,debug,enabled,log,debug,non,local,assignment,vertex,get,simple,name,instance,to,use,else,instance,to,use,this,instances,with,available,resources,poll,if,log,is,debug,enabled,log,debug,unconstrained,assignment,vertex,get,simple,name,instance,to,use,try,allocated,slot,slot,instance,to,use,allocate,slot,vertex,get,job,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,add,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,this,all,instances,remove,instance,to,use,this,instances,with,available,resources,remove,instance,to,use
Scheduler -> protected AllocatedSlot getFreeSlotForTask(ExecutionVertex vertex, Iterable<Instance> requestedLocations);1410924144;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected AllocatedSlot getFreeSlotForTask(ExecutionVertex vertex, Iterable<Instance> requestedLocations) {_		_		_		_		while (true) {_			if (this.instancesWithAvailableResources.isEmpty()) {_				return null__			}_			_			Iterator<Instance> locations = requestedLocations == null ? null : requestedLocations.iterator()__			_			Instance instanceToUse = null__			Locality locality = Locality.UNCONSTRAINED__			_			if (locations != null && locations.hasNext()) {_				_				_				while (locations.hasNext()) {_					Instance location = locations.next()__					_					if (location != null && this.instancesWithAvailableResources.remove(location)) {_						instanceToUse = location__						locality = Locality.LOCAL__						_						if (LOG.isDebugEnabled()) {_							LOG.debug("Local assignment: " + vertex.getSimpleName() + " --> " + location)__						}_						_						break__					}_				}_				_				if (instanceToUse == null) {_					instanceToUse = this.instancesWithAvailableResources.poll()__					locality = Locality.NON_LOCAL__					if (LOG.isDebugEnabled()) {_						LOG.debug("Non-local assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__					}_				}_			}_			else {_				instanceToUse = this.instancesWithAvailableResources.poll()__				if (LOG.isDebugEnabled()) {_					LOG.debug("Unconstrained assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__				}_			}_			_			try {_				AllocatedSlot slot = instanceToUse.allocateSlot(vertex.getJobId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.add(instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				this.allInstances.remove(instanceToUse)__				this.instancesWithAvailableResources.remove(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,allocated,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,instance,requested,locations,while,true,if,this,instances,with,available,resources,is,empty,return,null,iterator,instance,locations,requested,locations,null,null,requested,locations,iterator,instance,instance,to,use,null,locality,locality,locality,unconstrained,if,locations,null,locations,has,next,while,locations,has,next,instance,location,locations,next,if,location,null,this,instances,with,available,resources,remove,location,instance,to,use,location,locality,locality,local,if,log,is,debug,enabled,log,debug,local,assignment,vertex,get,simple,name,location,break,if,instance,to,use,null,instance,to,use,this,instances,with,available,resources,poll,locality,locality,if,log,is,debug,enabled,log,debug,non,local,assignment,vertex,get,simple,name,instance,to,use,else,instance,to,use,this,instances,with,available,resources,poll,if,log,is,debug,enabled,log,debug,unconstrained,assignment,vertex,get,simple,name,instance,to,use,try,allocated,slot,slot,instance,to,use,allocate,slot,vertex,get,job,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,add,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,this,all,instances,remove,instance,to,use,this,instances,with,available,resources,remove,instance,to,use
Scheduler -> protected AllocatedSlot getFreeSlotForTask(ExecutionVertex vertex, Iterable<Instance> requestedLocations);1411473561;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected AllocatedSlot getFreeSlotForTask(ExecutionVertex vertex, Iterable<Instance> requestedLocations) {_		_		_		_		while (true) {_			if (this.instancesWithAvailableResources.isEmpty()) {_				return null__			}_			_			Iterator<Instance> locations = requestedLocations == null ? null : requestedLocations.iterator()__			_			Instance instanceToUse = null__			Locality locality = Locality.UNCONSTRAINED__			_			if (locations != null && locations.hasNext()) {_				_				_				while (locations.hasNext()) {_					Instance location = locations.next()__					_					if (location != null && this.instancesWithAvailableResources.remove(location)) {_						instanceToUse = location__						locality = Locality.LOCAL__						_						if (LOG.isDebugEnabled()) {_							LOG.debug("Local assignment: " + vertex.getSimpleName() + " --> " + location)__						}_						_						break__					}_				}_				_				if (instanceToUse == null) {_					instanceToUse = this.instancesWithAvailableResources.poll()__					locality = Locality.NON_LOCAL__					if (LOG.isDebugEnabled()) {_						LOG.debug("Non-local assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__					}_				}_			}_			else {_				instanceToUse = this.instancesWithAvailableResources.poll()__				if (LOG.isDebugEnabled()) {_					LOG.debug("Unconstrained assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__				}_			}_			_			try {_				AllocatedSlot slot = instanceToUse.allocateSlot(vertex.getJobId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.add(instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				this.allInstances.remove(instanceToUse)__				this.instancesWithAvailableResources.remove(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,allocated,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,instance,requested,locations,while,true,if,this,instances,with,available,resources,is,empty,return,null,iterator,instance,locations,requested,locations,null,null,requested,locations,iterator,instance,instance,to,use,null,locality,locality,locality,unconstrained,if,locations,null,locations,has,next,while,locations,has,next,instance,location,locations,next,if,location,null,this,instances,with,available,resources,remove,location,instance,to,use,location,locality,locality,local,if,log,is,debug,enabled,log,debug,local,assignment,vertex,get,simple,name,location,break,if,instance,to,use,null,instance,to,use,this,instances,with,available,resources,poll,locality,locality,if,log,is,debug,enabled,log,debug,non,local,assignment,vertex,get,simple,name,instance,to,use,else,instance,to,use,this,instances,with,available,resources,poll,if,log,is,debug,enabled,log,debug,unconstrained,assignment,vertex,get,simple,name,instance,to,use,try,allocated,slot,slot,instance,to,use,allocate,slot,vertex,get,job,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,add,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,this,all,instances,remove,instance,to,use,this,instances,with,available,resources,remove,instance,to,use
Scheduler -> protected AllocatedSlot getFreeSlotForTask(ExecutionVertex vertex, Iterable<Instance> requestedLocations);1411494841;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected AllocatedSlot getFreeSlotForTask(ExecutionVertex vertex, Iterable<Instance> requestedLocations) {_		_		_		_		while (true) {_			if (this.instancesWithAvailableResources.isEmpty()) {_				return null__			}_			_			Iterator<Instance> locations = requestedLocations == null ? null : requestedLocations.iterator()__			_			Instance instanceToUse = null__			Locality locality = Locality.UNCONSTRAINED__			_			if (locations != null && locations.hasNext()) {_				_				_				while (locations.hasNext()) {_					Instance location = locations.next()__					_					if (location != null && this.instancesWithAvailableResources.remove(location)) {_						instanceToUse = location__						locality = Locality.LOCAL__						_						if (LOG.isDebugEnabled()) {_							LOG.debug("Local assignment: " + vertex.getSimpleName() + " --> " + location)__						}_						_						break__					}_				}_				_				if (instanceToUse == null) {_					instanceToUse = this.instancesWithAvailableResources.poll()__					locality = Locality.NON_LOCAL__					if (LOG.isDebugEnabled()) {_						LOG.debug("Non-local assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__					}_				}_			}_			else {_				instanceToUse = this.instancesWithAvailableResources.poll()__				if (LOG.isDebugEnabled()) {_					LOG.debug("Unconstrained assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__				}_			}_			_			try {_				AllocatedSlot slot = instanceToUse.allocateSlot(vertex.getJobId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.add(instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				this.allInstances.remove(instanceToUse)__				this.instancesWithAvailableResources.remove(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,allocated,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,instance,requested,locations,while,true,if,this,instances,with,available,resources,is,empty,return,null,iterator,instance,locations,requested,locations,null,null,requested,locations,iterator,instance,instance,to,use,null,locality,locality,locality,unconstrained,if,locations,null,locations,has,next,while,locations,has,next,instance,location,locations,next,if,location,null,this,instances,with,available,resources,remove,location,instance,to,use,location,locality,locality,local,if,log,is,debug,enabled,log,debug,local,assignment,vertex,get,simple,name,location,break,if,instance,to,use,null,instance,to,use,this,instances,with,available,resources,poll,locality,locality,if,log,is,debug,enabled,log,debug,non,local,assignment,vertex,get,simple,name,instance,to,use,else,instance,to,use,this,instances,with,available,resources,poll,if,log,is,debug,enabled,log,debug,unconstrained,assignment,vertex,get,simple,name,instance,to,use,try,allocated,slot,slot,instance,to,use,allocate,slot,vertex,get,job,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,add,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,this,all,instances,remove,instance,to,use,this,instances,with,available,resources,remove,instance,to,use
Scheduler -> protected AllocatedSlot getFreeSlotForTask(ExecutionVertex vertex, Iterable<Instance> requestedLocations);1411587268;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected AllocatedSlot getFreeSlotForTask(ExecutionVertex vertex, Iterable<Instance> requestedLocations) {_		_		_		_		while (true) {_			if (this.instancesWithAvailableResources.isEmpty()) {_				_				Instance queuedInstance = this.newlyAvailableInstances.poll()__				if (queuedInstance == null) {_					return null__				} else {_					this.instancesWithAvailableResources.add(queuedInstance)__				}_			}_			_			Iterator<Instance> locations = requestedLocations == null ? null : requestedLocations.iterator()__			_			Instance instanceToUse = null__			Locality locality = Locality.UNCONSTRAINED__			_			if (locations != null && locations.hasNext()) {_				_				_				while (locations.hasNext()) {_					Instance location = locations.next()__					_					if (location != null && this.instancesWithAvailableResources.remove(location)) {_						instanceToUse = location__						locality = Locality.LOCAL__						_						if (LOG.isDebugEnabled()) {_							LOG.debug("Local assignment: " + vertex.getSimpleName() + " --> " + location)__						}_						_						break__					}_				}_				_				if (instanceToUse == null) {_					instanceToUse = this.instancesWithAvailableResources.poll()__					locality = Locality.NON_LOCAL__					if (LOG.isDebugEnabled()) {_						LOG.debug("Non-local assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__					}_				}_			}_			else {_				instanceToUse = this.instancesWithAvailableResources.poll()__				if (LOG.isDebugEnabled()) {_					LOG.debug("Unconstrained assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__				}_			}_			_			try {_				AllocatedSlot slot = instanceToUse.allocateSlot(vertex.getJobId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.add(instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				this.allInstances.remove(instanceToUse)__				this.instancesWithAvailableResources.remove(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,allocated,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,instance,requested,locations,while,true,if,this,instances,with,available,resources,is,empty,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,return,null,else,this,instances,with,available,resources,add,queued,instance,iterator,instance,locations,requested,locations,null,null,requested,locations,iterator,instance,instance,to,use,null,locality,locality,locality,unconstrained,if,locations,null,locations,has,next,while,locations,has,next,instance,location,locations,next,if,location,null,this,instances,with,available,resources,remove,location,instance,to,use,location,locality,locality,local,if,log,is,debug,enabled,log,debug,local,assignment,vertex,get,simple,name,location,break,if,instance,to,use,null,instance,to,use,this,instances,with,available,resources,poll,locality,locality,if,log,is,debug,enabled,log,debug,non,local,assignment,vertex,get,simple,name,instance,to,use,else,instance,to,use,this,instances,with,available,resources,poll,if,log,is,debug,enabled,log,debug,unconstrained,assignment,vertex,get,simple,name,instance,to,use,try,allocated,slot,slot,instance,to,use,allocate,slot,vertex,get,job,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,add,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,this,all,instances,remove,instance,to,use,this,instances,with,available,resources,remove,instance,to,use
Scheduler -> protected AllocatedSlot getFreeSlotForTask(ExecutionVertex vertex, Iterable<Instance> requestedLocations);1415641452;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected AllocatedSlot getFreeSlotForTask(ExecutionVertex vertex, Iterable<Instance> requestedLocations) {_		_		_		_		while (true) {_			if (this.instancesWithAvailableResources.isEmpty()) {_				_				Instance queuedInstance = this.newlyAvailableInstances.poll()__				if (queuedInstance == null) {_					return null__				} else {_					this.instancesWithAvailableResources.add(queuedInstance)__				}_			}_			_			Iterator<Instance> locations = requestedLocations == null ? null : requestedLocations.iterator()__			_			Instance instanceToUse = null__			Locality locality = Locality.UNCONSTRAINED__			_			if (locations != null && locations.hasNext()) {_				_				_				while (locations.hasNext()) {_					Instance location = locations.next()__					_					if (location != null && this.instancesWithAvailableResources.remove(location)) {_						instanceToUse = location__						locality = Locality.LOCAL__						_						if (LOG.isDebugEnabled()) {_							LOG.debug("Local assignment: " + vertex.getSimpleName() + " --> " + location)__						}_						_						break__					}_				}_				_				if (instanceToUse == null) {_					instanceToUse = this.instancesWithAvailableResources.poll()__					locality = Locality.NON_LOCAL__					if (LOG.isDebugEnabled()) {_						LOG.debug("Non-local assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__					}_				}_			}_			else {_				instanceToUse = this.instancesWithAvailableResources.poll()__				if (LOG.isDebugEnabled()) {_					LOG.debug("Unconstrained assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__				}_			}_			_			try {_				AllocatedSlot slot = instanceToUse.allocateSlot(vertex.getJobId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.add(instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				this.allInstances.remove(instanceToUse)__				this.instancesWithAvailableResources.remove(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,allocated,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,instance,requested,locations,while,true,if,this,instances,with,available,resources,is,empty,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,return,null,else,this,instances,with,available,resources,add,queued,instance,iterator,instance,locations,requested,locations,null,null,requested,locations,iterator,instance,instance,to,use,null,locality,locality,locality,unconstrained,if,locations,null,locations,has,next,while,locations,has,next,instance,location,locations,next,if,location,null,this,instances,with,available,resources,remove,location,instance,to,use,location,locality,locality,local,if,log,is,debug,enabled,log,debug,local,assignment,vertex,get,simple,name,location,break,if,instance,to,use,null,instance,to,use,this,instances,with,available,resources,poll,locality,locality,if,log,is,debug,enabled,log,debug,non,local,assignment,vertex,get,simple,name,instance,to,use,else,instance,to,use,this,instances,with,available,resources,poll,if,log,is,debug,enabled,log,debug,unconstrained,assignment,vertex,get,simple,name,instance,to,use,try,allocated,slot,slot,instance,to,use,allocate,slot,vertex,get,job,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,add,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,this,all,instances,remove,instance,to,use,this,instances,with,available,resources,remove,instance,to,use
Scheduler -> protected AllocatedSlot getFreeSlotForTask(ExecutionVertex vertex, Iterable<Instance> requestedLocations);1416225736;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected AllocatedSlot getFreeSlotForTask(ExecutionVertex vertex, Iterable<Instance> requestedLocations) {_		_		_		_		while (true) {_			if (this.instancesWithAvailableResources.isEmpty()) {_				_				Instance queuedInstance = this.newlyAvailableInstances.poll()__				if (queuedInstance == null) {_					return null__				} else {_					this.instancesWithAvailableResources.add(queuedInstance)__				}_			}_			_			Iterator<Instance> locations = requestedLocations == null ? null : requestedLocations.iterator()__			_			Instance instanceToUse = null__			Locality locality = Locality.UNCONSTRAINED__			_			if (locations != null && locations.hasNext()) {_				_				_				while (locations.hasNext()) {_					Instance location = locations.next()__					_					if (location != null && this.instancesWithAvailableResources.remove(location)) {_						instanceToUse = location__						locality = Locality.LOCAL__						_						if (LOG.isDebugEnabled()) {_							LOG.debug("Local assignment: " + vertex.getSimpleName() + " --> " + location)__						}_						_						break__					}_				}_				_				if (instanceToUse == null) {_					instanceToUse = this.instancesWithAvailableResources.poll()__					locality = Locality.NON_LOCAL__					if (LOG.isDebugEnabled()) {_						LOG.debug("Non-local assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__					}_				}_			}_			else {_				instanceToUse = this.instancesWithAvailableResources.poll()__				if (LOG.isDebugEnabled()) {_					LOG.debug("Unconstrained assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__				}_			}_			_			try {_				AllocatedSlot slot = instanceToUse.allocateSlot(vertex.getJobId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.add(instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				this.allInstances.remove(instanceToUse)__				this.instancesWithAvailableResources.remove(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,allocated,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,instance,requested,locations,while,true,if,this,instances,with,available,resources,is,empty,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,return,null,else,this,instances,with,available,resources,add,queued,instance,iterator,instance,locations,requested,locations,null,null,requested,locations,iterator,instance,instance,to,use,null,locality,locality,locality,unconstrained,if,locations,null,locations,has,next,while,locations,has,next,instance,location,locations,next,if,location,null,this,instances,with,available,resources,remove,location,instance,to,use,location,locality,locality,local,if,log,is,debug,enabled,log,debug,local,assignment,vertex,get,simple,name,location,break,if,instance,to,use,null,instance,to,use,this,instances,with,available,resources,poll,locality,locality,if,log,is,debug,enabled,log,debug,non,local,assignment,vertex,get,simple,name,instance,to,use,else,instance,to,use,this,instances,with,available,resources,poll,if,log,is,debug,enabled,log,debug,unconstrained,assignment,vertex,get,simple,name,instance,to,use,try,allocated,slot,slot,instance,to,use,allocate,slot,vertex,get,job,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,add,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,this,all,instances,remove,instance,to,use,this,instances,with,available,resources,remove,instance,to,use
Scheduler -> protected AllocatedSlot getFreeSlotForTask(ExecutionVertex vertex, Iterable<Instance> requestedLocations);1416878271;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected AllocatedSlot getFreeSlotForTask(ExecutionVertex vertex, Iterable<Instance> requestedLocations) {_		_		_		_		while (true) {_			if (this.instancesWithAvailableResources.isEmpty()) {_				_				Instance queuedInstance = this.newlyAvailableInstances.poll()__				if (queuedInstance == null) {_					return null__				} else {_					this.instancesWithAvailableResources.add(queuedInstance)__				}_			}_			_			Iterator<Instance> locations = requestedLocations == null ? null : requestedLocations.iterator()__			_			Instance instanceToUse = null__			Locality locality = Locality.UNCONSTRAINED__			_			if (locations != null && locations.hasNext()) {_				_				_				while (locations.hasNext()) {_					Instance location = locations.next()__					_					if (location != null && this.instancesWithAvailableResources.remove(location)) {_						instanceToUse = location__						locality = Locality.LOCAL__						_						if (LOG.isDebugEnabled()) {_							LOG.debug("Local assignment: " + vertex.getSimpleName() + " --> " + location)__						}_						_						break__					}_				}_				_				if (instanceToUse == null) {_					instanceToUse = this.instancesWithAvailableResources.poll()__					locality = Locality.NON_LOCAL__					if (LOG.isDebugEnabled()) {_						LOG.debug("Non-local assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__					}_				}_			}_			else {_				instanceToUse = this.instancesWithAvailableResources.poll()__				if (LOG.isDebugEnabled()) {_					LOG.debug("Unconstrained assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__				}_			}_			_			try {_				AllocatedSlot slot = instanceToUse.allocateSlot(vertex.getJobId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.add(instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				this.allInstances.remove(instanceToUse)__				this.instancesWithAvailableResources.remove(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,allocated,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,instance,requested,locations,while,true,if,this,instances,with,available,resources,is,empty,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,return,null,else,this,instances,with,available,resources,add,queued,instance,iterator,instance,locations,requested,locations,null,null,requested,locations,iterator,instance,instance,to,use,null,locality,locality,locality,unconstrained,if,locations,null,locations,has,next,while,locations,has,next,instance,location,locations,next,if,location,null,this,instances,with,available,resources,remove,location,instance,to,use,location,locality,locality,local,if,log,is,debug,enabled,log,debug,local,assignment,vertex,get,simple,name,location,break,if,instance,to,use,null,instance,to,use,this,instances,with,available,resources,poll,locality,locality,if,log,is,debug,enabled,log,debug,non,local,assignment,vertex,get,simple,name,instance,to,use,else,instance,to,use,this,instances,with,available,resources,poll,if,log,is,debug,enabled,log,debug,unconstrained,assignment,vertex,get,simple,name,instance,to,use,try,allocated,slot,slot,instance,to,use,allocate,slot,vertex,get,job,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,add,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,this,all,instances,remove,instance,to,use,this,instances,with,available,resources,remove,instance,to,use
Scheduler -> private Pair<Instance, Locality> findInstance(Iterable<Instance> requestedLocations);1421056725;NOTE: This method is not thread-safe, it needs to be synchronized by the caller.__Tries to find a requested instance. If no such instance is available it will return a non-_local instance. If no such instance exists (all slots occupied), then return null.__@param requestedLocations_@return;private Pair<Instance, Locality> findInstance(Iterable<Instance> requestedLocations){_		if (this.instancesWithAvailableResources.isEmpty()) {_			_			Instance queuedInstance = this.newlyAvailableInstances.poll()__			if (queuedInstance == null) {_				return null__			} else {_				this.instancesWithAvailableResources.add(queuedInstance)__			}_		}__		Iterator<Instance> locations = requestedLocations == null ? null : requestedLocations.iterator()___		Instance instanceToUse = null__		Locality locality = Locality.UNCONSTRAINED___		if (locations != null && locations.hasNext()) {_			__			while (locations.hasNext()) {_				Instance location = locations.next()___				if (location != null && this.instancesWithAvailableResources.remove(location)) {_					instanceToUse = location__					locality = Locality.LOCAL___					break__				}_			}__			if (instanceToUse == null) {_				instanceToUse = this.instancesWithAvailableResources.poll()__				locality = Locality.NON_LOCAL__			}_		}_		else {_			instanceToUse = this.instancesWithAvailableResources.poll()__		}__		return new ImmutablePair<Instance, Locality>(instanceToUse, locality)__	};note,this,method,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,tries,to,find,a,requested,instance,if,no,such,instance,is,available,it,will,return,a,non,local,instance,if,no,such,instance,exists,all,slots,occupied,then,return,null,param,requested,locations,return;private,pair,instance,locality,find,instance,iterable,instance,requested,locations,if,this,instances,with,available,resources,is,empty,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,return,null,else,this,instances,with,available,resources,add,queued,instance,iterator,instance,locations,requested,locations,null,null,requested,locations,iterator,instance,instance,to,use,null,locality,locality,locality,unconstrained,if,locations,null,locations,has,next,while,locations,has,next,instance,location,locations,next,if,location,null,this,instances,with,available,resources,remove,location,instance,to,use,location,locality,locality,local,break,if,instance,to,use,null,instance,to,use,this,instances,with,available,resources,poll,locality,locality,else,instance,to,use,this,instances,with,available,resources,poll,return,new,immutable,pair,instance,locality,instance,to,use,locality
Scheduler -> private Pair<Instance, Locality> findInstance(Iterable<Instance> requestedLocations);1423053613;NOTE: This method is not thread-safe, it needs to be synchronized by the caller.__Tries to find a requested instance. If no such instance is available it will return a non-_local instance. If no such instance exists (all slots occupied), then return null.__@param requestedLocations;private Pair<Instance, Locality> findInstance(Iterable<Instance> requestedLocations){_		if (this.instancesWithAvailableResources.isEmpty()) {_			_			Instance queuedInstance = this.newlyAvailableInstances.poll()__			if (queuedInstance == null) {_				return null__			} else {_				this.instancesWithAvailableResources.add(queuedInstance)__			}_		}__		Iterator<Instance> locations = requestedLocations == null ? null : requestedLocations.iterator()___		Instance instanceToUse = null__		Locality locality = Locality.UNCONSTRAINED___		if (locations != null && locations.hasNext()) {_			__			while (locations.hasNext()) {_				Instance location = locations.next()___				if (location != null && this.instancesWithAvailableResources.remove(location)) {_					instanceToUse = location__					locality = Locality.LOCAL___					break__				}_			}__			if (instanceToUse == null) {_				instanceToUse = this.instancesWithAvailableResources.poll()__				locality = Locality.NON_LOCAL__			}_		}_		else {_			instanceToUse = this.instancesWithAvailableResources.poll()__		}__		return new ImmutablePair<Instance, Locality>(instanceToUse, locality)__	};note,this,method,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,tries,to,find,a,requested,instance,if,no,such,instance,is,available,it,will,return,a,non,local,instance,if,no,such,instance,exists,all,slots,occupied,then,return,null,param,requested,locations;private,pair,instance,locality,find,instance,iterable,instance,requested,locations,if,this,instances,with,available,resources,is,empty,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,return,null,else,this,instances,with,available,resources,add,queued,instance,iterator,instance,locations,requested,locations,null,null,requested,locations,iterator,instance,instance,to,use,null,locality,locality,locality,unconstrained,if,locations,null,locations,has,next,while,locations,has,next,instance,location,locations,next,if,location,null,this,instances,with,available,resources,remove,location,instance,to,use,location,locality,locality,local,break,if,instance,to,use,null,instance,to,use,this,instances,with,available,resources,poll,locality,locality,else,instance,to,use,this,instances,with,available,resources,poll,return,new,immutable,pair,instance,locality,instance,to,use,locality
Scheduler -> protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, 											Iterable<Instance> requestedLocations, 											boolean localOnly);1432114676;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex,_											Iterable<Instance> requestedLocations,_											boolean localOnly) {_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)___			if (instanceLocalityPair == null){_				return null__			}__			Instance instanceToUse = instanceLocalityPair.getLeft()__			Locality locality = instanceLocalityPair.getRight()___			try {_				SimpleSlot slot = instanceToUse.allocateSimpleSlot(vertex.getJobId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.add(instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,simple,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,instance,requested,locations,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,instance,instance,to,use,instance,locality,pair,get,left,locality,locality,instance,locality,pair,get,right,try,simple,slot,slot,instance,to,use,allocate,simple,slot,vertex,get,job,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,add,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, 											Iterable<Instance> requestedLocations, 											boolean localOnly);1434450422;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex,_											Iterable<Instance> requestedLocations,_											boolean localOnly) {_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)___			if (instanceLocalityPair == null){_				return null__			}__			Instance instanceToUse = instanceLocalityPair.getLeft()__			Locality locality = instanceLocalityPair.getRight()___			try {_				SimpleSlot slot = instanceToUse.allocateSimpleSlot(vertex.getJobId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.add(instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,simple,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,instance,requested,locations,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,instance,instance,to,use,instance,locality,pair,get,left,locality,locality,instance,locality,pair,get,right,try,simple,slot,slot,instance,to,use,allocate,simple,slot,vertex,get,job,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,add,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, 											Iterable<Instance> requestedLocations, 											boolean localOnly);1436262104;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex,_											Iterable<Instance> requestedLocations,_											boolean localOnly) {_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)___			if (instanceLocalityPair == null){_				return null__			}__			Instance instanceToUse = instanceLocalityPair.getLeft()__			Locality locality = instanceLocalityPair.getRight()___			try {_				SimpleSlot slot = instanceToUse.allocateSimpleSlot(vertex.getJobId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.add(instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,simple,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,instance,requested,locations,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,instance,instance,to,use,instance,locality,pair,get,left,locality,locality,instance,locality,pair,get,right,try,simple,slot,slot,instance,to,use,allocate,simple,slot,vertex,get,job,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,add,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, 											Iterable<Instance> requestedLocations, 											boolean localOnly);1445550685;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex,_											Iterable<Instance> requestedLocations,_											boolean localOnly) {_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)___			if (instanceLocalityPair == null){_				return null__			}__			Instance instanceToUse = instanceLocalityPair.getLeft()__			Locality locality = instanceLocalityPair.getRight()___			try {_				SimpleSlot slot = instanceToUse.allocateSimpleSlot(vertex.getJobId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.add(instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,simple,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,instance,requested,locations,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,instance,instance,to,use,instance,locality,pair,get,left,locality,locality,instance,locality,pair,get,right,try,simple,slot,slot,instance,to,use,allocate,simple,slot,vertex,get,job,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,add,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex, 													Iterable<Instance> requestedLocations, 													SlotSharingGroupAssignment groupAssignment, 													CoLocationConstraint constraint, 													boolean localOnly);1432114676;Tries to allocate a new slot for a vertex that is part of a slot sharing group. If one_of the instances has a slot available, the method will allocate it as a shared slot, add that_shared slot to the sharing group, and allocate a simple slot from that shared slot.__<p>This method will try to allocate a slot from one of the local instances, and fall back to_non-local instances, if permitted.</p>__@param vertex The vertex to allocate the slot for._@param requestedLocations The locations that are considered local. May be null or empty, if the_vertex has no location preferences._@param groupAssignment The slot sharing group of the vertex. Mandatory parameter._@param constraint The co-location constraint of the vertex. May be null._@param localOnly Flag to indicate if non-local choices are acceptable.__@return A sub-slot for the given vertex, or {@code null}, if no slot is available.;protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex,_													Iterable<Instance> requestedLocations,_													SlotSharingGroupAssignment groupAssignment,_													CoLocationConstraint constraint,_													boolean localOnly)_	{_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)__			_			if (instanceLocalityPair == null) {_				_				return null__			}__			final Instance instanceToUse = instanceLocalityPair.getLeft()__			final Locality locality = instanceLocalityPair.getRight()___			try {_				JobVertexID groupID = vertex.getJobvertexId()__				_				_				SharedSlot sharedSlot = instanceToUse.allocateSharedSlot(vertex.getJobId(), groupAssignment)___				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.add(instanceToUse)__				}__				if (sharedSlot != null) {_					_					SimpleSlot slot = constraint == null ?_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, groupID) :_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, constraint)___					if (slot != null) {_						return slot__					}_					else {_						_						sharedSlot.releaseSlot()__					}_				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}__			_		}_	};tries,to,allocate,a,new,slot,for,a,vertex,that,is,part,of,a,slot,sharing,group,if,one,of,the,instances,has,a,slot,available,the,method,will,allocate,it,as,a,shared,slot,add,that,shared,slot,to,the,sharing,group,and,allocate,a,simple,slot,from,that,shared,slot,p,this,method,will,try,to,allocate,a,slot,from,one,of,the,local,instances,and,fall,back,to,non,local,instances,if,permitted,p,param,vertex,the,vertex,to,allocate,the,slot,for,param,requested,locations,the,locations,that,are,considered,local,may,be,null,or,empty,if,the,vertex,has,no,location,preferences,param,group,assignment,the,slot,sharing,group,of,the,vertex,mandatory,parameter,param,constraint,the,co,location,constraint,of,the,vertex,may,be,null,param,local,only,flag,to,indicate,if,non,local,choices,are,acceptable,return,a,sub,slot,for,the,given,vertex,or,code,null,if,no,slot,is,available;protected,simple,slot,get,new,slot,for,sharing,group,execution,vertex,vertex,iterable,instance,requested,locations,slot,sharing,group,assignment,group,assignment,co,location,constraint,constraint,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,final,instance,instance,to,use,instance,locality,pair,get,left,final,locality,locality,instance,locality,pair,get,right,try,job,vertex,id,group,id,vertex,get,jobvertex,id,shared,slot,shared,slot,instance,to,use,allocate,shared,slot,vertex,get,job,id,group,assignment,if,instance,to,use,has,resources,available,this,instances,with,available,resources,add,instance,to,use,if,shared,slot,null,simple,slot,slot,constraint,null,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,group,id,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,constraint,if,slot,null,return,slot,else,shared,slot,release,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex, 													Iterable<Instance> requestedLocations, 													SlotSharingGroupAssignment groupAssignment, 													CoLocationConstraint constraint, 													boolean localOnly);1434450422;Tries to allocate a new slot for a vertex that is part of a slot sharing group. If one_of the instances has a slot available, the method will allocate it as a shared slot, add that_shared slot to the sharing group, and allocate a simple slot from that shared slot.__<p>This method will try to allocate a slot from one of the local instances, and fall back to_non-local instances, if permitted.</p>__@param vertex The vertex to allocate the slot for._@param requestedLocations The locations that are considered local. May be null or empty, if the_vertex has no location preferences._@param groupAssignment The slot sharing group of the vertex. Mandatory parameter._@param constraint The co-location constraint of the vertex. May be null._@param localOnly Flag to indicate if non-local choices are acceptable.__@return A sub-slot for the given vertex, or {@code null}, if no slot is available.;protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex,_													Iterable<Instance> requestedLocations,_													SlotSharingGroupAssignment groupAssignment,_													CoLocationConstraint constraint,_													boolean localOnly)_	{_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)__			_			if (instanceLocalityPair == null) {_				_				return null__			}__			final Instance instanceToUse = instanceLocalityPair.getLeft()__			final Locality locality = instanceLocalityPair.getRight()___			try {_				JobVertexID groupID = vertex.getJobvertexId()__				_				_				SharedSlot sharedSlot = instanceToUse.allocateSharedSlot(vertex.getJobId(), groupAssignment)___				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.add(instanceToUse)__				}__				if (sharedSlot != null) {_					_					SimpleSlot slot = constraint == null ?_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, groupID) :_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, constraint)___					if (slot != null) {_						return slot__					}_					else {_						_						sharedSlot.releaseSlot()__					}_				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}__			_		}_	};tries,to,allocate,a,new,slot,for,a,vertex,that,is,part,of,a,slot,sharing,group,if,one,of,the,instances,has,a,slot,available,the,method,will,allocate,it,as,a,shared,slot,add,that,shared,slot,to,the,sharing,group,and,allocate,a,simple,slot,from,that,shared,slot,p,this,method,will,try,to,allocate,a,slot,from,one,of,the,local,instances,and,fall,back,to,non,local,instances,if,permitted,p,param,vertex,the,vertex,to,allocate,the,slot,for,param,requested,locations,the,locations,that,are,considered,local,may,be,null,or,empty,if,the,vertex,has,no,location,preferences,param,group,assignment,the,slot,sharing,group,of,the,vertex,mandatory,parameter,param,constraint,the,co,location,constraint,of,the,vertex,may,be,null,param,local,only,flag,to,indicate,if,non,local,choices,are,acceptable,return,a,sub,slot,for,the,given,vertex,or,code,null,if,no,slot,is,available;protected,simple,slot,get,new,slot,for,sharing,group,execution,vertex,vertex,iterable,instance,requested,locations,slot,sharing,group,assignment,group,assignment,co,location,constraint,constraint,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,final,instance,instance,to,use,instance,locality,pair,get,left,final,locality,locality,instance,locality,pair,get,right,try,job,vertex,id,group,id,vertex,get,jobvertex,id,shared,slot,shared,slot,instance,to,use,allocate,shared,slot,vertex,get,job,id,group,assignment,if,instance,to,use,has,resources,available,this,instances,with,available,resources,add,instance,to,use,if,shared,slot,null,simple,slot,slot,constraint,null,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,group,id,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,constraint,if,slot,null,return,slot,else,shared,slot,release,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex, 													Iterable<Instance> requestedLocations, 													SlotSharingGroupAssignment groupAssignment, 													CoLocationConstraint constraint, 													boolean localOnly);1436262104;Tries to allocate a new slot for a vertex that is part of a slot sharing group. If one_of the instances has a slot available, the method will allocate it as a shared slot, add that_shared slot to the sharing group, and allocate a simple slot from that shared slot.__<p>This method will try to allocate a slot from one of the local instances, and fall back to_non-local instances, if permitted.</p>__@param vertex The vertex to allocate the slot for._@param requestedLocations The locations that are considered local. May be null or empty, if the_vertex has no location preferences._@param groupAssignment The slot sharing group of the vertex. Mandatory parameter._@param constraint The co-location constraint of the vertex. May be null._@param localOnly Flag to indicate if non-local choices are acceptable.__@return A sub-slot for the given vertex, or {@code null}, if no slot is available.;protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex,_													Iterable<Instance> requestedLocations,_													SlotSharingGroupAssignment groupAssignment,_													CoLocationConstraint constraint,_													boolean localOnly)_	{_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)__			_			if (instanceLocalityPair == null) {_				_				return null__			}__			final Instance instanceToUse = instanceLocalityPair.getLeft()__			final Locality locality = instanceLocalityPair.getRight()___			try {_				JobVertexID groupID = vertex.getJobvertexId()__				_				_				SharedSlot sharedSlot = instanceToUse.allocateSharedSlot(vertex.getJobId(), groupAssignment)___				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.add(instanceToUse)__				}__				if (sharedSlot != null) {_					_					SimpleSlot slot = constraint == null ?_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, groupID) :_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, constraint)___					if (slot != null) {_						return slot__					}_					else {_						_						sharedSlot.releaseSlot()__					}_				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}__			_		}_	};tries,to,allocate,a,new,slot,for,a,vertex,that,is,part,of,a,slot,sharing,group,if,one,of,the,instances,has,a,slot,available,the,method,will,allocate,it,as,a,shared,slot,add,that,shared,slot,to,the,sharing,group,and,allocate,a,simple,slot,from,that,shared,slot,p,this,method,will,try,to,allocate,a,slot,from,one,of,the,local,instances,and,fall,back,to,non,local,instances,if,permitted,p,param,vertex,the,vertex,to,allocate,the,slot,for,param,requested,locations,the,locations,that,are,considered,local,may,be,null,or,empty,if,the,vertex,has,no,location,preferences,param,group,assignment,the,slot,sharing,group,of,the,vertex,mandatory,parameter,param,constraint,the,co,location,constraint,of,the,vertex,may,be,null,param,local,only,flag,to,indicate,if,non,local,choices,are,acceptable,return,a,sub,slot,for,the,given,vertex,or,code,null,if,no,slot,is,available;protected,simple,slot,get,new,slot,for,sharing,group,execution,vertex,vertex,iterable,instance,requested,locations,slot,sharing,group,assignment,group,assignment,co,location,constraint,constraint,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,final,instance,instance,to,use,instance,locality,pair,get,left,final,locality,locality,instance,locality,pair,get,right,try,job,vertex,id,group,id,vertex,get,jobvertex,id,shared,slot,shared,slot,instance,to,use,allocate,shared,slot,vertex,get,job,id,group,assignment,if,instance,to,use,has,resources,available,this,instances,with,available,resources,add,instance,to,use,if,shared,slot,null,simple,slot,slot,constraint,null,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,group,id,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,constraint,if,slot,null,return,slot,else,shared,slot,release,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex, 													Iterable<Instance> requestedLocations, 													SlotSharingGroupAssignment groupAssignment, 													CoLocationConstraint constraint, 													boolean localOnly);1445550685;Tries to allocate a new slot for a vertex that is part of a slot sharing group. If one_of the instances has a slot available, the method will allocate it as a shared slot, add that_shared slot to the sharing group, and allocate a simple slot from that shared slot.__<p>This method will try to allocate a slot from one of the local instances, and fall back to_non-local instances, if permitted.</p>__@param vertex The vertex to allocate the slot for._@param requestedLocations The locations that are considered local. May be null or empty, if the_vertex has no location preferences._@param groupAssignment The slot sharing group of the vertex. Mandatory parameter._@param constraint The co-location constraint of the vertex. May be null._@param localOnly Flag to indicate if non-local choices are acceptable.__@return A sub-slot for the given vertex, or {@code null}, if no slot is available.;protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex,_													Iterable<Instance> requestedLocations,_													SlotSharingGroupAssignment groupAssignment,_													CoLocationConstraint constraint,_													boolean localOnly)_	{_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly)__			_			if (instanceLocalityPair == null) {_				_				return null__			}__			final Instance instanceToUse = instanceLocalityPair.getLeft()__			final Locality locality = instanceLocalityPair.getRight()___			try {_				JobVertexID groupID = vertex.getJobvertexId()__				_				_				SharedSlot sharedSlot = instanceToUse.allocateSharedSlot(vertex.getJobId(), groupAssignment)___				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.add(instanceToUse)__				}__				if (sharedSlot != null) {_					_					SimpleSlot slot = constraint == null ?_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, groupID) :_							groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, constraint)___					if (slot != null) {_						return slot__					}_					else {_						_						sharedSlot.releaseSlot()__					}_				}_			}_			catch (InstanceDiedException e) {_				_				_				removeInstance(instanceToUse)__			}__			_		}_	};tries,to,allocate,a,new,slot,for,a,vertex,that,is,part,of,a,slot,sharing,group,if,one,of,the,instances,has,a,slot,available,the,method,will,allocate,it,as,a,shared,slot,add,that,shared,slot,to,the,sharing,group,and,allocate,a,simple,slot,from,that,shared,slot,p,this,method,will,try,to,allocate,a,slot,from,one,of,the,local,instances,and,fall,back,to,non,local,instances,if,permitted,p,param,vertex,the,vertex,to,allocate,the,slot,for,param,requested,locations,the,locations,that,are,considered,local,may,be,null,or,empty,if,the,vertex,has,no,location,preferences,param,group,assignment,the,slot,sharing,group,of,the,vertex,mandatory,parameter,param,constraint,the,co,location,constraint,of,the,vertex,may,be,null,param,local,only,flag,to,indicate,if,non,local,choices,are,acceptable,return,a,sub,slot,for,the,given,vertex,or,code,null,if,no,slot,is,available;protected,simple,slot,get,new,slot,for,sharing,group,execution,vertex,vertex,iterable,instance,requested,locations,slot,sharing,group,assignment,group,assignment,co,location,constraint,constraint,boolean,local,only,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,local,only,if,instance,locality,pair,null,return,null,final,instance,instance,to,use,instance,locality,pair,get,left,final,locality,locality,instance,locality,pair,get,right,try,job,vertex,id,group,id,vertex,get,jobvertex,id,shared,slot,shared,slot,instance,to,use,allocate,shared,slot,vertex,get,job,id,group,assignment,if,instance,to,use,has,resources,available,this,instances,with,available,resources,add,instance,to,use,if,shared,slot,null,simple,slot,slot,constraint,null,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,group,id,group,assignment,add,shared,slot,and,allocate,sub,slot,shared,slot,locality,constraint,if,slot,null,return,slot,else,shared,slot,release,slot,catch,instance,died,exception,e,remove,instance,instance,to,use
Scheduler -> private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly);1472205100;Tries to find a requested instance. If no such instance is available it will return a non-_local instance. If no such instance exists (all slots occupied), then return null.__<p><b>NOTE:</b> This method is not thread-safe, it needs to be synchronized by the caller.</p>__@param requestedLocations The list of preferred instances. May be null or empty, which indicates that_no locality preference exists._@param localOnly Flag to indicate whether only one of the exact local instances can be chosen.;private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly) {_		_		_		while (this.newlyAvailableInstances.size() > 0) {_			Instance queuedInstance = this.newlyAvailableInstances.poll()__			if (queuedInstance != null) {_				this.instancesWithAvailableResources.put(queuedInstance.getTaskManagerID(), queuedInstance)__			}_		}_		_		_		if (this.instancesWithAvailableResources.isEmpty()) {_			return null__		}__		Iterator<TaskManagerLocation> locations = requestedLocations == null ? null : requestedLocations.iterator()___		if (locations != null && locations.hasNext()) {_			__			while (locations.hasNext()) {_				TaskManagerLocation location = locations.next()__				if (location != null) {_					Instance instance = instancesWithAvailableResources.remove(location.getResourceID())__					if (instance != null) {_						return new ImmutablePair<Instance, Locality>(instance, Locality.LOCAL)__					}_				}_			}_			_			_			if (localOnly) {_				return null__			}_			else {_				_				Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__				Instance instanceToUse = instances.next()__				instances.remove()___				return new ImmutablePair<>(instanceToUse, Locality.NON_LOCAL)__			}_		}_		else {_			_			Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__			Instance instanceToUse = instances.next()__			instances.remove()___			return new ImmutablePair<>(instanceToUse, Locality.UNCONSTRAINED)__		}_	};tries,to,find,a,requested,instance,if,no,such,instance,is,available,it,will,return,a,non,local,instance,if,no,such,instance,exists,all,slots,occupied,then,return,null,p,b,note,b,this,method,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,p,param,requested,locations,the,list,of,preferred,instances,may,be,null,or,empty,which,indicates,that,no,locality,preference,exists,param,local,only,flag,to,indicate,whether,only,one,of,the,exact,local,instances,can,be,chosen;private,pair,instance,locality,find,instance,iterable,task,manager,location,requested,locations,boolean,local,only,while,this,newly,available,instances,size,0,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,this,instances,with,available,resources,put,queued,instance,get,task,manager,id,queued,instance,if,this,instances,with,available,resources,is,empty,return,null,iterator,task,manager,location,locations,requested,locations,null,null,requested,locations,iterator,if,locations,null,locations,has,next,while,locations,has,next,task,manager,location,location,locations,next,if,location,null,instance,instance,instances,with,available,resources,remove,location,get,resource,id,if,instance,null,return,new,immutable,pair,instance,locality,instance,locality,local,if,local,only,return,null,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,unconstrained
Scheduler -> private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly);1472582060;Tries to find a requested instance. If no such instance is available it will return a non-_local instance. If no such instance exists (all slots occupied), then return null.__<p><b>NOTE:</b> This method is not thread-safe, it needs to be synchronized by the caller.</p>__@param requestedLocations The list of preferred instances. May be null or empty, which indicates that_no locality preference exists._@param localOnly Flag to indicate whether only one of the exact local instances can be chosen.;private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly) {_		_		_		while (this.newlyAvailableInstances.size() > 0) {_			Instance queuedInstance = this.newlyAvailableInstances.poll()__			if (queuedInstance != null) {_				this.instancesWithAvailableResources.put(queuedInstance.getResourceId(), queuedInstance)__			}_		}_		_		_		if (this.instancesWithAvailableResources.isEmpty()) {_			return null__		}__		Iterator<TaskManagerLocation> locations = requestedLocations == null ? null : requestedLocations.iterator()___		if (locations != null && locations.hasNext()) {_			__			while (locations.hasNext()) {_				TaskManagerLocation location = locations.next()__				if (location != null) {_					Instance instance = instancesWithAvailableResources.remove(location.getResourceID())__					if (instance != null) {_						return new ImmutablePair<Instance, Locality>(instance, Locality.LOCAL)__					}_				}_			}_			_			_			if (localOnly) {_				return null__			}_			else {_				_				Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__				Instance instanceToUse = instances.next()__				instances.remove()___				return new ImmutablePair<>(instanceToUse, Locality.NON_LOCAL)__			}_		}_		else {_			_			Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__			Instance instanceToUse = instances.next()__			instances.remove()___			return new ImmutablePair<>(instanceToUse, Locality.UNCONSTRAINED)__		}_	};tries,to,find,a,requested,instance,if,no,such,instance,is,available,it,will,return,a,non,local,instance,if,no,such,instance,exists,all,slots,occupied,then,return,null,p,b,note,b,this,method,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,p,param,requested,locations,the,list,of,preferred,instances,may,be,null,or,empty,which,indicates,that,no,locality,preference,exists,param,local,only,flag,to,indicate,whether,only,one,of,the,exact,local,instances,can,be,chosen;private,pair,instance,locality,find,instance,iterable,task,manager,location,requested,locations,boolean,local,only,while,this,newly,available,instances,size,0,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,this,instances,with,available,resources,put,queued,instance,get,resource,id,queued,instance,if,this,instances,with,available,resources,is,empty,return,null,iterator,task,manager,location,locations,requested,locations,null,null,requested,locations,iterator,if,locations,null,locations,has,next,while,locations,has,next,task,manager,location,location,locations,next,if,location,null,instance,instance,instances,with,available,resources,remove,location,get,resource,id,if,instance,null,return,new,immutable,pair,instance,locality,instance,locality,local,if,local,only,return,null,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,unconstrained
Scheduler -> private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly);1472644741;Tries to find a requested instance. If no such instance is available it will return a non-_local instance. If no such instance exists (all slots occupied), then return null.__<p><b>NOTE:</b> This method is not thread-safe, it needs to be synchronized by the caller.</p>__@param requestedLocations The list of preferred instances. May be null or empty, which indicates that_no locality preference exists._@param localOnly Flag to indicate whether only one of the exact local instances can be chosen.;private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly) {_		_		_		while (this.newlyAvailableInstances.size() > 0) {_			Instance queuedInstance = this.newlyAvailableInstances.poll()__			if (queuedInstance != null) {_				this.instancesWithAvailableResources.put(queuedInstance.getTaskManagerID(), queuedInstance)__			}_		}_		_		_		if (this.instancesWithAvailableResources.isEmpty()) {_			return null__		}__		Iterator<TaskManagerLocation> locations = requestedLocations == null ? null : requestedLocations.iterator()___		if (locations != null && locations.hasNext()) {_			__			while (locations.hasNext()) {_				TaskManagerLocation location = locations.next()__				if (location != null) {_					Instance instance = instancesWithAvailableResources.remove(location.getResourceID())__					if (instance != null) {_						return new ImmutablePair<Instance, Locality>(instance, Locality.LOCAL)__					}_				}_			}_			_			_			if (localOnly) {_				return null__			}_			else {_				_				Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__				Instance instanceToUse = instances.next()__				instances.remove()___				return new ImmutablePair<>(instanceToUse, Locality.NON_LOCAL)__			}_		}_		else {_			_			Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__			Instance instanceToUse = instances.next()__			instances.remove()___			return new ImmutablePair<>(instanceToUse, Locality.UNCONSTRAINED)__		}_	};tries,to,find,a,requested,instance,if,no,such,instance,is,available,it,will,return,a,non,local,instance,if,no,such,instance,exists,all,slots,occupied,then,return,null,p,b,note,b,this,method,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,p,param,requested,locations,the,list,of,preferred,instances,may,be,null,or,empty,which,indicates,that,no,locality,preference,exists,param,local,only,flag,to,indicate,whether,only,one,of,the,exact,local,instances,can,be,chosen;private,pair,instance,locality,find,instance,iterable,task,manager,location,requested,locations,boolean,local,only,while,this,newly,available,instances,size,0,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,this,instances,with,available,resources,put,queued,instance,get,task,manager,id,queued,instance,if,this,instances,with,available,resources,is,empty,return,null,iterator,task,manager,location,locations,requested,locations,null,null,requested,locations,iterator,if,locations,null,locations,has,next,while,locations,has,next,task,manager,location,location,locations,next,if,location,null,instance,instance,instances,with,available,resources,remove,location,get,resource,id,if,instance,null,return,new,immutable,pair,instance,locality,instance,locality,local,if,local,only,return,null,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,unconstrained
Scheduler -> private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly);1473307213;Tries to find a requested instance. If no such instance is available it will return a non-_local instance. If no such instance exists (all slots occupied), then return null.__<p><b>NOTE:</b> This method is not thread-safe, it needs to be synchronized by the caller.</p>__@param requestedLocations The list of preferred instances. May be null or empty, which indicates that_no locality preference exists._@param localOnly Flag to indicate whether only one of the exact local instances can be chosen.;private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly) {_		_		_		while (this.newlyAvailableInstances.size() > 0) {_			Instance queuedInstance = this.newlyAvailableInstances.poll()__			if (queuedInstance != null) {_				this.instancesWithAvailableResources.put(queuedInstance.getTaskManagerID(), queuedInstance)__			}_		}_		_		_		if (this.instancesWithAvailableResources.isEmpty()) {_			return null__		}__		Iterator<TaskManagerLocation> locations = requestedLocations == null ? null : requestedLocations.iterator()___		if (locations != null && locations.hasNext()) {_			__			while (locations.hasNext()) {_				TaskManagerLocation location = locations.next()__				if (location != null) {_					Instance instance = instancesWithAvailableResources.remove(location.getResourceID())__					if (instance != null) {_						return new ImmutablePair<Instance, Locality>(instance, Locality.LOCAL)__					}_				}_			}_			_			_			if (localOnly) {_				return null__			}_			else {_				_				Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__				Instance instanceToUse = instances.next()__				instances.remove()___				return new ImmutablePair<>(instanceToUse, Locality.NON_LOCAL)__			}_		}_		else {_			_			Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__			Instance instanceToUse = instances.next()__			instances.remove()___			return new ImmutablePair<>(instanceToUse, Locality.UNCONSTRAINED)__		}_	};tries,to,find,a,requested,instance,if,no,such,instance,is,available,it,will,return,a,non,local,instance,if,no,such,instance,exists,all,slots,occupied,then,return,null,p,b,note,b,this,method,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,p,param,requested,locations,the,list,of,preferred,instances,may,be,null,or,empty,which,indicates,that,no,locality,preference,exists,param,local,only,flag,to,indicate,whether,only,one,of,the,exact,local,instances,can,be,chosen;private,pair,instance,locality,find,instance,iterable,task,manager,location,requested,locations,boolean,local,only,while,this,newly,available,instances,size,0,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,this,instances,with,available,resources,put,queued,instance,get,task,manager,id,queued,instance,if,this,instances,with,available,resources,is,empty,return,null,iterator,task,manager,location,locations,requested,locations,null,null,requested,locations,iterator,if,locations,null,locations,has,next,while,locations,has,next,task,manager,location,location,locations,next,if,location,null,instance,instance,instances,with,available,resources,remove,location,get,resource,id,if,instance,null,return,new,immutable,pair,instance,locality,instance,locality,local,if,local,only,return,null,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,unconstrained
Scheduler -> private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly);1474949408;Tries to find a requested instance. If no such instance is available it will return a non-_local instance. If no such instance exists (all slots occupied), then return null.__<p><b>NOTE:</b> This method is not thread-safe, it needs to be synchronized by the caller.</p>__@param requestedLocations The list of preferred instances. May be null or empty, which indicates that_no locality preference exists._@param localOnly Flag to indicate whether only one of the exact local instances can be chosen.;private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly) {_		_		_		while (this.newlyAvailableInstances.size() > 0) {_			Instance queuedInstance = this.newlyAvailableInstances.poll()__			if (queuedInstance != null) {_				this.instancesWithAvailableResources.put(queuedInstance.getTaskManagerID(), queuedInstance)__			}_		}_		_		_		if (this.instancesWithAvailableResources.isEmpty()) {_			return null__		}__		Iterator<TaskManagerLocation> locations = requestedLocations == null ? null : requestedLocations.iterator()___		if (locations != null && locations.hasNext()) {_			__			while (locations.hasNext()) {_				TaskManagerLocation location = locations.next()__				if (location != null) {_					Instance instance = instancesWithAvailableResources.remove(location.getResourceID())__					if (instance != null) {_						return new ImmutablePair<Instance, Locality>(instance, Locality.LOCAL)__					}_				}_			}_			_			_			if (localOnly) {_				return null__			}_			else {_				_				Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__				Instance instanceToUse = instances.next()__				instances.remove()___				return new ImmutablePair<>(instanceToUse, Locality.NON_LOCAL)__			}_		}_		else {_			_			Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__			Instance instanceToUse = instances.next()__			instances.remove()___			return new ImmutablePair<>(instanceToUse, Locality.UNCONSTRAINED)__		}_	};tries,to,find,a,requested,instance,if,no,such,instance,is,available,it,will,return,a,non,local,instance,if,no,such,instance,exists,all,slots,occupied,then,return,null,p,b,note,b,this,method,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,p,param,requested,locations,the,list,of,preferred,instances,may,be,null,or,empty,which,indicates,that,no,locality,preference,exists,param,local,only,flag,to,indicate,whether,only,one,of,the,exact,local,instances,can,be,chosen;private,pair,instance,locality,find,instance,iterable,task,manager,location,requested,locations,boolean,local,only,while,this,newly,available,instances,size,0,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,this,instances,with,available,resources,put,queued,instance,get,task,manager,id,queued,instance,if,this,instances,with,available,resources,is,empty,return,null,iterator,task,manager,location,locations,requested,locations,null,null,requested,locations,iterator,if,locations,null,locations,has,next,while,locations,has,next,task,manager,location,location,locations,next,if,location,null,instance,instance,instances,with,available,resources,remove,location,get,resource,id,if,instance,null,return,new,immutable,pair,instance,locality,instance,locality,local,if,local,only,return,null,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,unconstrained
Scheduler -> private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly);1474983187;Tries to find a requested instance. If no such instance is available it will return a non-_local instance. If no such instance exists (all slots occupied), then return null.__<p><b>NOTE:</b> This method is not thread-safe, it needs to be synchronized by the caller.</p>__@param requestedLocations The list of preferred instances. May be null or empty, which indicates that_no locality preference exists._@param localOnly Flag to indicate whether only one of the exact local instances can be chosen.;private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly) {_		_		_		while (this.newlyAvailableInstances.size() > 0) {_			Instance queuedInstance = this.newlyAvailableInstances.poll()__			if (queuedInstance != null) {_				this.instancesWithAvailableResources.put(queuedInstance.getTaskManagerID(), queuedInstance)__			}_		}_		_		_		if (this.instancesWithAvailableResources.isEmpty()) {_			return null__		}__		Iterator<TaskManagerLocation> locations = requestedLocations == null ? null : requestedLocations.iterator()___		if (locations != null && locations.hasNext()) {_			__			while (locations.hasNext()) {_				TaskManagerLocation location = locations.next()__				if (location != null) {_					Instance instance = instancesWithAvailableResources.remove(location.getResourceID())__					if (instance != null) {_						return new ImmutablePair<Instance, Locality>(instance, Locality.LOCAL)__					}_				}_			}_			_			_			if (localOnly) {_				return null__			}_			else {_				_				Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__				Instance instanceToUse = instances.next()__				instances.remove()___				return new ImmutablePair<>(instanceToUse, Locality.NON_LOCAL)__			}_		}_		else {_			_			Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__			Instance instanceToUse = instances.next()__			instances.remove()___			return new ImmutablePair<>(instanceToUse, Locality.UNCONSTRAINED)__		}_	};tries,to,find,a,requested,instance,if,no,such,instance,is,available,it,will,return,a,non,local,instance,if,no,such,instance,exists,all,slots,occupied,then,return,null,p,b,note,b,this,method,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,p,param,requested,locations,the,list,of,preferred,instances,may,be,null,or,empty,which,indicates,that,no,locality,preference,exists,param,local,only,flag,to,indicate,whether,only,one,of,the,exact,local,instances,can,be,chosen;private,pair,instance,locality,find,instance,iterable,task,manager,location,requested,locations,boolean,local,only,while,this,newly,available,instances,size,0,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,this,instances,with,available,resources,put,queued,instance,get,task,manager,id,queued,instance,if,this,instances,with,available,resources,is,empty,return,null,iterator,task,manager,location,locations,requested,locations,null,null,requested,locations,iterator,if,locations,null,locations,has,next,while,locations,has,next,task,manager,location,location,locations,next,if,location,null,instance,instance,instances,with,available,resources,remove,location,get,resource,id,if,instance,null,return,new,immutable,pair,instance,locality,instance,locality,local,if,local,only,return,null,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,unconstrained
Scheduler -> private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly);1485888959;Tries to find a requested instance. If no such instance is available it will return a non-_local instance. If no such instance exists (all slots occupied), then return null.__<p><b>NOTE:</b> This method is not thread-safe, it needs to be synchronized by the caller.</p>__@param requestedLocations The list of preferred instances. May be null or empty, which indicates that_no locality preference exists._@param localOnly Flag to indicate whether only one of the exact local instances can be chosen.;private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly) {_		_		_		while (this.newlyAvailableInstances.size() > 0) {_			Instance queuedInstance = this.newlyAvailableInstances.poll()__			if (queuedInstance != null) {_				this.instancesWithAvailableResources.put(queuedInstance.getTaskManagerID(), queuedInstance)__			}_		}_		_		_		if (this.instancesWithAvailableResources.isEmpty()) {_			return null__		}__		Iterator<TaskManagerLocation> locations = requestedLocations == null ? null : requestedLocations.iterator()___		if (locations != null && locations.hasNext()) {_			__			while (locations.hasNext()) {_				TaskManagerLocation location = locations.next()__				if (location != null) {_					Instance instance = instancesWithAvailableResources.remove(location.getResourceID())__					if (instance != null) {_						return new ImmutablePair<Instance, Locality>(instance, Locality.LOCAL)__					}_				}_			}_			_			_			if (localOnly) {_				return null__			}_			else {_				_				Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__				Instance instanceToUse = instances.next()__				instances.remove()___				return new ImmutablePair<>(instanceToUse, Locality.NON_LOCAL)__			}_		}_		else {_			_			Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__			Instance instanceToUse = instances.next()__			instances.remove()___			return new ImmutablePair<>(instanceToUse, Locality.UNCONSTRAINED)__		}_	};tries,to,find,a,requested,instance,if,no,such,instance,is,available,it,will,return,a,non,local,instance,if,no,such,instance,exists,all,slots,occupied,then,return,null,p,b,note,b,this,method,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,p,param,requested,locations,the,list,of,preferred,instances,may,be,null,or,empty,which,indicates,that,no,locality,preference,exists,param,local,only,flag,to,indicate,whether,only,one,of,the,exact,local,instances,can,be,chosen;private,pair,instance,locality,find,instance,iterable,task,manager,location,requested,locations,boolean,local,only,while,this,newly,available,instances,size,0,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,this,instances,with,available,resources,put,queued,instance,get,task,manager,id,queued,instance,if,this,instances,with,available,resources,is,empty,return,null,iterator,task,manager,location,locations,requested,locations,null,null,requested,locations,iterator,if,locations,null,locations,has,next,while,locations,has,next,task,manager,location,location,locations,next,if,location,null,instance,instance,instances,with,available,resources,remove,location,get,resource,id,if,instance,null,return,new,immutable,pair,instance,locality,instance,locality,local,if,local,only,return,null,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,unconstrained
Scheduler -> private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly);1485891273;Tries to find a requested instance. If no such instance is available it will return a non-_local instance. If no such instance exists (all slots occupied), then return null.__<p><b>NOTE:</b> This method is not thread-safe, it needs to be synchronized by the caller.</p>__@param requestedLocations The list of preferred instances. May be null or empty, which indicates that_no locality preference exists._@param localOnly Flag to indicate whether only one of the exact local instances can be chosen.;private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly) {_		_		_		while (this.newlyAvailableInstances.size() > 0) {_			Instance queuedInstance = this.newlyAvailableInstances.poll()__			if (queuedInstance != null) {_				this.instancesWithAvailableResources.put(queuedInstance.getTaskManagerID(), queuedInstance)__			}_		}_		_		_		if (this.instancesWithAvailableResources.isEmpty()) {_			return null__		}__		Iterator<TaskManagerLocation> locations = requestedLocations == null ? null : requestedLocations.iterator()___		if (locations != null && locations.hasNext()) {_			__			while (locations.hasNext()) {_				TaskManagerLocation location = locations.next()__				if (location != null) {_					Instance instance = instancesWithAvailableResources.remove(location.getResourceID())__					if (instance != null) {_						return new ImmutablePair<Instance, Locality>(instance, Locality.LOCAL)__					}_				}_			}_			_			_			if (localOnly) {_				return null__			}_			else {_				_				Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__				Instance instanceToUse = instances.next()__				instances.remove()___				return new ImmutablePair<>(instanceToUse, Locality.NON_LOCAL)__			}_		}_		else {_			_			Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__			Instance instanceToUse = instances.next()__			instances.remove()___			return new ImmutablePair<>(instanceToUse, Locality.UNCONSTRAINED)__		}_	};tries,to,find,a,requested,instance,if,no,such,instance,is,available,it,will,return,a,non,local,instance,if,no,such,instance,exists,all,slots,occupied,then,return,null,p,b,note,b,this,method,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,p,param,requested,locations,the,list,of,preferred,instances,may,be,null,or,empty,which,indicates,that,no,locality,preference,exists,param,local,only,flag,to,indicate,whether,only,one,of,the,exact,local,instances,can,be,chosen;private,pair,instance,locality,find,instance,iterable,task,manager,location,requested,locations,boolean,local,only,while,this,newly,available,instances,size,0,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,this,instances,with,available,resources,put,queued,instance,get,task,manager,id,queued,instance,if,this,instances,with,available,resources,is,empty,return,null,iterator,task,manager,location,locations,requested,locations,null,null,requested,locations,iterator,if,locations,null,locations,has,next,while,locations,has,next,task,manager,location,location,locations,next,if,location,null,instance,instance,instances,with,available,resources,remove,location,get,resource,id,if,instance,null,return,new,immutable,pair,instance,locality,instance,locality,local,if,local,only,return,null,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,unconstrained
Scheduler -> private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly);1486663952;Tries to find a requested instance. If no such instance is available it will return a non-_local instance. If no such instance exists (all slots occupied), then return null.__<p><b>NOTE:</b> This method is not thread-safe, it needs to be synchronized by the caller.</p>__@param requestedLocations The list of preferred instances. May be null or empty, which indicates that_no locality preference exists._@param localOnly Flag to indicate whether only one of the exact local instances can be chosen.;private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly) {_		_		_		while (this.newlyAvailableInstances.size() > 0) {_			Instance queuedInstance = this.newlyAvailableInstances.poll()__			if (queuedInstance != null) {_				this.instancesWithAvailableResources.put(queuedInstance.getTaskManagerID(), queuedInstance)__			}_		}_		_		_		if (this.instancesWithAvailableResources.isEmpty()) {_			return null__		}__		Iterator<TaskManagerLocation> locations = requestedLocations == null ? null : requestedLocations.iterator()___		if (locations != null && locations.hasNext()) {_			__			while (locations.hasNext()) {_				TaskManagerLocation location = locations.next()__				if (location != null) {_					Instance instance = instancesWithAvailableResources.remove(location.getResourceID())__					if (instance != null) {_						return new ImmutablePair<Instance, Locality>(instance, Locality.LOCAL)__					}_				}_			}_			_			_			if (localOnly) {_				return null__			}_			else {_				_				Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__				Instance instanceToUse = instances.next()__				instances.remove()___				return new ImmutablePair<>(instanceToUse, Locality.NON_LOCAL)__			}_		}_		else {_			_			Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__			Instance instanceToUse = instances.next()__			instances.remove()___			return new ImmutablePair<>(instanceToUse, Locality.UNCONSTRAINED)__		}_	};tries,to,find,a,requested,instance,if,no,such,instance,is,available,it,will,return,a,non,local,instance,if,no,such,instance,exists,all,slots,occupied,then,return,null,p,b,note,b,this,method,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,p,param,requested,locations,the,list,of,preferred,instances,may,be,null,or,empty,which,indicates,that,no,locality,preference,exists,param,local,only,flag,to,indicate,whether,only,one,of,the,exact,local,instances,can,be,chosen;private,pair,instance,locality,find,instance,iterable,task,manager,location,requested,locations,boolean,local,only,while,this,newly,available,instances,size,0,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,this,instances,with,available,resources,put,queued,instance,get,task,manager,id,queued,instance,if,this,instances,with,available,resources,is,empty,return,null,iterator,task,manager,location,locations,requested,locations,null,null,requested,locations,iterator,if,locations,null,locations,has,next,while,locations,has,next,task,manager,location,location,locations,next,if,location,null,instance,instance,instances,with,available,resources,remove,location,get,resource,id,if,instance,null,return,new,immutable,pair,instance,locality,instance,locality,local,if,local,only,return,null,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,unconstrained
Scheduler -> private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly);1488299223;Tries to find a requested instance. If no such instance is available it will return a non-_local instance. If no such instance exists (all slots occupied), then return null.__<p><b>NOTE:</b> This method is not thread-safe, it needs to be synchronized by the caller.</p>__@param requestedLocations The list of preferred instances. May be null or empty, which indicates that_no locality preference exists._@param localOnly Flag to indicate whether only one of the exact local instances can be chosen.;private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly) {_		_		_		while (this.newlyAvailableInstances.size() > 0) {_			Instance queuedInstance = this.newlyAvailableInstances.poll()__			if (queuedInstance != null) {_				this.instancesWithAvailableResources.put(queuedInstance.getTaskManagerID(), queuedInstance)__			}_		}_		_		_		if (this.instancesWithAvailableResources.isEmpty()) {_			return null__		}__		Iterator<TaskManagerLocation> locations = requestedLocations == null ? null : requestedLocations.iterator()___		if (locations != null && locations.hasNext()) {_			__			while (locations.hasNext()) {_				TaskManagerLocation location = locations.next()__				if (location != null) {_					Instance instance = instancesWithAvailableResources.remove(location.getResourceID())__					if (instance != null) {_						return new ImmutablePair<Instance, Locality>(instance, Locality.LOCAL)__					}_				}_			}_			_			_			if (localOnly) {_				return null__			}_			else {_				_				Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__				Instance instanceToUse = instances.next()__				instances.remove()___				return new ImmutablePair<>(instanceToUse, Locality.NON_LOCAL)__			}_		}_		else {_			_			Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__			Instance instanceToUse = instances.next()__			instances.remove()___			return new ImmutablePair<>(instanceToUse, Locality.UNCONSTRAINED)__		}_	};tries,to,find,a,requested,instance,if,no,such,instance,is,available,it,will,return,a,non,local,instance,if,no,such,instance,exists,all,slots,occupied,then,return,null,p,b,note,b,this,method,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,p,param,requested,locations,the,list,of,preferred,instances,may,be,null,or,empty,which,indicates,that,no,locality,preference,exists,param,local,only,flag,to,indicate,whether,only,one,of,the,exact,local,instances,can,be,chosen;private,pair,instance,locality,find,instance,iterable,task,manager,location,requested,locations,boolean,local,only,while,this,newly,available,instances,size,0,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,this,instances,with,available,resources,put,queued,instance,get,task,manager,id,queued,instance,if,this,instances,with,available,resources,is,empty,return,null,iterator,task,manager,location,locations,requested,locations,null,null,requested,locations,iterator,if,locations,null,locations,has,next,while,locations,has,next,task,manager,location,location,locations,next,if,location,null,instance,instance,instances,with,available,resources,remove,location,get,resource,id,if,instance,null,return,new,immutable,pair,instance,locality,instance,locality,local,if,local,only,return,null,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,unconstrained
Scheduler -> private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly);1490819573;Tries to find a requested instance. If no such instance is available it will return a non-_local instance. If no such instance exists (all slots occupied), then return null.__<p><b>NOTE:</b> This method is not thread-safe, it needs to be synchronized by the caller.</p>__@param requestedLocations The list of preferred instances. May be null or empty, which indicates that_no locality preference exists._@param localOnly Flag to indicate whether only one of the exact local instances can be chosen.;private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly) {_		_		_		while (this.newlyAvailableInstances.size() > 0) {_			Instance queuedInstance = this.newlyAvailableInstances.poll()__			if (queuedInstance != null) {_				this.instancesWithAvailableResources.put(queuedInstance.getTaskManagerID(), queuedInstance)__			}_		}_		_		_		if (this.instancesWithAvailableResources.isEmpty()) {_			return null__		}__		Iterator<TaskManagerLocation> locations = requestedLocations == null ? null : requestedLocations.iterator()___		if (locations != null && locations.hasNext()) {_			__			while (locations.hasNext()) {_				TaskManagerLocation location = locations.next()__				if (location != null) {_					Instance instance = instancesWithAvailableResources.remove(location.getResourceID())__					if (instance != null) {_						return new ImmutablePair<Instance, Locality>(instance, Locality.LOCAL)__					}_				}_			}_			_			_			if (localOnly) {_				return null__			}_			else {_				_				Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__				Instance instanceToUse = instances.next()__				instances.remove()___				return new ImmutablePair<>(instanceToUse, Locality.NON_LOCAL)__			}_		}_		else {_			_			Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__			Instance instanceToUse = instances.next()__			instances.remove()___			return new ImmutablePair<>(instanceToUse, Locality.UNCONSTRAINED)__		}_	};tries,to,find,a,requested,instance,if,no,such,instance,is,available,it,will,return,a,non,local,instance,if,no,such,instance,exists,all,slots,occupied,then,return,null,p,b,note,b,this,method,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,p,param,requested,locations,the,list,of,preferred,instances,may,be,null,or,empty,which,indicates,that,no,locality,preference,exists,param,local,only,flag,to,indicate,whether,only,one,of,the,exact,local,instances,can,be,chosen;private,pair,instance,locality,find,instance,iterable,task,manager,location,requested,locations,boolean,local,only,while,this,newly,available,instances,size,0,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,this,instances,with,available,resources,put,queued,instance,get,task,manager,id,queued,instance,if,this,instances,with,available,resources,is,empty,return,null,iterator,task,manager,location,locations,requested,locations,null,null,requested,locations,iterator,if,locations,null,locations,has,next,while,locations,has,next,task,manager,location,location,locations,next,if,location,null,instance,instance,instances,with,available,resources,remove,location,get,resource,id,if,instance,null,return,new,immutable,pair,instance,locality,instance,locality,local,if,local,only,return,null,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,unconstrained
Scheduler -> private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly);1501519020;Tries to find a requested instance. If no such instance is available it will return a non-_local instance. If no such instance exists (all slots occupied), then return null.__<p><b>NOTE:</b> This method is not thread-safe, it needs to be synchronized by the caller.</p>__@param requestedLocations The list of preferred instances. May be null or empty, which indicates that_no locality preference exists._@param localOnly Flag to indicate whether only one of the exact local instances can be chosen.;private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly) {_		_		_		while (this.newlyAvailableInstances.size() > 0) {_			Instance queuedInstance = this.newlyAvailableInstances.poll()__			if (queuedInstance != null) {_				this.instancesWithAvailableResources.put(queuedInstance.getTaskManagerID(), queuedInstance)__			}_		}_		_		_		if (this.instancesWithAvailableResources.isEmpty()) {_			return null__		}__		Iterator<TaskManagerLocation> locations = requestedLocations == null ? null : requestedLocations.iterator()___		if (locations != null && locations.hasNext()) {_			__			while (locations.hasNext()) {_				TaskManagerLocation location = locations.next()__				if (location != null) {_					Instance instance = instancesWithAvailableResources.remove(location.getResourceID())__					if (instance != null) {_						return new ImmutablePair<Instance, Locality>(instance, Locality.LOCAL)__					}_				}_			}_			_			_			if (localOnly) {_				return null__			}_			else {_				_				Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__				Instance instanceToUse = instances.next()__				instances.remove()___				return new ImmutablePair<>(instanceToUse, Locality.NON_LOCAL)__			}_		}_		else {_			_			Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__			Instance instanceToUse = instances.next()__			instances.remove()___			return new ImmutablePair<>(instanceToUse, Locality.UNCONSTRAINED)__		}_	};tries,to,find,a,requested,instance,if,no,such,instance,is,available,it,will,return,a,non,local,instance,if,no,such,instance,exists,all,slots,occupied,then,return,null,p,b,note,b,this,method,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,p,param,requested,locations,the,list,of,preferred,instances,may,be,null,or,empty,which,indicates,that,no,locality,preference,exists,param,local,only,flag,to,indicate,whether,only,one,of,the,exact,local,instances,can,be,chosen;private,pair,instance,locality,find,instance,iterable,task,manager,location,requested,locations,boolean,local,only,while,this,newly,available,instances,size,0,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,this,instances,with,available,resources,put,queued,instance,get,task,manager,id,queued,instance,if,this,instances,with,available,resources,is,empty,return,null,iterator,task,manager,location,locations,requested,locations,null,null,requested,locations,iterator,if,locations,null,locations,has,next,while,locations,has,next,task,manager,location,location,locations,next,if,location,null,instance,instance,instances,with,available,resources,remove,location,get,resource,id,if,instance,null,return,new,immutable,pair,instance,locality,instance,locality,local,if,local,only,return,null,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,unconstrained
Scheduler -> private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly);1508155453;Tries to find a requested instance. If no such instance is available it will return a non-_local instance. If no such instance exists (all slots occupied), then return null.__<p><b>NOTE:</b> This method is not thread-safe, it needs to be synchronized by the caller.</p>__@param requestedLocations The list of preferred instances. May be null or empty, which indicates that_no locality preference exists._@param localOnly Flag to indicate whether only one of the exact local instances can be chosen.;private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly) {_		_		_		while (this.newlyAvailableInstances.size() > 0) {_			Instance queuedInstance = this.newlyAvailableInstances.poll()__			if (queuedInstance != null) {_				this.instancesWithAvailableResources.put(queuedInstance.getTaskManagerID(), queuedInstance)__			}_		}_		_		_		if (this.instancesWithAvailableResources.isEmpty()) {_			return null__		}__		Iterator<TaskManagerLocation> locations = requestedLocations == null ? null : requestedLocations.iterator()___		if (locations != null && locations.hasNext()) {_			__			while (locations.hasNext()) {_				TaskManagerLocation location = locations.next()__				if (location != null) {_					Instance instance = instancesWithAvailableResources.remove(location.getResourceID())__					if (instance != null) {_						return new ImmutablePair<Instance, Locality>(instance, Locality.LOCAL)__					}_				}_			}_			_			_			if (localOnly) {_				return null__			}_			else {_				_				Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__				Instance instanceToUse = instances.next()__				instances.remove()___				return new ImmutablePair<>(instanceToUse, Locality.NON_LOCAL)__			}_		}_		else {_			_			Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__			Instance instanceToUse = instances.next()__			instances.remove()___			return new ImmutablePair<>(instanceToUse, Locality.UNCONSTRAINED)__		}_	};tries,to,find,a,requested,instance,if,no,such,instance,is,available,it,will,return,a,non,local,instance,if,no,such,instance,exists,all,slots,occupied,then,return,null,p,b,note,b,this,method,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,p,param,requested,locations,the,list,of,preferred,instances,may,be,null,or,empty,which,indicates,that,no,locality,preference,exists,param,local,only,flag,to,indicate,whether,only,one,of,the,exact,local,instances,can,be,chosen;private,pair,instance,locality,find,instance,iterable,task,manager,location,requested,locations,boolean,local,only,while,this,newly,available,instances,size,0,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,this,instances,with,available,resources,put,queued,instance,get,task,manager,id,queued,instance,if,this,instances,with,available,resources,is,empty,return,null,iterator,task,manager,location,locations,requested,locations,null,null,requested,locations,iterator,if,locations,null,locations,has,next,while,locations,has,next,task,manager,location,location,locations,next,if,location,null,instance,instance,instances,with,available,resources,remove,location,get,resource,id,if,instance,null,return,new,immutable,pair,instance,locality,instance,locality,local,if,local,only,return,null,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,unconstrained
Scheduler -> private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly);1509090423;Tries to find a requested instance. If no such instance is available it will return a non-_local instance. If no such instance exists (all slots occupied), then return null.__<p><b>NOTE:</b> This method is not thread-safe, it needs to be synchronized by the caller.</p>__@param requestedLocations The list of preferred instances. May be null or empty, which indicates that_no locality preference exists._@param localOnly Flag to indicate whether only one of the exact local instances can be chosen.;private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly) {_		_		_		while (this.newlyAvailableInstances.size() > 0) {_			Instance queuedInstance = this.newlyAvailableInstances.poll()__			if (queuedInstance != null) {_				this.instancesWithAvailableResources.put(queuedInstance.getTaskManagerID(), queuedInstance)__			}_		}_		_		_		if (this.instancesWithAvailableResources.isEmpty()) {_			return null__		}__		Iterator<TaskManagerLocation> locations = requestedLocations == null ? null : requestedLocations.iterator()___		if (locations != null && locations.hasNext()) {_			__			while (locations.hasNext()) {_				TaskManagerLocation location = locations.next()__				if (location != null) {_					Instance instance = instancesWithAvailableResources.remove(location.getResourceID())__					if (instance != null) {_						return new ImmutablePair<Instance, Locality>(instance, Locality.LOCAL)__					}_				}_			}_			_			_			if (localOnly) {_				return null__			}_			else {_				_				Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__				Instance instanceToUse = instances.next()__				instances.remove()___				return new ImmutablePair<>(instanceToUse, Locality.NON_LOCAL)__			}_		}_		else {_			_			Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__			Instance instanceToUse = instances.next()__			instances.remove()___			return new ImmutablePair<>(instanceToUse, Locality.UNCONSTRAINED)__		}_	};tries,to,find,a,requested,instance,if,no,such,instance,is,available,it,will,return,a,non,local,instance,if,no,such,instance,exists,all,slots,occupied,then,return,null,p,b,note,b,this,method,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,p,param,requested,locations,the,list,of,preferred,instances,may,be,null,or,empty,which,indicates,that,no,locality,preference,exists,param,local,only,flag,to,indicate,whether,only,one,of,the,exact,local,instances,can,be,chosen;private,pair,instance,locality,find,instance,iterable,task,manager,location,requested,locations,boolean,local,only,while,this,newly,available,instances,size,0,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,this,instances,with,available,resources,put,queued,instance,get,task,manager,id,queued,instance,if,this,instances,with,available,resources,is,empty,return,null,iterator,task,manager,location,locations,requested,locations,null,null,requested,locations,iterator,if,locations,null,locations,has,next,while,locations,has,next,task,manager,location,location,locations,next,if,location,null,instance,instance,instances,with,available,resources,remove,location,get,resource,id,if,instance,null,return,new,immutable,pair,instance,locality,instance,locality,local,if,local,only,return,null,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,unconstrained
Scheduler -> private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly);1510699852;Tries to find a requested instance. If no such instance is available it will return a non-_local instance. If no such instance exists (all slots occupied), then return null.__<p><b>NOTE:</b> This method is not thread-safe, it needs to be synchronized by the caller.</p>__@param requestedLocations The list of preferred instances. May be null or empty, which indicates that_no locality preference exists._@param localOnly Flag to indicate whether only one of the exact local instances can be chosen.;private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly) {_		_		_		while (this.newlyAvailableInstances.size() > 0) {_			Instance queuedInstance = this.newlyAvailableInstances.poll()__			if (queuedInstance != null) {_				this.instancesWithAvailableResources.put(queuedInstance.getTaskManagerID(), queuedInstance)__			}_		}_		_		_		if (this.instancesWithAvailableResources.isEmpty()) {_			return null__		}__		Iterator<TaskManagerLocation> locations = requestedLocations == null ? null : requestedLocations.iterator()___		if (locations != null && locations.hasNext()) {_			__			while (locations.hasNext()) {_				TaskManagerLocation location = locations.next()__				if (location != null) {_					Instance instance = instancesWithAvailableResources.remove(location.getResourceID())__					if (instance != null) {_						return new ImmutablePair<Instance, Locality>(instance, Locality.LOCAL)__					}_				}_			}_			_			_			if (localOnly) {_				return null__			}_			else {_				_				Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__				Instance instanceToUse = instances.next()__				instances.remove()___				return new ImmutablePair<>(instanceToUse, Locality.NON_LOCAL)__			}_		}_		else {_			_			Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__			Instance instanceToUse = instances.next()__			instances.remove()___			return new ImmutablePair<>(instanceToUse, Locality.UNCONSTRAINED)__		}_	};tries,to,find,a,requested,instance,if,no,such,instance,is,available,it,will,return,a,non,local,instance,if,no,such,instance,exists,all,slots,occupied,then,return,null,p,b,note,b,this,method,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,p,param,requested,locations,the,list,of,preferred,instances,may,be,null,or,empty,which,indicates,that,no,locality,preference,exists,param,local,only,flag,to,indicate,whether,only,one,of,the,exact,local,instances,can,be,chosen;private,pair,instance,locality,find,instance,iterable,task,manager,location,requested,locations,boolean,local,only,while,this,newly,available,instances,size,0,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,this,instances,with,available,resources,put,queued,instance,get,task,manager,id,queued,instance,if,this,instances,with,available,resources,is,empty,return,null,iterator,task,manager,location,locations,requested,locations,null,null,requested,locations,iterator,if,locations,null,locations,has,next,while,locations,has,next,task,manager,location,location,locations,next,if,location,null,instance,instance,instances,with,available,resources,remove,location,get,resource,id,if,instance,null,return,new,immutable,pair,instance,locality,instance,locality,local,if,local,only,return,null,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,unconstrained
Scheduler -> private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly);1510752027;Tries to find a requested instance. If no such instance is available it will return a non-_local instance. If no such instance exists (all slots occupied), then return null.__<p><b>NOTE:</b> This method is not thread-safe, it needs to be synchronized by the caller.</p>__@param requestedLocations The list of preferred instances. May be null or empty, which indicates that_no locality preference exists._@param localOnly Flag to indicate whether only one of the exact local instances can be chosen.;private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly) {_		_		_		while (this.newlyAvailableInstances.size() > 0) {_			Instance queuedInstance = this.newlyAvailableInstances.poll()__			if (queuedInstance != null) {_				this.instancesWithAvailableResources.put(queuedInstance.getTaskManagerID(), queuedInstance)__			}_		}_		_		_		if (this.instancesWithAvailableResources.isEmpty()) {_			return null__		}__		Iterator<TaskManagerLocation> locations = requestedLocations == null ? null : requestedLocations.iterator()___		if (locations != null && locations.hasNext()) {_			__			while (locations.hasNext()) {_				TaskManagerLocation location = locations.next()__				if (location != null) {_					Instance instance = instancesWithAvailableResources.remove(location.getResourceID())__					if (instance != null) {_						return new ImmutablePair<Instance, Locality>(instance, Locality.LOCAL)__					}_				}_			}_			_			_			if (localOnly) {_				return null__			}_			else {_				_				Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__				Instance instanceToUse = instances.next()__				instances.remove()___				return new ImmutablePair<>(instanceToUse, Locality.NON_LOCAL)__			}_		}_		else {_			_			Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__			Instance instanceToUse = instances.next()__			instances.remove()___			return new ImmutablePair<>(instanceToUse, Locality.UNCONSTRAINED)__		}_	};tries,to,find,a,requested,instance,if,no,such,instance,is,available,it,will,return,a,non,local,instance,if,no,such,instance,exists,all,slots,occupied,then,return,null,p,b,note,b,this,method,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,p,param,requested,locations,the,list,of,preferred,instances,may,be,null,or,empty,which,indicates,that,no,locality,preference,exists,param,local,only,flag,to,indicate,whether,only,one,of,the,exact,local,instances,can,be,chosen;private,pair,instance,locality,find,instance,iterable,task,manager,location,requested,locations,boolean,local,only,while,this,newly,available,instances,size,0,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,this,instances,with,available,resources,put,queued,instance,get,task,manager,id,queued,instance,if,this,instances,with,available,resources,is,empty,return,null,iterator,task,manager,location,locations,requested,locations,null,null,requested,locations,iterator,if,locations,null,locations,has,next,while,locations,has,next,task,manager,location,location,locations,next,if,location,null,instance,instance,instances,with,available,resources,remove,location,get,resource,id,if,instance,null,return,new,immutable,pair,instance,locality,instance,locality,local,if,local,only,return,null,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,unconstrained
Scheduler -> private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly);1511543029;Tries to find a requested instance. If no such instance is available it will return a non-_local instance. If no such instance exists (all slots occupied), then return null.__<p><b>NOTE:</b> This method is not thread-safe, it needs to be synchronized by the caller.</p>__@param requestedLocations The list of preferred instances. May be null or empty, which indicates that_no locality preference exists._@param localOnly Flag to indicate whether only one of the exact local instances can be chosen.;private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly) {_		_		_		while (this.newlyAvailableInstances.size() > 0) {_			Instance queuedInstance = this.newlyAvailableInstances.poll()__			if (queuedInstance != null) {_				this.instancesWithAvailableResources.put(queuedInstance.getTaskManagerID(), queuedInstance)__			}_		}_		_		_		if (this.instancesWithAvailableResources.isEmpty()) {_			return null__		}__		Iterator<TaskManagerLocation> locations = requestedLocations == null ? null : requestedLocations.iterator()___		if (locations != null && locations.hasNext()) {_			__			while (locations.hasNext()) {_				TaskManagerLocation location = locations.next()__				if (location != null) {_					Instance instance = instancesWithAvailableResources.remove(location.getResourceID())__					if (instance != null) {_						return new ImmutablePair<Instance, Locality>(instance, Locality.LOCAL)__					}_				}_			}_			_			_			if (localOnly) {_				return null__			}_			else {_				_				Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__				Instance instanceToUse = instances.next()__				instances.remove()___				return new ImmutablePair<>(instanceToUse, Locality.NON_LOCAL)__			}_		}_		else {_			_			Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__			Instance instanceToUse = instances.next()__			instances.remove()___			return new ImmutablePair<>(instanceToUse, Locality.UNCONSTRAINED)__		}_	};tries,to,find,a,requested,instance,if,no,such,instance,is,available,it,will,return,a,non,local,instance,if,no,such,instance,exists,all,slots,occupied,then,return,null,p,b,note,b,this,method,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,p,param,requested,locations,the,list,of,preferred,instances,may,be,null,or,empty,which,indicates,that,no,locality,preference,exists,param,local,only,flag,to,indicate,whether,only,one,of,the,exact,local,instances,can,be,chosen;private,pair,instance,locality,find,instance,iterable,task,manager,location,requested,locations,boolean,local,only,while,this,newly,available,instances,size,0,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,this,instances,with,available,resources,put,queued,instance,get,task,manager,id,queued,instance,if,this,instances,with,available,resources,is,empty,return,null,iterator,task,manager,location,locations,requested,locations,null,null,requested,locations,iterator,if,locations,null,locations,has,next,while,locations,has,next,task,manager,location,location,locations,next,if,location,null,instance,instance,instances,with,available,resources,remove,location,get,resource,id,if,instance,null,return,new,immutable,pair,instance,locality,instance,locality,local,if,local,only,return,null,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,unconstrained
Scheduler -> private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly);1513261475;Tries to find a requested instance. If no such instance is available it will return a non-_local instance. If no such instance exists (all slots occupied), then return null.__<p><b>NOTE:</b> This method is not thread-safe, it needs to be synchronized by the caller.</p>__@param requestedLocations The list of preferred instances. May be null or empty, which indicates that_no locality preference exists._@param localOnly Flag to indicate whether only one of the exact local instances can be chosen.;private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly) {_		_		_		while (this.newlyAvailableInstances.size() > 0) {_			Instance queuedInstance = this.newlyAvailableInstances.poll()__			if (queuedInstance != null) {_				this.instancesWithAvailableResources.put(queuedInstance.getTaskManagerID(), queuedInstance)__			}_		}_		_		_		if (this.instancesWithAvailableResources.isEmpty()) {_			return null__		}__		Iterator<TaskManagerLocation> locations = requestedLocations == null ? null : requestedLocations.iterator()___		if (locations != null && locations.hasNext()) {_			__			while (locations.hasNext()) {_				TaskManagerLocation location = locations.next()__				if (location != null) {_					Instance instance = instancesWithAvailableResources.remove(location.getResourceID())__					if (instance != null) {_						return new ImmutablePair<Instance, Locality>(instance, Locality.LOCAL)__					}_				}_			}_			_			_			if (localOnly) {_				return null__			}_			else {_				_				Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__				Instance instanceToUse = instances.next()__				instances.remove()___				return new ImmutablePair<>(instanceToUse, Locality.NON_LOCAL)__			}_		}_		else {_			_			Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__			Instance instanceToUse = instances.next()__			instances.remove()___			return new ImmutablePair<>(instanceToUse, Locality.UNCONSTRAINED)__		}_	};tries,to,find,a,requested,instance,if,no,such,instance,is,available,it,will,return,a,non,local,instance,if,no,such,instance,exists,all,slots,occupied,then,return,null,p,b,note,b,this,method,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,p,param,requested,locations,the,list,of,preferred,instances,may,be,null,or,empty,which,indicates,that,no,locality,preference,exists,param,local,only,flag,to,indicate,whether,only,one,of,the,exact,local,instances,can,be,chosen;private,pair,instance,locality,find,instance,iterable,task,manager,location,requested,locations,boolean,local,only,while,this,newly,available,instances,size,0,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,this,instances,with,available,resources,put,queued,instance,get,task,manager,id,queued,instance,if,this,instances,with,available,resources,is,empty,return,null,iterator,task,manager,location,locations,requested,locations,null,null,requested,locations,iterator,if,locations,null,locations,has,next,while,locations,has,next,task,manager,location,location,locations,next,if,location,null,instance,instance,instances,with,available,resources,remove,location,get,resource,id,if,instance,null,return,new,immutable,pair,instance,locality,instance,locality,local,if,local,only,return,null,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,unconstrained
Scheduler -> private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly);1517497348;Tries to find a requested instance. If no such instance is available it will return a non-_local instance. If no such instance exists (all slots occupied), then return null.__<p><b>NOTE:</b> This method is not thread-safe, it needs to be synchronized by the caller.</p>__@param requestedLocations The list of preferred instances. May be null or empty, which indicates that_no locality preference exists._@param localOnly Flag to indicate whether only one of the exact local instances can be chosen.;private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly) {_		_		_		while (this.newlyAvailableInstances.size() > 0) {_			Instance queuedInstance = this.newlyAvailableInstances.poll()__			if (queuedInstance != null) {_				this.instancesWithAvailableResources.put(queuedInstance.getTaskManagerID(), queuedInstance)__			}_		}_		_		_		if (this.instancesWithAvailableResources.isEmpty()) {_			return null__		}__		Iterator<TaskManagerLocation> locations = requestedLocations == null ? null : requestedLocations.iterator()___		if (locations != null && locations.hasNext()) {_			__			while (locations.hasNext()) {_				TaskManagerLocation location = locations.next()__				if (location != null) {_					Instance instance = instancesWithAvailableResources.remove(location.getResourceID())__					if (instance != null) {_						return new ImmutablePair<Instance, Locality>(instance, Locality.LOCAL)__					}_				}_			}_			_			_			if (localOnly) {_				return null__			}_			else {_				_				Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__				Instance instanceToUse = instances.next()__				instances.remove()___				return new ImmutablePair<>(instanceToUse, Locality.NON_LOCAL)__			}_		}_		else {_			_			Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__			Instance instanceToUse = instances.next()__			instances.remove()___			return new ImmutablePair<>(instanceToUse, Locality.UNCONSTRAINED)__		}_	};tries,to,find,a,requested,instance,if,no,such,instance,is,available,it,will,return,a,non,local,instance,if,no,such,instance,exists,all,slots,occupied,then,return,null,p,b,note,b,this,method,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,p,param,requested,locations,the,list,of,preferred,instances,may,be,null,or,empty,which,indicates,that,no,locality,preference,exists,param,local,only,flag,to,indicate,whether,only,one,of,the,exact,local,instances,can,be,chosen;private,pair,instance,locality,find,instance,iterable,task,manager,location,requested,locations,boolean,local,only,while,this,newly,available,instances,size,0,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,this,instances,with,available,resources,put,queued,instance,get,task,manager,id,queued,instance,if,this,instances,with,available,resources,is,empty,return,null,iterator,task,manager,location,locations,requested,locations,null,null,requested,locations,iterator,if,locations,null,locations,has,next,while,locations,has,next,task,manager,location,location,locations,next,if,location,null,instance,instance,instances,with,available,resources,remove,location,get,resource,id,if,instance,null,return,new,immutable,pair,instance,locality,instance,locality,local,if,local,only,return,null,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,unconstrained
Scheduler -> private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly);1518522104;Tries to find a requested instance. If no such instance is available it will return a non-_local instance. If no such instance exists (all slots occupied), then return null.__<p><b>NOTE:</b> This method is not thread-safe, it needs to be synchronized by the caller.</p>__@param requestedLocations The list of preferred instances. May be null or empty, which indicates that_no locality preference exists._@param localOnly Flag to indicate whether only one of the exact local instances can be chosen.;private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly) {_		_		_		while (this.newlyAvailableInstances.size() > 0) {_			Instance queuedInstance = this.newlyAvailableInstances.poll()__			if (queuedInstance != null) {_				this.instancesWithAvailableResources.put(queuedInstance.getTaskManagerID(), queuedInstance)__			}_		}_		_		_		if (this.instancesWithAvailableResources.isEmpty()) {_			return null__		}__		Iterator<TaskManagerLocation> locations = requestedLocations == null ? null : requestedLocations.iterator()___		if (locations != null && locations.hasNext()) {_			__			while (locations.hasNext()) {_				TaskManagerLocation location = locations.next()__				if (location != null) {_					Instance instance = instancesWithAvailableResources.remove(location.getResourceID())__					if (instance != null) {_						return new ImmutablePair<Instance, Locality>(instance, Locality.LOCAL)__					}_				}_			}_			_			_			if (localOnly) {_				return null__			}_			else {_				_				Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__				Instance instanceToUse = instances.next()__				instances.remove()___				return new ImmutablePair<>(instanceToUse, Locality.NON_LOCAL)__			}_		}_		else {_			_			Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__			Instance instanceToUse = instances.next()__			instances.remove()___			return new ImmutablePair<>(instanceToUse, Locality.UNCONSTRAINED)__		}_	};tries,to,find,a,requested,instance,if,no,such,instance,is,available,it,will,return,a,non,local,instance,if,no,such,instance,exists,all,slots,occupied,then,return,null,p,b,note,b,this,method,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,p,param,requested,locations,the,list,of,preferred,instances,may,be,null,or,empty,which,indicates,that,no,locality,preference,exists,param,local,only,flag,to,indicate,whether,only,one,of,the,exact,local,instances,can,be,chosen;private,pair,instance,locality,find,instance,iterable,task,manager,location,requested,locations,boolean,local,only,while,this,newly,available,instances,size,0,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,this,instances,with,available,resources,put,queued,instance,get,task,manager,id,queued,instance,if,this,instances,with,available,resources,is,empty,return,null,iterator,task,manager,location,locations,requested,locations,null,null,requested,locations,iterator,if,locations,null,locations,has,next,while,locations,has,next,task,manager,location,location,locations,next,if,location,null,instance,instance,instances,with,available,resources,remove,location,get,resource,id,if,instance,null,return,new,immutable,pair,instance,locality,instance,locality,local,if,local,only,return,null,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,unconstrained
Scheduler -> private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly);1519315265;Tries to find a requested instance. If no such instance is available it will return a non-_local instance. If no such instance exists (all slots occupied), then return null.__<p><b>NOTE:</b> This method is not thread-safe, it needs to be synchronized by the caller.</p>__@param requestedLocations The list of preferred instances. May be null or empty, which indicates that_no locality preference exists._@param localOnly Flag to indicate whether only one of the exact local instances can be chosen.;private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly) {_		_		_		while (this.newlyAvailableInstances.size() > 0) {_			Instance queuedInstance = this.newlyAvailableInstances.poll()__			if (queuedInstance != null) {_				this.instancesWithAvailableResources.put(queuedInstance.getTaskManagerID(), queuedInstance)__			}_		}_		_		_		if (this.instancesWithAvailableResources.isEmpty()) {_			return null__		}__		Iterator<TaskManagerLocation> locations = requestedLocations == null ? null : requestedLocations.iterator()___		if (locations != null && locations.hasNext()) {_			__			while (locations.hasNext()) {_				TaskManagerLocation location = locations.next()__				if (location != null) {_					Instance instance = instancesWithAvailableResources.remove(location.getResourceID())__					if (instance != null) {_						return new ImmutablePair<Instance, Locality>(instance, Locality.LOCAL)__					}_				}_			}_			_			_			if (localOnly) {_				return null__			}_			else {_				_				Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__				Instance instanceToUse = instances.next()__				instances.remove()___				return new ImmutablePair<>(instanceToUse, Locality.NON_LOCAL)__			}_		}_		else {_			_			Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__			Instance instanceToUse = instances.next()__			instances.remove()___			return new ImmutablePair<>(instanceToUse, Locality.UNCONSTRAINED)__		}_	};tries,to,find,a,requested,instance,if,no,such,instance,is,available,it,will,return,a,non,local,instance,if,no,such,instance,exists,all,slots,occupied,then,return,null,p,b,note,b,this,method,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,p,param,requested,locations,the,list,of,preferred,instances,may,be,null,or,empty,which,indicates,that,no,locality,preference,exists,param,local,only,flag,to,indicate,whether,only,one,of,the,exact,local,instances,can,be,chosen;private,pair,instance,locality,find,instance,iterable,task,manager,location,requested,locations,boolean,local,only,while,this,newly,available,instances,size,0,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,this,instances,with,available,resources,put,queued,instance,get,task,manager,id,queued,instance,if,this,instances,with,available,resources,is,empty,return,null,iterator,task,manager,location,locations,requested,locations,null,null,requested,locations,iterator,if,locations,null,locations,has,next,while,locations,has,next,task,manager,location,location,locations,next,if,location,null,instance,instance,instances,with,available,resources,remove,location,get,resource,id,if,instance,null,return,new,immutable,pair,instance,locality,instance,locality,local,if,local,only,return,null,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,unconstrained
Scheduler -> private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly);1538764056;Tries to find a requested instance. If no such instance is available it will return a non-_local instance. If no such instance exists (all slots occupied), then return null.__<p><b>NOTE:</b> This method is not thread-safe, it needs to be synchronized by the caller.</p>__@param requestedLocations The list of preferred instances. May be null or empty, which indicates that_no locality preference exists._@param localOnly Flag to indicate whether only one of the exact local instances can be chosen.;private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly) {_		_		_		while (this.newlyAvailableInstances.size() > 0) {_			Instance queuedInstance = this.newlyAvailableInstances.poll()__			if (queuedInstance != null) {_				this.instancesWithAvailableResources.put(queuedInstance.getTaskManagerID(), queuedInstance)__			}_		}_		_		_		if (this.instancesWithAvailableResources.isEmpty()) {_			return null__		}__		Iterator<TaskManagerLocation> locations = requestedLocations == null ? null : requestedLocations.iterator()___		if (locations != null && locations.hasNext()) {_			__			while (locations.hasNext()) {_				TaskManagerLocation location = locations.next()__				if (location != null) {_					Instance instance = instancesWithAvailableResources.remove(location.getResourceID())__					if (instance != null) {_						return new ImmutablePair<Instance, Locality>(instance, Locality.LOCAL)__					}_				}_			}_			_			_			if (localOnly) {_				return null__			}_			else {_				_				Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__				Instance instanceToUse = instances.next()__				instances.remove()___				return new ImmutablePair<>(instanceToUse, Locality.NON_LOCAL)__			}_		}_		else {_			_			Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__			Instance instanceToUse = instances.next()__			instances.remove()___			return new ImmutablePair<>(instanceToUse, Locality.UNCONSTRAINED)__		}_	};tries,to,find,a,requested,instance,if,no,such,instance,is,available,it,will,return,a,non,local,instance,if,no,such,instance,exists,all,slots,occupied,then,return,null,p,b,note,b,this,method,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,p,param,requested,locations,the,list,of,preferred,instances,may,be,null,or,empty,which,indicates,that,no,locality,preference,exists,param,local,only,flag,to,indicate,whether,only,one,of,the,exact,local,instances,can,be,chosen;private,pair,instance,locality,find,instance,iterable,task,manager,location,requested,locations,boolean,local,only,while,this,newly,available,instances,size,0,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,this,instances,with,available,resources,put,queued,instance,get,task,manager,id,queued,instance,if,this,instances,with,available,resources,is,empty,return,null,iterator,task,manager,location,locations,requested,locations,null,null,requested,locations,iterator,if,locations,null,locations,has,next,while,locations,has,next,task,manager,location,location,locations,next,if,location,null,instance,instance,instances,with,available,resources,remove,location,get,resource,id,if,instance,null,return,new,immutable,pair,instance,locality,instance,locality,local,if,local,only,return,null,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,unconstrained
Scheduler -> private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly);1543229263;Tries to find a requested instance. If no such instance is available it will return a non-_local instance. If no such instance exists (all slots occupied), then return null.__<p><b>NOTE:</b> This method is not thread-safe, it needs to be synchronized by the caller.</p>__@param requestedLocations The list of preferred instances. May be null or empty, which indicates that_no locality preference exists._@param localOnly Flag to indicate whether only one of the exact local instances can be chosen.;private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly) {_		_		_		while (this.newlyAvailableInstances.size() > 0) {_			Instance queuedInstance = this.newlyAvailableInstances.poll()__			if (queuedInstance != null) {_				this.instancesWithAvailableResources.put(queuedInstance.getTaskManagerID(), queuedInstance)__			}_		}_		_		_		if (this.instancesWithAvailableResources.isEmpty()) {_			return null__		}__		Iterator<TaskManagerLocation> locations = requestedLocations == null ? null : requestedLocations.iterator()___		if (locations != null && locations.hasNext()) {_			__			while (locations.hasNext()) {_				TaskManagerLocation location = locations.next()__				if (location != null) {_					Instance instance = instancesWithAvailableResources.remove(location.getResourceID())__					if (instance != null) {_						return new ImmutablePair<Instance, Locality>(instance, Locality.LOCAL)__					}_				}_			}_			_			_			if (localOnly) {_				return null__			}_			else {_				_				Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__				Instance instanceToUse = instances.next()__				instances.remove()___				return new ImmutablePair<>(instanceToUse, Locality.NON_LOCAL)__			}_		}_		else {_			_			Iterator<Instance> instances = instancesWithAvailableResources.values().iterator()__			Instance instanceToUse = instances.next()__			instances.remove()___			return new ImmutablePair<>(instanceToUse, Locality.UNCONSTRAINED)__		}_	};tries,to,find,a,requested,instance,if,no,such,instance,is,available,it,will,return,a,non,local,instance,if,no,such,instance,exists,all,slots,occupied,then,return,null,p,b,note,b,this,method,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,p,param,requested,locations,the,list,of,preferred,instances,may,be,null,or,empty,which,indicates,that,no,locality,preference,exists,param,local,only,flag,to,indicate,whether,only,one,of,the,exact,local,instances,can,be,chosen;private,pair,instance,locality,find,instance,iterable,task,manager,location,requested,locations,boolean,local,only,while,this,newly,available,instances,size,0,instance,queued,instance,this,newly,available,instances,poll,if,queued,instance,null,this,instances,with,available,resources,put,queued,instance,get,task,manager,id,queued,instance,if,this,instances,with,available,resources,is,empty,return,null,iterator,task,manager,location,locations,requested,locations,null,null,requested,locations,iterator,if,locations,null,locations,has,next,while,locations,has,next,task,manager,location,location,locations,next,if,location,null,instance,instance,instances,with,available,resources,remove,location,get,resource,id,if,instance,null,return,new,immutable,pair,instance,locality,instance,locality,local,if,local,only,return,null,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,else,iterator,instance,instances,instances,with,available,resources,values,iterator,instance,instance,to,use,instances,next,instances,remove,return,new,immutable,pair,instance,to,use,locality,unconstrained
Scheduler -> public Scheduler(ExecutorService executor);1473307213;Creates a new scheduler.;public Scheduler(ExecutorService executor) {_		this(ExecutionContext$.MODULE$.fromExecutor(executor))__	};creates,a,new,scheduler;public,scheduler,executor,service,executor,this,execution,context,module,from,executor,executor
Scheduler -> public Scheduler(ExecutorService executor);1485888959;Creates a new scheduler.;public Scheduler(ExecutorService executor) {_		this(ExecutionContext$.MODULE$.fromExecutor(executor))__	};creates,a,new,scheduler;public,scheduler,executor,service,executor,this,execution,context,module,from,executor,executor
Scheduler -> public Scheduler(ExecutorService executor);1485891273;Creates a new scheduler.;public Scheduler(ExecutorService executor) {_		this(ExecutionContext$.MODULE$.fromExecutor(executor))__	};creates,a,new,scheduler;public,scheduler,executor,service,executor,this,execution,context,module,from,executor,executor
Scheduler -> public Scheduler(ExecutorService executor);1486663952;Creates a new scheduler.;public Scheduler(ExecutorService executor) {_		this(ExecutionContext$.MODULE$.fromExecutor(executor))__	};creates,a,new,scheduler;public,scheduler,executor,service,executor,this,execution,context,module,from,executor,executor
Scheduler -> public int getNumberOfAvailableSlots();1410445910;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0__		_		synchronized (globalLock) {_			for (Instance instance : instancesWithAvailableResources) {_				count += instance.getNumberOfAvailableSlots()__			}_		}_		_		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,for,instance,instance,instances,with,available,resources,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1410722608;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0__		_		synchronized (globalLock) {_			for (Instance instance : instancesWithAvailableResources) {_				count += instance.getNumberOfAvailableSlots()__			}_		}_		_		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,for,instance,instance,instances,with,available,resources,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1410734340;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0__		_		synchronized (globalLock) {_			for (Instance instance : instancesWithAvailableResources) {_				count += instance.getNumberOfAvailableSlots()__			}_		}_		_		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,for,instance,instance,instances,with,available,resources,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1410808507;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0__		_		synchronized (globalLock) {_			for (Instance instance : instancesWithAvailableResources) {_				count += instance.getNumberOfAvailableSlots()__			}_		}_		_		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,for,instance,instance,instances,with,available,resources,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1410924144;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0__		_		synchronized (globalLock) {_			for (Instance instance : instancesWithAvailableResources) {_				count += instance.getNumberOfAvailableSlots()__			}_		}_		_		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,for,instance,instance,instances,with,available,resources,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1411473561;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0__		_		synchronized (globalLock) {_			for (Instance instance : instancesWithAvailableResources) {_				count += instance.getNumberOfAvailableSlots()__			}_		}_		_		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,for,instance,instance,instances,with,available,resources,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1411494841;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0__		_		synchronized (globalLock) {_			for (Instance instance : instancesWithAvailableResources) {_				count += instance.getNumberOfAvailableSlots()__			}_		}_		_		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,for,instance,instance,instances,with,available,resources,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1411587268;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0__		_		synchronized (globalLock) {_			for (Instance instance : instancesWithAvailableResources) {_				count += instance.getNumberOfAvailableSlots()__			}_		}_		_		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,for,instance,instance,instances,with,available,resources,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1415641452;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0__		_		synchronized (globalLock) {_			for (Instance instance : instancesWithAvailableResources) {_				count += instance.getNumberOfAvailableSlots()__			}_		}_		_		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,for,instance,instance,instances,with,available,resources,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1416225736;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0__		_		synchronized (globalLock) {_			for (Instance instance : instancesWithAvailableResources) {_				count += instance.getNumberOfAvailableSlots()__			}_		}_		_		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,for,instance,instance,instances,with,available,resources,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1416317653;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0___		synchronized (globalLock) {_			processNewlyAvailableInstances()___			for (Instance instance : instancesWithAvailableResources) {_				count += instance.getNumberOfAvailableSlots()__			}_		}__		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,process,newly,available,instances,for,instance,instance,instances,with,available,resources,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1416878271;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0__		_		synchronized (globalLock) {_			for (Instance instance : instancesWithAvailableResources) {_				count += instance.getNumberOfAvailableSlots()__			}_		}_		_		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,for,instance,instance,instances,with,available,resources,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1421056725;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0__		_		synchronized (globalLock) {_			for (Instance instance : instancesWithAvailableResources) {_				count += instance.getNumberOfAvailableSlots()__			}_		}_		_		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,for,instance,instance,instances,with,available,resources,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1423053613;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0__		_		synchronized (globalLock) {_			for (Instance instance : instancesWithAvailableResources) {_				count += instance.getNumberOfAvailableSlots()__			}_		}_		_		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,for,instance,instance,instances,with,available,resources,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1423157292;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0__		_		synchronized (globalLock) {_			for (Instance instance : instancesWithAvailableResources) {_				count += instance.getNumberOfAvailableSlots()__			}_		}_		_		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,for,instance,instance,instances,with,available,resources,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1423419464;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0__		_		synchronized (globalLock) {_			for (Instance instance : instancesWithAvailableResources) {_				count += instance.getNumberOfAvailableSlots()__			}_		}_		_		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,for,instance,instance,instances,with,available,resources,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1423749105;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0__		_		synchronized (globalLock) {_			for (Instance instance : instancesWithAvailableResources) {_				count += instance.getNumberOfAvailableSlots()__			}_		}_		_		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,for,instance,instance,instances,with,available,resources,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1423931937;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0___		synchronized (globalLock) {_			processNewlyAvailableInstances()___			for (Instance instance : instancesWithAvailableResources) {_				count += instance.getNumberOfAvailableSlots()__			}_		}__		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,process,newly,available,instances,for,instance,instance,instances,with,available,resources,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1432114676;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0___		synchronized (globalLock) {_			processNewlyAvailableInstances()___			for (Instance instance : instancesWithAvailableResources) {_				count += instance.getNumberOfAvailableSlots()__			}_		}__		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,process,newly,available,instances,for,instance,instance,instances,with,available,resources,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1434450422;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0___		synchronized (globalLock) {_			processNewlyAvailableInstances()___			for (Instance instance : instancesWithAvailableResources) {_				count += instance.getNumberOfAvailableSlots()__			}_		}__		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,process,newly,available,instances,for,instance,instance,instances,with,available,resources,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1436262104;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0___		synchronized (globalLock) {_			processNewlyAvailableInstances()___			for (Instance instance : instancesWithAvailableResources) {_				count += instance.getNumberOfAvailableSlots()__			}_		}__		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,process,newly,available,instances,for,instance,instance,instances,with,available,resources,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1445550685;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0___		synchronized (globalLock) {_			processNewlyAvailableInstances()___			for (Instance instance : instancesWithAvailableResources) {_				count += instance.getNumberOfAvailableSlots()__			}_		}__		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,process,newly,available,instances,for,instance,instance,instances,with,available,resources,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1472205100;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0___		synchronized (globalLock) {_			processNewlyAvailableInstances()___			for (Instance instance : instancesWithAvailableResources.values()) {_				count += instance.getNumberOfAvailableSlots()__			}_		}__		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,process,newly,available,instances,for,instance,instance,instances,with,available,resources,values,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1472582060;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0___		synchronized (globalLock) {_			processNewlyAvailableInstances()___			for (Instance instance : instancesWithAvailableResources.values()) {_				count += instance.getNumberOfAvailableSlots()__			}_		}__		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,process,newly,available,instances,for,instance,instance,instances,with,available,resources,values,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1472644741;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0___		synchronized (globalLock) {_			processNewlyAvailableInstances()___			for (Instance instance : instancesWithAvailableResources.values()) {_				count += instance.getNumberOfAvailableSlots()__			}_		}__		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,process,newly,available,instances,for,instance,instance,instances,with,available,resources,values,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1473307213;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0___		synchronized (globalLock) {_			processNewlyAvailableInstances()___			for (Instance instance : instancesWithAvailableResources.values()) {_				count += instance.getNumberOfAvailableSlots()__			}_		}__		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,process,newly,available,instances,for,instance,instance,instances,with,available,resources,values,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1474949408;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0___		synchronized (globalLock) {_			processNewlyAvailableInstances()___			for (Instance instance : instancesWithAvailableResources.values()) {_				count += instance.getNumberOfAvailableSlots()__			}_		}__		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,process,newly,available,instances,for,instance,instance,instances,with,available,resources,values,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1474983187;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0___		synchronized (globalLock) {_			processNewlyAvailableInstances()___			for (Instance instance : instancesWithAvailableResources.values()) {_				count += instance.getNumberOfAvailableSlots()__			}_		}__		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,process,newly,available,instances,for,instance,instance,instances,with,available,resources,values,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1485888959;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0___		synchronized (globalLock) {_			processNewlyAvailableInstances()___			for (Instance instance : instancesWithAvailableResources.values()) {_				count += instance.getNumberOfAvailableSlots()__			}_		}__		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,process,newly,available,instances,for,instance,instance,instances,with,available,resources,values,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1485891273;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0___		synchronized (globalLock) {_			processNewlyAvailableInstances()___			for (Instance instance : instancesWithAvailableResources.values()) {_				count += instance.getNumberOfAvailableSlots()__			}_		}__		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,process,newly,available,instances,for,instance,instance,instances,with,available,resources,values,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1486663952;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0___		synchronized (globalLock) {_			processNewlyAvailableInstances()___			for (Instance instance : instancesWithAvailableResources.values()) {_				count += instance.getNumberOfAvailableSlots()__			}_		}__		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,process,newly,available,instances,for,instance,instance,instances,with,available,resources,values,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1488299223;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0___		synchronized (globalLock) {_			processNewlyAvailableInstances()___			for (Instance instance : instancesWithAvailableResources.values()) {_				count += instance.getNumberOfAvailableSlots()__			}_		}__		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,process,newly,available,instances,for,instance,instance,instances,with,available,resources,values,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1490819573;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0___		synchronized (globalLock) {_			processNewlyAvailableInstances()___			for (Instance instance : instancesWithAvailableResources.values()) {_				count += instance.getNumberOfAvailableSlots()__			}_		}__		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,process,newly,available,instances,for,instance,instance,instances,with,available,resources,values,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1501519020;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0___		synchronized (globalLock) {_			processNewlyAvailableInstances()___			for (Instance instance : instancesWithAvailableResources.values()) {_				count += instance.getNumberOfAvailableSlots()__			}_		}__		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,process,newly,available,instances,for,instance,instance,instances,with,available,resources,values,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1508155453;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0___		synchronized (globalLock) {_			processNewlyAvailableInstances()___			for (Instance instance : instancesWithAvailableResources.values()) {_				count += instance.getNumberOfAvailableSlots()__			}_		}__		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,process,newly,available,instances,for,instance,instance,instances,with,available,resources,values,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1509090423;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0___		synchronized (globalLock) {_			processNewlyAvailableInstances()___			for (Instance instance : instancesWithAvailableResources.values()) {_				count += instance.getNumberOfAvailableSlots()__			}_		}__		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,process,newly,available,instances,for,instance,instance,instances,with,available,resources,values,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1510699852;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0___		synchronized (globalLock) {_			processNewlyAvailableInstances()___			for (Instance instance : instancesWithAvailableResources.values()) {_				count += instance.getNumberOfAvailableSlots()__			}_		}__		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,process,newly,available,instances,for,instance,instance,instances,with,available,resources,values,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1510752027;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0___		synchronized (globalLock) {_			processNewlyAvailableInstances()___			for (Instance instance : instancesWithAvailableResources.values()) {_				count += instance.getNumberOfAvailableSlots()__			}_		}__		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,process,newly,available,instances,for,instance,instance,instances,with,available,resources,values,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1511543029;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0___		synchronized (globalLock) {_			processNewlyAvailableInstances()___			for (Instance instance : instancesWithAvailableResources.values()) {_				count += instance.getNumberOfAvailableSlots()__			}_		}__		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,process,newly,available,instances,for,instance,instance,instances,with,available,resources,values,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1513261475;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0___		synchronized (globalLock) {_			processNewlyAvailableInstances()___			for (Instance instance : instancesWithAvailableResources.values()) {_				count += instance.getNumberOfAvailableSlots()__			}_		}__		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,process,newly,available,instances,for,instance,instance,instances,with,available,resources,values,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1517497348;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0___		synchronized (globalLock) {_			processNewlyAvailableInstances()___			for (Instance instance : instancesWithAvailableResources.values()) {_				count += instance.getNumberOfAvailableSlots()__			}_		}__		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,process,newly,available,instances,for,instance,instance,instances,with,available,resources,values,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1518522104;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0___		synchronized (globalLock) {_			processNewlyAvailableInstances()___			for (Instance instance : instancesWithAvailableResources.values()) {_				count += instance.getNumberOfAvailableSlots()__			}_		}__		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,process,newly,available,instances,for,instance,instance,instances,with,available,resources,values,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1519315265;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0___		synchronized (globalLock) {_			processNewlyAvailableInstances()___			for (Instance instance : instancesWithAvailableResources.values()) {_				count += instance.getNumberOfAvailableSlots()__			}_		}__		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,process,newly,available,instances,for,instance,instance,instances,with,available,resources,values,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1538764056;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0___		synchronized (globalLock) {_			processNewlyAvailableInstances()___			for (Instance instance : instancesWithAvailableResources.values()) {_				count += instance.getNumberOfAvailableSlots()__			}_		}__		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,process,newly,available,instances,for,instance,instance,instances,with,available,resources,values,count,instance,get,number,of,available,slots,return,count
Scheduler -> public int getNumberOfAvailableSlots();1543229263;NOTE: In the presence of multi-threaded operations, this number may be inexact.__@return The number of empty slots, for tasks.;public int getNumberOfAvailableSlots() {_		int count = 0___		synchronized (globalLock) {_			processNewlyAvailableInstances()___			for (Instance instance : instancesWithAvailableResources.values()) {_				count += instance.getNumberOfAvailableSlots()__			}_		}__		return count__	};note,in,the,presence,of,multi,threaded,operations,this,number,may,be,inexact,return,the,number,of,empty,slots,for,tasks;public,int,get,number,of,available,slots,int,count,0,synchronized,global,lock,process,newly,available,instances,for,instance,instance,instances,with,available,resources,values,count,instance,get,number,of,available,slots,return,count
Scheduler -> protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, Iterable<Instance> requestedLocations);1421056725;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, Iterable<Instance> requestedLocations) {_		_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations)___			if(instanceLocalityPair == null){_				return null__			}__			Instance instanceToUse = instanceLocalityPair.getLeft()__			Locality locality = instanceLocalityPair.getRight()___			if(LOG.isDebugEnabled()){_				if(locality == Locality.LOCAL){_					LOG.debug("Local assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__				}else if(locality == Locality.NON_LOCAL){_					LOG.debug("Non-local assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__				}else if(locality == Locality.UNCONSTRAINED) {_					LOG.debug("Unconstrained assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__				}_			}__			try {_				SimpleSlot slot = instanceToUse.allocateSimpleSlot(vertex.getJobId(), vertex.getJobvertexId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.add(instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				this.allInstances.remove(instanceToUse)__				this.instancesWithAvailableResources.remove(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,simple,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,instance,requested,locations,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,if,instance,locality,pair,null,return,null,instance,instance,to,use,instance,locality,pair,get,left,locality,locality,instance,locality,pair,get,right,if,log,is,debug,enabled,if,locality,locality,local,log,debug,local,assignment,vertex,get,simple,name,instance,to,use,else,if,locality,locality,log,debug,non,local,assignment,vertex,get,simple,name,instance,to,use,else,if,locality,locality,unconstrained,log,debug,unconstrained,assignment,vertex,get,simple,name,instance,to,use,try,simple,slot,slot,instance,to,use,allocate,simple,slot,vertex,get,job,id,vertex,get,jobvertex,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,add,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,this,all,instances,remove,instance,to,use,this,instances,with,available,resources,remove,instance,to,use
Scheduler -> protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, Iterable<Instance> requestedLocations);1423053613;Gets a suitable instance to schedule the vertex execution to._<p>_NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.__@param vertex The task to run._@return The instance to run the vertex on, it {@code null}, if no instance is available.;protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, Iterable<Instance> requestedLocations) {_		_		_		_		while (true) {_			Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations)___			if(instanceLocalityPair == null){_				return null__			}__			Instance instanceToUse = instanceLocalityPair.getLeft()__			Locality locality = instanceLocalityPair.getRight()___			if(LOG.isDebugEnabled()){_				if(locality == Locality.LOCAL){_					LOG.debug("Local assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__				}else if(locality == Locality.NON_LOCAL){_					LOG.debug("Non-local assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__				}else if(locality == Locality.UNCONSTRAINED) {_					LOG.debug("Unconstrained assignment: " + vertex.getSimpleName() + " --> " + instanceToUse)__				}_			}__			try {_				SimpleSlot slot = instanceToUse.allocateSimpleSlot(vertex.getJobId(), vertex.getJobvertexId())__				_				_				if (instanceToUse.hasResourcesAvailable()) {_					this.instancesWithAvailableResources.add(instanceToUse)__				}_				_				if (slot != null) {_					slot.setLocality(locality)__					return slot__				}_			}_			catch (InstanceDiedException e) {_				_				_				this.allInstances.remove(instanceToUse)__				this.instancesWithAvailableResources.remove(instanceToUse)__			}_			_			_		}_	};gets,a,suitable,instance,to,schedule,the,vertex,execution,to,p,note,this,method,does,is,not,thread,safe,it,needs,to,be,synchronized,by,the,caller,param,vertex,the,task,to,run,return,the,instance,to,run,the,vertex,on,it,code,null,if,no,instance,is,available;protected,simple,slot,get,free,slot,for,task,execution,vertex,vertex,iterable,instance,requested,locations,while,true,pair,instance,locality,instance,locality,pair,find,instance,requested,locations,if,instance,locality,pair,null,return,null,instance,instance,to,use,instance,locality,pair,get,left,locality,locality,instance,locality,pair,get,right,if,log,is,debug,enabled,if,locality,locality,local,log,debug,local,assignment,vertex,get,simple,name,instance,to,use,else,if,locality,locality,log,debug,non,local,assignment,vertex,get,simple,name,instance,to,use,else,if,locality,locality,unconstrained,log,debug,unconstrained,assignment,vertex,get,simple,name,instance,to,use,try,simple,slot,slot,instance,to,use,allocate,simple,slot,vertex,get,job,id,vertex,get,jobvertex,id,if,instance,to,use,has,resources,available,this,instances,with,available,resources,add,instance,to,use,if,slot,null,slot,set,locality,locality,return,slot,catch,instance,died,exception,e,this,all,instances,remove,instance,to,use,this,instances,with,available,resources,remove,instance,to,use
Scheduler -> public Scheduler();1432114676;Creates a new scheduler.;public Scheduler() {};creates,a,new,scheduler;public,scheduler
Scheduler -> public Scheduler();1434450422;Creates a new scheduler.;public Scheduler() {};creates,a,new,scheduler;public,scheduler
Scheduler -> public Scheduler(ExecutionContext executionContext);1436262104;Creates a new scheduler.;public Scheduler(ExecutionContext executionContext) {_		this.executionContext = executionContext__	};creates,a,new,scheduler;public,scheduler,execution,context,execution,context,this,execution,context,execution,context
Scheduler -> public Scheduler(ExecutionContext executionContext);1445550685;Creates a new scheduler.;public Scheduler(ExecutionContext executionContext) {_		this.executionContext = executionContext__	};creates,a,new,scheduler;public,scheduler,execution,context,execution,context,this,execution,context,execution,context
Scheduler -> public Scheduler(ExecutionContext executionContext);1472205100;Creates a new scheduler.;public Scheduler(ExecutionContext executionContext) {_		this.executionContext = executionContext__	};creates,a,new,scheduler;public,scheduler,execution,context,execution,context,this,execution,context,execution,context
Scheduler -> public Scheduler(ExecutionContext executionContext);1472582060;Creates a new scheduler.;public Scheduler(ExecutionContext executionContext) {_		this.executionContext = executionContext__	};creates,a,new,scheduler;public,scheduler,execution,context,execution,context,this,execution,context,execution,context
Scheduler -> public Scheduler(ExecutionContext executionContext);1472644741;Creates a new scheduler.;public Scheduler(ExecutionContext executionContext) {_		this.executionContext = executionContext__	};creates,a,new,scheduler;public,scheduler,execution,context,execution,context,this,execution,context,execution,context
Scheduler -> public Scheduler(ExecutionContext executionContext);1473307213;Creates a new scheduler.;public Scheduler(ExecutionContext executionContext) {_		this.executionContext = executionContext__	};creates,a,new,scheduler;public,scheduler,execution,context,execution,context,this,execution,context,execution,context
Scheduler -> public Scheduler(ExecutionContext executionContext);1474949408;Creates a new scheduler.;public Scheduler(ExecutionContext executionContext) {_		this.executionContext = executionContext__	};creates,a,new,scheduler;public,scheduler,execution,context,execution,context,this,execution,context,execution,context
Scheduler -> public Scheduler(ExecutionContext executionContext);1474983187;Creates a new scheduler.;public Scheduler(ExecutionContext executionContext) {_		this.executionContext = executionContext__	};creates,a,new,scheduler;public,scheduler,execution,context,execution,context,this,execution,context,execution,context
Scheduler -> public Scheduler(ExecutionContext executionContext);1485888959;Creates a new scheduler.;public Scheduler(ExecutionContext executionContext) {_		this.executionContext = executionContext__	};creates,a,new,scheduler;public,scheduler,execution,context,execution,context,this,execution,context,execution,context
Scheduler -> public Scheduler(ExecutionContext executionContext);1485891273;Creates a new scheduler.;public Scheduler(ExecutionContext executionContext) {_		this.executionContext = executionContext__	};creates,a,new,scheduler;public,scheduler,execution,context,execution,context,this,execution,context,execution,context
Scheduler -> public Scheduler(ExecutionContext executionContext);1486663952;Creates a new scheduler.;public Scheduler(ExecutionContext executionContext) {_		this.executionContext = executionContext__	};creates,a,new,scheduler;public,scheduler,execution,context,execution,context,this,execution,context,execution,context
