# id;timestamp;commentText;codeText;commentWords;codeWords
FencedRpcEndpoint -> protected Executor getUnfencedMainThreadExecutor();1522316583;Returns a main thread executor which is not bound to the fencing token._This means that {@link Runnable} which are executed with this executor will always_be executed.__@return MainThreadExecutor which is not bound to the fencing token;protected Executor getUnfencedMainThreadExecutor() {_		return unfencedMainThreadExecutor__	};returns,a,main,thread,executor,which,is,not,bound,to,the,fencing,token,this,means,that,link,runnable,which,are,executed,with,this,executor,will,always,be,executed,return,main,thread,executor,which,is,not,bound,to,the,fencing,token;protected,executor,get,unfenced,main,thread,executor,return,unfenced,main,thread,executor
FencedRpcEndpoint -> protected Executor getUnfencedMainThreadExecutor();1543229263;Returns a main thread executor which is not bound to the fencing token._This means that {@link Runnable} which are executed with this executor will always_be executed.__@return MainThreadExecutor which is not bound to the fencing token;protected Executor getUnfencedMainThreadExecutor() {_		return unfencedMainThreadExecutor__	};returns,a,main,thread,executor,which,is,not,bound,to,the,fencing,token,this,means,that,link,runnable,which,are,executed,with,this,executor,will,always,be,executed,return,main,thread,executor,which,is,not,bound,to,the,fencing,token;protected,executor,get,unfenced,main,thread,executor,return,unfenced,main,thread,executor
FencedRpcEndpoint -> protected void runAsyncWithoutFencing(Runnable runnable);1503500935;Run the given runnable in the main thread of the RpcEndpoint without checking the fencing_token. This allows to run operations outside of the fencing token scope.__@param runnable to execute in the main thread of the rpc endpoint without checking the fencing token.;protected void runAsyncWithoutFencing(Runnable runnable) {_		if (rpcServer instanceof FencedMainThreadExecutable) {_			((FencedMainThreadExecutable) rpcServer).runAsyncWithoutFencing(runnable)__		} else {_			throw new RuntimeException("FencedRpcEndpoint has not been started with a FencedMainThreadExecutable RpcServer.")__		}_	};run,the,given,runnable,in,the,main,thread,of,the,rpc,endpoint,without,checking,the,fencing,token,this,allows,to,run,operations,outside,of,the,fencing,token,scope,param,runnable,to,execute,in,the,main,thread,of,the,rpc,endpoint,without,checking,the,fencing,token;protected,void,run,async,without,fencing,runnable,runnable,if,rpc,server,instanceof,fenced,main,thread,executable,fenced,main,thread,executable,rpc,server,run,async,without,fencing,runnable,else,throw,new,runtime,exception,fenced,rpc,endpoint,has,not,been,started,with,a,fenced,main,thread,executable,rpc,server
FencedRpcEndpoint -> protected void runAsyncWithoutFencing(Runnable runnable);1505921975;Run the given runnable in the main thread of the RpcEndpoint without checking the fencing_token. This allows to run operations outside of the fencing token scope.__@param runnable to execute in the main thread of the rpc endpoint without checking the fencing token.;protected void runAsyncWithoutFencing(Runnable runnable) {_		if (rpcServer instanceof FencedMainThreadExecutable) {_			((FencedMainThreadExecutable) rpcServer).runAsyncWithoutFencing(runnable)__		} else {_			throw new RuntimeException("FencedRpcEndpoint has not been started with a FencedMainThreadExecutable RpcServer.")__		}_	};run,the,given,runnable,in,the,main,thread,of,the,rpc,endpoint,without,checking,the,fencing,token,this,allows,to,run,operations,outside,of,the,fencing,token,scope,param,runnable,to,execute,in,the,main,thread,of,the,rpc,endpoint,without,checking,the,fencing,token;protected,void,run,async,without,fencing,runnable,runnable,if,rpc,server,instanceof,fenced,main,thread,executable,fenced,main,thread,executable,rpc,server,run,async,without,fencing,runnable,else,throw,new,runtime,exception,fenced,rpc,endpoint,has,not,been,started,with,a,fenced,main,thread,executable,rpc,server
FencedRpcEndpoint -> protected void runAsyncWithoutFencing(Runnable runnable);1518718788;Run the given runnable in the main thread of the RpcEndpoint without checking the fencing_token. This allows to run operations outside of the fencing token scope.__@param runnable to execute in the main thread of the rpc endpoint without checking the fencing token.;protected void runAsyncWithoutFencing(Runnable runnable) {_		if (rpcServer instanceof FencedMainThreadExecutable) {_			((FencedMainThreadExecutable) rpcServer).runAsyncWithoutFencing(runnable)__		} else {_			throw new RuntimeException("FencedRpcEndpoint has not been started with a FencedMainThreadExecutable RpcServer.")__		}_	};run,the,given,runnable,in,the,main,thread,of,the,rpc,endpoint,without,checking,the,fencing,token,this,allows,to,run,operations,outside,of,the,fencing,token,scope,param,runnable,to,execute,in,the,main,thread,of,the,rpc,endpoint,without,checking,the,fencing,token;protected,void,run,async,without,fencing,runnable,runnable,if,rpc,server,instanceof,fenced,main,thread,executable,fenced,main,thread,executable,rpc,server,run,async,without,fencing,runnable,else,throw,new,runtime,exception,fenced,rpc,endpoint,has,not,been,started,with,a,fenced,main,thread,executable,rpc,server
FencedRpcEndpoint -> protected void runAsyncWithoutFencing(Runnable runnable);1522316583;Run the given runnable in the main thread of the RpcEndpoint without checking the fencing_token. This allows to run operations outside of the fencing token scope.__@param runnable to execute in the main thread of the rpc endpoint without checking the fencing token.;protected void runAsyncWithoutFencing(Runnable runnable) {_		if (rpcServer instanceof FencedMainThreadExecutable) {_			((FencedMainThreadExecutable) rpcServer).runAsyncWithoutFencing(runnable)__		} else {_			throw new RuntimeException("FencedRpcEndpoint has not been started with a FencedMainThreadExecutable RpcServer.")__		}_	};run,the,given,runnable,in,the,main,thread,of,the,rpc,endpoint,without,checking,the,fencing,token,this,allows,to,run,operations,outside,of,the,fencing,token,scope,param,runnable,to,execute,in,the,main,thread,of,the,rpc,endpoint,without,checking,the,fencing,token;protected,void,run,async,without,fencing,runnable,runnable,if,rpc,server,instanceof,fenced,main,thread,executable,fenced,main,thread,executable,rpc,server,run,async,without,fencing,runnable,else,throw,new,runtime,exception,fenced,rpc,endpoint,has,not,been,started,with,a,fenced,main,thread,executable,rpc,server
FencedRpcEndpoint -> protected void runAsyncWithoutFencing(Runnable runnable);1543229263;Run the given runnable in the main thread of the RpcEndpoint without checking the fencing_token. This allows to run operations outside of the fencing token scope.__@param runnable to execute in the main thread of the rpc endpoint without checking the fencing token.;protected void runAsyncWithoutFencing(Runnable runnable) {_		if (rpcServer instanceof FencedMainThreadExecutable) {_			((FencedMainThreadExecutable) rpcServer).runAsyncWithoutFencing(runnable)__		} else {_			throw new RuntimeException("FencedRpcEndpoint has not been started with a FencedMainThreadExecutable RpcServer.")__		}_	};run,the,given,runnable,in,the,main,thread,of,the,rpc,endpoint,without,checking,the,fencing,token,this,allows,to,run,operations,outside,of,the,fencing,token,scope,param,runnable,to,execute,in,the,main,thread,of,the,rpc,endpoint,without,checking,the,fencing,token;protected,void,run,async,without,fencing,runnable,runnable,if,rpc,server,instanceof,fenced,main,thread,executable,fenced,main,thread,executable,rpc,server,run,async,without,fencing,runnable,else,throw,new,runtime,exception,fenced,rpc,endpoint,has,not,been,started,with,a,fenced,main,thread,executable,rpc,server
FencedRpcEndpoint -> @Override 	protected MainThreadExecutor getMainThreadExecutor();1503500935;Returns a main thread executor which is bound to the currently valid fencing token._This means that runnables which are executed with this executor fail after the fencing_token has changed. This allows to scope operations by the fencing token.__@return MainThreadExecutor bound to the current fencing token;@Override_	protected MainThreadExecutor getMainThreadExecutor() {_		return fencedMainThreadExecutor__	};returns,a,main,thread,executor,which,is,bound,to,the,currently,valid,fencing,token,this,means,that,runnables,which,are,executed,with,this,executor,fail,after,the,fencing,token,has,changed,this,allows,to,scope,operations,by,the,fencing,token,return,main,thread,executor,bound,to,the,current,fencing,token;override,protected,main,thread,executor,get,main,thread,executor,return,fenced,main,thread,executor
FencedRpcEndpoint -> @Override 	protected MainThreadExecutor getMainThreadExecutor();1505921975;Returns a main thread executor which is bound to the currently valid fencing token._This means that runnables which are executed with this executor fail after the fencing_token has changed. This allows to scope operations by the fencing token.__@return MainThreadExecutor bound to the current fencing token;@Override_	protected MainThreadExecutor getMainThreadExecutor() {_		return fencedMainThreadExecutor__	};returns,a,main,thread,executor,which,is,bound,to,the,currently,valid,fencing,token,this,means,that,runnables,which,are,executed,with,this,executor,fail,after,the,fencing,token,has,changed,this,allows,to,scope,operations,by,the,fencing,token,return,main,thread,executor,bound,to,the,current,fencing,token;override,protected,main,thread,executor,get,main,thread,executor,return,fenced,main,thread,executor
FencedRpcEndpoint -> @Override 	protected MainThreadExecutor getMainThreadExecutor();1518718788;Returns a main thread executor which is bound to the currently valid fencing token._This means that runnables which are executed with this executor fail after the fencing_token has changed. This allows to scope operations by the fencing token.__@return MainThreadExecutor bound to the current fencing token;@Override_	protected MainThreadExecutor getMainThreadExecutor() {_		return fencedMainThreadExecutor__	};returns,a,main,thread,executor,which,is,bound,to,the,currently,valid,fencing,token,this,means,that,runnables,which,are,executed,with,this,executor,fail,after,the,fencing,token,has,changed,this,allows,to,scope,operations,by,the,fencing,token,return,main,thread,executor,bound,to,the,current,fencing,token;override,protected,main,thread,executor,get,main,thread,executor,return,fenced,main,thread,executor
FencedRpcEndpoint -> @Override 	protected MainThreadExecutor getMainThreadExecutor();1522316583;Returns a main thread executor which is bound to the currently valid fencing token._This means that runnables which are executed with this executor fail after the fencing_token has changed. This allows to scope operations by the fencing token.__@return MainThreadExecutor bound to the current fencing token;@Override_	protected MainThreadExecutor getMainThreadExecutor() {_		return fencedMainThreadExecutor__	};returns,a,main,thread,executor,which,is,bound,to,the,currently,valid,fencing,token,this,means,that,runnables,which,are,executed,with,this,executor,fail,after,the,fencing,token,has,changed,this,allows,to,scope,operations,by,the,fencing,token,return,main,thread,executor,bound,to,the,current,fencing,token;override,protected,main,thread,executor,get,main,thread,executor,return,fenced,main,thread,executor
FencedRpcEndpoint -> @Override 	protected MainThreadExecutor getMainThreadExecutor();1543229263;Returns a main thread executor which is bound to the currently valid fencing token._This means that runnables which are executed with this executor fail after the fencing_token has changed. This allows to scope operations by the fencing token.__@return MainThreadExecutor bound to the current fencing token;@Override_	protected MainThreadExecutor getMainThreadExecutor() {_		return fencedMainThreadExecutor__	};returns,a,main,thread,executor,which,is,bound,to,the,currently,valid,fencing,token,this,means,that,runnables,which,are,executed,with,this,executor,fail,after,the,fencing,token,has,changed,this,allows,to,scope,operations,by,the,fencing,token,return,main,thread,executor,bound,to,the,current,fencing,token;override,protected,main,thread,executor,get,main,thread,executor,return,fenced,main,thread,executor
FencedRpcEndpoint -> protected <V> CompletableFuture<V> callAsyncWithoutFencing(Callable<V> callable, Time timeout);1503500935;Run the given callable in the main thread of the RpcEndpoint without checking the fencing_token. This allows to run operations outside of the fencing token scope.__@param callable to run in the main thread of the rpc endpoint without checkint the fencing token._@param timeout for the operation._@return Future containing the callable result.;protected <V> CompletableFuture<V> callAsyncWithoutFencing(Callable<V> callable, Time timeout) {_		if (rpcServer instanceof FencedMainThreadExecutable) {_			return ((FencedMainThreadExecutable) rpcServer).callAsyncWithoutFencing(callable, timeout)__		} else {_			throw new RuntimeException("FencedRpcEndpoint has not been started with a FencedMainThreadExecutable RpcServer.")__		}_	};run,the,given,callable,in,the,main,thread,of,the,rpc,endpoint,without,checking,the,fencing,token,this,allows,to,run,operations,outside,of,the,fencing,token,scope,param,callable,to,run,in,the,main,thread,of,the,rpc,endpoint,without,checkint,the,fencing,token,param,timeout,for,the,operation,return,future,containing,the,callable,result;protected,v,completable,future,v,call,async,without,fencing,callable,v,callable,time,timeout,if,rpc,server,instanceof,fenced,main,thread,executable,return,fenced,main,thread,executable,rpc,server,call,async,without,fencing,callable,timeout,else,throw,new,runtime,exception,fenced,rpc,endpoint,has,not,been,started,with,a,fenced,main,thread,executable,rpc,server
FencedRpcEndpoint -> protected <V> CompletableFuture<V> callAsyncWithoutFencing(Callable<V> callable, Time timeout);1505921975;Run the given callable in the main thread of the RpcEndpoint without checking the fencing_token. This allows to run operations outside of the fencing token scope.__@param callable to run in the main thread of the rpc endpoint without checkint the fencing token._@param timeout for the operation._@return Future containing the callable result.;protected <V> CompletableFuture<V> callAsyncWithoutFencing(Callable<V> callable, Time timeout) {_		if (rpcServer instanceof FencedMainThreadExecutable) {_			return ((FencedMainThreadExecutable) rpcServer).callAsyncWithoutFencing(callable, timeout)__		} else {_			throw new RuntimeException("FencedRpcEndpoint has not been started with a FencedMainThreadExecutable RpcServer.")__		}_	};run,the,given,callable,in,the,main,thread,of,the,rpc,endpoint,without,checking,the,fencing,token,this,allows,to,run,operations,outside,of,the,fencing,token,scope,param,callable,to,run,in,the,main,thread,of,the,rpc,endpoint,without,checkint,the,fencing,token,param,timeout,for,the,operation,return,future,containing,the,callable,result;protected,v,completable,future,v,call,async,without,fencing,callable,v,callable,time,timeout,if,rpc,server,instanceof,fenced,main,thread,executable,return,fenced,main,thread,executable,rpc,server,call,async,without,fencing,callable,timeout,else,throw,new,runtime,exception,fenced,rpc,endpoint,has,not,been,started,with,a,fenced,main,thread,executable,rpc,server
FencedRpcEndpoint -> protected <V> CompletableFuture<V> callAsyncWithoutFencing(Callable<V> callable, Time timeout);1518718788;Run the given callable in the main thread of the RpcEndpoint without checking the fencing_token. This allows to run operations outside of the fencing token scope.__@param callable to run in the main thread of the rpc endpoint without checkint the fencing token._@param timeout for the operation._@return Future containing the callable result.;protected <V> CompletableFuture<V> callAsyncWithoutFencing(Callable<V> callable, Time timeout) {_		if (rpcServer instanceof FencedMainThreadExecutable) {_			return ((FencedMainThreadExecutable) rpcServer).callAsyncWithoutFencing(callable, timeout)__		} else {_			throw new RuntimeException("FencedRpcEndpoint has not been started with a FencedMainThreadExecutable RpcServer.")__		}_	};run,the,given,callable,in,the,main,thread,of,the,rpc,endpoint,without,checking,the,fencing,token,this,allows,to,run,operations,outside,of,the,fencing,token,scope,param,callable,to,run,in,the,main,thread,of,the,rpc,endpoint,without,checkint,the,fencing,token,param,timeout,for,the,operation,return,future,containing,the,callable,result;protected,v,completable,future,v,call,async,without,fencing,callable,v,callable,time,timeout,if,rpc,server,instanceof,fenced,main,thread,executable,return,fenced,main,thread,executable,rpc,server,call,async,without,fencing,callable,timeout,else,throw,new,runtime,exception,fenced,rpc,endpoint,has,not,been,started,with,a,fenced,main,thread,executable,rpc,server
FencedRpcEndpoint -> protected <V> CompletableFuture<V> callAsyncWithoutFencing(Callable<V> callable, Time timeout);1522316583;Run the given callable in the main thread of the RpcEndpoint without checking the fencing_token. This allows to run operations outside of the fencing token scope.__@param callable to run in the main thread of the rpc endpoint without checkint the fencing token._@param timeout for the operation._@return Future containing the callable result.;protected <V> CompletableFuture<V> callAsyncWithoutFencing(Callable<V> callable, Time timeout) {_		if (rpcServer instanceof FencedMainThreadExecutable) {_			return ((FencedMainThreadExecutable) rpcServer).callAsyncWithoutFencing(callable, timeout)__		} else {_			throw new RuntimeException("FencedRpcEndpoint has not been started with a FencedMainThreadExecutable RpcServer.")__		}_	};run,the,given,callable,in,the,main,thread,of,the,rpc,endpoint,without,checking,the,fencing,token,this,allows,to,run,operations,outside,of,the,fencing,token,scope,param,callable,to,run,in,the,main,thread,of,the,rpc,endpoint,without,checkint,the,fencing,token,param,timeout,for,the,operation,return,future,containing,the,callable,result;protected,v,completable,future,v,call,async,without,fencing,callable,v,callable,time,timeout,if,rpc,server,instanceof,fenced,main,thread,executable,return,fenced,main,thread,executable,rpc,server,call,async,without,fencing,callable,timeout,else,throw,new,runtime,exception,fenced,rpc,endpoint,has,not,been,started,with,a,fenced,main,thread,executable,rpc,server
FencedRpcEndpoint -> protected <V> CompletableFuture<V> callAsyncWithoutFencing(Callable<V> callable, Time timeout);1543229263;Run the given callable in the main thread of the RpcEndpoint without checking the fencing_token. This allows to run operations outside of the fencing token scope.__@param callable to run in the main thread of the rpc endpoint without checkint the fencing token._@param timeout for the operation._@return Future containing the callable result.;protected <V> CompletableFuture<V> callAsyncWithoutFencing(Callable<V> callable, Time timeout) {_		if (rpcServer instanceof FencedMainThreadExecutable) {_			return ((FencedMainThreadExecutable) rpcServer).callAsyncWithoutFencing(callable, timeout)__		} else {_			throw new RuntimeException("FencedRpcEndpoint has not been started with a FencedMainThreadExecutable RpcServer.")__		}_	};run,the,given,callable,in,the,main,thread,of,the,rpc,endpoint,without,checking,the,fencing,token,this,allows,to,run,operations,outside,of,the,fencing,token,scope,param,callable,to,run,in,the,main,thread,of,the,rpc,endpoint,without,checkint,the,fencing,token,param,timeout,for,the,operation,return,future,containing,the,callable,result;protected,v,completable,future,v,call,async,without,fencing,callable,v,callable,time,timeout,if,rpc,server,instanceof,fenced,main,thread,executable,return,fenced,main,thread,executable,rpc,server,call,async,without,fencing,callable,timeout,else,throw,new,runtime,exception,fenced,rpc,endpoint,has,not,been,started,with,a,fenced,main,thread,executable,rpc,server
