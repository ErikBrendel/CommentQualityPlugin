# id;timestamp;commentText;codeText;commentWords;codeWords
Execution -> public CompletableFuture<Execution> allocateAndAssignSlotForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint) throws IllegalExecutionStateException;1509638685;Allocates and assigns a slot obtained from the slot provider to the execution.__@param slotProvider to obtain a new slot from_@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@return Future which is completed with this execution once the slot has been assigned_or with an exception if an error occurred._@throws IllegalExecutionStateException if this method has been called while not being in the CREATED state;public CompletableFuture<Execution> allocateAndAssignSlotForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) throws IllegalExecutionStateException {__		checkNotNull(slotProvider)___		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new IllegalStateException(_					"Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		_		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_					new ScheduledUnit(this, sharingGroup) :_					new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture = calculatePreferredLocations(locationPreferenceConstraint)___			return preferredLocationsFuture_				.thenCompose(_					(Collection<TaskManagerLocation> preferredLocations) ->_						slotProvider.allocateSlot(_							toSchedule,_							queued,_							preferredLocations))_				.thenApply(_					(SimpleSlot slot) -> {_						if (tryAssignResource(slot)) {_							return this__						} else {_							_							slot.releaseSlot()___							throw new CompletionException(new FlinkException("Could not assign slot " + slot + " to execution " + this + " because it has already been assigned "))__						}_					})__		}_		else {_			_			throw new IllegalExecutionStateException(this, CREATED, state)__		}_	};allocates,and,assigns,a,slot,obtained,from,the,slot,provider,to,the,execution,param,slot,provider,to,obtain,a,new,slot,from,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,return,future,which,is,completed,with,this,execution,once,the,slot,has,been,assigned,or,with,an,exception,if,an,error,occurred,throws,illegal,execution,state,exception,if,this,method,has,been,called,while,not,being,in,the,created,state;public,completable,future,execution,allocate,and,assign,slot,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,throws,illegal,execution,state,exception,check,not,null,slot,provider,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,illegal,state,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,final,completable,future,collection,task,manager,location,preferred,locations,future,calculate,preferred,locations,location,preference,constraint,return,preferred,locations,future,then,compose,collection,task,manager,location,preferred,locations,slot,provider,allocate,slot,to,schedule,queued,preferred,locations,then,apply,simple,slot,slot,if,try,assign,resource,slot,return,this,else,slot,release,slot,throw,new,completion,exception,new,flink,exception,could,not,assign,slot,slot,to,execution,this,because,it,has,already,been,assigned,else,throw,new,illegal,execution,state,exception,this,created,state
Execution -> public CompletableFuture<Execution> allocateAndAssignSlotForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint) throws IllegalExecutionStateException;1513201052;Allocates and assigns a slot obtained from the slot provider to the execution.__@param slotProvider to obtain a new slot from_@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@return Future which is completed with this execution once the slot has been assigned_or with an exception if an error occurred._@throws IllegalExecutionStateException if this method has been called while not being in the CREATED state;public CompletableFuture<Execution> allocateAndAssignSlotForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) throws IllegalExecutionStateException {__		checkNotNull(slotProvider)___		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new IllegalStateException(_					"Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		_		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_					new ScheduledUnit(this, sharingGroup) :_					new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture = calculatePreferredLocations(locationPreferenceConstraint)___			return preferredLocationsFuture_				.thenCompose(_					(Collection<TaskManagerLocation> preferredLocations) ->_						slotProvider.allocateSlot(_							toSchedule,_							queued,_							preferredLocations))_				.thenApply(_					(LogicalSlot logicalSlot) -> {_						if (tryAssignResource(logicalSlot)) {_							return this__						} else {_							_							logicalSlot.releaseSlot()___							throw new CompletionException(new FlinkException("Could not assign slot " + logicalSlot + " to execution " + this + " because it has already been assigned "))__						}_					})__		}_		else {_			_			throw new IllegalExecutionStateException(this, CREATED, state)__		}_	};allocates,and,assigns,a,slot,obtained,from,the,slot,provider,to,the,execution,param,slot,provider,to,obtain,a,new,slot,from,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,return,future,which,is,completed,with,this,execution,once,the,slot,has,been,assigned,or,with,an,exception,if,an,error,occurred,throws,illegal,execution,state,exception,if,this,method,has,been,called,while,not,being,in,the,created,state;public,completable,future,execution,allocate,and,assign,slot,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,throws,illegal,execution,state,exception,check,not,null,slot,provider,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,illegal,state,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,final,completable,future,collection,task,manager,location,preferred,locations,future,calculate,preferred,locations,location,preference,constraint,return,preferred,locations,future,then,compose,collection,task,manager,location,preferred,locations,slot,provider,allocate,slot,to,schedule,queued,preferred,locations,then,apply,logical,slot,logical,slot,if,try,assign,resource,logical,slot,return,this,else,logical,slot,release,slot,throw,new,completion,exception,new,flink,exception,could,not,assign,slot,logical,slot,to,execution,this,because,it,has,already,been,assigned,else,throw,new,illegal,execution,state,exception,this,created,state
Execution -> public CompletableFuture<Execution> allocateAndAssignSlotForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint) throws IllegalExecutionStateException;1513201070;Allocates and assigns a slot obtained from the slot provider to the execution.__@param slotProvider to obtain a new slot from_@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@return Future which is completed with this execution once the slot has been assigned_or with an exception if an error occurred._@throws IllegalExecutionStateException if this method has been called while not being in the CREATED state;public CompletableFuture<Execution> allocateAndAssignSlotForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) throws IllegalExecutionStateException {__		checkNotNull(slotProvider)___		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new IllegalStateException(_					"Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		_		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_					new ScheduledUnit(this, sharingGroup) :_					new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture = calculatePreferredLocations(locationPreferenceConstraint)___			return preferredLocationsFuture_				.thenCompose(_					(Collection<TaskManagerLocation> preferredLocations) ->_						slotProvider.allocateSlot(_							toSchedule,_							queued,_							preferredLocations))_				.thenApply(_					(LogicalSlot logicalSlot) -> {_						if (tryAssignResource(logicalSlot)) {_							return this__						} else {_							_							logicalSlot.releaseSlot()___							throw new CompletionException(new FlinkException("Could not assign slot " + logicalSlot + " to execution " + this + " because it has already been assigned "))__						}_					})__		}_		else {_			_			throw new IllegalExecutionStateException(this, CREATED, state)__		}_	};allocates,and,assigns,a,slot,obtained,from,the,slot,provider,to,the,execution,param,slot,provider,to,obtain,a,new,slot,from,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,return,future,which,is,completed,with,this,execution,once,the,slot,has,been,assigned,or,with,an,exception,if,an,error,occurred,throws,illegal,execution,state,exception,if,this,method,has,been,called,while,not,being,in,the,created,state;public,completable,future,execution,allocate,and,assign,slot,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,throws,illegal,execution,state,exception,check,not,null,slot,provider,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,illegal,state,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,final,completable,future,collection,task,manager,location,preferred,locations,future,calculate,preferred,locations,location,preference,constraint,return,preferred,locations,future,then,compose,collection,task,manager,location,preferred,locations,slot,provider,allocate,slot,to,schedule,queued,preferred,locations,then,apply,logical,slot,logical,slot,if,try,assign,resource,logical,slot,return,this,else,logical,slot,release,slot,throw,new,completion,exception,new,flink,exception,could,not,assign,slot,logical,slot,to,execution,this,because,it,has,already,been,assigned,else,throw,new,illegal,execution,state,exception,this,created,state
Execution -> public CompletableFuture<Execution> allocateAndAssignSlotForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint) throws IllegalExecutionStateException;1513261599;Allocates and assigns a slot obtained from the slot provider to the execution.__@param slotProvider to obtain a new slot from_@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@return Future which is completed with this execution once the slot has been assigned_or with an exception if an error occurred._@throws IllegalExecutionStateException if this method has been called while not being in the CREATED state;public CompletableFuture<Execution> allocateAndAssignSlotForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) throws IllegalExecutionStateException {__		checkNotNull(slotProvider)___		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new IllegalStateException(_					"Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		_		if (transitionState(CREATED, SCHEDULED)) {__			final SlotSharingGroupId slotSharingGroupId = sharingGroup != null ? sharingGroup.getSlotSharingGroupId() : null___			ScheduledUnit toSchedule = locationConstraint == null ?_					new ScheduledUnit(this, slotSharingGroupId) :_					new ScheduledUnit(this, slotSharingGroupId, locationConstraint)___			_			final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture = calculatePreferredLocations(locationPreferenceConstraint)___			return preferredLocationsFuture_				.thenCompose(_					(Collection<TaskManagerLocation> preferredLocations) ->_						slotProvider.allocateSlot(_							toSchedule,_							queued,_							preferredLocations))_				.thenApply(_					(LogicalSlot logicalSlot) -> {_						if (tryAssignResource(logicalSlot)) {_							return this__						} else {_							_							logicalSlot.releaseSlot(new FlinkException("Could not assign logical slot to execution " + this + '.'))___							throw new CompletionException(new FlinkException("Could not assign slot " + logicalSlot + " to execution " + this + " because it has already been assigned "))__						}_					})__		}_		else {_			_			throw new IllegalExecutionStateException(this, CREATED, state)__		}_	};allocates,and,assigns,a,slot,obtained,from,the,slot,provider,to,the,execution,param,slot,provider,to,obtain,a,new,slot,from,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,return,future,which,is,completed,with,this,execution,once,the,slot,has,been,assigned,or,with,an,exception,if,an,error,occurred,throws,illegal,execution,state,exception,if,this,method,has,been,called,while,not,being,in,the,created,state;public,completable,future,execution,allocate,and,assign,slot,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,throws,illegal,execution,state,exception,check,not,null,slot,provider,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,illegal,state,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,final,slot,sharing,group,id,slot,sharing,group,id,sharing,group,null,sharing,group,get,slot,sharing,group,id,null,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,slot,sharing,group,id,new,scheduled,unit,this,slot,sharing,group,id,location,constraint,final,completable,future,collection,task,manager,location,preferred,locations,future,calculate,preferred,locations,location,preference,constraint,return,preferred,locations,future,then,compose,collection,task,manager,location,preferred,locations,slot,provider,allocate,slot,to,schedule,queued,preferred,locations,then,apply,logical,slot,logical,slot,if,try,assign,resource,logical,slot,return,this,else,logical,slot,release,slot,new,flink,exception,could,not,assign,logical,slot,to,execution,this,throw,new,completion,exception,new,flink,exception,could,not,assign,slot,logical,slot,to,execution,this,because,it,has,already,been,assigned,else,throw,new,illegal,execution,state,exception,this,created,state
Execution -> public CompletableFuture<Execution> allocateAndAssignSlotForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint) throws IllegalExecutionStateException;1515177485;Allocates and assigns a slot obtained from the slot provider to the execution.__@param slotProvider to obtain a new slot from_@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@return Future which is completed with this execution once the slot has been assigned_or with an exception if an error occurred._@throws IllegalExecutionStateException if this method has been called while not being in the CREATED state;public CompletableFuture<Execution> allocateAndAssignSlotForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) throws IllegalExecutionStateException {__		checkNotNull(slotProvider)___		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new IllegalStateException(_					"Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		_		if (transitionState(CREATED, SCHEDULED)) {__			final SlotSharingGroupId slotSharingGroupId = sharingGroup != null ? sharingGroup.getSlotSharingGroupId() : null___			ScheduledUnit toSchedule = locationConstraint == null ?_					new ScheduledUnit(this, slotSharingGroupId) :_					new ScheduledUnit(this, slotSharingGroupId, locationConstraint)___			_			final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture = calculatePreferredLocations(locationPreferenceConstraint)___			return preferredLocationsFuture_				.thenCompose(_					(Collection<TaskManagerLocation> preferredLocations) ->_						slotProvider.allocateSlot(_							toSchedule,_							queued,_							preferredLocations))_				.thenApply(_					(LogicalSlot logicalSlot) -> {_						if (tryAssignResource(logicalSlot)) {_							return this__						} else {_							_							logicalSlot.releaseSlot(new FlinkException("Could not assign logical slot to execution " + this + '.'))___							throw new CompletionException(new FlinkException("Could not assign slot " + logicalSlot + " to execution " + this + " because it has already been assigned "))__						}_					})__		}_		else {_			_			throw new IllegalExecutionStateException(this, CREATED, state)__		}_	};allocates,and,assigns,a,slot,obtained,from,the,slot,provider,to,the,execution,param,slot,provider,to,obtain,a,new,slot,from,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,return,future,which,is,completed,with,this,execution,once,the,slot,has,been,assigned,or,with,an,exception,if,an,error,occurred,throws,illegal,execution,state,exception,if,this,method,has,been,called,while,not,being,in,the,created,state;public,completable,future,execution,allocate,and,assign,slot,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,throws,illegal,execution,state,exception,check,not,null,slot,provider,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,illegal,state,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,final,slot,sharing,group,id,slot,sharing,group,id,sharing,group,null,sharing,group,get,slot,sharing,group,id,null,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,slot,sharing,group,id,new,scheduled,unit,this,slot,sharing,group,id,location,constraint,final,completable,future,collection,task,manager,location,preferred,locations,future,calculate,preferred,locations,location,preference,constraint,return,preferred,locations,future,then,compose,collection,task,manager,location,preferred,locations,slot,provider,allocate,slot,to,schedule,queued,preferred,locations,then,apply,logical,slot,logical,slot,if,try,assign,resource,logical,slot,return,this,else,logical,slot,release,slot,new,flink,exception,could,not,assign,logical,slot,to,execution,this,throw,new,completion,exception,new,flink,exception,could,not,assign,slot,logical,slot,to,execution,this,because,it,has,already,been,assigned,else,throw,new,illegal,execution,state,exception,this,created,state
Execution -> public CompletableFuture<Execution> allocateAndAssignSlotForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint) throws IllegalExecutionStateException;1516626377;Allocates and assigns a slot obtained from the slot provider to the execution.__@param slotProvider to obtain a new slot from_@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@return Future which is completed with this execution once the slot has been assigned_or with an exception if an error occurred._@throws IllegalExecutionStateException if this method has been called while not being in the CREATED state;public CompletableFuture<Execution> allocateAndAssignSlotForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) throws IllegalExecutionStateException {__		checkNotNull(slotProvider)___		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new IllegalStateException(_					"Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		_		if (transitionState(CREATED, SCHEDULED)) {__			final SlotSharingGroupId slotSharingGroupId = sharingGroup != null ? sharingGroup.getSlotSharingGroupId() : null___			ScheduledUnit toSchedule = locationConstraint == null ?_					new ScheduledUnit(this, slotSharingGroupId) :_					new ScheduledUnit(this, slotSharingGroupId, locationConstraint)___			_			final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture = calculatePreferredLocations(locationPreferenceConstraint)___			return preferredLocationsFuture_				.thenCompose(_					(Collection<TaskManagerLocation> preferredLocations) ->_						slotProvider.allocateSlot(_							toSchedule,_							queued,_							preferredLocations))_				.thenApply(_					(LogicalSlot logicalSlot) -> {_						if (tryAssignResource(logicalSlot)) {_							return this__						} else {_							_							logicalSlot.releaseSlot(new FlinkException("Could not assign logical slot to execution " + this + '.'))___							throw new CompletionException(new FlinkException("Could not assign slot " + logicalSlot + " to execution " + this + " because it has already been assigned "))__						}_					})__		}_		else {_			_			throw new IllegalExecutionStateException(this, CREATED, state)__		}_	};allocates,and,assigns,a,slot,obtained,from,the,slot,provider,to,the,execution,param,slot,provider,to,obtain,a,new,slot,from,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,return,future,which,is,completed,with,this,execution,once,the,slot,has,been,assigned,or,with,an,exception,if,an,error,occurred,throws,illegal,execution,state,exception,if,this,method,has,been,called,while,not,being,in,the,created,state;public,completable,future,execution,allocate,and,assign,slot,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,throws,illegal,execution,state,exception,check,not,null,slot,provider,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,illegal,state,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,final,slot,sharing,group,id,slot,sharing,group,id,sharing,group,null,sharing,group,get,slot,sharing,group,id,null,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,slot,sharing,group,id,new,scheduled,unit,this,slot,sharing,group,id,location,constraint,final,completable,future,collection,task,manager,location,preferred,locations,future,calculate,preferred,locations,location,preference,constraint,return,preferred,locations,future,then,compose,collection,task,manager,location,preferred,locations,slot,provider,allocate,slot,to,schedule,queued,preferred,locations,then,apply,logical,slot,logical,slot,if,try,assign,resource,logical,slot,return,this,else,logical,slot,release,slot,new,flink,exception,could,not,assign,logical,slot,to,execution,this,throw,new,completion,exception,new,flink,exception,could,not,assign,slot,logical,slot,to,execution,this,because,it,has,already,been,assigned,else,throw,new,illegal,execution,state,exception,this,created,state
Execution -> public CompletableFuture<Execution> allocateAndAssignSlotForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint) throws IllegalExecutionStateException;1516626397;Allocates and assigns a slot obtained from the slot provider to the execution.__@param slotProvider to obtain a new slot from_@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@return Future which is completed with this execution once the slot has been assigned_or with an exception if an error occurred._@throws IllegalExecutionStateException if this method has been called while not being in the CREATED state;public CompletableFuture<Execution> allocateAndAssignSlotForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) throws IllegalExecutionStateException {__		checkNotNull(slotProvider)___		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new IllegalStateException(_					"Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		_		if (transitionState(CREATED, SCHEDULED)) {__			final SlotSharingGroupId slotSharingGroupId = sharingGroup != null ? sharingGroup.getSlotSharingGroupId() : null___			ScheduledUnit toSchedule = locationConstraint == null ?_					new ScheduledUnit(this, slotSharingGroupId) :_					new ScheduledUnit(this, slotSharingGroupId, locationConstraint)___			_			final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture = calculatePreferredLocations(locationPreferenceConstraint)___			return preferredLocationsFuture_				.thenCompose(_					(Collection<TaskManagerLocation> preferredLocations) ->_						slotProvider.allocateSlot(_							toSchedule,_							queued,_							preferredLocations))_				.thenApply(_					(LogicalSlot logicalSlot) -> {_						if (tryAssignResource(logicalSlot)) {_							return this__						} else {_							_							logicalSlot.releaseSlot(new FlinkException("Could not assign logical slot to execution " + this + '.'))___							throw new CompletionException(new FlinkException("Could not assign slot " + logicalSlot + " to execution " + this + " because it has already been assigned "))__						}_					})__		}_		else {_			_			throw new IllegalExecutionStateException(this, CREATED, state)__		}_	};allocates,and,assigns,a,slot,obtained,from,the,slot,provider,to,the,execution,param,slot,provider,to,obtain,a,new,slot,from,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,return,future,which,is,completed,with,this,execution,once,the,slot,has,been,assigned,or,with,an,exception,if,an,error,occurred,throws,illegal,execution,state,exception,if,this,method,has,been,called,while,not,being,in,the,created,state;public,completable,future,execution,allocate,and,assign,slot,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,throws,illegal,execution,state,exception,check,not,null,slot,provider,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,illegal,state,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,final,slot,sharing,group,id,slot,sharing,group,id,sharing,group,null,sharing,group,get,slot,sharing,group,id,null,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,slot,sharing,group,id,new,scheduled,unit,this,slot,sharing,group,id,location,constraint,final,completable,future,collection,task,manager,location,preferred,locations,future,calculate,preferred,locations,location,preference,constraint,return,preferred,locations,future,then,compose,collection,task,manager,location,preferred,locations,slot,provider,allocate,slot,to,schedule,queued,preferred,locations,then,apply,logical,slot,logical,slot,if,try,assign,resource,logical,slot,return,this,else,logical,slot,release,slot,new,flink,exception,could,not,assign,logical,slot,to,execution,this,throw,new,completion,exception,new,flink,exception,could,not,assign,slot,logical,slot,to,execution,this,because,it,has,already,been,assigned,else,throw,new,illegal,execution,state,exception,this,created,state
Execution -> private void sendCancelRpcCall(int numberRetries);1550683188;This method sends a CancelTask message to the instance of the assigned slot.__<p>The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall(int numberRetries) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final ComponentMainThreadExecutor jobMasterMainThreadExecutor =_				getVertex().getExecutionGraph().getJobMasterMainThreadExecutor()___			CompletableFuture<Acknowledge> cancelResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.cancelTask(attemptId, rpcTimeout),_				numberRetries,_				jobMasterMainThreadExecutor)___			cancelResultFuture.whenComplete(_				(ack, failure) -> {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					}_				})__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,p,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,int,number,retries,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,component,main,thread,executor,job,master,main,thread,executor,get,vertex,get,execution,graph,get,job,master,main,thread,executor,completable,future,acknowledge,cancel,result,future,future,utils,retry,task,manager,gateway,cancel,task,attempt,id,rpc,timeout,number,retries,job,master,main,thread,executor,cancel,result,future,when,complete,ack,failure,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure
Execution -> private void sendCancelRpcCall(int numberRetries);1550855836;This method sends a CancelTask message to the instance of the assigned slot.__<p>The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall(int numberRetries) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final ComponentMainThreadExecutor jobMasterMainThreadExecutor =_				getVertex().getExecutionGraph().getJobMasterMainThreadExecutor()___			CompletableFuture<Acknowledge> cancelResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.cancelTask(attemptId, rpcTimeout),_				numberRetries,_				jobMasterMainThreadExecutor)___			cancelResultFuture.whenComplete(_				(ack, failure) -> {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					}_				})__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,p,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,int,number,retries,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,component,main,thread,executor,job,master,main,thread,executor,get,vertex,get,execution,graph,get,job,master,main,thread,executor,completable,future,acknowledge,cancel,result,future,future,utils,retry,task,manager,gateway,cancel,task,attempt,id,rpc,timeout,number,retries,job,master,main,thread,executor,cancel,result,future,when,complete,ack,failure,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure
Execution -> public CompletableFuture<Execution> allocateAndAssignSlotForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds, 			Time allocationTimeout) throws IllegalExecutionStateException;1540920690;Allocates and assigns a slot obtained from the slot provider to the execution.__@param slotProvider to obtain a new slot from_@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph._Can be empty if the allocation ids are not required for scheduling._@param allocationTimeout rpcTimeout for allocating a new slot_@return Future which is completed with this execution once the slot has been assigned_or with an exception if an error occurred._@throws IllegalExecutionStateException if this method has been called while not being in the CREATED state;public CompletableFuture<Execution> allocateAndAssignSlotForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds,_			Time allocationTimeout) throws IllegalExecutionStateException {__		checkNotNull(slotProvider)___		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new IllegalStateException(_					"Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		_		if (transitionState(CREATED, SCHEDULED)) {__			final SlotSharingGroupId slotSharingGroupId = sharingGroup != null ? sharingGroup.getSlotSharingGroupId() : null___			ScheduledUnit toSchedule = locationConstraint == null ?_					new ScheduledUnit(this, slotSharingGroupId) :_					new ScheduledUnit(this, slotSharingGroupId, locationConstraint)___			_			ExecutionVertex executionVertex = getVertex()__			AllocationID lastAllocation = executionVertex.getLatestPriorAllocation()___			Collection<AllocationID> previousAllocationIDs =_				lastAllocation != null ? Collections.singletonList(lastAllocation) : Collections.emptyList()___			_			final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture =_				calculatePreferredLocations(locationPreferenceConstraint)___			final SlotRequestId slotRequestId = new SlotRequestId()___			final CompletableFuture<LogicalSlot> logicalSlotFuture = preferredLocationsFuture_				.thenCompose(_					(Collection<TaskManagerLocation> preferredLocations) ->_						slotProvider.allocateSlot(_							slotRequestId,_							toSchedule,_							queued,_							new SlotProfile(_								ResourceProfile.UNKNOWN,_								preferredLocations,_								previousAllocationIDs,_								allPreviousExecutionGraphAllocationIds),_							allocationTimeout))___			_			releaseFuture.whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (logicalSlotFuture.cancel(false)) {_						slotProvider.cancelSlotRequest(_							slotRequestId,_							slotSharingGroupId,_							new FlinkException("Execution " + this + " was released."))__					}_				})___			return logicalSlotFuture.thenApply(_				(LogicalSlot logicalSlot) -> {_					if (tryAssignResource(logicalSlot)) {_						return this__					} else {_						_						logicalSlot.releaseSlot(new FlinkException("Could not assign logical slot to execution " + this + '.'))___						throw new CompletionException(new FlinkException("Could not assign slot " + logicalSlot + " to execution " + this + " because it has already been assigned "))__					}_				})__		}_		else {_			_			throw new IllegalExecutionStateException(this, CREATED, state)__		}_	};allocates,and,assigns,a,slot,obtained,from,the,slot,provider,to,the,execution,param,slot,provider,to,obtain,a,new,slot,from,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,set,with,all,previous,allocation,ids,in,the,job,graph,can,be,empty,if,the,allocation,ids,are,not,required,for,scheduling,param,allocation,timeout,rpc,timeout,for,allocating,a,new,slot,return,future,which,is,completed,with,this,execution,once,the,slot,has,been,assigned,or,with,an,exception,if,an,error,occurred,throws,illegal,execution,state,exception,if,this,method,has,been,called,while,not,being,in,the,created,state;public,completable,future,execution,allocate,and,assign,slot,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,time,allocation,timeout,throws,illegal,execution,state,exception,check,not,null,slot,provider,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,illegal,state,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,final,slot,sharing,group,id,slot,sharing,group,id,sharing,group,null,sharing,group,get,slot,sharing,group,id,null,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,slot,sharing,group,id,new,scheduled,unit,this,slot,sharing,group,id,location,constraint,execution,vertex,execution,vertex,get,vertex,allocation,id,last,allocation,execution,vertex,get,latest,prior,allocation,collection,allocation,id,previous,allocation,ids,last,allocation,null,collections,singleton,list,last,allocation,collections,empty,list,final,completable,future,collection,task,manager,location,preferred,locations,future,calculate,preferred,locations,location,preference,constraint,final,slot,request,id,slot,request,id,new,slot,request,id,final,completable,future,logical,slot,logical,slot,future,preferred,locations,future,then,compose,collection,task,manager,location,preferred,locations,slot,provider,allocate,slot,slot,request,id,to,schedule,queued,new,slot,profile,resource,profile,unknown,preferred,locations,previous,allocation,ids,all,previous,execution,graph,allocation,ids,allocation,timeout,release,future,when,complete,object,ignored,throwable,throwable,if,logical,slot,future,cancel,false,slot,provider,cancel,slot,request,slot,request,id,slot,sharing,group,id,new,flink,exception,execution,this,was,released,return,logical,slot,future,then,apply,logical,slot,logical,slot,if,try,assign,resource,logical,slot,return,this,else,logical,slot,release,slot,new,flink,exception,could,not,assign,logical,slot,to,execution,this,throw,new,completion,exception,new,flink,exception,could,not,assign,slot,logical,slot,to,execution,this,because,it,has,already,been,assigned,else,throw,new,illegal,execution,state,exception,this,created,state
Execution -> public CompletableFuture<Execution> allocateAndAssignSlotForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds, 			Time allocationTimeout) throws IllegalExecutionStateException;1542356428;Allocates and assigns a slot obtained from the slot provider to the execution.__@param slotProvider to obtain a new slot from_@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph._Can be empty if the allocation ids are not required for scheduling._@param allocationTimeout rpcTimeout for allocating a new slot_@return Future which is completed with this execution once the slot has been assigned_or with an exception if an error occurred._@throws IllegalExecutionStateException if this method has been called while not being in the CREATED state;public CompletableFuture<Execution> allocateAndAssignSlotForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds,_			Time allocationTimeout) throws IllegalExecutionStateException {__		checkNotNull(slotProvider)___		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new IllegalStateException(_					"Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		_		if (transitionState(CREATED, SCHEDULED)) {__			final SlotSharingGroupId slotSharingGroupId = sharingGroup != null ? sharingGroup.getSlotSharingGroupId() : null___			ScheduledUnit toSchedule = locationConstraint == null ?_					new ScheduledUnit(this, slotSharingGroupId) :_					new ScheduledUnit(this, slotSharingGroupId, locationConstraint)___			_			ExecutionVertex executionVertex = getVertex()__			AllocationID lastAllocation = executionVertex.getLatestPriorAllocation()___			Collection<AllocationID> previousAllocationIDs =_				lastAllocation != null ? Collections.singletonList(lastAllocation) : Collections.emptyList()___			_			final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture =_				calculatePreferredLocations(locationPreferenceConstraint)___			final SlotRequestId slotRequestId = new SlotRequestId()___			final CompletableFuture<LogicalSlot> logicalSlotFuture = preferredLocationsFuture_				.thenCompose(_					(Collection<TaskManagerLocation> preferredLocations) ->_						slotProvider.allocateSlot(_							slotRequestId,_							toSchedule,_							queued,_							new SlotProfile(_								ResourceProfile.UNKNOWN,_								preferredLocations,_								previousAllocationIDs,_								allPreviousExecutionGraphAllocationIds),_							allocationTimeout))___			_			releaseFuture.whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (logicalSlotFuture.cancel(false)) {_						slotProvider.cancelSlotRequest(_							slotRequestId,_							slotSharingGroupId,_							new FlinkException("Execution " + this + " was released."))__					}_				})___			return logicalSlotFuture.thenApply(_				(LogicalSlot logicalSlot) -> {_					if (tryAssignResource(logicalSlot)) {_						return this__					} else {_						_						logicalSlot.releaseSlot(new FlinkException("Could not assign logical slot to execution " + this + '.'))___						throw new CompletionException(new FlinkException("Could not assign slot " + logicalSlot + " to execution " + this + " because it has already been assigned "))__					}_				})__		}_		else {_			_			throw new IllegalExecutionStateException(this, CREATED, state)__		}_	};allocates,and,assigns,a,slot,obtained,from,the,slot,provider,to,the,execution,param,slot,provider,to,obtain,a,new,slot,from,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,set,with,all,previous,allocation,ids,in,the,job,graph,can,be,empty,if,the,allocation,ids,are,not,required,for,scheduling,param,allocation,timeout,rpc,timeout,for,allocating,a,new,slot,return,future,which,is,completed,with,this,execution,once,the,slot,has,been,assigned,or,with,an,exception,if,an,error,occurred,throws,illegal,execution,state,exception,if,this,method,has,been,called,while,not,being,in,the,created,state;public,completable,future,execution,allocate,and,assign,slot,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,time,allocation,timeout,throws,illegal,execution,state,exception,check,not,null,slot,provider,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,illegal,state,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,final,slot,sharing,group,id,slot,sharing,group,id,sharing,group,null,sharing,group,get,slot,sharing,group,id,null,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,slot,sharing,group,id,new,scheduled,unit,this,slot,sharing,group,id,location,constraint,execution,vertex,execution,vertex,get,vertex,allocation,id,last,allocation,execution,vertex,get,latest,prior,allocation,collection,allocation,id,previous,allocation,ids,last,allocation,null,collections,singleton,list,last,allocation,collections,empty,list,final,completable,future,collection,task,manager,location,preferred,locations,future,calculate,preferred,locations,location,preference,constraint,final,slot,request,id,slot,request,id,new,slot,request,id,final,completable,future,logical,slot,logical,slot,future,preferred,locations,future,then,compose,collection,task,manager,location,preferred,locations,slot,provider,allocate,slot,slot,request,id,to,schedule,queued,new,slot,profile,resource,profile,unknown,preferred,locations,previous,allocation,ids,all,previous,execution,graph,allocation,ids,allocation,timeout,release,future,when,complete,object,ignored,throwable,throwable,if,logical,slot,future,cancel,false,slot,provider,cancel,slot,request,slot,request,id,slot,sharing,group,id,new,flink,exception,execution,this,was,released,return,logical,slot,future,then,apply,logical,slot,logical,slot,if,try,assign,resource,logical,slot,return,this,else,logical,slot,release,slot,new,flink,exception,could,not,assign,logical,slot,to,execution,this,throw,new,completion,exception,new,flink,exception,could,not,assign,slot,logical,slot,to,execution,this,because,it,has,already,been,assigned,else,throw,new,illegal,execution,state,exception,this,created,state
Execution -> public CompletableFuture<Execution> allocateAndAssignSlotForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds, 			Time allocationTimeout) throws IllegalExecutionStateException;1546870832;Allocates and assigns a slot obtained from the slot provider to the execution.__@param slotProvider to obtain a new slot from_@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph._Can be empty if the allocation ids are not required for scheduling._@param allocationTimeout rpcTimeout for allocating a new slot_@return Future which is completed with this execution once the slot has been assigned_or with an exception if an error occurred._@throws IllegalExecutionStateException if this method has been called while not being in the CREATED state;public CompletableFuture<Execution> allocateAndAssignSlotForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds,_			Time allocationTimeout) throws IllegalExecutionStateException {__		checkNotNull(slotProvider)___		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new IllegalStateException(_					"Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		_		if (transitionState(CREATED, SCHEDULED)) {__			final SlotSharingGroupId slotSharingGroupId = sharingGroup != null ? sharingGroup.getSlotSharingGroupId() : null___			ScheduledUnit toSchedule = locationConstraint == null ?_					new ScheduledUnit(this, slotSharingGroupId) :_					new ScheduledUnit(this, slotSharingGroupId, locationConstraint)___			_			ExecutionVertex executionVertex = getVertex()__			AllocationID lastAllocation = executionVertex.getLatestPriorAllocation()___			Collection<AllocationID> previousAllocationIDs =_				lastAllocation != null ? Collections.singletonList(lastAllocation) : Collections.emptyList()___			_			final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture =_				calculatePreferredLocations(locationPreferenceConstraint)___			final SlotRequestId slotRequestId = new SlotRequestId()___			final CompletableFuture<LogicalSlot> logicalSlotFuture = preferredLocationsFuture_				.thenCompose(_					(Collection<TaskManagerLocation> preferredLocations) ->_						slotProvider.allocateSlot(_							slotRequestId,_							toSchedule,_							queued,_							new SlotProfile(_								ResourceProfile.UNKNOWN,_								preferredLocations,_								previousAllocationIDs,_								allPreviousExecutionGraphAllocationIds),_							allocationTimeout))___			_			releaseFuture.whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (logicalSlotFuture.cancel(false)) {_						slotProvider.cancelSlotRequest(_							slotRequestId,_							slotSharingGroupId,_							new FlinkException("Execution " + this + " was released."))__					}_				})___			return logicalSlotFuture.thenApply(_				(LogicalSlot logicalSlot) -> {_					if (tryAssignResource(logicalSlot)) {_						return this__					} else {_						_						logicalSlot.releaseSlot(new FlinkException("Could not assign logical slot to execution " + this + '.'))___						throw new CompletionException(new FlinkException("Could not assign slot " + logicalSlot + " to execution " + this + " because it has already been assigned "))__					}_				})__		}_		else {_			_			throw new IllegalExecutionStateException(this, CREATED, state)__		}_	};allocates,and,assigns,a,slot,obtained,from,the,slot,provider,to,the,execution,param,slot,provider,to,obtain,a,new,slot,from,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,set,with,all,previous,allocation,ids,in,the,job,graph,can,be,empty,if,the,allocation,ids,are,not,required,for,scheduling,param,allocation,timeout,rpc,timeout,for,allocating,a,new,slot,return,future,which,is,completed,with,this,execution,once,the,slot,has,been,assigned,or,with,an,exception,if,an,error,occurred,throws,illegal,execution,state,exception,if,this,method,has,been,called,while,not,being,in,the,created,state;public,completable,future,execution,allocate,and,assign,slot,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,time,allocation,timeout,throws,illegal,execution,state,exception,check,not,null,slot,provider,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,illegal,state,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,final,slot,sharing,group,id,slot,sharing,group,id,sharing,group,null,sharing,group,get,slot,sharing,group,id,null,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,slot,sharing,group,id,new,scheduled,unit,this,slot,sharing,group,id,location,constraint,execution,vertex,execution,vertex,get,vertex,allocation,id,last,allocation,execution,vertex,get,latest,prior,allocation,collection,allocation,id,previous,allocation,ids,last,allocation,null,collections,singleton,list,last,allocation,collections,empty,list,final,completable,future,collection,task,manager,location,preferred,locations,future,calculate,preferred,locations,location,preference,constraint,final,slot,request,id,slot,request,id,new,slot,request,id,final,completable,future,logical,slot,logical,slot,future,preferred,locations,future,then,compose,collection,task,manager,location,preferred,locations,slot,provider,allocate,slot,slot,request,id,to,schedule,queued,new,slot,profile,resource,profile,unknown,preferred,locations,previous,allocation,ids,all,previous,execution,graph,allocation,ids,allocation,timeout,release,future,when,complete,object,ignored,throwable,throwable,if,logical,slot,future,cancel,false,slot,provider,cancel,slot,request,slot,request,id,slot,sharing,group,id,new,flink,exception,execution,this,was,released,return,logical,slot,future,then,apply,logical,slot,logical,slot,if,try,assign,resource,logical,slot,return,this,else,logical,slot,release,slot,new,flink,exception,could,not,assign,logical,slot,to,execution,this,throw,new,completion,exception,new,flink,exception,could,not,assign,slot,logical,slot,to,execution,this,because,it,has,already,been,assigned,else,throw,new,illegal,execution,state,exception,this,created,state
Execution -> public CompletableFuture<Execution> allocateAndAssignSlotForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds, 			Time allocationTimeout) throws IllegalExecutionStateException;1547644408;Allocates and assigns a slot obtained from the slot provider to the execution.__@param slotProvider to obtain a new slot from_@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph._Can be empty if the allocation ids are not required for scheduling._@param allocationTimeout rpcTimeout for allocating a new slot_@return Future which is completed with this execution once the slot has been assigned_or with an exception if an error occurred._@throws IllegalExecutionStateException if this method has been called while not being in the CREATED state;public CompletableFuture<Execution> allocateAndAssignSlotForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds,_			Time allocationTimeout) throws IllegalExecutionStateException {__		checkNotNull(slotProvider)___		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new IllegalStateException(_					"Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		_		if (transitionState(CREATED, SCHEDULED)) {__			final SlotSharingGroupId slotSharingGroupId = sharingGroup != null ? sharingGroup.getSlotSharingGroupId() : null___			ScheduledUnit toSchedule = locationConstraint == null ?_					new ScheduledUnit(this, slotSharingGroupId) :_					new ScheduledUnit(this, slotSharingGroupId, locationConstraint)___			_			ExecutionVertex executionVertex = getVertex()__			AllocationID lastAllocation = executionVertex.getLatestPriorAllocation()___			Collection<AllocationID> previousAllocationIDs =_				lastAllocation != null ? Collections.singletonList(lastAllocation) : Collections.emptyList()___			_			final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture =_				calculatePreferredLocations(locationPreferenceConstraint)___			final SlotRequestId slotRequestId = new SlotRequestId()___			final CompletableFuture<LogicalSlot> logicalSlotFuture = preferredLocationsFuture_				.thenCompose(_					(Collection<TaskManagerLocation> preferredLocations) ->_						slotProvider.allocateSlot(_							slotRequestId,_							toSchedule,_							queued,_							new SlotProfile(_								ResourceProfile.UNKNOWN,_								preferredLocations,_								previousAllocationIDs,_								allPreviousExecutionGraphAllocationIds),_							allocationTimeout))___			_			releaseFuture.whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (logicalSlotFuture.cancel(false)) {_						slotProvider.cancelSlotRequest(_							slotRequestId,_							slotSharingGroupId,_							new FlinkException("Execution " + this + " was released."))__					}_				})___			return logicalSlotFuture.thenApply(_				(LogicalSlot logicalSlot) -> {_					if (tryAssignResource(logicalSlot)) {_						return this__					} else {_						_						logicalSlot.releaseSlot(new FlinkException("Could not assign logical slot to execution " + this + '.'))___						throw new CompletionException(new FlinkException("Could not assign slot " + logicalSlot + " to execution " + this + " because it has already been assigned "))__					}_				})__		}_		else {_			_			throw new IllegalExecutionStateException(this, CREATED, state)__		}_	};allocates,and,assigns,a,slot,obtained,from,the,slot,provider,to,the,execution,param,slot,provider,to,obtain,a,new,slot,from,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,set,with,all,previous,allocation,ids,in,the,job,graph,can,be,empty,if,the,allocation,ids,are,not,required,for,scheduling,param,allocation,timeout,rpc,timeout,for,allocating,a,new,slot,return,future,which,is,completed,with,this,execution,once,the,slot,has,been,assigned,or,with,an,exception,if,an,error,occurred,throws,illegal,execution,state,exception,if,this,method,has,been,called,while,not,being,in,the,created,state;public,completable,future,execution,allocate,and,assign,slot,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,time,allocation,timeout,throws,illegal,execution,state,exception,check,not,null,slot,provider,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,illegal,state,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,final,slot,sharing,group,id,slot,sharing,group,id,sharing,group,null,sharing,group,get,slot,sharing,group,id,null,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,slot,sharing,group,id,new,scheduled,unit,this,slot,sharing,group,id,location,constraint,execution,vertex,execution,vertex,get,vertex,allocation,id,last,allocation,execution,vertex,get,latest,prior,allocation,collection,allocation,id,previous,allocation,ids,last,allocation,null,collections,singleton,list,last,allocation,collections,empty,list,final,completable,future,collection,task,manager,location,preferred,locations,future,calculate,preferred,locations,location,preference,constraint,final,slot,request,id,slot,request,id,new,slot,request,id,final,completable,future,logical,slot,logical,slot,future,preferred,locations,future,then,compose,collection,task,manager,location,preferred,locations,slot,provider,allocate,slot,slot,request,id,to,schedule,queued,new,slot,profile,resource,profile,unknown,preferred,locations,previous,allocation,ids,all,previous,execution,graph,allocation,ids,allocation,timeout,release,future,when,complete,object,ignored,throwable,throwable,if,logical,slot,future,cancel,false,slot,provider,cancel,slot,request,slot,request,id,slot,sharing,group,id,new,flink,exception,execution,this,was,released,return,logical,slot,future,then,apply,logical,slot,logical,slot,if,try,assign,resource,logical,slot,return,this,else,logical,slot,release,slot,new,flink,exception,could,not,assign,logical,slot,to,execution,this,throw,new,completion,exception,new,flink,exception,could,not,assign,slot,logical,slot,to,execution,this,because,it,has,already,been,assigned,else,throw,new,illegal,execution,state,exception,this,created,state
Execution -> public CompletableFuture<Execution> allocateAndAssignSlotForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds, 			Time allocationTimeout) throws IllegalExecutionStateException;1549365080;Allocates and assigns a slot obtained from the slot provider to the execution.__@param slotProvider to obtain a new slot from_@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph._Can be empty if the allocation ids are not required for scheduling._@param allocationTimeout rpcTimeout for allocating a new slot_@return Future which is completed with this execution once the slot has been assigned_or with an exception if an error occurred._@throws IllegalExecutionStateException if this method has been called while not being in the CREATED state;public CompletableFuture<Execution> allocateAndAssignSlotForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds,_			Time allocationTimeout) throws IllegalExecutionStateException {__		checkNotNull(slotProvider)___		assertRunningInJobMasterMainThread()___		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new IllegalStateException(_					"Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		_		if (transitionState(CREATED, SCHEDULED)) {__			final SlotSharingGroupId slotSharingGroupId = sharingGroup != null ? sharingGroup.getSlotSharingGroupId() : null___			ScheduledUnit toSchedule = locationConstraint == null ?_					new ScheduledUnit(this, slotSharingGroupId) :_					new ScheduledUnit(this, slotSharingGroupId, locationConstraint)___			_			ExecutionVertex executionVertex = getVertex()__			AllocationID lastAllocation = executionVertex.getLatestPriorAllocation()___			Collection<AllocationID> previousAllocationIDs =_				lastAllocation != null ? Collections.singletonList(lastAllocation) : Collections.emptyList()___			_			final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture =_				calculatePreferredLocations(locationPreferenceConstraint)___			final SlotRequestId slotRequestId = new SlotRequestId()___			final ComponentMainThreadExecutor mainThreadExecutor =_				vertex.getExecutionGraph().getJobMasterMainThreadExecutor()___			final CompletableFuture<LogicalSlot> logicalSlotFuture =_				preferredLocationsFuture.thenCompose(_					(Collection<TaskManagerLocation> preferredLocations) ->_						slotProvider.allocateSlot(_							slotRequestId,_							toSchedule,_							queued,_							new SlotProfile(_								ResourceProfile.UNKNOWN,_								preferredLocations,_								previousAllocationIDs,_								allPreviousExecutionGraphAllocationIds),_							allocationTimeout))___			_			releaseFuture.whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (logicalSlotFuture.cancel(false)) {_						slotProvider.cancelSlotRequest(_							slotRequestId,_							slotSharingGroupId,_							new FlinkException("Execution " + this + " was released."))__					}_				})___			_			return FutureUtils.handleAsyncIfNotDone(_				logicalSlotFuture,_				mainThreadExecutor,_				(LogicalSlot logicalSlot, Throwable failure) -> {__					if (failure != null) {_						throw new CompletionException(failure)__					}__					if (tryAssignResource(logicalSlot)) {_						return this__					} else {_						_						logicalSlot.releaseSlot(new FlinkException("Could not assign logical slot to execution " + this + '.'))__						throw new CompletionException(_							new FlinkException(_								"Could not assign slot " + logicalSlot + " to execution " + this + " because it has already been assigned "))__					}_				})__		} else {_			_			throw new IllegalExecutionStateException(this, CREATED, state)__		}_	};allocates,and,assigns,a,slot,obtained,from,the,slot,provider,to,the,execution,param,slot,provider,to,obtain,a,new,slot,from,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,set,with,all,previous,allocation,ids,in,the,job,graph,can,be,empty,if,the,allocation,ids,are,not,required,for,scheduling,param,allocation,timeout,rpc,timeout,for,allocating,a,new,slot,return,future,which,is,completed,with,this,execution,once,the,slot,has,been,assigned,or,with,an,exception,if,an,error,occurred,throws,illegal,execution,state,exception,if,this,method,has,been,called,while,not,being,in,the,created,state;public,completable,future,execution,allocate,and,assign,slot,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,time,allocation,timeout,throws,illegal,execution,state,exception,check,not,null,slot,provider,assert,running,in,job,master,main,thread,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,illegal,state,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,final,slot,sharing,group,id,slot,sharing,group,id,sharing,group,null,sharing,group,get,slot,sharing,group,id,null,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,slot,sharing,group,id,new,scheduled,unit,this,slot,sharing,group,id,location,constraint,execution,vertex,execution,vertex,get,vertex,allocation,id,last,allocation,execution,vertex,get,latest,prior,allocation,collection,allocation,id,previous,allocation,ids,last,allocation,null,collections,singleton,list,last,allocation,collections,empty,list,final,completable,future,collection,task,manager,location,preferred,locations,future,calculate,preferred,locations,location,preference,constraint,final,slot,request,id,slot,request,id,new,slot,request,id,final,component,main,thread,executor,main,thread,executor,vertex,get,execution,graph,get,job,master,main,thread,executor,final,completable,future,logical,slot,logical,slot,future,preferred,locations,future,then,compose,collection,task,manager,location,preferred,locations,slot,provider,allocate,slot,slot,request,id,to,schedule,queued,new,slot,profile,resource,profile,unknown,preferred,locations,previous,allocation,ids,all,previous,execution,graph,allocation,ids,allocation,timeout,release,future,when,complete,object,ignored,throwable,throwable,if,logical,slot,future,cancel,false,slot,provider,cancel,slot,request,slot,request,id,slot,sharing,group,id,new,flink,exception,execution,this,was,released,return,future,utils,handle,async,if,not,done,logical,slot,future,main,thread,executor,logical,slot,logical,slot,throwable,failure,if,failure,null,throw,new,completion,exception,failure,if,try,assign,resource,logical,slot,return,this,else,logical,slot,release,slot,new,flink,exception,could,not,assign,logical,slot,to,execution,this,throw,new,completion,exception,new,flink,exception,could,not,assign,slot,logical,slot,to,execution,this,because,it,has,already,been,assigned,else,throw,new,illegal,execution,state,exception,this,created,state
Execution -> public CompletableFuture<Execution> allocateAndAssignSlotForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds, 			Time allocationTimeout) throws IllegalExecutionStateException;1550220073;Allocates and assigns a slot obtained from the slot provider to the execution.__@param slotProvider to obtain a new slot from_@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph._Can be empty if the allocation ids are not required for scheduling._@param allocationTimeout rpcTimeout for allocating a new slot_@return Future which is completed with this execution once the slot has been assigned_or with an exception if an error occurred._@throws IllegalExecutionStateException if this method has been called while not being in the CREATED state;public CompletableFuture<Execution> allocateAndAssignSlotForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds,_			Time allocationTimeout) throws IllegalExecutionStateException {__		checkNotNull(slotProvider)___		assertRunningInJobMasterMainThread()___		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new IllegalStateException(_					"Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		_		if (transitionState(CREATED, SCHEDULED)) {__			final SlotSharingGroupId slotSharingGroupId = sharingGroup != null ? sharingGroup.getSlotSharingGroupId() : null___			ScheduledUnit toSchedule = locationConstraint == null ?_					new ScheduledUnit(this, slotSharingGroupId) :_					new ScheduledUnit(this, slotSharingGroupId, locationConstraint)___			_			ExecutionVertex executionVertex = getVertex()__			AllocationID lastAllocation = executionVertex.getLatestPriorAllocation()___			Collection<AllocationID> previousAllocationIDs =_				lastAllocation != null ? Collections.singletonList(lastAllocation) : Collections.emptyList()___			_			final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture =_				calculatePreferredLocations(locationPreferenceConstraint)___			final SlotRequestId slotRequestId = new SlotRequestId()___			final ComponentMainThreadExecutor mainThreadExecutor =_				vertex.getExecutionGraph().getJobMasterMainThreadExecutor()___			final CompletableFuture<LogicalSlot> logicalSlotFuture =_				preferredLocationsFuture.thenCompose(_					(Collection<TaskManagerLocation> preferredLocations) ->_						slotProvider.allocateSlot(_							slotRequestId,_							toSchedule,_							new SlotProfile(_								ResourceProfile.UNKNOWN,_								preferredLocations,_								previousAllocationIDs,_								allPreviousExecutionGraphAllocationIds),_							queued,_							allocationTimeout))___			_			releaseFuture.whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (logicalSlotFuture.cancel(false)) {_						slotProvider.cancelSlotRequest(_							slotRequestId,_							slotSharingGroupId,_							new FlinkException("Execution " + this + " was released."))__					}_				})___			_			return logicalSlotFuture.handle(_				(LogicalSlot logicalSlot, Throwable failure) -> {__					if (failure != null) {_						throw new CompletionException(failure)__					}__					if (tryAssignResource(logicalSlot)) {_						return this__					} else {_						_						logicalSlot.releaseSlot(new FlinkException("Could not assign logical slot to execution " + this + '.'))__						throw new CompletionException(_							new FlinkException(_								"Could not assign slot " + logicalSlot + " to execution " + this + " because it has already been assigned "))__					}_				})__		} else {_			_			throw new IllegalExecutionStateException(this, CREATED, state)__		}_	};allocates,and,assigns,a,slot,obtained,from,the,slot,provider,to,the,execution,param,slot,provider,to,obtain,a,new,slot,from,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,set,with,all,previous,allocation,ids,in,the,job,graph,can,be,empty,if,the,allocation,ids,are,not,required,for,scheduling,param,allocation,timeout,rpc,timeout,for,allocating,a,new,slot,return,future,which,is,completed,with,this,execution,once,the,slot,has,been,assigned,or,with,an,exception,if,an,error,occurred,throws,illegal,execution,state,exception,if,this,method,has,been,called,while,not,being,in,the,created,state;public,completable,future,execution,allocate,and,assign,slot,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,time,allocation,timeout,throws,illegal,execution,state,exception,check,not,null,slot,provider,assert,running,in,job,master,main,thread,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,illegal,state,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,final,slot,sharing,group,id,slot,sharing,group,id,sharing,group,null,sharing,group,get,slot,sharing,group,id,null,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,slot,sharing,group,id,new,scheduled,unit,this,slot,sharing,group,id,location,constraint,execution,vertex,execution,vertex,get,vertex,allocation,id,last,allocation,execution,vertex,get,latest,prior,allocation,collection,allocation,id,previous,allocation,ids,last,allocation,null,collections,singleton,list,last,allocation,collections,empty,list,final,completable,future,collection,task,manager,location,preferred,locations,future,calculate,preferred,locations,location,preference,constraint,final,slot,request,id,slot,request,id,new,slot,request,id,final,component,main,thread,executor,main,thread,executor,vertex,get,execution,graph,get,job,master,main,thread,executor,final,completable,future,logical,slot,logical,slot,future,preferred,locations,future,then,compose,collection,task,manager,location,preferred,locations,slot,provider,allocate,slot,slot,request,id,to,schedule,new,slot,profile,resource,profile,unknown,preferred,locations,previous,allocation,ids,all,previous,execution,graph,allocation,ids,queued,allocation,timeout,release,future,when,complete,object,ignored,throwable,throwable,if,logical,slot,future,cancel,false,slot,provider,cancel,slot,request,slot,request,id,slot,sharing,group,id,new,flink,exception,execution,this,was,released,return,logical,slot,future,handle,logical,slot,logical,slot,throwable,failure,if,failure,null,throw,new,completion,exception,failure,if,try,assign,resource,logical,slot,return,this,else,logical,slot,release,slot,new,flink,exception,could,not,assign,logical,slot,to,execution,this,throw,new,completion,exception,new,flink,exception,could,not,assign,slot,logical,slot,to,execution,this,because,it,has,already,been,assigned,else,throw,new,illegal,execution,state,exception,this,created,state
Execution -> public CompletableFuture<Execution> allocateAndAssignSlotForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds, 			Time allocationTimeout) throws IllegalExecutionStateException;1550654143;Allocates and assigns a slot obtained from the slot provider to the execution.__@param slotProvider to obtain a new slot from_@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph._Can be empty if the allocation ids are not required for scheduling._@param allocationTimeout rpcTimeout for allocating a new slot_@return Future which is completed with this execution once the slot has been assigned_or with an exception if an error occurred._@throws IllegalExecutionStateException if this method has been called while not being in the CREATED state;public CompletableFuture<Execution> allocateAndAssignSlotForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds,_			Time allocationTimeout) throws IllegalExecutionStateException {__		checkNotNull(slotProvider)___		assertRunningInJobMasterMainThread()___		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new IllegalStateException(_					"Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		_		if (transitionState(CREATED, SCHEDULED)) {__			final SlotSharingGroupId slotSharingGroupId = sharingGroup != null ? sharingGroup.getSlotSharingGroupId() : null___			ScheduledUnit toSchedule = locationConstraint == null ?_					new ScheduledUnit(this, slotSharingGroupId) :_					new ScheduledUnit(this, slotSharingGroupId, locationConstraint)___			_			ExecutionVertex executionVertex = getVertex()__			AllocationID lastAllocation = executionVertex.getLatestPriorAllocation()___			Collection<AllocationID> previousAllocationIDs =_				lastAllocation != null ? Collections.singletonList(lastAllocation) : Collections.emptyList()___			_			final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture =_				calculatePreferredLocations(locationPreferenceConstraint)___			final SlotRequestId slotRequestId = new SlotRequestId()___			final ComponentMainThreadExecutor mainThreadExecutor =_				vertex.getExecutionGraph().getJobMasterMainThreadExecutor()___			final CompletableFuture<LogicalSlot> logicalSlotFuture =_				preferredLocationsFuture.thenCompose(_					(Collection<TaskManagerLocation> preferredLocations) ->_						slotProvider.allocateSlot(_							slotRequestId,_							toSchedule,_							new SlotProfile(_								ResourceProfile.UNKNOWN,_								preferredLocations,_								previousAllocationIDs,_								allPreviousExecutionGraphAllocationIds),_							queued,_							allocationTimeout))___			_			releaseFuture.whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (logicalSlotFuture.cancel(false)) {_						slotProvider.cancelSlotRequest(_							slotRequestId,_							slotSharingGroupId,_							new FlinkException("Execution " + this + " was released."))__					}_				})___			_			return logicalSlotFuture.handle(_				(LogicalSlot logicalSlot, Throwable failure) -> {__					if (failure != null) {_						throw new CompletionException(failure)__					}__					if (tryAssignResource(logicalSlot)) {_						return this__					} else {_						_						logicalSlot.releaseSlot(new FlinkException("Could not assign logical slot to execution " + this + '.'))__						throw new CompletionException(_							new FlinkException(_								"Could not assign slot " + logicalSlot + " to execution " + this + " because it has already been assigned "))__					}_				})__		} else {_			_			throw new IllegalExecutionStateException(this, CREATED, state)__		}_	};allocates,and,assigns,a,slot,obtained,from,the,slot,provider,to,the,execution,param,slot,provider,to,obtain,a,new,slot,from,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,set,with,all,previous,allocation,ids,in,the,job,graph,can,be,empty,if,the,allocation,ids,are,not,required,for,scheduling,param,allocation,timeout,rpc,timeout,for,allocating,a,new,slot,return,future,which,is,completed,with,this,execution,once,the,slot,has,been,assigned,or,with,an,exception,if,an,error,occurred,throws,illegal,execution,state,exception,if,this,method,has,been,called,while,not,being,in,the,created,state;public,completable,future,execution,allocate,and,assign,slot,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,time,allocation,timeout,throws,illegal,execution,state,exception,check,not,null,slot,provider,assert,running,in,job,master,main,thread,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,illegal,state,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,final,slot,sharing,group,id,slot,sharing,group,id,sharing,group,null,sharing,group,get,slot,sharing,group,id,null,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,slot,sharing,group,id,new,scheduled,unit,this,slot,sharing,group,id,location,constraint,execution,vertex,execution,vertex,get,vertex,allocation,id,last,allocation,execution,vertex,get,latest,prior,allocation,collection,allocation,id,previous,allocation,ids,last,allocation,null,collections,singleton,list,last,allocation,collections,empty,list,final,completable,future,collection,task,manager,location,preferred,locations,future,calculate,preferred,locations,location,preference,constraint,final,slot,request,id,slot,request,id,new,slot,request,id,final,component,main,thread,executor,main,thread,executor,vertex,get,execution,graph,get,job,master,main,thread,executor,final,completable,future,logical,slot,logical,slot,future,preferred,locations,future,then,compose,collection,task,manager,location,preferred,locations,slot,provider,allocate,slot,slot,request,id,to,schedule,new,slot,profile,resource,profile,unknown,preferred,locations,previous,allocation,ids,all,previous,execution,graph,allocation,ids,queued,allocation,timeout,release,future,when,complete,object,ignored,throwable,throwable,if,logical,slot,future,cancel,false,slot,provider,cancel,slot,request,slot,request,id,slot,sharing,group,id,new,flink,exception,execution,this,was,released,return,logical,slot,future,handle,logical,slot,logical,slot,throwable,failure,if,failure,null,throw,new,completion,exception,failure,if,try,assign,resource,logical,slot,return,this,else,logical,slot,release,slot,new,flink,exception,could,not,assign,logical,slot,to,execution,this,throw,new,completion,exception,new,flink,exception,could,not,assign,slot,logical,slot,to,execution,this,because,it,has,already,been,assigned,else,throw,new,illegal,execution,state,exception,this,created,state
Execution -> public CompletableFuture<Execution> allocateAndAssignSlotForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds, 			Time allocationTimeout) throws IllegalExecutionStateException;1550683188;Allocates and assigns a slot obtained from the slot provider to the execution.__@param slotProvider to obtain a new slot from_@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph._Can be empty if the allocation ids are not required for scheduling._@param allocationTimeout rpcTimeout for allocating a new slot_@return Future which is completed with this execution once the slot has been assigned_or with an exception if an error occurred._@throws IllegalExecutionStateException if this method has been called while not being in the CREATED state;public CompletableFuture<Execution> allocateAndAssignSlotForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds,_			Time allocationTimeout) throws IllegalExecutionStateException {__		checkNotNull(slotProvider)___		assertRunningInJobMasterMainThread()___		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new IllegalStateException(_					"Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		_		if (transitionState(CREATED, SCHEDULED)) {__			final SlotSharingGroupId slotSharingGroupId = sharingGroup != null ? sharingGroup.getSlotSharingGroupId() : null___			ScheduledUnit toSchedule = locationConstraint == null ?_					new ScheduledUnit(this, slotSharingGroupId) :_					new ScheduledUnit(this, slotSharingGroupId, locationConstraint)___			_			ExecutionVertex executionVertex = getVertex()__			AllocationID lastAllocation = executionVertex.getLatestPriorAllocation()___			Collection<AllocationID> previousAllocationIDs =_				lastAllocation != null ? Collections.singletonList(lastAllocation) : Collections.emptyList()___			_			final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture =_				calculatePreferredLocations(locationPreferenceConstraint)___			final SlotRequestId slotRequestId = new SlotRequestId()___			final ComponentMainThreadExecutor mainThreadExecutor =_				vertex.getExecutionGraph().getJobMasterMainThreadExecutor()___			final CompletableFuture<LogicalSlot> logicalSlotFuture =_				preferredLocationsFuture.thenCompose(_					(Collection<TaskManagerLocation> preferredLocations) ->_						slotProvider.allocateSlot(_							slotRequestId,_							toSchedule,_							new SlotProfile(_								ResourceProfile.UNKNOWN,_								preferredLocations,_								previousAllocationIDs,_								allPreviousExecutionGraphAllocationIds),_							queued,_							allocationTimeout))___			_			releaseFuture.whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (logicalSlotFuture.cancel(false)) {_						slotProvider.cancelSlotRequest(_							slotRequestId,_							slotSharingGroupId,_							new FlinkException("Execution " + this + " was released."))__					}_				})___			_			return logicalSlotFuture.handle(_				(LogicalSlot logicalSlot, Throwable failure) -> {__					if (failure != null) {_						throw new CompletionException(failure)__					}__					if (tryAssignResource(logicalSlot)) {_						return this__					} else {_						_						logicalSlot.releaseSlot(new FlinkException("Could not assign logical slot to execution " + this + '.'))__						throw new CompletionException(_							new FlinkException(_								"Could not assign slot " + logicalSlot + " to execution " + this + " because it has already been assigned "))__					}_				})__		} else {_			_			throw new IllegalExecutionStateException(this, CREATED, state)__		}_	};allocates,and,assigns,a,slot,obtained,from,the,slot,provider,to,the,execution,param,slot,provider,to,obtain,a,new,slot,from,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,set,with,all,previous,allocation,ids,in,the,job,graph,can,be,empty,if,the,allocation,ids,are,not,required,for,scheduling,param,allocation,timeout,rpc,timeout,for,allocating,a,new,slot,return,future,which,is,completed,with,this,execution,once,the,slot,has,been,assigned,or,with,an,exception,if,an,error,occurred,throws,illegal,execution,state,exception,if,this,method,has,been,called,while,not,being,in,the,created,state;public,completable,future,execution,allocate,and,assign,slot,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,time,allocation,timeout,throws,illegal,execution,state,exception,check,not,null,slot,provider,assert,running,in,job,master,main,thread,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,illegal,state,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,final,slot,sharing,group,id,slot,sharing,group,id,sharing,group,null,sharing,group,get,slot,sharing,group,id,null,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,slot,sharing,group,id,new,scheduled,unit,this,slot,sharing,group,id,location,constraint,execution,vertex,execution,vertex,get,vertex,allocation,id,last,allocation,execution,vertex,get,latest,prior,allocation,collection,allocation,id,previous,allocation,ids,last,allocation,null,collections,singleton,list,last,allocation,collections,empty,list,final,completable,future,collection,task,manager,location,preferred,locations,future,calculate,preferred,locations,location,preference,constraint,final,slot,request,id,slot,request,id,new,slot,request,id,final,component,main,thread,executor,main,thread,executor,vertex,get,execution,graph,get,job,master,main,thread,executor,final,completable,future,logical,slot,logical,slot,future,preferred,locations,future,then,compose,collection,task,manager,location,preferred,locations,slot,provider,allocate,slot,slot,request,id,to,schedule,new,slot,profile,resource,profile,unknown,preferred,locations,previous,allocation,ids,all,previous,execution,graph,allocation,ids,queued,allocation,timeout,release,future,when,complete,object,ignored,throwable,throwable,if,logical,slot,future,cancel,false,slot,provider,cancel,slot,request,slot,request,id,slot,sharing,group,id,new,flink,exception,execution,this,was,released,return,logical,slot,future,handle,logical,slot,logical,slot,throwable,failure,if,failure,null,throw,new,completion,exception,failure,if,try,assign,resource,logical,slot,return,this,else,logical,slot,release,slot,new,flink,exception,could,not,assign,logical,slot,to,execution,this,throw,new,completion,exception,new,flink,exception,could,not,assign,slot,logical,slot,to,execution,this,because,it,has,already,been,assigned,else,throw,new,illegal,execution,state,exception,this,created,state
Execution -> public CompletableFuture<Execution> allocateAndAssignSlotForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds, 			Time allocationTimeout) throws IllegalExecutionStateException;1550855836;Allocates and assigns a slot obtained from the slot provider to the execution.__@param slotProvider to obtain a new slot from_@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph._Can be empty if the allocation ids are not required for scheduling._@param allocationTimeout rpcTimeout for allocating a new slot_@return Future which is completed with this execution once the slot has been assigned_or with an exception if an error occurred._@throws IllegalExecutionStateException if this method has been called while not being in the CREATED state;public CompletableFuture<Execution> allocateAndAssignSlotForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds,_			Time allocationTimeout) throws IllegalExecutionStateException {__		checkNotNull(slotProvider)___		assertRunningInJobMasterMainThread()___		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new IllegalStateException(_					"Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		_		if (transitionState(CREATED, SCHEDULED)) {__			final SlotSharingGroupId slotSharingGroupId = sharingGroup != null ? sharingGroup.getSlotSharingGroupId() : null___			ScheduledUnit toSchedule = locationConstraint == null ?_					new ScheduledUnit(this, slotSharingGroupId) :_					new ScheduledUnit(this, slotSharingGroupId, locationConstraint)___			_			ExecutionVertex executionVertex = getVertex()__			AllocationID lastAllocation = executionVertex.getLatestPriorAllocation()___			Collection<AllocationID> previousAllocationIDs =_				lastAllocation != null ? Collections.singletonList(lastAllocation) : Collections.emptyList()___			_			final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture =_				calculatePreferredLocations(locationPreferenceConstraint)___			final SlotRequestId slotRequestId = new SlotRequestId()___			final CompletableFuture<LogicalSlot> logicalSlotFuture =_				preferredLocationsFuture.thenCompose(_					(Collection<TaskManagerLocation> preferredLocations) ->_						slotProvider.allocateSlot(_							slotRequestId,_							toSchedule,_							new SlotProfile(_								ResourceProfile.UNKNOWN,_								preferredLocations,_								previousAllocationIDs,_								allPreviousExecutionGraphAllocationIds),_							queued,_							allocationTimeout))___			_			releaseFuture.whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (logicalSlotFuture.cancel(false)) {_						slotProvider.cancelSlotRequest(_							slotRequestId,_							slotSharingGroupId,_							new FlinkException("Execution " + this + " was released."))__					}_				})___			_			return logicalSlotFuture.handle(_				(LogicalSlot logicalSlot, Throwable failure) -> {__					if (failure != null) {_						throw new CompletionException(failure)__					}__					if (tryAssignResource(logicalSlot)) {_						return this__					} else {_						_						logicalSlot.releaseSlot(new FlinkException("Could not assign logical slot to execution " + this + '.'))__						throw new CompletionException(_							new FlinkException(_								"Could not assign slot " + logicalSlot + " to execution " + this + " because it has already been assigned "))__					}_				})__		} else {_			_			throw new IllegalExecutionStateException(this, CREATED, state)__		}_	};allocates,and,assigns,a,slot,obtained,from,the,slot,provider,to,the,execution,param,slot,provider,to,obtain,a,new,slot,from,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,set,with,all,previous,allocation,ids,in,the,job,graph,can,be,empty,if,the,allocation,ids,are,not,required,for,scheduling,param,allocation,timeout,rpc,timeout,for,allocating,a,new,slot,return,future,which,is,completed,with,this,execution,once,the,slot,has,been,assigned,or,with,an,exception,if,an,error,occurred,throws,illegal,execution,state,exception,if,this,method,has,been,called,while,not,being,in,the,created,state;public,completable,future,execution,allocate,and,assign,slot,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,time,allocation,timeout,throws,illegal,execution,state,exception,check,not,null,slot,provider,assert,running,in,job,master,main,thread,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,illegal,state,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,final,slot,sharing,group,id,slot,sharing,group,id,sharing,group,null,sharing,group,get,slot,sharing,group,id,null,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,slot,sharing,group,id,new,scheduled,unit,this,slot,sharing,group,id,location,constraint,execution,vertex,execution,vertex,get,vertex,allocation,id,last,allocation,execution,vertex,get,latest,prior,allocation,collection,allocation,id,previous,allocation,ids,last,allocation,null,collections,singleton,list,last,allocation,collections,empty,list,final,completable,future,collection,task,manager,location,preferred,locations,future,calculate,preferred,locations,location,preference,constraint,final,slot,request,id,slot,request,id,new,slot,request,id,final,completable,future,logical,slot,logical,slot,future,preferred,locations,future,then,compose,collection,task,manager,location,preferred,locations,slot,provider,allocate,slot,slot,request,id,to,schedule,new,slot,profile,resource,profile,unknown,preferred,locations,previous,allocation,ids,all,previous,execution,graph,allocation,ids,queued,allocation,timeout,release,future,when,complete,object,ignored,throwable,throwable,if,logical,slot,future,cancel,false,slot,provider,cancel,slot,request,slot,request,id,slot,sharing,group,id,new,flink,exception,execution,this,was,released,return,logical,slot,future,handle,logical,slot,logical,slot,throwable,failure,if,failure,null,throw,new,completion,exception,failure,if,try,assign,resource,logical,slot,return,this,else,logical,slot,release,slot,new,flink,exception,could,not,assign,logical,slot,to,execution,this,throw,new,completion,exception,new,flink,exception,could,not,assign,slot,logical,slot,to,execution,this,because,it,has,already,been,assigned,else,throw,new,illegal,execution,state,exception,this,created,state
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1487871589;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1488878443;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1490800309;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1490819573;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1493831843;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1493831843;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1501622876;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1501665499;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1501760738;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1502801814;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1509125300;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1509631297;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1509638684;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final SimpleSlot slot = assignedResource.get()___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,simple,slot,slot,assigned,resource,get,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1509638685;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1513201052;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1513201070;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1513261599;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1515177485;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1516626377;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1516626397;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1518680774;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1518712478;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1519316529;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1519481114;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1519568061;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1519655521;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1522049586;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1522249273;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1530712207;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1532383539;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1532383539;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1532383539;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1540920690;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1542356428;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1546870832;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1547644408;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1549365080;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1550220073;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1550654143;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1550683188;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions);1550855836;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger_@param checkpointOptions of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger,param,checkpoint,options,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,checkpoint,options,checkpoint,options,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,checkpoint,options,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time rpcTimeout);1518680774;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param rpcTimeout_The rpcTimeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time rpcTimeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.rpcTimeout = checkNotNull(rpcTimeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(ExecutionState.CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminalStateFuture = new CompletableFuture<>()__		this.releaseFuture = new CompletableFuture<>()__		this.taskManagerLocationFuture = new CompletableFuture<>()___		this.assignedResource = null__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,rpc,timeout,the,rpc,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,rpc,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,rpc,timeout,check,not,null,rpc,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,execution,state,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,terminal,state,future,new,completable,future,this,release,future,new,completable,future,this,task,manager,location,future,new,completable,future,this,assigned,resource,null
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time rpcTimeout);1518712478;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param rpcTimeout_The rpcTimeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time rpcTimeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.rpcTimeout = checkNotNull(rpcTimeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(ExecutionState.CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminalStateFuture = new CompletableFuture<>()__		this.releaseFuture = new CompletableFuture<>()__		this.taskManagerLocationFuture = new CompletableFuture<>()___		this.assignedResource = null__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,rpc,timeout,the,rpc,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,rpc,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,rpc,timeout,check,not,null,rpc,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,execution,state,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,terminal,state,future,new,completable,future,this,release,future,new,completable,future,this,task,manager,location,future,new,completable,future,this,assigned,resource,null
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time rpcTimeout);1519316529;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param rpcTimeout_The rpcTimeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time rpcTimeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.rpcTimeout = checkNotNull(rpcTimeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(ExecutionState.CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminalStateFuture = new CompletableFuture<>()__		this.releaseFuture = new CompletableFuture<>()__		this.taskManagerLocationFuture = new CompletableFuture<>()___		this.assignedResource = null__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,rpc,timeout,the,rpc,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,rpc,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,rpc,timeout,check,not,null,rpc,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,execution,state,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,terminal,state,future,new,completable,future,this,release,future,new,completable,future,this,task,manager,location,future,new,completable,future,this,assigned,resource,null
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time rpcTimeout);1519481114;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param rpcTimeout_The rpcTimeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time rpcTimeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.rpcTimeout = checkNotNull(rpcTimeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(ExecutionState.CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminalStateFuture = new CompletableFuture<>()__		this.releaseFuture = new CompletableFuture<>()__		this.taskManagerLocationFuture = new CompletableFuture<>()___		this.assignedResource = null__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,rpc,timeout,the,rpc,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,rpc,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,rpc,timeout,check,not,null,rpc,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,execution,state,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,terminal,state,future,new,completable,future,this,release,future,new,completable,future,this,task,manager,location,future,new,completable,future,this,assigned,resource,null
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time rpcTimeout);1519568061;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param rpcTimeout_The rpcTimeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time rpcTimeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.rpcTimeout = checkNotNull(rpcTimeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(ExecutionState.CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminalStateFuture = new CompletableFuture<>()__		this.releaseFuture = new CompletableFuture<>()__		this.taskManagerLocationFuture = new CompletableFuture<>()___		this.assignedResource = null__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,rpc,timeout,the,rpc,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,rpc,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,rpc,timeout,check,not,null,rpc,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,execution,state,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,terminal,state,future,new,completable,future,this,release,future,new,completable,future,this,task,manager,location,future,new,completable,future,this,assigned,resource,null
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time rpcTimeout);1519655521;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param rpcTimeout_The rpcTimeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time rpcTimeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.rpcTimeout = checkNotNull(rpcTimeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(ExecutionState.CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminalStateFuture = new CompletableFuture<>()__		this.releaseFuture = new CompletableFuture<>()__		this.taskManagerLocationFuture = new CompletableFuture<>()___		this.assignedResource = null__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,rpc,timeout,the,rpc,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,rpc,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,rpc,timeout,check,not,null,rpc,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,execution,state,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,terminal,state,future,new,completable,future,this,release,future,new,completable,future,this,task,manager,location,future,new,completable,future,this,assigned,resource,null
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time rpcTimeout);1522049586;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param rpcTimeout_The rpcTimeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time rpcTimeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.rpcTimeout = checkNotNull(rpcTimeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(ExecutionState.CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminalStateFuture = new CompletableFuture<>()__		this.releaseFuture = new CompletableFuture<>()__		this.taskManagerLocationFuture = new CompletableFuture<>()___		this.assignedResource = null__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,rpc,timeout,the,rpc,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,rpc,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,rpc,timeout,check,not,null,rpc,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,execution,state,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,terminal,state,future,new,completable,future,this,release,future,new,completable,future,this,task,manager,location,future,new,completable,future,this,assigned,resource,null
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time rpcTimeout);1522249273;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param rpcTimeout_The rpcTimeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time rpcTimeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.rpcTimeout = checkNotNull(rpcTimeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(ExecutionState.CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminalStateFuture = new CompletableFuture<>()__		this.releaseFuture = new CompletableFuture<>()__		this.taskManagerLocationFuture = new CompletableFuture<>()___		this.assignedResource = null__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,rpc,timeout,the,rpc,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,rpc,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,rpc,timeout,check,not,null,rpc,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,execution,state,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,terminal,state,future,new,completable,future,this,release,future,new,completable,future,this,task,manager,location,future,new,completable,future,this,assigned,resource,null
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time rpcTimeout);1530712207;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param rpcTimeout_The rpcTimeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time rpcTimeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.rpcTimeout = checkNotNull(rpcTimeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(ExecutionState.CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminalStateFuture = new CompletableFuture<>()__		this.releaseFuture = new CompletableFuture<>()__		this.taskManagerLocationFuture = new CompletableFuture<>()___		this.assignedResource = null__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,rpc,timeout,the,rpc,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,rpc,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,rpc,timeout,check,not,null,rpc,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,execution,state,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,terminal,state,future,new,completable,future,this,release,future,new,completable,future,this,task,manager,location,future,new,completable,future,this,assigned,resource,null
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time rpcTimeout);1532383539;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param rpcTimeout_The rpcTimeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time rpcTimeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.rpcTimeout = checkNotNull(rpcTimeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(ExecutionState.CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminalStateFuture = new CompletableFuture<>()__		this.releaseFuture = new CompletableFuture<>()__		this.taskManagerLocationFuture = new CompletableFuture<>()___		this.assignedResource = null__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,rpc,timeout,the,rpc,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,rpc,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,rpc,timeout,check,not,null,rpc,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,execution,state,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,terminal,state,future,new,completable,future,this,release,future,new,completable,future,this,task,manager,location,future,new,completable,future,this,assigned,resource,null
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time rpcTimeout);1532383539;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param rpcTimeout_The rpcTimeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time rpcTimeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.rpcTimeout = checkNotNull(rpcTimeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(ExecutionState.CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminalStateFuture = new CompletableFuture<>()__		this.releaseFuture = new CompletableFuture<>()__		this.taskManagerLocationFuture = new CompletableFuture<>()___		this.assignedResource = null__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,rpc,timeout,the,rpc,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,rpc,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,rpc,timeout,check,not,null,rpc,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,execution,state,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,terminal,state,future,new,completable,future,this,release,future,new,completable,future,this,task,manager,location,future,new,completable,future,this,assigned,resource,null
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time rpcTimeout);1532383539;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param rpcTimeout_The rpcTimeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time rpcTimeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.rpcTimeout = checkNotNull(rpcTimeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(ExecutionState.CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminalStateFuture = new CompletableFuture<>()__		this.releaseFuture = new CompletableFuture<>()__		this.taskManagerLocationFuture = new CompletableFuture<>()___		this.assignedResource = null__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,rpc,timeout,the,rpc,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,rpc,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,rpc,timeout,check,not,null,rpc,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,execution,state,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,terminal,state,future,new,completable,future,this,release,future,new,completable,future,this,task,manager,location,future,new,completable,future,this,assigned,resource,null
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time rpcTimeout);1540920690;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param rpcTimeout_The rpcTimeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time rpcTimeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.rpcTimeout = checkNotNull(rpcTimeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(ExecutionState.CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminalStateFuture = new CompletableFuture<>()__		this.releaseFuture = new CompletableFuture<>()__		this.taskManagerLocationFuture = new CompletableFuture<>()___		this.assignedResource = null__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,rpc,timeout,the,rpc,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,rpc,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,rpc,timeout,check,not,null,rpc,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,execution,state,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,terminal,state,future,new,completable,future,this,release,future,new,completable,future,this,task,manager,location,future,new,completable,future,this,assigned,resource,null
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time rpcTimeout);1542356428;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param rpcTimeout_The rpcTimeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time rpcTimeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.rpcTimeout = checkNotNull(rpcTimeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(ExecutionState.CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminalStateFuture = new CompletableFuture<>()__		this.releaseFuture = new CompletableFuture<>()__		this.taskManagerLocationFuture = new CompletableFuture<>()___		this.assignedResource = null__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,rpc,timeout,the,rpc,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,rpc,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,rpc,timeout,check,not,null,rpc,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,execution,state,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,terminal,state,future,new,completable,future,this,release,future,new,completable,future,this,task,manager,location,future,new,completable,future,this,assigned,resource,null
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time rpcTimeout);1546870832;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param rpcTimeout_The rpcTimeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time rpcTimeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.rpcTimeout = checkNotNull(rpcTimeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(ExecutionState.CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminalStateFuture = new CompletableFuture<>()__		this.releaseFuture = new CompletableFuture<>()__		this.taskManagerLocationFuture = new CompletableFuture<>()___		this.assignedResource = null__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,rpc,timeout,the,rpc,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,rpc,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,rpc,timeout,check,not,null,rpc,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,execution,state,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,terminal,state,future,new,completable,future,this,release,future,new,completable,future,this,task,manager,location,future,new,completable,future,this,assigned,resource,null
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time rpcTimeout);1547644408;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param rpcTimeout_The rpcTimeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time rpcTimeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.rpcTimeout = checkNotNull(rpcTimeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(ExecutionState.CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminalStateFuture = new CompletableFuture<>()__		this.releaseFuture = new CompletableFuture<>()__		this.taskManagerLocationFuture = new CompletableFuture<>()___		this.assignedResource = null__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,rpc,timeout,the,rpc,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,rpc,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,rpc,timeout,check,not,null,rpc,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,execution,state,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,terminal,state,future,new,completable,future,this,release,future,new,completable,future,this,task,manager,location,future,new,completable,future,this,assigned,resource,null
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time rpcTimeout);1549365080;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param rpcTimeout_The rpcTimeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time rpcTimeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.rpcTimeout = checkNotNull(rpcTimeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminalStateFuture = new CompletableFuture<>()__		this.releaseFuture = new CompletableFuture<>()__		this.taskManagerLocationFuture = new CompletableFuture<>()___		this.assignedResource = null__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,rpc,timeout,the,rpc,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,rpc,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,rpc,timeout,check,not,null,rpc,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,terminal,state,future,new,completable,future,this,release,future,new,completable,future,this,task,manager,location,future,new,completable,future,this,assigned,resource,null
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time rpcTimeout);1550220073;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param rpcTimeout_The rpcTimeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time rpcTimeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.rpcTimeout = checkNotNull(rpcTimeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminalStateFuture = new CompletableFuture<>()__		this.releaseFuture = new CompletableFuture<>()__		this.taskManagerLocationFuture = new CompletableFuture<>()___		this.assignedResource = null__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,rpc,timeout,the,rpc,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,rpc,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,rpc,timeout,check,not,null,rpc,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,terminal,state,future,new,completable,future,this,release,future,new,completable,future,this,task,manager,location,future,new,completable,future,this,assigned,resource,null
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time rpcTimeout);1550654143;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param rpcTimeout_The rpcTimeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time rpcTimeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.rpcTimeout = checkNotNull(rpcTimeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminalStateFuture = new CompletableFuture<>()__		this.releaseFuture = new CompletableFuture<>()__		this.taskManagerLocationFuture = new CompletableFuture<>()___		this.assignedResource = null__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,rpc,timeout,the,rpc,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,rpc,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,rpc,timeout,check,not,null,rpc,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,terminal,state,future,new,completable,future,this,release,future,new,completable,future,this,task,manager,location,future,new,completable,future,this,assigned,resource,null
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time rpcTimeout);1550683188;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param rpcTimeout_The rpcTimeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time rpcTimeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.rpcTimeout = checkNotNull(rpcTimeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminalStateFuture = new CompletableFuture<>()__		this.releaseFuture = new CompletableFuture<>()__		this.taskManagerLocationFuture = new CompletableFuture<>()___		this.assignedResource = null__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,rpc,timeout,the,rpc,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,rpc,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,rpc,timeout,check,not,null,rpc,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,terminal,state,future,new,completable,future,this,release,future,new,completable,future,this,task,manager,location,future,new,completable,future,this,assigned,resource,null
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time rpcTimeout);1550855836;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param rpcTimeout_The rpcTimeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time rpcTimeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.rpcTimeout = checkNotNull(rpcTimeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminalStateFuture = new CompletableFuture<>()__		this.releaseFuture = new CompletableFuture<>()__		this.taskManagerLocationFuture = new CompletableFuture<>()___		this.assignedResource = null__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,rpc,timeout,the,rpc,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,rpc,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,rpc,timeout,check,not,null,rpc,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,terminal,state,future,new,completable,future,this,release,future,new,completable,future,this,task,manager,location,future,new,completable,future,this,assigned,resource,null
Execution -> public void prepareForArchiving();1423135035;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null
Execution -> public void prepareForArchiving();1423144032;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null
Execution -> public void prepareForArchiving();1423672458;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null
Execution -> public void prepareForArchiving();1423847366;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null
Execution -> public void prepareForArchiving();1423927053;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null
Execution -> public void prepareForArchiving();1424171945;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null
Execution -> public void prepareForArchiving();1424732907;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null
Execution -> public void prepareForArchiving();1424858532;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null
Execution -> public void prepareForArchiving();1424858532;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		partialPartitionInfos.clear()__		partialPartitionInfos = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,partial,partition,infos,clear,partial,partition,infos,null
Execution -> public void prepareForArchiving();1425489637;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		partialPartitionInfos.clear()__		partialPartitionInfos = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,partial,partition,infos,clear,partial,partition,infos,null
Execution -> public void prepareForArchiving();1425601895;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		partialPartitionInfos.clear()__		partialPartitionInfos = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,partial,partition,infos,clear,partial,partition,infos,null
Execution -> public void prepareForArchiving();1425995928;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		partialPartitionInfos.clear()__		partialPartitionInfos = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,partial,partition,infos,clear,partial,partition,infos,null
Execution -> public void prepareForArchiving();1425995929;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		partialPartitionInfos.clear()__		partialPartitionInfos = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,partial,partition,infos,clear,partial,partition,infos,null
Execution -> public void prepareForArchiving();1425995929;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		partialPartitionInfos.clear()__		partialPartitionInfos = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,partial,partition,infos,clear,partial,partition,infos,null
Execution -> public void prepareForArchiving();1426697080;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1426783962;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1426860022;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1428327044;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1430296839;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1430296839;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1431432049;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1431459357;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1431459358;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1432031793;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1432295874;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1432629253;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1433537224;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1436802871;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		executionContext = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,execution,context,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1436966346;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		executionContext = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,execution,context,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1437665997;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		executionContext = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,execution,context,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1439908661;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		executionContext = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,execution,context,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1440782435;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		executionContext = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,execution,context,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1440951699;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		executionContext = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,execution,context,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1441011751;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		executionContext = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,execution,context,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1442492512;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		executionContext = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,execution,context,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1448353719;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		executionContext = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,execution,context,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1448353719;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		executionContext = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,execution,context,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1449496469;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		executionContext = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,execution,context,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1455114877;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		executionContext = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,execution,context,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1455549373;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		executionContext = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,execution,context,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1456772768;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		executionContext = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,execution,context,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1461666173;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		executionContext = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,execution,context,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1464612094;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		executionContext = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,execution,context,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1465991918;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		executionContext = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,execution,context,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1468523508;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		executionContext = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,execution,context,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1470070623;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		executionContext = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,execution,context,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1470419821;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		executionContext = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,execution,context,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1472663401;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		executionContext = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,execution,context,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1472663402;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		executionContext = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,execution,context,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1472830377;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		executionContext = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,execution,context,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1472830377;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		executionContext = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,execution,context,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1473023399;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		executionContext = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,execution,context,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1474994376;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		executionContext = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,execution,context,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1474994376;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		executionContext = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,execution,context,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void prepareForArchiving();1475231926;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		if (assignedResource != null && assignedResource.isAlive()) {_			throw new IllegalStateException("Cannot archive Execution while the assigned resource is still running.")__		}_		assignedResource = null___		executionContext = null___		partialInputChannelDeploymentDescriptors.clear()__		partialInputChannelDeploymentDescriptors = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,if,assigned,resource,null,assigned,resource,is,alive,throw,new,illegal,state,exception,cannot,archive,execution,while,the,assigned,resource,is,still,running,assigned,resource,null,execution,context,null,partial,input,channel,deployment,descriptors,clear,partial,input,channel,deployment,descriptors,null
Execution -> public void fail(Throwable t);1411236169;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		if (processFail(t, false)) {_			if (LOG.isErrorEnabled()) {_				LOG.error("Task " + getVertexWithAttempt() + " was failed.", t)__			}_		}_	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,if,process,fail,t,false,if,log,is,error,enabled,log,error,task,get,vertex,with,attempt,was,failed,t
Execution -> public void fail(Throwable t);1411236169;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1411236170;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1411237261;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1411237262;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1411473593;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1412605211;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1415027294;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1415278814;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1418925507;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1418925508;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1418925510;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1418925510;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1418925511;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1418925511;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1420538822;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1421050512;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1422007786;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1423135035;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1423135035;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1423144032;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1423672458;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1423847366;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1423927053;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1424171945;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1424732907;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1424858532;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1424858532;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1425489637;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1425601895;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1425995928;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1425995929;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1425995929;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1426697080;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1426783962;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1426860022;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1428327044;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1430296839;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1430296839;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1431432049;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1431459357;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1431459358;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1432031793;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1432295874;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1432629253;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1433537224;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1436802871;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1436966346;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1437665997;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1439908661;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1440782435;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1440951699;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1441011751;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1442492512;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1448353719;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1448353719;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1449496469;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1455114877;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1455549373;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1456772768;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1461666173;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1464612094;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1465991918;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1468523508;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1470070623;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1470419821;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1472663401;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1472663402;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1472830377;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1472830377;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1473023399;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1474994376;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1474994376;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1475231926;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1476446128;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1476972861;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1477923124;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1477989375;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1478800024;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1481290933;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1482522865;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1486114103;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1486114103;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1486740510;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1487548884;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1487871589;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1488878443;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1490800309;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1490819573;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1493831843;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1493831843;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1501622876;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1501665499;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1501760738;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1502801814;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1509125300;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1509631297;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1509638684;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1509638685;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void fail(Throwable t);1513201052;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;public,void,fail,throwable,t,process,fail,t,false
Execution -> public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators, 								Map<String, Accumulator<?, ?>> userAccumulators);1436966346;Update accumulators (discarded when the Execution has already been terminated)._@param flinkAccumulators the flink internal accumulators_@param userAccumulators the user accumulators;public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators,_								Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.flinkAccumulators = flinkAccumulators__				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,flink,accumulators,the,flink,internal,accumulators,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,accumulator,registry,metric,accumulator,flink,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,flink,accumulators,flink,accumulators,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators, 								Map<String, Accumulator<?, ?>> userAccumulators);1437665997;Update accumulators (discarded when the Execution has already been terminated)._@param flinkAccumulators the flink internal accumulators_@param userAccumulators the user accumulators;public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators,_								Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.flinkAccumulators = flinkAccumulators__				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,flink,accumulators,the,flink,internal,accumulators,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,accumulator,registry,metric,accumulator,flink,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,flink,accumulators,flink,accumulators,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators, 								Map<String, Accumulator<?, ?>> userAccumulators);1439908661;Update accumulators (discarded when the Execution has already been terminated)._@param flinkAccumulators the flink internal accumulators_@param userAccumulators the user accumulators;public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators,_								Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.flinkAccumulators = flinkAccumulators__				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,flink,accumulators,the,flink,internal,accumulators,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,accumulator,registry,metric,accumulator,flink,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,flink,accumulators,flink,accumulators,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators, 								Map<String, Accumulator<?, ?>> userAccumulators);1440782435;Update accumulators (discarded when the Execution has already been terminated)._@param flinkAccumulators the flink internal accumulators_@param userAccumulators the user accumulators;public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators,_								Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.flinkAccumulators = flinkAccumulators__				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,flink,accumulators,the,flink,internal,accumulators,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,accumulator,registry,metric,accumulator,flink,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,flink,accumulators,flink,accumulators,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators, 								Map<String, Accumulator<?, ?>> userAccumulators);1440951699;Update accumulators (discarded when the Execution has already been terminated)._@param flinkAccumulators the flink internal accumulators_@param userAccumulators the user accumulators;public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators,_								Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.flinkAccumulators = flinkAccumulators__				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,flink,accumulators,the,flink,internal,accumulators,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,accumulator,registry,metric,accumulator,flink,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,flink,accumulators,flink,accumulators,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators, 								Map<String, Accumulator<?, ?>> userAccumulators);1441011751;Update accumulators (discarded when the Execution has already been terminated)._@param flinkAccumulators the flink internal accumulators_@param userAccumulators the user accumulators;public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators,_								Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.flinkAccumulators = flinkAccumulators__				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,flink,accumulators,the,flink,internal,accumulators,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,accumulator,registry,metric,accumulator,flink,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,flink,accumulators,flink,accumulators,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators, 								Map<String, Accumulator<?, ?>> userAccumulators);1442492512;Update accumulators (discarded when the Execution has already been terminated)._@param flinkAccumulators the flink internal accumulators_@param userAccumulators the user accumulators;public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators,_								Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.flinkAccumulators = flinkAccumulators__				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,flink,accumulators,the,flink,internal,accumulators,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,accumulator,registry,metric,accumulator,flink,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,flink,accumulators,flink,accumulators,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators, 								Map<String, Accumulator<?, ?>> userAccumulators);1448353719;Update accumulators (discarded when the Execution has already been terminated)._@param flinkAccumulators the flink internal accumulators_@param userAccumulators the user accumulators;public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators,_								Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.flinkAccumulators = flinkAccumulators__				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,flink,accumulators,the,flink,internal,accumulators,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,accumulator,registry,metric,accumulator,flink,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,flink,accumulators,flink,accumulators,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators, 								Map<String, Accumulator<?, ?>> userAccumulators);1448353719;Update accumulators (discarded when the Execution has already been terminated)._@param flinkAccumulators the flink internal accumulators_@param userAccumulators the user accumulators;public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators,_								Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.flinkAccumulators = flinkAccumulators__				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,flink,accumulators,the,flink,internal,accumulators,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,accumulator,registry,metric,accumulator,flink,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,flink,accumulators,flink,accumulators,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators, 								Map<String, Accumulator<?, ?>> userAccumulators);1449496469;Update accumulators (discarded when the Execution has already been terminated)._@param flinkAccumulators the flink internal accumulators_@param userAccumulators the user accumulators;public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators,_								Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.flinkAccumulators = flinkAccumulators__				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,flink,accumulators,the,flink,internal,accumulators,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,accumulator,registry,metric,accumulator,flink,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,flink,accumulators,flink,accumulators,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators, 								Map<String, Accumulator<?, ?>> userAccumulators);1455114877;Update accumulators (discarded when the Execution has already been terminated)._@param flinkAccumulators the flink internal accumulators_@param userAccumulators the user accumulators;public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators,_								Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.flinkAccumulators = flinkAccumulators__				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,flink,accumulators,the,flink,internal,accumulators,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,accumulator,registry,metric,accumulator,flink,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,flink,accumulators,flink,accumulators,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators, 								Map<String, Accumulator<?, ?>> userAccumulators);1455549373;Update accumulators (discarded when the Execution has already been terminated)._@param flinkAccumulators the flink internal accumulators_@param userAccumulators the user accumulators;public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators,_								Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.flinkAccumulators = flinkAccumulators__				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,flink,accumulators,the,flink,internal,accumulators,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,accumulator,registry,metric,accumulator,flink,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,flink,accumulators,flink,accumulators,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators, 								Map<String, Accumulator<?, ?>> userAccumulators);1456772768;Update accumulators (discarded when the Execution has already been terminated)._@param flinkAccumulators the flink internal accumulators_@param userAccumulators the user accumulators;public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators,_								Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.flinkAccumulators = flinkAccumulators__				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,flink,accumulators,the,flink,internal,accumulators,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,accumulator,registry,metric,accumulator,flink,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,flink,accumulators,flink,accumulators,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators, 								Map<String, Accumulator<?, ?>> userAccumulators);1461666173;Update accumulators (discarded when the Execution has already been terminated)._@param flinkAccumulators the flink internal accumulators_@param userAccumulators the user accumulators;public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators,_								Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.flinkAccumulators = flinkAccumulators__				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,flink,accumulators,the,flink,internal,accumulators,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,accumulator,registry,metric,accumulator,flink,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,flink,accumulators,flink,accumulators,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators, 								Map<String, Accumulator<?, ?>> userAccumulators);1464612094;Update accumulators (discarded when the Execution has already been terminated)._@param flinkAccumulators the flink internal accumulators_@param userAccumulators the user accumulators;public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators,_								Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.flinkAccumulators = flinkAccumulators__				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,flink,accumulators,the,flink,internal,accumulators,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,accumulator,registry,metric,accumulator,flink,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,flink,accumulators,flink,accumulators,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators, 								Map<String, Accumulator<?, ?>> userAccumulators);1465991918;Update accumulators (discarded when the Execution has already been terminated)._@param flinkAccumulators the flink internal accumulators_@param userAccumulators the user accumulators;public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators,_								Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.flinkAccumulators = flinkAccumulators__				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,flink,accumulators,the,flink,internal,accumulators,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,accumulator,registry,metric,accumulator,flink,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,flink,accumulators,flink,accumulators,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators, 								Map<String, Accumulator<?, ?>> userAccumulators);1468523508;Update accumulators (discarded when the Execution has already been terminated)._@param flinkAccumulators the flink internal accumulators_@param userAccumulators the user accumulators;public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators,_								Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.flinkAccumulators = flinkAccumulators__				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,flink,accumulators,the,flink,internal,accumulators,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,accumulator,registry,metric,accumulator,flink,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,flink,accumulators,flink,accumulators,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators, 								Map<String, Accumulator<?, ?>> userAccumulators);1470070623;Update accumulators (discarded when the Execution has already been terminated)._@param flinkAccumulators the flink internal accumulators_@param userAccumulators the user accumulators;public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators,_								Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.flinkAccumulators = flinkAccumulators__				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,flink,accumulators,the,flink,internal,accumulators,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,accumulator,registry,metric,accumulator,flink,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,flink,accumulators,flink,accumulators,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators, 								Map<String, Accumulator<?, ?>> userAccumulators);1470419821;Update accumulators (discarded when the Execution has already been terminated)._@param flinkAccumulators the flink internal accumulators_@param userAccumulators the user accumulators;public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators,_								Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.flinkAccumulators = flinkAccumulators__				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,flink,accumulators,the,flink,internal,accumulators,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,accumulator,registry,metric,accumulator,flink,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,flink,accumulators,flink,accumulators,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators, 								Map<String, Accumulator<?, ?>> userAccumulators);1472663401;Update accumulators (discarded when the Execution has already been terminated)._@param flinkAccumulators the flink internal accumulators_@param userAccumulators the user accumulators;public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators,_								Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.flinkAccumulators = flinkAccumulators__				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,flink,accumulators,the,flink,internal,accumulators,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,accumulator,registry,metric,accumulator,flink,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,flink,accumulators,flink,accumulators,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators, 								Map<String, Accumulator<?, ?>> userAccumulators);1472663402;Update accumulators (discarded when the Execution has already been terminated)._@param flinkAccumulators the flink internal accumulators_@param userAccumulators the user accumulators;public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators,_								Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.flinkAccumulators = flinkAccumulators__				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,flink,accumulators,the,flink,internal,accumulators,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,accumulator,registry,metric,accumulator,flink,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,flink,accumulators,flink,accumulators,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators, 								Map<String, Accumulator<?, ?>> userAccumulators);1472830377;Update accumulators (discarded when the Execution has already been terminated)._@param flinkAccumulators the flink internal accumulators_@param userAccumulators the user accumulators;public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators,_								Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.flinkAccumulators = flinkAccumulators__				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,flink,accumulators,the,flink,internal,accumulators,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,accumulator,registry,metric,accumulator,flink,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,flink,accumulators,flink,accumulators,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators, 								Map<String, Accumulator<?, ?>> userAccumulators);1472830377;Update accumulators (discarded when the Execution has already been terminated)._@param flinkAccumulators the flink internal accumulators_@param userAccumulators the user accumulators;public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators,_								Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.flinkAccumulators = flinkAccumulators__				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,flink,accumulators,the,flink,internal,accumulators,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,accumulator,registry,metric,accumulator,flink,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,flink,accumulators,flink,accumulators,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators, 								Map<String, Accumulator<?, ?>> userAccumulators);1473023399;Update accumulators (discarded when the Execution has already been terminated)._@param flinkAccumulators the flink internal accumulators_@param userAccumulators the user accumulators;public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators,_								Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.flinkAccumulators = flinkAccumulators__				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,flink,accumulators,the,flink,internal,accumulators,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,accumulator,registry,metric,accumulator,flink,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,flink,accumulators,flink,accumulators,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators, 								Map<String, Accumulator<?, ?>> userAccumulators);1474994376;Update accumulators (discarded when the Execution has already been terminated)._@param flinkAccumulators the flink internal accumulators_@param userAccumulators the user accumulators;public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators,_								Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.flinkAccumulators = flinkAccumulators__				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,flink,accumulators,the,flink,internal,accumulators,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,accumulator,registry,metric,accumulator,flink,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,flink,accumulators,flink,accumulators,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators, 								Map<String, Accumulator<?, ?>> userAccumulators);1474994376;Update accumulators (discarded when the Execution has already been terminated)._@param flinkAccumulators the flink internal accumulators_@param userAccumulators the user accumulators;public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators,_								Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.flinkAccumulators = flinkAccumulators__				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,flink,accumulators,the,flink,internal,accumulators,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,accumulator,registry,metric,accumulator,flink,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,flink,accumulators,flink,accumulators,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators, 								Map<String, Accumulator<?, ?>> userAccumulators);1475231926;Update accumulators (discarded when the Execution has already been terminated)._@param flinkAccumulators the flink internal accumulators_@param userAccumulators the user accumulators;public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators,_								Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.flinkAccumulators = flinkAccumulators__				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,flink,accumulators,the,flink,internal,accumulators,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,accumulator,registry,metric,accumulator,flink,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,flink,accumulators,flink,accumulators,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators, 								Map<String, Accumulator<?, ?>> userAccumulators);1476446128;Update accumulators (discarded when the Execution has already been terminated)._@param flinkAccumulators the flink internal accumulators_@param userAccumulators the user accumulators;public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators,_								Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.flinkAccumulators = flinkAccumulators__				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,flink,accumulators,the,flink,internal,accumulators,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,accumulator,registry,metric,accumulator,flink,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,flink,accumulators,flink,accumulators,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators, 								Map<String, Accumulator<?, ?>> userAccumulators);1476972861;Update accumulators (discarded when the Execution has already been terminated)._@param flinkAccumulators the flink internal accumulators_@param userAccumulators the user accumulators;public void setAccumulators(Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> flinkAccumulators,_								Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.flinkAccumulators = flinkAccumulators__				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,flink,accumulators,the,flink,internal,accumulators,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,accumulator,registry,metric,accumulator,flink,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,flink,accumulators,flink,accumulators,this,user,accumulators,user,accumulators
Execution -> public void deploy() throws JobException;1509638684;Deploys the execution to the previously assigned resource.__@throws JobException if the execution cannot be deployed to the assigned resource;public void deploy() throws JobException {_		final SimpleSlot slot  = assignedResource.get()___		checkNotNull(slot, "In order to deploy the execution we first have to assign a resource via tryAssignResource.")___		_		_		_		if (!slot.isAlive()) {_			throw new JobException("Target slot (TaskManager) for deployment is no longer alive.")__		}__		_		_		ExecutionState previous = this.state__		if (previous == SCHEDULED || previous == CREATED) {_			if (!transitionState(previous, DEPLOYING)) {_				_				_				throw new IllegalStateException("Cannot deploy task: Concurrent deployment call race.")__			}_		}_		else {_			_			throw new IllegalStateException("The vertex must be in CREATED or SCHEDULED state to be deployed. Found state " + previous)__		}__		try {_			_			if (!slot.setExecutedVertex(this)) {_				throw new JobException("Could not assign the ExecutionVertex to the slot " + slot)__			}__			_			if (this.state != DEPLOYING) {_				slot.releaseSlot()__				return__			}__			if (LOG.isInfoEnabled()) {_				LOG.info(String.format("Deploying %s (attempt #%d) to %s", vertex.getTaskNameWithSubtaskIndex(),_						attemptNumber, getAssignedResourceLocation().getHostname()))__			}__			final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(_				attemptId,_				slot,_				taskState,_				attemptNumber)___			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			final CompletableFuture<Acknowledge> submitResultFuture = taskManagerGateway.submitTask(deployment, timeout)___			submitResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						if (failure instanceof TimeoutException) {_							String taskname = vertex.getTaskNameWithSubtaskIndex() + " (" + attemptId + ')'___							markFailed(new Exception(_								"Cannot deploy task " + taskname + " - TaskManager (" + getAssignedResourceLocation()_									+ ") not responding after a timeout of " + timeout, failure))__						} else {_							markFailed(failure)__						}_					}_				},_				executor)__		}_		catch (Throwable t) {_			markFailed(t)__			ExceptionUtils.rethrow(t)__		}_	};deploys,the,execution,to,the,previously,assigned,resource,throws,job,exception,if,the,execution,cannot,be,deployed,to,the,assigned,resource;public,void,deploy,throws,job,exception,final,simple,slot,slot,assigned,resource,get,check,not,null,slot,in,order,to,deploy,the,execution,we,first,have,to,assign,a,resource,via,try,assign,resource,if,slot,is,alive,throw,new,job,exception,target,slot,task,manager,for,deployment,is,no,longer,alive,execution,state,previous,this,state,if,previous,scheduled,previous,created,if,transition,state,previous,deploying,throw,new,illegal,state,exception,cannot,deploy,task,concurrent,deployment,call,race,else,throw,new,illegal,state,exception,the,vertex,must,be,in,created,or,scheduled,state,to,be,deployed,found,state,previous,try,if,slot,set,executed,vertex,this,throw,new,job,exception,could,not,assign,the,execution,vertex,to,the,slot,slot,if,this,state,deploying,slot,release,slot,return,if,log,is,info,enabled,log,info,string,format,deploying,s,attempt,d,to,s,vertex,get,task,name,with,subtask,index,attempt,number,get,assigned,resource,location,get,hostname,final,task,deployment,descriptor,deployment,vertex,create,deployment,descriptor,attempt,id,slot,task,state,attempt,number,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,completable,future,acknowledge,submit,result,future,task,manager,gateway,submit,task,deployment,timeout,submit,result,future,when,complete,async,ack,failure,if,failure,null,if,failure,instanceof,timeout,exception,string,taskname,vertex,get,task,name,with,subtask,index,attempt,id,mark,failed,new,exception,cannot,deploy,task,taskname,task,manager,get,assigned,resource,location,not,responding,after,a,timeout,of,timeout,failure,else,mark,failed,failure,executor,catch,throwable,t,mark,failed,t,exception,utils,rethrow,t
Execution -> public void deploy() throws JobException;1509638685;Deploys the execution to the previously assigned resource.__@throws JobException if the execution cannot be deployed to the assigned resource;public void deploy() throws JobException {_		final SimpleSlot slot  = assignedResource___		checkNotNull(slot, "In order to deploy the execution we first have to assign a resource via tryAssignResource.")___		_		_		_		if (!slot.isAlive()) {_			throw new JobException("Target slot (TaskManager) for deployment is no longer alive.")__		}__		_		_		ExecutionState previous = this.state__		if (previous == SCHEDULED || previous == CREATED) {_			if (!transitionState(previous, DEPLOYING)) {_				_				_				throw new IllegalStateException("Cannot deploy task: Concurrent deployment call race.")__			}_		}_		else {_			_			throw new IllegalStateException("The vertex must be in CREATED or SCHEDULED state to be deployed. Found state " + previous)__		}__		try {_			_			if (!slot.setExecutedVertex(this)) {_				throw new JobException("Could not assign the ExecutionVertex to the slot " + slot)__			}__			_			if (this.state != DEPLOYING) {_				slot.releaseSlot()__				return__			}__			if (LOG.isInfoEnabled()) {_				LOG.info(String.format("Deploying %s (attempt #%d) to %s", vertex.getTaskNameWithSubtaskIndex(),_						attemptNumber, getAssignedResourceLocation().getHostname()))__			}__			final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(_				attemptId,_				slot,_				taskState,_				attemptNumber)___			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			final CompletableFuture<Acknowledge> submitResultFuture = taskManagerGateway.submitTask(deployment, timeout)___			submitResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						if (failure instanceof TimeoutException) {_							String taskname = vertex.getTaskNameWithSubtaskIndex() + " (" + attemptId + ')'___							markFailed(new Exception(_								"Cannot deploy task " + taskname + " - TaskManager (" + getAssignedResourceLocation()_									+ ") not responding after a timeout of " + timeout, failure))__						} else {_							markFailed(failure)__						}_					}_				},_				executor)__		}_		catch (Throwable t) {_			markFailed(t)__			ExceptionUtils.rethrow(t)__		}_	};deploys,the,execution,to,the,previously,assigned,resource,throws,job,exception,if,the,execution,cannot,be,deployed,to,the,assigned,resource;public,void,deploy,throws,job,exception,final,simple,slot,slot,assigned,resource,check,not,null,slot,in,order,to,deploy,the,execution,we,first,have,to,assign,a,resource,via,try,assign,resource,if,slot,is,alive,throw,new,job,exception,target,slot,task,manager,for,deployment,is,no,longer,alive,execution,state,previous,this,state,if,previous,scheduled,previous,created,if,transition,state,previous,deploying,throw,new,illegal,state,exception,cannot,deploy,task,concurrent,deployment,call,race,else,throw,new,illegal,state,exception,the,vertex,must,be,in,created,or,scheduled,state,to,be,deployed,found,state,previous,try,if,slot,set,executed,vertex,this,throw,new,job,exception,could,not,assign,the,execution,vertex,to,the,slot,slot,if,this,state,deploying,slot,release,slot,return,if,log,is,info,enabled,log,info,string,format,deploying,s,attempt,d,to,s,vertex,get,task,name,with,subtask,index,attempt,number,get,assigned,resource,location,get,hostname,final,task,deployment,descriptor,deployment,vertex,create,deployment,descriptor,attempt,id,slot,task,state,attempt,number,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,completable,future,acknowledge,submit,result,future,task,manager,gateway,submit,task,deployment,timeout,submit,result,future,when,complete,async,ack,failure,if,failure,null,if,failure,instanceof,timeout,exception,string,taskname,vertex,get,task,name,with,subtask,index,attempt,id,mark,failed,new,exception,cannot,deploy,task,taskname,task,manager,get,assigned,resource,location,not,responding,after,a,timeout,of,timeout,failure,else,mark,failed,failure,executor,catch,throwable,t,mark,failed,t,exception,utils,rethrow,t
Execution -> public void deploy() throws JobException;1513201052;Deploys the execution to the previously assigned resource.__@throws JobException if the execution cannot be deployed to the assigned resource;public void deploy() throws JobException {_		final LogicalSlot slot  = assignedResource___		checkNotNull(slot, "In order to deploy the execution we first have to assign a resource via tryAssignResource.")___		_		_		_		if (!slot.isAlive()) {_			throw new JobException("Target slot (TaskManager) for deployment is no longer alive.")__		}__		_		_		ExecutionState previous = this.state__		if (previous == SCHEDULED || previous == CREATED) {_			if (!transitionState(previous, DEPLOYING)) {_				_				_				throw new IllegalStateException("Cannot deploy task: Concurrent deployment call race.")__			}_		}_		else {_			_			throw new IllegalStateException("The vertex must be in CREATED or SCHEDULED state to be deployed. Found state " + previous)__		}__		try {_			_			if (!slot.setExecution(this)) {_				throw new JobException("Could not assign the ExecutionVertex to the slot " + slot)__			}__			_			if (this.state != DEPLOYING) {_				slot.releaseSlot()__				return__			}__			if (LOG.isInfoEnabled()) {_				LOG.info(String.format("Deploying %s (attempt #%d) to %s", vertex.getTaskNameWithSubtaskIndex(),_						attemptNumber, getAssignedResourceLocation().getHostname()))__			}__			final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(_				attemptId,_				slot,_				taskState,_				attemptNumber)___			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			final CompletableFuture<Acknowledge> submitResultFuture = taskManagerGateway.submitTask(deployment, timeout)___			submitResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						if (failure instanceof TimeoutException) {_							String taskname = vertex.getTaskNameWithSubtaskIndex() + " (" + attemptId + ')'___							markFailed(new Exception(_								"Cannot deploy task " + taskname + " - TaskManager (" + getAssignedResourceLocation()_									+ ") not responding after a timeout of " + timeout, failure))__						} else {_							markFailed(failure)__						}_					}_				},_				executor)__		}_		catch (Throwable t) {_			markFailed(t)__			ExceptionUtils.rethrow(t)__		}_	};deploys,the,execution,to,the,previously,assigned,resource,throws,job,exception,if,the,execution,cannot,be,deployed,to,the,assigned,resource;public,void,deploy,throws,job,exception,final,logical,slot,slot,assigned,resource,check,not,null,slot,in,order,to,deploy,the,execution,we,first,have,to,assign,a,resource,via,try,assign,resource,if,slot,is,alive,throw,new,job,exception,target,slot,task,manager,for,deployment,is,no,longer,alive,execution,state,previous,this,state,if,previous,scheduled,previous,created,if,transition,state,previous,deploying,throw,new,illegal,state,exception,cannot,deploy,task,concurrent,deployment,call,race,else,throw,new,illegal,state,exception,the,vertex,must,be,in,created,or,scheduled,state,to,be,deployed,found,state,previous,try,if,slot,set,execution,this,throw,new,job,exception,could,not,assign,the,execution,vertex,to,the,slot,slot,if,this,state,deploying,slot,release,slot,return,if,log,is,info,enabled,log,info,string,format,deploying,s,attempt,d,to,s,vertex,get,task,name,with,subtask,index,attempt,number,get,assigned,resource,location,get,hostname,final,task,deployment,descriptor,deployment,vertex,create,deployment,descriptor,attempt,id,slot,task,state,attempt,number,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,completable,future,acknowledge,submit,result,future,task,manager,gateway,submit,task,deployment,timeout,submit,result,future,when,complete,async,ack,failure,if,failure,null,if,failure,instanceof,timeout,exception,string,taskname,vertex,get,task,name,with,subtask,index,attempt,id,mark,failed,new,exception,cannot,deploy,task,taskname,task,manager,get,assigned,resource,location,not,responding,after,a,timeout,of,timeout,failure,else,mark,failed,failure,executor,catch,throwable,t,mark,failed,t,exception,utils,rethrow,t
Execution -> public void deploy() throws JobException;1513201070;Deploys the execution to the previously assigned resource.__@throws JobException if the execution cannot be deployed to the assigned resource;public void deploy() throws JobException {_		final LogicalSlot slot  = assignedResource___		checkNotNull(slot, "In order to deploy the execution we first have to assign a resource via tryAssignResource.")___		_		_		_		if (!slot.isAlive()) {_			throw new JobException("Target slot (TaskManager) for deployment is no longer alive.")__		}__		_		_		ExecutionState previous = this.state__		if (previous == SCHEDULED || previous == CREATED) {_			if (!transitionState(previous, DEPLOYING)) {_				_				_				throw new IllegalStateException("Cannot deploy task: Concurrent deployment call race.")__			}_		}_		else {_			_			throw new IllegalStateException("The vertex must be in CREATED or SCHEDULED state to be deployed. Found state " + previous)__		}__		try {_			_			if (!slot.tryAssignPayload(this)) {_				throw new JobException("Could not assign the ExecutionVertex to the slot " + slot)__			}__			_			if (this.state != DEPLOYING) {_				slot.releaseSlot()__				return__			}__			if (LOG.isInfoEnabled()) {_				LOG.info(String.format("Deploying %s (attempt #%d) to %s", vertex.getTaskNameWithSubtaskIndex(),_						attemptNumber, getAssignedResourceLocation().getHostname()))__			}__			final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(_				attemptId,_				slot,_				taskState,_				attemptNumber)___			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			final CompletableFuture<Acknowledge> submitResultFuture = taskManagerGateway.submitTask(deployment, timeout)___			submitResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						if (failure instanceof TimeoutException) {_							String taskname = vertex.getTaskNameWithSubtaskIndex() + " (" + attemptId + ')'___							markFailed(new Exception(_								"Cannot deploy task " + taskname + " - TaskManager (" + getAssignedResourceLocation()_									+ ") not responding after a timeout of " + timeout, failure))__						} else {_							markFailed(failure)__						}_					}_				},_				executor)__		}_		catch (Throwable t) {_			markFailed(t)__			ExceptionUtils.rethrow(t)__		}_	};deploys,the,execution,to,the,previously,assigned,resource,throws,job,exception,if,the,execution,cannot,be,deployed,to,the,assigned,resource;public,void,deploy,throws,job,exception,final,logical,slot,slot,assigned,resource,check,not,null,slot,in,order,to,deploy,the,execution,we,first,have,to,assign,a,resource,via,try,assign,resource,if,slot,is,alive,throw,new,job,exception,target,slot,task,manager,for,deployment,is,no,longer,alive,execution,state,previous,this,state,if,previous,scheduled,previous,created,if,transition,state,previous,deploying,throw,new,illegal,state,exception,cannot,deploy,task,concurrent,deployment,call,race,else,throw,new,illegal,state,exception,the,vertex,must,be,in,created,or,scheduled,state,to,be,deployed,found,state,previous,try,if,slot,try,assign,payload,this,throw,new,job,exception,could,not,assign,the,execution,vertex,to,the,slot,slot,if,this,state,deploying,slot,release,slot,return,if,log,is,info,enabled,log,info,string,format,deploying,s,attempt,d,to,s,vertex,get,task,name,with,subtask,index,attempt,number,get,assigned,resource,location,get,hostname,final,task,deployment,descriptor,deployment,vertex,create,deployment,descriptor,attempt,id,slot,task,state,attempt,number,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,completable,future,acknowledge,submit,result,future,task,manager,gateway,submit,task,deployment,timeout,submit,result,future,when,complete,async,ack,failure,if,failure,null,if,failure,instanceof,timeout,exception,string,taskname,vertex,get,task,name,with,subtask,index,attempt,id,mark,failed,new,exception,cannot,deploy,task,taskname,task,manager,get,assigned,resource,location,not,responding,after,a,timeout,of,timeout,failure,else,mark,failed,failure,executor,catch,throwable,t,mark,failed,t,exception,utils,rethrow,t
Execution -> public void deploy() throws JobException;1513261599;Deploys the execution to the previously assigned resource.__@throws JobException if the execution cannot be deployed to the assigned resource;public void deploy() throws JobException {_		final LogicalSlot slot  = assignedResource___		checkNotNull(slot, "In order to deploy the execution we first have to assign a resource via tryAssignResource.")___		_		_		_		if (!slot.isAlive()) {_			throw new JobException("Target slot (TaskManager) for deployment is no longer alive.")__		}__		_		_		ExecutionState previous = this.state__		if (previous == SCHEDULED || previous == CREATED) {_			if (!transitionState(previous, DEPLOYING)) {_				_				_				throw new IllegalStateException("Cannot deploy task: Concurrent deployment call race.")__			}_		}_		else {_			_			throw new IllegalStateException("The vertex must be in CREATED or SCHEDULED state to be deployed. Found state " + previous)__		}__		try {_			_			if (!slot.tryAssignPayload(this)) {_				throw new JobException("Could not assign the ExecutionVertex to the slot " + slot)__			}__			_			if (this.state != DEPLOYING) {_				slot.releaseSlot(new FlinkException("Actual state of execution " + this + " (" + state + ") does not match expected state DEPLOYING."))__				return__			}__			if (LOG.isInfoEnabled()) {_				LOG.info(String.format("Deploying %s (attempt #%d) to %s", vertex.getTaskNameWithSubtaskIndex(),_						attemptNumber, getAssignedResourceLocation().getHostname()))__			}__			final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(_				attemptId,_				slot,_				taskState,_				attemptNumber)___			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			final CompletableFuture<Acknowledge> submitResultFuture = taskManagerGateway.submitTask(deployment, timeout)___			submitResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						if (failure instanceof TimeoutException) {_							String taskname = vertex.getTaskNameWithSubtaskIndex() + " (" + attemptId + ')'___							markFailed(new Exception(_								"Cannot deploy task " + taskname + " - TaskManager (" + getAssignedResourceLocation()_									+ ") not responding after a timeout of " + timeout, failure))__						} else {_							markFailed(failure)__						}_					}_				},_				executor)__		}_		catch (Throwable t) {_			markFailed(t)__			ExceptionUtils.rethrow(t)__		}_	};deploys,the,execution,to,the,previously,assigned,resource,throws,job,exception,if,the,execution,cannot,be,deployed,to,the,assigned,resource;public,void,deploy,throws,job,exception,final,logical,slot,slot,assigned,resource,check,not,null,slot,in,order,to,deploy,the,execution,we,first,have,to,assign,a,resource,via,try,assign,resource,if,slot,is,alive,throw,new,job,exception,target,slot,task,manager,for,deployment,is,no,longer,alive,execution,state,previous,this,state,if,previous,scheduled,previous,created,if,transition,state,previous,deploying,throw,new,illegal,state,exception,cannot,deploy,task,concurrent,deployment,call,race,else,throw,new,illegal,state,exception,the,vertex,must,be,in,created,or,scheduled,state,to,be,deployed,found,state,previous,try,if,slot,try,assign,payload,this,throw,new,job,exception,could,not,assign,the,execution,vertex,to,the,slot,slot,if,this,state,deploying,slot,release,slot,new,flink,exception,actual,state,of,execution,this,state,does,not,match,expected,state,deploying,return,if,log,is,info,enabled,log,info,string,format,deploying,s,attempt,d,to,s,vertex,get,task,name,with,subtask,index,attempt,number,get,assigned,resource,location,get,hostname,final,task,deployment,descriptor,deployment,vertex,create,deployment,descriptor,attempt,id,slot,task,state,attempt,number,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,completable,future,acknowledge,submit,result,future,task,manager,gateway,submit,task,deployment,timeout,submit,result,future,when,complete,async,ack,failure,if,failure,null,if,failure,instanceof,timeout,exception,string,taskname,vertex,get,task,name,with,subtask,index,attempt,id,mark,failed,new,exception,cannot,deploy,task,taskname,task,manager,get,assigned,resource,location,not,responding,after,a,timeout,of,timeout,failure,else,mark,failed,failure,executor,catch,throwable,t,mark,failed,t,exception,utils,rethrow,t
Execution -> public void deploy() throws JobException;1515177485;Deploys the execution to the previously assigned resource.__@throws JobException if the execution cannot be deployed to the assigned resource;public void deploy() throws JobException {_		final LogicalSlot slot  = assignedResource___		checkNotNull(slot, "In order to deploy the execution we first have to assign a resource via tryAssignResource.")___		_		_		_		if (!slot.isAlive()) {_			throw new JobException("Target slot (TaskManager) for deployment is no longer alive.")__		}__		_		_		ExecutionState previous = this.state__		if (previous == SCHEDULED || previous == CREATED) {_			if (!transitionState(previous, DEPLOYING)) {_				_				_				throw new IllegalStateException("Cannot deploy task: Concurrent deployment call race.")__			}_		}_		else {_			_			throw new IllegalStateException("The vertex must be in CREATED or SCHEDULED state to be deployed. Found state " + previous)__		}__		try {_			_			if (!slot.tryAssignPayload(this)) {_				throw new JobException("Could not assign the ExecutionVertex to the slot " + slot)__			}__			_			if (this.state != DEPLOYING) {_				slot.releaseSlot(new FlinkException("Actual state of execution " + this + " (" + state + ") does not match expected state DEPLOYING."))__				return__			}__			if (LOG.isInfoEnabled()) {_				LOG.info(String.format("Deploying %s (attempt #%d) to %s", vertex.getTaskNameWithSubtaskIndex(),_						attemptNumber, getAssignedResourceLocation().getHostname()))__			}__			final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(_				attemptId,_				slot,_				taskState,_				attemptNumber)___			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			final CompletableFuture<Acknowledge> submitResultFuture = taskManagerGateway.submitTask(deployment, timeout)___			submitResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						if (failure instanceof TimeoutException) {_							String taskname = vertex.getTaskNameWithSubtaskIndex() + " (" + attemptId + ')'___							markFailed(new Exception(_								"Cannot deploy task " + taskname + " - TaskManager (" + getAssignedResourceLocation()_									+ ") not responding after a timeout of " + timeout, failure))__						} else {_							markFailed(failure)__						}_					}_				},_				executor)__		}_		catch (Throwable t) {_			markFailed(t)__			ExceptionUtils.rethrow(t)__		}_	};deploys,the,execution,to,the,previously,assigned,resource,throws,job,exception,if,the,execution,cannot,be,deployed,to,the,assigned,resource;public,void,deploy,throws,job,exception,final,logical,slot,slot,assigned,resource,check,not,null,slot,in,order,to,deploy,the,execution,we,first,have,to,assign,a,resource,via,try,assign,resource,if,slot,is,alive,throw,new,job,exception,target,slot,task,manager,for,deployment,is,no,longer,alive,execution,state,previous,this,state,if,previous,scheduled,previous,created,if,transition,state,previous,deploying,throw,new,illegal,state,exception,cannot,deploy,task,concurrent,deployment,call,race,else,throw,new,illegal,state,exception,the,vertex,must,be,in,created,or,scheduled,state,to,be,deployed,found,state,previous,try,if,slot,try,assign,payload,this,throw,new,job,exception,could,not,assign,the,execution,vertex,to,the,slot,slot,if,this,state,deploying,slot,release,slot,new,flink,exception,actual,state,of,execution,this,state,does,not,match,expected,state,deploying,return,if,log,is,info,enabled,log,info,string,format,deploying,s,attempt,d,to,s,vertex,get,task,name,with,subtask,index,attempt,number,get,assigned,resource,location,get,hostname,final,task,deployment,descriptor,deployment,vertex,create,deployment,descriptor,attempt,id,slot,task,state,attempt,number,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,completable,future,acknowledge,submit,result,future,task,manager,gateway,submit,task,deployment,timeout,submit,result,future,when,complete,async,ack,failure,if,failure,null,if,failure,instanceof,timeout,exception,string,taskname,vertex,get,task,name,with,subtask,index,attempt,id,mark,failed,new,exception,cannot,deploy,task,taskname,task,manager,get,assigned,resource,location,not,responding,after,a,timeout,of,timeout,failure,else,mark,failed,failure,executor,catch,throwable,t,mark,failed,t,exception,utils,rethrow,t
Execution -> public void deploy() throws JobException;1516626377;Deploys the execution to the previously assigned resource.__@throws JobException if the execution cannot be deployed to the assigned resource;public void deploy() throws JobException {_		final LogicalSlot slot  = assignedResource___		checkNotNull(slot, "In order to deploy the execution we first have to assign a resource via tryAssignResource.")___		_		_		_		if (!slot.isAlive()) {_			throw new JobException("Target slot (TaskManager) for deployment is no longer alive.")__		}__		_		_		ExecutionState previous = this.state__		if (previous == SCHEDULED || previous == CREATED) {_			if (!transitionState(previous, DEPLOYING)) {_				_				_				throw new IllegalStateException("Cannot deploy task: Concurrent deployment call race.")__			}_		}_		else {_			_			throw new IllegalStateException("The vertex must be in CREATED or SCHEDULED state to be deployed. Found state " + previous)__		}__		try {_			_			if (!slot.tryAssignPayload(this)) {_				throw new JobException("Could not assign the ExecutionVertex to the slot " + slot)__			}__			_			if (this.state != DEPLOYING) {_				slot.releaseSlot(new FlinkException("Actual state of execution " + this + " (" + state + ") does not match expected state DEPLOYING."))__				return__			}__			if (LOG.isInfoEnabled()) {_				LOG.info(String.format("Deploying %s (attempt #%d) to %s", vertex.getTaskNameWithSubtaskIndex(),_						attemptNumber, getAssignedResourceLocation().getHostname()))__			}__			final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(_				attemptId,_				slot,_				taskRestore,_				attemptNumber)___			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			final CompletableFuture<Acknowledge> submitResultFuture = taskManagerGateway.submitTask(deployment, timeout)___			submitResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						if (failure instanceof TimeoutException) {_							String taskname = vertex.getTaskNameWithSubtaskIndex() + " (" + attemptId + ')'___							markFailed(new Exception(_								"Cannot deploy task " + taskname + " - TaskManager (" + getAssignedResourceLocation()_									+ ") not responding after a timeout of " + timeout, failure))__						} else {_							markFailed(failure)__						}_					}_				},_				executor)__		}_		catch (Throwable t) {_			markFailed(t)__			ExceptionUtils.rethrow(t)__		}_	};deploys,the,execution,to,the,previously,assigned,resource,throws,job,exception,if,the,execution,cannot,be,deployed,to,the,assigned,resource;public,void,deploy,throws,job,exception,final,logical,slot,slot,assigned,resource,check,not,null,slot,in,order,to,deploy,the,execution,we,first,have,to,assign,a,resource,via,try,assign,resource,if,slot,is,alive,throw,new,job,exception,target,slot,task,manager,for,deployment,is,no,longer,alive,execution,state,previous,this,state,if,previous,scheduled,previous,created,if,transition,state,previous,deploying,throw,new,illegal,state,exception,cannot,deploy,task,concurrent,deployment,call,race,else,throw,new,illegal,state,exception,the,vertex,must,be,in,created,or,scheduled,state,to,be,deployed,found,state,previous,try,if,slot,try,assign,payload,this,throw,new,job,exception,could,not,assign,the,execution,vertex,to,the,slot,slot,if,this,state,deploying,slot,release,slot,new,flink,exception,actual,state,of,execution,this,state,does,not,match,expected,state,deploying,return,if,log,is,info,enabled,log,info,string,format,deploying,s,attempt,d,to,s,vertex,get,task,name,with,subtask,index,attempt,number,get,assigned,resource,location,get,hostname,final,task,deployment,descriptor,deployment,vertex,create,deployment,descriptor,attempt,id,slot,task,restore,attempt,number,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,completable,future,acknowledge,submit,result,future,task,manager,gateway,submit,task,deployment,timeout,submit,result,future,when,complete,async,ack,failure,if,failure,null,if,failure,instanceof,timeout,exception,string,taskname,vertex,get,task,name,with,subtask,index,attempt,id,mark,failed,new,exception,cannot,deploy,task,taskname,task,manager,get,assigned,resource,location,not,responding,after,a,timeout,of,timeout,failure,else,mark,failed,failure,executor,catch,throwable,t,mark,failed,t,exception,utils,rethrow,t
Execution -> public void deploy() throws JobException;1516626397;Deploys the execution to the previously assigned resource.__@throws JobException if the execution cannot be deployed to the assigned resource;public void deploy() throws JobException {_		final LogicalSlot slot  = assignedResource___		checkNotNull(slot, "In order to deploy the execution we first have to assign a resource via tryAssignResource.")___		_		_		_		if (!slot.isAlive()) {_			throw new JobException("Target slot (TaskManager) for deployment is no longer alive.")__		}__		_		_		ExecutionState previous = this.state__		if (previous == SCHEDULED || previous == CREATED) {_			if (!transitionState(previous, DEPLOYING)) {_				_				_				throw new IllegalStateException("Cannot deploy task: Concurrent deployment call race.")__			}_		}_		else {_			_			throw new IllegalStateException("The vertex must be in CREATED or SCHEDULED state to be deployed. Found state " + previous)__		}__		try {_			_			if (!slot.tryAssignPayload(this)) {_				throw new JobException("Could not assign the ExecutionVertex to the slot " + slot)__			}__			_			if (this.state != DEPLOYING) {_				slot.releaseSlot(new FlinkException("Actual state of execution " + this + " (" + state + ") does not match expected state DEPLOYING."))__				return__			}__			if (LOG.isInfoEnabled()) {_				LOG.info(String.format("Deploying %s (attempt #%d) to %s", vertex.getTaskNameWithSubtaskIndex(),_						attemptNumber, getAssignedResourceLocation().getHostname()))__			}__			final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(_				attemptId,_				slot,_				taskRestore,_				attemptNumber)___			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			final CompletableFuture<Acknowledge> submitResultFuture = taskManagerGateway.submitTask(deployment, timeout)___			submitResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						if (failure instanceof TimeoutException) {_							String taskname = vertex.getTaskNameWithSubtaskIndex() + " (" + attemptId + ')'___							markFailed(new Exception(_								"Cannot deploy task " + taskname + " - TaskManager (" + getAssignedResourceLocation()_									+ ") not responding after a timeout of " + timeout, failure))__						} else {_							markFailed(failure)__						}_					}_				},_				executor)__		}_		catch (Throwable t) {_			markFailed(t)__			ExceptionUtils.rethrow(t)__		}_	};deploys,the,execution,to,the,previously,assigned,resource,throws,job,exception,if,the,execution,cannot,be,deployed,to,the,assigned,resource;public,void,deploy,throws,job,exception,final,logical,slot,slot,assigned,resource,check,not,null,slot,in,order,to,deploy,the,execution,we,first,have,to,assign,a,resource,via,try,assign,resource,if,slot,is,alive,throw,new,job,exception,target,slot,task,manager,for,deployment,is,no,longer,alive,execution,state,previous,this,state,if,previous,scheduled,previous,created,if,transition,state,previous,deploying,throw,new,illegal,state,exception,cannot,deploy,task,concurrent,deployment,call,race,else,throw,new,illegal,state,exception,the,vertex,must,be,in,created,or,scheduled,state,to,be,deployed,found,state,previous,try,if,slot,try,assign,payload,this,throw,new,job,exception,could,not,assign,the,execution,vertex,to,the,slot,slot,if,this,state,deploying,slot,release,slot,new,flink,exception,actual,state,of,execution,this,state,does,not,match,expected,state,deploying,return,if,log,is,info,enabled,log,info,string,format,deploying,s,attempt,d,to,s,vertex,get,task,name,with,subtask,index,attempt,number,get,assigned,resource,location,get,hostname,final,task,deployment,descriptor,deployment,vertex,create,deployment,descriptor,attempt,id,slot,task,restore,attempt,number,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,completable,future,acknowledge,submit,result,future,task,manager,gateway,submit,task,deployment,timeout,submit,result,future,when,complete,async,ack,failure,if,failure,null,if,failure,instanceof,timeout,exception,string,taskname,vertex,get,task,name,with,subtask,index,attempt,id,mark,failed,new,exception,cannot,deploy,task,taskname,task,manager,get,assigned,resource,location,not,responding,after,a,timeout,of,timeout,failure,else,mark,failed,failure,executor,catch,throwable,t,mark,failed,t,exception,utils,rethrow,t
Execution -> public void deploy() throws JobException;1518680774;Deploys the execution to the previously assigned resource.__@throws JobException if the execution cannot be deployed to the assigned resource;public void deploy() throws JobException {_		final LogicalSlot slot  = assignedResource___		checkNotNull(slot, "In order to deploy the execution we first have to assign a resource via tryAssignResource.")___		_		_		_		if (!slot.isAlive()) {_			throw new JobException("Target slot (TaskManager) for deployment is no longer alive.")__		}__		_		_		ExecutionState previous = this.state__		if (previous == SCHEDULED || previous == CREATED) {_			if (!transitionState(previous, DEPLOYING)) {_				_				_				throw new IllegalStateException("Cannot deploy task: Concurrent deployment call race.")__			}_		}_		else {_			_			throw new IllegalStateException("The vertex must be in CREATED or SCHEDULED state to be deployed. Found state " + previous)__		}__		try {_			_			if (!slot.tryAssignPayload(this)) {_				throw new JobException("Could not assign the ExecutionVertex to the slot " + slot)__			}__			_			if (this.state != DEPLOYING) {_				slot.releaseSlot(new FlinkException("Actual state of execution " + this + " (" + state + ") does not match expected state DEPLOYING."))__				return__			}__			if (LOG.isInfoEnabled()) {_				LOG.info(String.format("Deploying %s (attempt #%d) to %s", vertex.getTaskNameWithSubtaskIndex(),_						attemptNumber, getAssignedResourceLocation().getHostname()))__			}__			final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(_				attemptId,_				slot,_				taskRestore,_				attemptNumber)___			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			final CompletableFuture<Acknowledge> submitResultFuture = taskManagerGateway.submitTask(deployment, rpcTimeout)___			submitResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						if (failure instanceof TimeoutException) {_							String taskname = vertex.getTaskNameWithSubtaskIndex() + " (" + attemptId + ')'___							markFailed(new Exception(_								"Cannot deploy task " + taskname + " - TaskManager (" + getAssignedResourceLocation()_									+ ") not responding after a rpcTimeout of " + rpcTimeout, failure))__						} else {_							markFailed(failure)__						}_					}_				},_				executor)__		}_		catch (Throwable t) {_			markFailed(t)__			ExceptionUtils.rethrow(t)__		}_	};deploys,the,execution,to,the,previously,assigned,resource,throws,job,exception,if,the,execution,cannot,be,deployed,to,the,assigned,resource;public,void,deploy,throws,job,exception,final,logical,slot,slot,assigned,resource,check,not,null,slot,in,order,to,deploy,the,execution,we,first,have,to,assign,a,resource,via,try,assign,resource,if,slot,is,alive,throw,new,job,exception,target,slot,task,manager,for,deployment,is,no,longer,alive,execution,state,previous,this,state,if,previous,scheduled,previous,created,if,transition,state,previous,deploying,throw,new,illegal,state,exception,cannot,deploy,task,concurrent,deployment,call,race,else,throw,new,illegal,state,exception,the,vertex,must,be,in,created,or,scheduled,state,to,be,deployed,found,state,previous,try,if,slot,try,assign,payload,this,throw,new,job,exception,could,not,assign,the,execution,vertex,to,the,slot,slot,if,this,state,deploying,slot,release,slot,new,flink,exception,actual,state,of,execution,this,state,does,not,match,expected,state,deploying,return,if,log,is,info,enabled,log,info,string,format,deploying,s,attempt,d,to,s,vertex,get,task,name,with,subtask,index,attempt,number,get,assigned,resource,location,get,hostname,final,task,deployment,descriptor,deployment,vertex,create,deployment,descriptor,attempt,id,slot,task,restore,attempt,number,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,completable,future,acknowledge,submit,result,future,task,manager,gateway,submit,task,deployment,rpc,timeout,submit,result,future,when,complete,async,ack,failure,if,failure,null,if,failure,instanceof,timeout,exception,string,taskname,vertex,get,task,name,with,subtask,index,attempt,id,mark,failed,new,exception,cannot,deploy,task,taskname,task,manager,get,assigned,resource,location,not,responding,after,a,rpc,timeout,of,rpc,timeout,failure,else,mark,failed,failure,executor,catch,throwable,t,mark,failed,t,exception,utils,rethrow,t
Execution -> public void deploy() throws JobException;1518712478;Deploys the execution to the previously assigned resource.__@throws JobException if the execution cannot be deployed to the assigned resource;public void deploy() throws JobException {_		final LogicalSlot slot  = assignedResource___		checkNotNull(slot, "In order to deploy the execution we first have to assign a resource via tryAssignResource.")___		_		_		_		if (!slot.isAlive()) {_			throw new JobException("Target slot (TaskManager) for deployment is no longer alive.")__		}__		_		_		ExecutionState previous = this.state__		if (previous == SCHEDULED || previous == CREATED) {_			if (!transitionState(previous, DEPLOYING)) {_				_				_				throw new IllegalStateException("Cannot deploy task: Concurrent deployment call race.")__			}_		}_		else {_			_			throw new IllegalStateException("The vertex must be in CREATED or SCHEDULED state to be deployed. Found state " + previous)__		}__		try {_			_			if (!slot.tryAssignPayload(this)) {_				throw new JobException("Could not assign the ExecutionVertex to the slot " + slot)__			}__			_			if (this.state != DEPLOYING) {_				slot.releaseSlot(new FlinkException("Actual state of execution " + this + " (" + state + ") does not match expected state DEPLOYING."))__				return__			}__			if (LOG.isInfoEnabled()) {_				LOG.info(String.format("Deploying %s (attempt #%d) to %s", vertex.getTaskNameWithSubtaskIndex(),_						attemptNumber, getAssignedResourceLocation().getHostname()))__			}__			final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(_				attemptId,_				slot,_				taskRestore,_				attemptNumber)___			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			final CompletableFuture<Acknowledge> submitResultFuture = taskManagerGateway.submitTask(deployment, rpcTimeout)___			submitResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						if (failure instanceof TimeoutException) {_							String taskname = vertex.getTaskNameWithSubtaskIndex() + " (" + attemptId + ')'___							markFailed(new Exception(_								"Cannot deploy task " + taskname + " - TaskManager (" + getAssignedResourceLocation()_									+ ") not responding after a rpcTimeout of " + rpcTimeout, failure))__						} else {_							markFailed(failure)__						}_					}_				},_				executor)__		}_		catch (Throwable t) {_			markFailed(t)__			ExceptionUtils.rethrow(t)__		}_	};deploys,the,execution,to,the,previously,assigned,resource,throws,job,exception,if,the,execution,cannot,be,deployed,to,the,assigned,resource;public,void,deploy,throws,job,exception,final,logical,slot,slot,assigned,resource,check,not,null,slot,in,order,to,deploy,the,execution,we,first,have,to,assign,a,resource,via,try,assign,resource,if,slot,is,alive,throw,new,job,exception,target,slot,task,manager,for,deployment,is,no,longer,alive,execution,state,previous,this,state,if,previous,scheduled,previous,created,if,transition,state,previous,deploying,throw,new,illegal,state,exception,cannot,deploy,task,concurrent,deployment,call,race,else,throw,new,illegal,state,exception,the,vertex,must,be,in,created,or,scheduled,state,to,be,deployed,found,state,previous,try,if,slot,try,assign,payload,this,throw,new,job,exception,could,not,assign,the,execution,vertex,to,the,slot,slot,if,this,state,deploying,slot,release,slot,new,flink,exception,actual,state,of,execution,this,state,does,not,match,expected,state,deploying,return,if,log,is,info,enabled,log,info,string,format,deploying,s,attempt,d,to,s,vertex,get,task,name,with,subtask,index,attempt,number,get,assigned,resource,location,get,hostname,final,task,deployment,descriptor,deployment,vertex,create,deployment,descriptor,attempt,id,slot,task,restore,attempt,number,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,completable,future,acknowledge,submit,result,future,task,manager,gateway,submit,task,deployment,rpc,timeout,submit,result,future,when,complete,async,ack,failure,if,failure,null,if,failure,instanceof,timeout,exception,string,taskname,vertex,get,task,name,with,subtask,index,attempt,id,mark,failed,new,exception,cannot,deploy,task,taskname,task,manager,get,assigned,resource,location,not,responding,after,a,rpc,timeout,of,rpc,timeout,failure,else,mark,failed,failure,executor,catch,throwable,t,mark,failed,t,exception,utils,rethrow,t
Execution -> public void deploy() throws JobException;1519316529;Deploys the execution to the previously assigned resource.__@throws JobException if the execution cannot be deployed to the assigned resource;public void deploy() throws JobException {_		final LogicalSlot slot  = assignedResource___		checkNotNull(slot, "In order to deploy the execution we first have to assign a resource via tryAssignResource.")___		_		_		_		if (!slot.isAlive()) {_			throw new JobException("Target slot (TaskManager) for deployment is no longer alive.")__		}__		_		_		ExecutionState previous = this.state__		if (previous == SCHEDULED || previous == CREATED) {_			if (!transitionState(previous, DEPLOYING)) {_				_				_				throw new IllegalStateException("Cannot deploy task: Concurrent deployment call race.")__			}_		}_		else {_			_			throw new IllegalStateException("The vertex must be in CREATED or SCHEDULED state to be deployed. Found state " + previous)__		}__		try {_			_			if (!slot.tryAssignPayload(this)) {_				throw new JobException("Could not assign the ExecutionVertex to the slot " + slot)__			}__			_			if (this.state != DEPLOYING) {_				slot.releaseSlot(new FlinkException("Actual state of execution " + this + " (" + state + ") does not match expected state DEPLOYING."))__				return__			}__			if (LOG.isInfoEnabled()) {_				LOG.info(String.format("Deploying %s (attempt #%d) to %s", vertex.getTaskNameWithSubtaskIndex(),_						attemptNumber, getAssignedResourceLocation().getHostname()))__			}__			final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(_				attemptId,_				slot,_				taskRestore,_				attemptNumber)___			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			final CompletableFuture<Acknowledge> submitResultFuture = taskManagerGateway.submitTask(deployment, rpcTimeout)___			submitResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						if (failure instanceof TimeoutException) {_							String taskname = vertex.getTaskNameWithSubtaskIndex() + " (" + attemptId + ')'___							markFailed(new Exception(_								"Cannot deploy task " + taskname + " - TaskManager (" + getAssignedResourceLocation()_									+ ") not responding after a rpcTimeout of " + rpcTimeout, failure))__						} else {_							markFailed(failure)__						}_					}_				},_				executor)__		}_		catch (Throwable t) {_			markFailed(t)__			ExceptionUtils.rethrow(t)__		}_	};deploys,the,execution,to,the,previously,assigned,resource,throws,job,exception,if,the,execution,cannot,be,deployed,to,the,assigned,resource;public,void,deploy,throws,job,exception,final,logical,slot,slot,assigned,resource,check,not,null,slot,in,order,to,deploy,the,execution,we,first,have,to,assign,a,resource,via,try,assign,resource,if,slot,is,alive,throw,new,job,exception,target,slot,task,manager,for,deployment,is,no,longer,alive,execution,state,previous,this,state,if,previous,scheduled,previous,created,if,transition,state,previous,deploying,throw,new,illegal,state,exception,cannot,deploy,task,concurrent,deployment,call,race,else,throw,new,illegal,state,exception,the,vertex,must,be,in,created,or,scheduled,state,to,be,deployed,found,state,previous,try,if,slot,try,assign,payload,this,throw,new,job,exception,could,not,assign,the,execution,vertex,to,the,slot,slot,if,this,state,deploying,slot,release,slot,new,flink,exception,actual,state,of,execution,this,state,does,not,match,expected,state,deploying,return,if,log,is,info,enabled,log,info,string,format,deploying,s,attempt,d,to,s,vertex,get,task,name,with,subtask,index,attempt,number,get,assigned,resource,location,get,hostname,final,task,deployment,descriptor,deployment,vertex,create,deployment,descriptor,attempt,id,slot,task,restore,attempt,number,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,completable,future,acknowledge,submit,result,future,task,manager,gateway,submit,task,deployment,rpc,timeout,submit,result,future,when,complete,async,ack,failure,if,failure,null,if,failure,instanceof,timeout,exception,string,taskname,vertex,get,task,name,with,subtask,index,attempt,id,mark,failed,new,exception,cannot,deploy,task,taskname,task,manager,get,assigned,resource,location,not,responding,after,a,rpc,timeout,of,rpc,timeout,failure,else,mark,failed,failure,executor,catch,throwable,t,mark,failed,t,exception,utils,rethrow,t
Execution -> public void deploy() throws JobException;1519481114;Deploys the execution to the previously assigned resource.__@throws JobException if the execution cannot be deployed to the assigned resource;public void deploy() throws JobException {_		final LogicalSlot slot  = assignedResource___		checkNotNull(slot, "In order to deploy the execution we first have to assign a resource via tryAssignResource.")___		_		_		_		if (!slot.isAlive()) {_			throw new JobException("Target slot (TaskManager) for deployment is no longer alive.")__		}__		_		_		ExecutionState previous = this.state__		if (previous == SCHEDULED || previous == CREATED) {_			if (!transitionState(previous, DEPLOYING)) {_				_				_				throw new IllegalStateException("Cannot deploy task: Concurrent deployment call race.")__			}_		}_		else {_			_			throw new IllegalStateException("The vertex must be in CREATED or SCHEDULED state to be deployed. Found state " + previous)__		}__		try {_			_			if (!slot.tryAssignPayload(this)) {_				throw new JobException("Could not assign the ExecutionVertex to the slot " + slot)__			}__			_			if (this.state != DEPLOYING) {_				slot.releaseSlot(new FlinkException("Actual state of execution " + this + " (" + state + ") does not match expected state DEPLOYING."))__				return__			}__			if (LOG.isInfoEnabled()) {_				LOG.info(String.format("Deploying %s (attempt #%d) to %s", vertex.getTaskNameWithSubtaskIndex(),_						attemptNumber, getAssignedResourceLocation().getHostname()))__			}__			final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(_				attemptId,_				slot,_				taskRestore,_				attemptNumber)___			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			final CompletableFuture<Acknowledge> submitResultFuture = taskManagerGateway.submitTask(deployment, rpcTimeout)___			submitResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						if (failure instanceof TimeoutException) {_							String taskname = vertex.getTaskNameWithSubtaskIndex() + " (" + attemptId + ')'___							markFailed(new Exception(_								"Cannot deploy task " + taskname + " - TaskManager (" + getAssignedResourceLocation()_									+ ") not responding after a rpcTimeout of " + rpcTimeout, failure))__						} else {_							markFailed(failure)__						}_					}_				},_				executor)__		}_		catch (Throwable t) {_			markFailed(t)__			ExceptionUtils.rethrow(t)__		}_	};deploys,the,execution,to,the,previously,assigned,resource,throws,job,exception,if,the,execution,cannot,be,deployed,to,the,assigned,resource;public,void,deploy,throws,job,exception,final,logical,slot,slot,assigned,resource,check,not,null,slot,in,order,to,deploy,the,execution,we,first,have,to,assign,a,resource,via,try,assign,resource,if,slot,is,alive,throw,new,job,exception,target,slot,task,manager,for,deployment,is,no,longer,alive,execution,state,previous,this,state,if,previous,scheduled,previous,created,if,transition,state,previous,deploying,throw,new,illegal,state,exception,cannot,deploy,task,concurrent,deployment,call,race,else,throw,new,illegal,state,exception,the,vertex,must,be,in,created,or,scheduled,state,to,be,deployed,found,state,previous,try,if,slot,try,assign,payload,this,throw,new,job,exception,could,not,assign,the,execution,vertex,to,the,slot,slot,if,this,state,deploying,slot,release,slot,new,flink,exception,actual,state,of,execution,this,state,does,not,match,expected,state,deploying,return,if,log,is,info,enabled,log,info,string,format,deploying,s,attempt,d,to,s,vertex,get,task,name,with,subtask,index,attempt,number,get,assigned,resource,location,get,hostname,final,task,deployment,descriptor,deployment,vertex,create,deployment,descriptor,attempt,id,slot,task,restore,attempt,number,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,completable,future,acknowledge,submit,result,future,task,manager,gateway,submit,task,deployment,rpc,timeout,submit,result,future,when,complete,async,ack,failure,if,failure,null,if,failure,instanceof,timeout,exception,string,taskname,vertex,get,task,name,with,subtask,index,attempt,id,mark,failed,new,exception,cannot,deploy,task,taskname,task,manager,get,assigned,resource,location,not,responding,after,a,rpc,timeout,of,rpc,timeout,failure,else,mark,failed,failure,executor,catch,throwable,t,mark,failed,t,exception,utils,rethrow,t
Execution -> public void deploy() throws JobException;1519568061;Deploys the execution to the previously assigned resource.__@throws JobException if the execution cannot be deployed to the assigned resource;public void deploy() throws JobException {_		final LogicalSlot slot  = assignedResource___		checkNotNull(slot, "In order to deploy the execution we first have to assign a resource via tryAssignResource.")___		_		_		_		if (!slot.isAlive()) {_			throw new JobException("Target slot (TaskManager) for deployment is no longer alive.")__		}__		_		_		ExecutionState previous = this.state__		if (previous == SCHEDULED || previous == CREATED) {_			if (!transitionState(previous, DEPLOYING)) {_				_				_				throw new IllegalStateException("Cannot deploy task: Concurrent deployment call race.")__			}_		}_		else {_			_			throw new IllegalStateException("The vertex must be in CREATED or SCHEDULED state to be deployed. Found state " + previous)__		}__		try {_			_			if (!slot.tryAssignPayload(this)) {_				throw new JobException("Could not assign the ExecutionVertex to the slot " + slot)__			}__			_			if (this.state != DEPLOYING) {_				slot.releaseSlot(new FlinkException("Actual state of execution " + this + " (" + state + ") does not match expected state DEPLOYING."))__				return__			}__			if (LOG.isInfoEnabled()) {_				LOG.info(String.format("Deploying %s (attempt #%d) to %s", vertex.getTaskNameWithSubtaskIndex(),_						attemptNumber, getAssignedResourceLocation().getHostname()))__			}__			final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(_				attemptId,_				slot,_				taskRestore,_				attemptNumber)___			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			final CompletableFuture<Acknowledge> submitResultFuture = taskManagerGateway.submitTask(deployment, rpcTimeout)___			submitResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						if (failure instanceof TimeoutException) {_							String taskname = vertex.getTaskNameWithSubtaskIndex() + " (" + attemptId + ')'___							markFailed(new Exception(_								"Cannot deploy task " + taskname + " - TaskManager (" + getAssignedResourceLocation()_									+ ") not responding after a rpcTimeout of " + rpcTimeout, failure))__						} else {_							markFailed(failure)__						}_					}_				},_				executor)__		}_		catch (Throwable t) {_			markFailed(t)__			ExceptionUtils.rethrow(t)__		}_	};deploys,the,execution,to,the,previously,assigned,resource,throws,job,exception,if,the,execution,cannot,be,deployed,to,the,assigned,resource;public,void,deploy,throws,job,exception,final,logical,slot,slot,assigned,resource,check,not,null,slot,in,order,to,deploy,the,execution,we,first,have,to,assign,a,resource,via,try,assign,resource,if,slot,is,alive,throw,new,job,exception,target,slot,task,manager,for,deployment,is,no,longer,alive,execution,state,previous,this,state,if,previous,scheduled,previous,created,if,transition,state,previous,deploying,throw,new,illegal,state,exception,cannot,deploy,task,concurrent,deployment,call,race,else,throw,new,illegal,state,exception,the,vertex,must,be,in,created,or,scheduled,state,to,be,deployed,found,state,previous,try,if,slot,try,assign,payload,this,throw,new,job,exception,could,not,assign,the,execution,vertex,to,the,slot,slot,if,this,state,deploying,slot,release,slot,new,flink,exception,actual,state,of,execution,this,state,does,not,match,expected,state,deploying,return,if,log,is,info,enabled,log,info,string,format,deploying,s,attempt,d,to,s,vertex,get,task,name,with,subtask,index,attempt,number,get,assigned,resource,location,get,hostname,final,task,deployment,descriptor,deployment,vertex,create,deployment,descriptor,attempt,id,slot,task,restore,attempt,number,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,completable,future,acknowledge,submit,result,future,task,manager,gateway,submit,task,deployment,rpc,timeout,submit,result,future,when,complete,async,ack,failure,if,failure,null,if,failure,instanceof,timeout,exception,string,taskname,vertex,get,task,name,with,subtask,index,attempt,id,mark,failed,new,exception,cannot,deploy,task,taskname,task,manager,get,assigned,resource,location,not,responding,after,a,rpc,timeout,of,rpc,timeout,failure,else,mark,failed,failure,executor,catch,throwable,t,mark,failed,t,exception,utils,rethrow,t
Execution -> public void deploy() throws JobException;1519655521;Deploys the execution to the previously assigned resource.__@throws JobException if the execution cannot be deployed to the assigned resource;public void deploy() throws JobException {_		final LogicalSlot slot  = assignedResource___		checkNotNull(slot, "In order to deploy the execution we first have to assign a resource via tryAssignResource.")___		_		_		_		if (!slot.isAlive()) {_			throw new JobException("Target slot (TaskManager) for deployment is no longer alive.")__		}__		_		_		ExecutionState previous = this.state__		if (previous == SCHEDULED || previous == CREATED) {_			if (!transitionState(previous, DEPLOYING)) {_				_				_				throw new IllegalStateException("Cannot deploy task: Concurrent deployment call race.")__			}_		}_		else {_			_			throw new IllegalStateException("The vertex must be in CREATED or SCHEDULED state to be deployed. Found state " + previous)__		}__		try {_			_			if (!slot.tryAssignPayload(this)) {_				throw new JobException("Could not assign the ExecutionVertex to the slot " + slot)__			}__			_			if (this.state != DEPLOYING) {_				slot.releaseSlot(new FlinkException("Actual state of execution " + this + " (" + state + ") does not match expected state DEPLOYING."))__				return__			}__			if (LOG.isInfoEnabled()) {_				LOG.info(String.format("Deploying %s (attempt #%d) to %s", vertex.getTaskNameWithSubtaskIndex(),_						attemptNumber, getAssignedResourceLocation().getHostname()))__			}__			final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(_				attemptId,_				slot,_				taskRestore,_				attemptNumber)___			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			final CompletableFuture<Acknowledge> submitResultFuture = taskManagerGateway.submitTask(deployment, rpcTimeout)___			submitResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						if (failure instanceof TimeoutException) {_							String taskname = vertex.getTaskNameWithSubtaskIndex() + " (" + attemptId + ')'___							markFailed(new Exception(_								"Cannot deploy task " + taskname + " - TaskManager (" + getAssignedResourceLocation()_									+ ") not responding after a rpcTimeout of " + rpcTimeout, failure))__						} else {_							markFailed(failure)__						}_					}_				},_				executor)__		}_		catch (Throwable t) {_			markFailed(t)__			ExceptionUtils.rethrow(t)__		}_	};deploys,the,execution,to,the,previously,assigned,resource,throws,job,exception,if,the,execution,cannot,be,deployed,to,the,assigned,resource;public,void,deploy,throws,job,exception,final,logical,slot,slot,assigned,resource,check,not,null,slot,in,order,to,deploy,the,execution,we,first,have,to,assign,a,resource,via,try,assign,resource,if,slot,is,alive,throw,new,job,exception,target,slot,task,manager,for,deployment,is,no,longer,alive,execution,state,previous,this,state,if,previous,scheduled,previous,created,if,transition,state,previous,deploying,throw,new,illegal,state,exception,cannot,deploy,task,concurrent,deployment,call,race,else,throw,new,illegal,state,exception,the,vertex,must,be,in,created,or,scheduled,state,to,be,deployed,found,state,previous,try,if,slot,try,assign,payload,this,throw,new,job,exception,could,not,assign,the,execution,vertex,to,the,slot,slot,if,this,state,deploying,slot,release,slot,new,flink,exception,actual,state,of,execution,this,state,does,not,match,expected,state,deploying,return,if,log,is,info,enabled,log,info,string,format,deploying,s,attempt,d,to,s,vertex,get,task,name,with,subtask,index,attempt,number,get,assigned,resource,location,get,hostname,final,task,deployment,descriptor,deployment,vertex,create,deployment,descriptor,attempt,id,slot,task,restore,attempt,number,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,completable,future,acknowledge,submit,result,future,task,manager,gateway,submit,task,deployment,rpc,timeout,submit,result,future,when,complete,async,ack,failure,if,failure,null,if,failure,instanceof,timeout,exception,string,taskname,vertex,get,task,name,with,subtask,index,attempt,id,mark,failed,new,exception,cannot,deploy,task,taskname,task,manager,get,assigned,resource,location,not,responding,after,a,rpc,timeout,of,rpc,timeout,failure,else,mark,failed,failure,executor,catch,throwable,t,mark,failed,t,exception,utils,rethrow,t
Execution -> public void deploy() throws JobException;1522049586;Deploys the execution to the previously assigned resource.__@throws JobException if the execution cannot be deployed to the assigned resource;public void deploy() throws JobException {_		final LogicalSlot slot  = assignedResource___		checkNotNull(slot, "In order to deploy the execution we first have to assign a resource via tryAssignResource.")___		_		_		_		if (!slot.isAlive()) {_			throw new JobException("Target slot (TaskManager) for deployment is no longer alive.")__		}__		_		_		ExecutionState previous = this.state__		if (previous == SCHEDULED || previous == CREATED) {_			if (!transitionState(previous, DEPLOYING)) {_				_				_				throw new IllegalStateException("Cannot deploy task: Concurrent deployment call race.")__			}_		}_		else {_			_			throw new IllegalStateException("The vertex must be in CREATED or SCHEDULED state to be deployed. Found state " + previous)__		}__		try {_			_			if (!slot.tryAssignPayload(this)) {_				throw new JobException("Could not assign the ExecutionVertex to the slot " + slot)__			}__			_			if (this.state != DEPLOYING) {_				slot.releaseSlot(new FlinkException("Actual state of execution " + this + " (" + state + ") does not match expected state DEPLOYING."))__				return__			}__			if (LOG.isInfoEnabled()) {_				LOG.info(String.format("Deploying %s (attempt #%d) to %s", vertex.getTaskNameWithSubtaskIndex(),_						attemptNumber, getAssignedResourceLocation().getHostname()))__			}__			final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(_				attemptId,_				slot,_				taskRestore,_				attemptNumber)___			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			final CompletableFuture<Acknowledge> submitResultFuture = taskManagerGateway.submitTask(deployment, rpcTimeout)___			submitResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						if (failure instanceof TimeoutException) {_							String taskname = vertex.getTaskNameWithSubtaskIndex() + " (" + attemptId + ')'___							markFailed(new Exception(_								"Cannot deploy task " + taskname + " - TaskManager (" + getAssignedResourceLocation()_									+ ") not responding after a rpcTimeout of " + rpcTimeout, failure))__						} else {_							markFailed(failure)__						}_					}_				},_				executor)__		}_		catch (Throwable t) {_			markFailed(t)__			ExceptionUtils.rethrow(t)__		}_	};deploys,the,execution,to,the,previously,assigned,resource,throws,job,exception,if,the,execution,cannot,be,deployed,to,the,assigned,resource;public,void,deploy,throws,job,exception,final,logical,slot,slot,assigned,resource,check,not,null,slot,in,order,to,deploy,the,execution,we,first,have,to,assign,a,resource,via,try,assign,resource,if,slot,is,alive,throw,new,job,exception,target,slot,task,manager,for,deployment,is,no,longer,alive,execution,state,previous,this,state,if,previous,scheduled,previous,created,if,transition,state,previous,deploying,throw,new,illegal,state,exception,cannot,deploy,task,concurrent,deployment,call,race,else,throw,new,illegal,state,exception,the,vertex,must,be,in,created,or,scheduled,state,to,be,deployed,found,state,previous,try,if,slot,try,assign,payload,this,throw,new,job,exception,could,not,assign,the,execution,vertex,to,the,slot,slot,if,this,state,deploying,slot,release,slot,new,flink,exception,actual,state,of,execution,this,state,does,not,match,expected,state,deploying,return,if,log,is,info,enabled,log,info,string,format,deploying,s,attempt,d,to,s,vertex,get,task,name,with,subtask,index,attempt,number,get,assigned,resource,location,get,hostname,final,task,deployment,descriptor,deployment,vertex,create,deployment,descriptor,attempt,id,slot,task,restore,attempt,number,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,completable,future,acknowledge,submit,result,future,task,manager,gateway,submit,task,deployment,rpc,timeout,submit,result,future,when,complete,async,ack,failure,if,failure,null,if,failure,instanceof,timeout,exception,string,taskname,vertex,get,task,name,with,subtask,index,attempt,id,mark,failed,new,exception,cannot,deploy,task,taskname,task,manager,get,assigned,resource,location,not,responding,after,a,rpc,timeout,of,rpc,timeout,failure,else,mark,failed,failure,executor,catch,throwable,t,mark,failed,t,exception,utils,rethrow,t
Execution -> public void deploy() throws JobException;1522249273;Deploys the execution to the previously assigned resource.__@throws JobException if the execution cannot be deployed to the assigned resource;public void deploy() throws JobException {_		final LogicalSlot slot  = assignedResource___		checkNotNull(slot, "In order to deploy the execution we first have to assign a resource via tryAssignResource.")___		_		_		_		if (!slot.isAlive()) {_			throw new JobException("Target slot (TaskManager) for deployment is no longer alive.")__		}__		_		_		ExecutionState previous = this.state__		if (previous == SCHEDULED || previous == CREATED) {_			if (!transitionState(previous, DEPLOYING)) {_				_				_				throw new IllegalStateException("Cannot deploy task: Concurrent deployment call race.")__			}_		}_		else {_			_			throw new IllegalStateException("The vertex must be in CREATED or SCHEDULED state to be deployed. Found state " + previous)__		}__		if (this != slot.getPayload()) {_			throw new IllegalStateException(_				String.format("The execution %s has not been assigned to the assigned slot.", this))__		}__		try {__			_			if (this.state != DEPLOYING) {_				slot.releaseSlot(new FlinkException("Actual state of execution " + this + " (" + state + ") does not match expected state DEPLOYING."))__				return__			}__			if (LOG.isInfoEnabled()) {_				LOG.info(String.format("Deploying %s (attempt #%d) to %s", vertex.getTaskNameWithSubtaskIndex(),_						attemptNumber, getAssignedResourceLocation().getHostname()))__			}__			final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(_				attemptId,_				slot,_				taskRestore,_				attemptNumber)___			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			final CompletableFuture<Acknowledge> submitResultFuture = taskManagerGateway.submitTask(deployment, rpcTimeout)___			submitResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						if (failure instanceof TimeoutException) {_							String taskname = vertex.getTaskNameWithSubtaskIndex() + " (" + attemptId + ')'___							markFailed(new Exception(_								"Cannot deploy task " + taskname + " - TaskManager (" + getAssignedResourceLocation()_									+ ") not responding after a rpcTimeout of " + rpcTimeout, failure))__						} else {_							markFailed(failure)__						}_					}_				},_				executor)__		}_		catch (Throwable t) {_			markFailed(t)__			ExceptionUtils.rethrow(t)__		}_	};deploys,the,execution,to,the,previously,assigned,resource,throws,job,exception,if,the,execution,cannot,be,deployed,to,the,assigned,resource;public,void,deploy,throws,job,exception,final,logical,slot,slot,assigned,resource,check,not,null,slot,in,order,to,deploy,the,execution,we,first,have,to,assign,a,resource,via,try,assign,resource,if,slot,is,alive,throw,new,job,exception,target,slot,task,manager,for,deployment,is,no,longer,alive,execution,state,previous,this,state,if,previous,scheduled,previous,created,if,transition,state,previous,deploying,throw,new,illegal,state,exception,cannot,deploy,task,concurrent,deployment,call,race,else,throw,new,illegal,state,exception,the,vertex,must,be,in,created,or,scheduled,state,to,be,deployed,found,state,previous,if,this,slot,get,payload,throw,new,illegal,state,exception,string,format,the,execution,s,has,not,been,assigned,to,the,assigned,slot,this,try,if,this,state,deploying,slot,release,slot,new,flink,exception,actual,state,of,execution,this,state,does,not,match,expected,state,deploying,return,if,log,is,info,enabled,log,info,string,format,deploying,s,attempt,d,to,s,vertex,get,task,name,with,subtask,index,attempt,number,get,assigned,resource,location,get,hostname,final,task,deployment,descriptor,deployment,vertex,create,deployment,descriptor,attempt,id,slot,task,restore,attempt,number,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,completable,future,acknowledge,submit,result,future,task,manager,gateway,submit,task,deployment,rpc,timeout,submit,result,future,when,complete,async,ack,failure,if,failure,null,if,failure,instanceof,timeout,exception,string,taskname,vertex,get,task,name,with,subtask,index,attempt,id,mark,failed,new,exception,cannot,deploy,task,taskname,task,manager,get,assigned,resource,location,not,responding,after,a,rpc,timeout,of,rpc,timeout,failure,else,mark,failed,failure,executor,catch,throwable,t,mark,failed,t,exception,utils,rethrow,t
Execution -> public void deploy() throws JobException;1530712207;Deploys the execution to the previously assigned resource.__@throws JobException if the execution cannot be deployed to the assigned resource;public void deploy() throws JobException {_		final LogicalSlot slot  = assignedResource___		checkNotNull(slot, "In order to deploy the execution we first have to assign a resource via tryAssignResource.")___		_		_		_		if (!slot.isAlive()) {_			throw new JobException("Target slot (TaskManager) for deployment is no longer alive.")__		}__		_		_		ExecutionState previous = this.state__		if (previous == SCHEDULED || previous == CREATED) {_			if (!transitionState(previous, DEPLOYING)) {_				_				_				throw new IllegalStateException("Cannot deploy task: Concurrent deployment call race.")__			}_		}_		else {_			_			throw new IllegalStateException("The vertex must be in CREATED or SCHEDULED state to be deployed. Found state " + previous)__		}__		if (this != slot.getPayload()) {_			throw new IllegalStateException(_				String.format("The execution %s has not been assigned to the assigned slot.", this))__		}__		try {__			_			if (this.state != DEPLOYING) {_				slot.releaseSlot(new FlinkException("Actual state of execution " + this + " (" + state + ") does not match expected state DEPLOYING."))__				return__			}__			if (LOG.isInfoEnabled()) {_				LOG.info(String.format("Deploying %s (attempt #%d) to %s", vertex.getTaskNameWithSubtaskIndex(),_						attemptNumber, getAssignedResourceLocation().getHostname()))__			}__			final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(_				attemptId,_				slot,_				taskRestore,_				attemptNumber)___			_			taskRestore = null___			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			final CompletableFuture<Acknowledge> submitResultFuture = taskManagerGateway.submitTask(deployment, rpcTimeout)___			submitResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						if (failure instanceof TimeoutException) {_							String taskname = vertex.getTaskNameWithSubtaskIndex() + " (" + attemptId + ')'___							markFailed(new Exception(_								"Cannot deploy task " + taskname + " - TaskManager (" + getAssignedResourceLocation()_									+ ") not responding after a rpcTimeout of " + rpcTimeout, failure))__						} else {_							markFailed(failure)__						}_					}_				},_				executor)__		}_		catch (Throwable t) {_			markFailed(t)__			ExceptionUtils.rethrow(t)__		}_	};deploys,the,execution,to,the,previously,assigned,resource,throws,job,exception,if,the,execution,cannot,be,deployed,to,the,assigned,resource;public,void,deploy,throws,job,exception,final,logical,slot,slot,assigned,resource,check,not,null,slot,in,order,to,deploy,the,execution,we,first,have,to,assign,a,resource,via,try,assign,resource,if,slot,is,alive,throw,new,job,exception,target,slot,task,manager,for,deployment,is,no,longer,alive,execution,state,previous,this,state,if,previous,scheduled,previous,created,if,transition,state,previous,deploying,throw,new,illegal,state,exception,cannot,deploy,task,concurrent,deployment,call,race,else,throw,new,illegal,state,exception,the,vertex,must,be,in,created,or,scheduled,state,to,be,deployed,found,state,previous,if,this,slot,get,payload,throw,new,illegal,state,exception,string,format,the,execution,s,has,not,been,assigned,to,the,assigned,slot,this,try,if,this,state,deploying,slot,release,slot,new,flink,exception,actual,state,of,execution,this,state,does,not,match,expected,state,deploying,return,if,log,is,info,enabled,log,info,string,format,deploying,s,attempt,d,to,s,vertex,get,task,name,with,subtask,index,attempt,number,get,assigned,resource,location,get,hostname,final,task,deployment,descriptor,deployment,vertex,create,deployment,descriptor,attempt,id,slot,task,restore,attempt,number,task,restore,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,completable,future,acknowledge,submit,result,future,task,manager,gateway,submit,task,deployment,rpc,timeout,submit,result,future,when,complete,async,ack,failure,if,failure,null,if,failure,instanceof,timeout,exception,string,taskname,vertex,get,task,name,with,subtask,index,attempt,id,mark,failed,new,exception,cannot,deploy,task,taskname,task,manager,get,assigned,resource,location,not,responding,after,a,rpc,timeout,of,rpc,timeout,failure,else,mark,failed,failure,executor,catch,throwable,t,mark,failed,t,exception,utils,rethrow,t
Execution -> public void deploy() throws JobException;1532383539;Deploys the execution to the previously assigned resource.__@throws JobException if the execution cannot be deployed to the assigned resource;public void deploy() throws JobException {_		final LogicalSlot slot  = assignedResource___		checkNotNull(slot, "In order to deploy the execution we first have to assign a resource via tryAssignResource.")___		_		_		_		if (!slot.isAlive()) {_			throw new JobException("Target slot (TaskManager) for deployment is no longer alive.")__		}__		_		_		ExecutionState previous = this.state__		if (previous == SCHEDULED || previous == CREATED) {_			if (!transitionState(previous, DEPLOYING)) {_				_				_				throw new IllegalStateException("Cannot deploy task: Concurrent deployment call race.")__			}_		}_		else {_			_			throw new IllegalStateException("The vertex must be in CREATED or SCHEDULED state to be deployed. Found state " + previous)__		}__		if (this != slot.getPayload()) {_			throw new IllegalStateException(_				String.format("The execution %s has not been assigned to the assigned slot.", this))__		}__		try {__			_			if (this.state != DEPLOYING) {_				slot.releaseSlot(new FlinkException("Actual state of execution " + this + " (" + state + ") does not match expected state DEPLOYING."))__				return__			}__			if (LOG.isInfoEnabled()) {_				LOG.info(String.format("Deploying %s (attempt #%d) to %s", vertex.getTaskNameWithSubtaskIndex(),_						attemptNumber, getAssignedResourceLocation().getHostname()))__			}__			final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(_				attemptId,_				slot,_				taskRestore,_				attemptNumber)___			_			taskRestore = null___			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			final CompletableFuture<Acknowledge> submitResultFuture = taskManagerGateway.submitTask(deployment, rpcTimeout)___			submitResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						if (failure instanceof TimeoutException) {_							String taskname = vertex.getTaskNameWithSubtaskIndex() + " (" + attemptId + ')'___							markFailed(new Exception(_								"Cannot deploy task " + taskname + " - TaskManager (" + getAssignedResourceLocation()_									+ ") not responding after a rpcTimeout of " + rpcTimeout, failure))__						} else {_							markFailed(failure)__						}_					}_				},_				executor)__		}_		catch (Throwable t) {_			markFailed(t)__			ExceptionUtils.rethrow(t)__		}_	};deploys,the,execution,to,the,previously,assigned,resource,throws,job,exception,if,the,execution,cannot,be,deployed,to,the,assigned,resource;public,void,deploy,throws,job,exception,final,logical,slot,slot,assigned,resource,check,not,null,slot,in,order,to,deploy,the,execution,we,first,have,to,assign,a,resource,via,try,assign,resource,if,slot,is,alive,throw,new,job,exception,target,slot,task,manager,for,deployment,is,no,longer,alive,execution,state,previous,this,state,if,previous,scheduled,previous,created,if,transition,state,previous,deploying,throw,new,illegal,state,exception,cannot,deploy,task,concurrent,deployment,call,race,else,throw,new,illegal,state,exception,the,vertex,must,be,in,created,or,scheduled,state,to,be,deployed,found,state,previous,if,this,slot,get,payload,throw,new,illegal,state,exception,string,format,the,execution,s,has,not,been,assigned,to,the,assigned,slot,this,try,if,this,state,deploying,slot,release,slot,new,flink,exception,actual,state,of,execution,this,state,does,not,match,expected,state,deploying,return,if,log,is,info,enabled,log,info,string,format,deploying,s,attempt,d,to,s,vertex,get,task,name,with,subtask,index,attempt,number,get,assigned,resource,location,get,hostname,final,task,deployment,descriptor,deployment,vertex,create,deployment,descriptor,attempt,id,slot,task,restore,attempt,number,task,restore,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,completable,future,acknowledge,submit,result,future,task,manager,gateway,submit,task,deployment,rpc,timeout,submit,result,future,when,complete,async,ack,failure,if,failure,null,if,failure,instanceof,timeout,exception,string,taskname,vertex,get,task,name,with,subtask,index,attempt,id,mark,failed,new,exception,cannot,deploy,task,taskname,task,manager,get,assigned,resource,location,not,responding,after,a,rpc,timeout,of,rpc,timeout,failure,else,mark,failed,failure,executor,catch,throwable,t,mark,failed,t,exception,utils,rethrow,t
Execution -> public void deploy() throws JobException;1532383539;Deploys the execution to the previously assigned resource.__@throws JobException if the execution cannot be deployed to the assigned resource;public void deploy() throws JobException {_		final LogicalSlot slot  = assignedResource___		checkNotNull(slot, "In order to deploy the execution we first have to assign a resource via tryAssignResource.")___		_		_		_		if (!slot.isAlive()) {_			throw new JobException("Target slot (TaskManager) for deployment is no longer alive.")__		}__		_		_		ExecutionState previous = this.state__		if (previous == SCHEDULED || previous == CREATED) {_			if (!transitionState(previous, DEPLOYING)) {_				_				_				throw new IllegalStateException("Cannot deploy task: Concurrent deployment call race.")__			}_		}_		else {_			_			throw new IllegalStateException("The vertex must be in CREATED or SCHEDULED state to be deployed. Found state " + previous)__		}__		if (this != slot.getPayload()) {_			throw new IllegalStateException(_				String.format("The execution %s has not been assigned to the assigned slot.", this))__		}__		try {__			_			if (this.state != DEPLOYING) {_				slot.releaseSlot(new FlinkException("Actual state of execution " + this + " (" + state + ") does not match expected state DEPLOYING."))__				return__			}__			if (LOG.isInfoEnabled()) {_				LOG.info(String.format("Deploying %s (attempt #%d) to %s", vertex.getTaskNameWithSubtaskIndex(),_						attemptNumber, getAssignedResourceLocation().getHostname()))__			}__			final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(_				attemptId,_				slot,_				taskRestore,_				attemptNumber)___			_			taskRestore = null___			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			final CompletableFuture<Acknowledge> submitResultFuture = taskManagerGateway.submitTask(deployment, rpcTimeout)___			submitResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						if (failure instanceof TimeoutException) {_							String taskname = vertex.getTaskNameWithSubtaskIndex() + " (" + attemptId + ')'___							markFailed(new Exception(_								"Cannot deploy task " + taskname + " - TaskManager (" + getAssignedResourceLocation()_									+ ") not responding after a rpcTimeout of " + rpcTimeout, failure))__						} else {_							markFailed(failure)__						}_					}_				},_				executor)__		}_		catch (Throwable t) {_			markFailed(t)__			ExceptionUtils.rethrow(t)__		}_	};deploys,the,execution,to,the,previously,assigned,resource,throws,job,exception,if,the,execution,cannot,be,deployed,to,the,assigned,resource;public,void,deploy,throws,job,exception,final,logical,slot,slot,assigned,resource,check,not,null,slot,in,order,to,deploy,the,execution,we,first,have,to,assign,a,resource,via,try,assign,resource,if,slot,is,alive,throw,new,job,exception,target,slot,task,manager,for,deployment,is,no,longer,alive,execution,state,previous,this,state,if,previous,scheduled,previous,created,if,transition,state,previous,deploying,throw,new,illegal,state,exception,cannot,deploy,task,concurrent,deployment,call,race,else,throw,new,illegal,state,exception,the,vertex,must,be,in,created,or,scheduled,state,to,be,deployed,found,state,previous,if,this,slot,get,payload,throw,new,illegal,state,exception,string,format,the,execution,s,has,not,been,assigned,to,the,assigned,slot,this,try,if,this,state,deploying,slot,release,slot,new,flink,exception,actual,state,of,execution,this,state,does,not,match,expected,state,deploying,return,if,log,is,info,enabled,log,info,string,format,deploying,s,attempt,d,to,s,vertex,get,task,name,with,subtask,index,attempt,number,get,assigned,resource,location,get,hostname,final,task,deployment,descriptor,deployment,vertex,create,deployment,descriptor,attempt,id,slot,task,restore,attempt,number,task,restore,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,completable,future,acknowledge,submit,result,future,task,manager,gateway,submit,task,deployment,rpc,timeout,submit,result,future,when,complete,async,ack,failure,if,failure,null,if,failure,instanceof,timeout,exception,string,taskname,vertex,get,task,name,with,subtask,index,attempt,id,mark,failed,new,exception,cannot,deploy,task,taskname,task,manager,get,assigned,resource,location,not,responding,after,a,rpc,timeout,of,rpc,timeout,failure,else,mark,failed,failure,executor,catch,throwable,t,mark,failed,t,exception,utils,rethrow,t
Execution -> public void deploy() throws JobException;1532383539;Deploys the execution to the previously assigned resource.__@throws JobException if the execution cannot be deployed to the assigned resource;public void deploy() throws JobException {_		final LogicalSlot slot  = assignedResource___		checkNotNull(slot, "In order to deploy the execution we first have to assign a resource via tryAssignResource.")___		_		_		_		if (!slot.isAlive()) {_			throw new JobException("Target slot (TaskManager) for deployment is no longer alive.")__		}__		_		_		ExecutionState previous = this.state__		if (previous == SCHEDULED || previous == CREATED) {_			if (!transitionState(previous, DEPLOYING)) {_				_				_				throw new IllegalStateException("Cannot deploy task: Concurrent deployment call race.")__			}_		}_		else {_			_			throw new IllegalStateException("The vertex must be in CREATED or SCHEDULED state to be deployed. Found state " + previous)__		}__		if (this != slot.getPayload()) {_			throw new IllegalStateException(_				String.format("The execution %s has not been assigned to the assigned slot.", this))__		}__		try {__			_			if (this.state != DEPLOYING) {_				slot.releaseSlot(new FlinkException("Actual state of execution " + this + " (" + state + ") does not match expected state DEPLOYING."))__				return__			}__			if (LOG.isInfoEnabled()) {_				LOG.info(String.format("Deploying %s (attempt #%d) to %s", vertex.getTaskNameWithSubtaskIndex(),_						attemptNumber, getAssignedResourceLocation().getHostname()))__			}__			final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(_				attemptId,_				slot,_				taskRestore,_				attemptNumber)___			_			taskRestore = null___			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			final CompletableFuture<Acknowledge> submitResultFuture = taskManagerGateway.submitTask(deployment, rpcTimeout)___			submitResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						if (failure instanceof TimeoutException) {_							String taskname = vertex.getTaskNameWithSubtaskIndex() + " (" + attemptId + ')'___							markFailed(new Exception(_								"Cannot deploy task " + taskname + " - TaskManager (" + getAssignedResourceLocation()_									+ ") not responding after a rpcTimeout of " + rpcTimeout, failure))__						} else {_							markFailed(failure)__						}_					}_				},_				executor)__		}_		catch (Throwable t) {_			markFailed(t)__			ExceptionUtils.rethrow(t)__		}_	};deploys,the,execution,to,the,previously,assigned,resource,throws,job,exception,if,the,execution,cannot,be,deployed,to,the,assigned,resource;public,void,deploy,throws,job,exception,final,logical,slot,slot,assigned,resource,check,not,null,slot,in,order,to,deploy,the,execution,we,first,have,to,assign,a,resource,via,try,assign,resource,if,slot,is,alive,throw,new,job,exception,target,slot,task,manager,for,deployment,is,no,longer,alive,execution,state,previous,this,state,if,previous,scheduled,previous,created,if,transition,state,previous,deploying,throw,new,illegal,state,exception,cannot,deploy,task,concurrent,deployment,call,race,else,throw,new,illegal,state,exception,the,vertex,must,be,in,created,or,scheduled,state,to,be,deployed,found,state,previous,if,this,slot,get,payload,throw,new,illegal,state,exception,string,format,the,execution,s,has,not,been,assigned,to,the,assigned,slot,this,try,if,this,state,deploying,slot,release,slot,new,flink,exception,actual,state,of,execution,this,state,does,not,match,expected,state,deploying,return,if,log,is,info,enabled,log,info,string,format,deploying,s,attempt,d,to,s,vertex,get,task,name,with,subtask,index,attempt,number,get,assigned,resource,location,get,hostname,final,task,deployment,descriptor,deployment,vertex,create,deployment,descriptor,attempt,id,slot,task,restore,attempt,number,task,restore,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,completable,future,acknowledge,submit,result,future,task,manager,gateway,submit,task,deployment,rpc,timeout,submit,result,future,when,complete,async,ack,failure,if,failure,null,if,failure,instanceof,timeout,exception,string,taskname,vertex,get,task,name,with,subtask,index,attempt,id,mark,failed,new,exception,cannot,deploy,task,taskname,task,manager,get,assigned,resource,location,not,responding,after,a,rpc,timeout,of,rpc,timeout,failure,else,mark,failed,failure,executor,catch,throwable,t,mark,failed,t,exception,utils,rethrow,t
Execution -> public void deploy() throws JobException;1540920690;Deploys the execution to the previously assigned resource.__@throws JobException if the execution cannot be deployed to the assigned resource;public void deploy() throws JobException {_		final LogicalSlot slot  = assignedResource___		checkNotNull(slot, "In order to deploy the execution we first have to assign a resource via tryAssignResource.")___		_		_		_		if (!slot.isAlive()) {_			throw new JobException("Target slot (TaskManager) for deployment is no longer alive.")__		}__		_		_		ExecutionState previous = this.state__		if (previous == SCHEDULED || previous == CREATED) {_			if (!transitionState(previous, DEPLOYING)) {_				_				_				throw new IllegalStateException("Cannot deploy task: Concurrent deployment call race.")__			}_		}_		else {_			_			throw new IllegalStateException("The vertex must be in CREATED or SCHEDULED state to be deployed. Found state " + previous)__		}__		if (this != slot.getPayload()) {_			throw new IllegalStateException(_				String.format("The execution %s has not been assigned to the assigned slot.", this))__		}__		try {__			_			if (this.state != DEPLOYING) {_				slot.releaseSlot(new FlinkException("Actual state of execution " + this + " (" + state + ") does not match expected state DEPLOYING."))__				return__			}__			if (LOG.isInfoEnabled()) {_				LOG.info(String.format("Deploying %s (attempt #%d) to %s", vertex.getTaskNameWithSubtaskIndex(),_						attemptNumber, getAssignedResourceLocation().getHostname()))__			}__			final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(_				attemptId,_				slot,_				taskRestore,_				attemptNumber)___			_			taskRestore = null___			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			final CompletableFuture<Acknowledge> submitResultFuture = taskManagerGateway.submitTask(deployment, rpcTimeout)___			submitResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						if (failure instanceof TimeoutException) {_							String taskname = vertex.getTaskNameWithSubtaskIndex() + " (" + attemptId + ')'___							markFailed(new Exception(_								"Cannot deploy task " + taskname + " - TaskManager (" + getAssignedResourceLocation()_									+ ") not responding after a rpcTimeout of " + rpcTimeout, failure))__						} else {_							markFailed(failure)__						}_					}_				},_				executor)__		}_		catch (Throwable t) {_			markFailed(t)__			ExceptionUtils.rethrow(t)__		}_	};deploys,the,execution,to,the,previously,assigned,resource,throws,job,exception,if,the,execution,cannot,be,deployed,to,the,assigned,resource;public,void,deploy,throws,job,exception,final,logical,slot,slot,assigned,resource,check,not,null,slot,in,order,to,deploy,the,execution,we,first,have,to,assign,a,resource,via,try,assign,resource,if,slot,is,alive,throw,new,job,exception,target,slot,task,manager,for,deployment,is,no,longer,alive,execution,state,previous,this,state,if,previous,scheduled,previous,created,if,transition,state,previous,deploying,throw,new,illegal,state,exception,cannot,deploy,task,concurrent,deployment,call,race,else,throw,new,illegal,state,exception,the,vertex,must,be,in,created,or,scheduled,state,to,be,deployed,found,state,previous,if,this,slot,get,payload,throw,new,illegal,state,exception,string,format,the,execution,s,has,not,been,assigned,to,the,assigned,slot,this,try,if,this,state,deploying,slot,release,slot,new,flink,exception,actual,state,of,execution,this,state,does,not,match,expected,state,deploying,return,if,log,is,info,enabled,log,info,string,format,deploying,s,attempt,d,to,s,vertex,get,task,name,with,subtask,index,attempt,number,get,assigned,resource,location,get,hostname,final,task,deployment,descriptor,deployment,vertex,create,deployment,descriptor,attempt,id,slot,task,restore,attempt,number,task,restore,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,completable,future,acknowledge,submit,result,future,task,manager,gateway,submit,task,deployment,rpc,timeout,submit,result,future,when,complete,async,ack,failure,if,failure,null,if,failure,instanceof,timeout,exception,string,taskname,vertex,get,task,name,with,subtask,index,attempt,id,mark,failed,new,exception,cannot,deploy,task,taskname,task,manager,get,assigned,resource,location,not,responding,after,a,rpc,timeout,of,rpc,timeout,failure,else,mark,failed,failure,executor,catch,throwable,t,mark,failed,t,exception,utils,rethrow,t
Execution -> public void deploy() throws JobException;1542356428;Deploys the execution to the previously assigned resource.__@throws JobException if the execution cannot be deployed to the assigned resource;public void deploy() throws JobException {_		final LogicalSlot slot  = assignedResource___		checkNotNull(slot, "In order to deploy the execution we first have to assign a resource via tryAssignResource.")___		_		_		_		if (!slot.isAlive()) {_			throw new JobException("Target slot (TaskManager) for deployment is no longer alive.")__		}__		_		_		ExecutionState previous = this.state__		if (previous == SCHEDULED || previous == CREATED) {_			if (!transitionState(previous, DEPLOYING)) {_				_				_				throw new IllegalStateException("Cannot deploy task: Concurrent deployment call race.")__			}_		}_		else {_			_			throw new IllegalStateException("The vertex must be in CREATED or SCHEDULED state to be deployed. Found state " + previous)__		}__		if (this != slot.getPayload()) {_			throw new IllegalStateException(_				String.format("The execution %s has not been assigned to the assigned slot.", this))__		}__		try {__			_			if (this.state != DEPLOYING) {_				slot.releaseSlot(new FlinkException("Actual state of execution " + this + " (" + state + ") does not match expected state DEPLOYING."))__				return__			}__			if (LOG.isInfoEnabled()) {_				LOG.info(String.format("Deploying %s (attempt #%d) to %s", vertex.getTaskNameWithSubtaskIndex(),_						attemptNumber, getAssignedResourceLocation().getHostname()))__			}__			final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(_				attemptId,_				slot,_				taskRestore,_				attemptNumber)___			_			taskRestore = null___			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			final CompletableFuture<Acknowledge> submitResultFuture = taskManagerGateway.submitTask(deployment, rpcTimeout)___			submitResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						if (failure instanceof TimeoutException) {_							String taskname = vertex.getTaskNameWithSubtaskIndex() + " (" + attemptId + ')'___							markFailed(new Exception(_								"Cannot deploy task " + taskname + " - TaskManager (" + getAssignedResourceLocation()_									+ ") not responding after a rpcTimeout of " + rpcTimeout, failure))__						} else {_							markFailed(failure)__						}_					}_				},_				executor)__		}_		catch (Throwable t) {_			markFailed(t)__			ExceptionUtils.rethrow(t)__		}_	};deploys,the,execution,to,the,previously,assigned,resource,throws,job,exception,if,the,execution,cannot,be,deployed,to,the,assigned,resource;public,void,deploy,throws,job,exception,final,logical,slot,slot,assigned,resource,check,not,null,slot,in,order,to,deploy,the,execution,we,first,have,to,assign,a,resource,via,try,assign,resource,if,slot,is,alive,throw,new,job,exception,target,slot,task,manager,for,deployment,is,no,longer,alive,execution,state,previous,this,state,if,previous,scheduled,previous,created,if,transition,state,previous,deploying,throw,new,illegal,state,exception,cannot,deploy,task,concurrent,deployment,call,race,else,throw,new,illegal,state,exception,the,vertex,must,be,in,created,or,scheduled,state,to,be,deployed,found,state,previous,if,this,slot,get,payload,throw,new,illegal,state,exception,string,format,the,execution,s,has,not,been,assigned,to,the,assigned,slot,this,try,if,this,state,deploying,slot,release,slot,new,flink,exception,actual,state,of,execution,this,state,does,not,match,expected,state,deploying,return,if,log,is,info,enabled,log,info,string,format,deploying,s,attempt,d,to,s,vertex,get,task,name,with,subtask,index,attempt,number,get,assigned,resource,location,get,hostname,final,task,deployment,descriptor,deployment,vertex,create,deployment,descriptor,attempt,id,slot,task,restore,attempt,number,task,restore,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,completable,future,acknowledge,submit,result,future,task,manager,gateway,submit,task,deployment,rpc,timeout,submit,result,future,when,complete,async,ack,failure,if,failure,null,if,failure,instanceof,timeout,exception,string,taskname,vertex,get,task,name,with,subtask,index,attempt,id,mark,failed,new,exception,cannot,deploy,task,taskname,task,manager,get,assigned,resource,location,not,responding,after,a,rpc,timeout,of,rpc,timeout,failure,else,mark,failed,failure,executor,catch,throwable,t,mark,failed,t,exception,utils,rethrow,t
Execution -> public void deploy() throws JobException;1546870832;Deploys the execution to the previously assigned resource.__@throws JobException if the execution cannot be deployed to the assigned resource;public void deploy() throws JobException {_		final LogicalSlot slot  = assignedResource___		checkNotNull(slot, "In order to deploy the execution we first have to assign a resource via tryAssignResource.")___		_		_		_		if (!slot.isAlive()) {_			throw new JobException("Target slot (TaskManager) for deployment is no longer alive.")__		}__		_		_		ExecutionState previous = this.state__		if (previous == SCHEDULED || previous == CREATED) {_			if (!transitionState(previous, DEPLOYING)) {_				_				_				throw new IllegalStateException("Cannot deploy task: Concurrent deployment call race.")__			}_		}_		else {_			_			throw new IllegalStateException("The vertex must be in CREATED or SCHEDULED state to be deployed. Found state " + previous)__		}__		if (this != slot.getPayload()) {_			throw new IllegalStateException(_				String.format("The execution %s has not been assigned to the assigned slot.", this))__		}__		try {__			_			if (this.state != DEPLOYING) {_				slot.releaseSlot(new FlinkException("Actual state of execution " + this + " (" + state + ") does not match expected state DEPLOYING."))__				return__			}__			if (LOG.isInfoEnabled()) {_				LOG.info(String.format("Deploying %s (attempt #%d) to %s", vertex.getTaskNameWithSubtaskIndex(),_						attemptNumber, getAssignedResourceLocation()))__			}__			final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(_				attemptId,_				slot,_				taskRestore,_				attemptNumber)___			_			taskRestore = null___			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			final CompletableFuture<Acknowledge> submitResultFuture = taskManagerGateway.submitTask(deployment, rpcTimeout)___			submitResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						if (failure instanceof TimeoutException) {_							String taskname = vertex.getTaskNameWithSubtaskIndex() + " (" + attemptId + ')'___							markFailed(new Exception(_								"Cannot deploy task " + taskname + " - TaskManager (" + getAssignedResourceLocation()_									+ ") not responding after a rpcTimeout of " + rpcTimeout, failure))__						} else {_							markFailed(failure)__						}_					}_				},_				executor)__		}_		catch (Throwable t) {_			markFailed(t)__			ExceptionUtils.rethrow(t)__		}_	};deploys,the,execution,to,the,previously,assigned,resource,throws,job,exception,if,the,execution,cannot,be,deployed,to,the,assigned,resource;public,void,deploy,throws,job,exception,final,logical,slot,slot,assigned,resource,check,not,null,slot,in,order,to,deploy,the,execution,we,first,have,to,assign,a,resource,via,try,assign,resource,if,slot,is,alive,throw,new,job,exception,target,slot,task,manager,for,deployment,is,no,longer,alive,execution,state,previous,this,state,if,previous,scheduled,previous,created,if,transition,state,previous,deploying,throw,new,illegal,state,exception,cannot,deploy,task,concurrent,deployment,call,race,else,throw,new,illegal,state,exception,the,vertex,must,be,in,created,or,scheduled,state,to,be,deployed,found,state,previous,if,this,slot,get,payload,throw,new,illegal,state,exception,string,format,the,execution,s,has,not,been,assigned,to,the,assigned,slot,this,try,if,this,state,deploying,slot,release,slot,new,flink,exception,actual,state,of,execution,this,state,does,not,match,expected,state,deploying,return,if,log,is,info,enabled,log,info,string,format,deploying,s,attempt,d,to,s,vertex,get,task,name,with,subtask,index,attempt,number,get,assigned,resource,location,final,task,deployment,descriptor,deployment,vertex,create,deployment,descriptor,attempt,id,slot,task,restore,attempt,number,task,restore,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,completable,future,acknowledge,submit,result,future,task,manager,gateway,submit,task,deployment,rpc,timeout,submit,result,future,when,complete,async,ack,failure,if,failure,null,if,failure,instanceof,timeout,exception,string,taskname,vertex,get,task,name,with,subtask,index,attempt,id,mark,failed,new,exception,cannot,deploy,task,taskname,task,manager,get,assigned,resource,location,not,responding,after,a,rpc,timeout,of,rpc,timeout,failure,else,mark,failed,failure,executor,catch,throwable,t,mark,failed,t,exception,utils,rethrow,t
Execution -> public void deploy() throws JobException;1547644408;Deploys the execution to the previously assigned resource.__@throws JobException if the execution cannot be deployed to the assigned resource;public void deploy() throws JobException {_		final LogicalSlot slot  = assignedResource___		checkNotNull(slot, "In order to deploy the execution we first have to assign a resource via tryAssignResource.")___		_		_		_		if (!slot.isAlive()) {_			throw new JobException("Target slot (TaskManager) for deployment is no longer alive.")__		}__		_		_		ExecutionState previous = this.state__		if (previous == SCHEDULED || previous == CREATED) {_			if (!transitionState(previous, DEPLOYING)) {_				_				_				throw new IllegalStateException("Cannot deploy task: Concurrent deployment call race.")__			}_		}_		else {_			_			throw new IllegalStateException("The vertex must be in CREATED or SCHEDULED state to be deployed. Found state " + previous)__		}__		if (this != slot.getPayload()) {_			throw new IllegalStateException(_				String.format("The execution %s has not been assigned to the assigned slot.", this))__		}__		try {__			_			if (this.state != DEPLOYING) {_				slot.releaseSlot(new FlinkException("Actual state of execution " + this + " (" + state + ") does not match expected state DEPLOYING."))__				return__			}__			if (LOG.isInfoEnabled()) {_				LOG.info(String.format("Deploying %s (attempt #%d) to %s", vertex.getTaskNameWithSubtaskIndex(),_						attemptNumber, getAssignedResourceLocation()))__			}__			final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(_				attemptId,_				slot,_				taskRestore,_				attemptNumber)___			_			taskRestore = null___			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			final CompletableFuture<Acknowledge> submitResultFuture = taskManagerGateway.submitTask(deployment, rpcTimeout)___			submitResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						if (failure instanceof TimeoutException) {_							String taskname = vertex.getTaskNameWithSubtaskIndex() + " (" + attemptId + ')'___							markFailed(new Exception(_								"Cannot deploy task " + taskname + " - TaskManager (" + getAssignedResourceLocation()_									+ ") not responding after a rpcTimeout of " + rpcTimeout, failure))__						} else {_							markFailed(failure)__						}_					}_				},_				executor)__		}_		catch (Throwable t) {_			markFailed(t)__			ExceptionUtils.rethrow(t)__		}_	};deploys,the,execution,to,the,previously,assigned,resource,throws,job,exception,if,the,execution,cannot,be,deployed,to,the,assigned,resource;public,void,deploy,throws,job,exception,final,logical,slot,slot,assigned,resource,check,not,null,slot,in,order,to,deploy,the,execution,we,first,have,to,assign,a,resource,via,try,assign,resource,if,slot,is,alive,throw,new,job,exception,target,slot,task,manager,for,deployment,is,no,longer,alive,execution,state,previous,this,state,if,previous,scheduled,previous,created,if,transition,state,previous,deploying,throw,new,illegal,state,exception,cannot,deploy,task,concurrent,deployment,call,race,else,throw,new,illegal,state,exception,the,vertex,must,be,in,created,or,scheduled,state,to,be,deployed,found,state,previous,if,this,slot,get,payload,throw,new,illegal,state,exception,string,format,the,execution,s,has,not,been,assigned,to,the,assigned,slot,this,try,if,this,state,deploying,slot,release,slot,new,flink,exception,actual,state,of,execution,this,state,does,not,match,expected,state,deploying,return,if,log,is,info,enabled,log,info,string,format,deploying,s,attempt,d,to,s,vertex,get,task,name,with,subtask,index,attempt,number,get,assigned,resource,location,final,task,deployment,descriptor,deployment,vertex,create,deployment,descriptor,attempt,id,slot,task,restore,attempt,number,task,restore,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,completable,future,acknowledge,submit,result,future,task,manager,gateway,submit,task,deployment,rpc,timeout,submit,result,future,when,complete,async,ack,failure,if,failure,null,if,failure,instanceof,timeout,exception,string,taskname,vertex,get,task,name,with,subtask,index,attempt,id,mark,failed,new,exception,cannot,deploy,task,taskname,task,manager,get,assigned,resource,location,not,responding,after,a,rpc,timeout,of,rpc,timeout,failure,else,mark,failed,failure,executor,catch,throwable,t,mark,failed,t,exception,utils,rethrow,t
Execution -> public void deploy() throws JobException;1549365080;Deploys the execution to the previously assigned resource.__@throws JobException if the execution cannot be deployed to the assigned resource;public void deploy() throws JobException {_		assertRunningInJobMasterMainThread()___		final LogicalSlot slot  = assignedResource___		checkNotNull(slot, "In order to deploy the execution we first have to assign a resource via tryAssignResource.")___		_		_		_		if (!slot.isAlive()) {_			throw new JobException("Target slot (TaskManager) for deployment is no longer alive.")__		}__		_		_		ExecutionState previous = this.state__		if (previous == SCHEDULED || previous == CREATED) {_			if (!transitionState(previous, DEPLOYING)) {_				_				_				throw new IllegalStateException("Cannot deploy task: Concurrent deployment call race.")__			}_		}_		else {_			_			throw new IllegalStateException("The vertex must be in CREATED or SCHEDULED state to be deployed. Found state " + previous)__		}__		if (this != slot.getPayload()) {_			throw new IllegalStateException(_				String.format("The execution %s has not been assigned to the assigned slot.", this))__		}__		try {__			_			if (this.state != DEPLOYING) {_				slot.releaseSlot(new FlinkException("Actual state of execution " + this + " (" + state + ") does not match expected state DEPLOYING."))__				return__			}__			if (LOG.isInfoEnabled()) {_				LOG.info(String.format("Deploying %s (attempt #%d) to %s", vertex.getTaskNameWithSubtaskIndex(),_						attemptNumber, getAssignedResourceLocation()))__			}__			final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(_				attemptId,_				slot,_				taskRestore,_				attemptNumber)___			_			taskRestore = null___			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			final CompletableFuture<Acknowledge> submitResultFuture = taskManagerGateway.submitTask(deployment, rpcTimeout)__			ComponentMainThreadExecutor jobMasterMainThreadExecutor =_				vertex.getExecutionGraph().getJobMasterMainThreadExecutor()___			FutureUtils.whenCompleteAsyncIfNotDone(_				submitResultFuture,_				jobMasterMainThreadExecutor,_				(ack, failure) -> {_					_					if (failure != null) {_						if (failure instanceof TimeoutException) {_							String taskname = vertex.getTaskNameWithSubtaskIndex() + " (" + attemptId + ')'___							markFailed(new Exception(_								"Cannot deploy task " + taskname + " - TaskManager (" + getAssignedResourceLocation()_									+ ") not responding after a rpcTimeout of " + rpcTimeout, failure))__						} else {_							markFailed(failure)__						}_					}_				})__		}_		catch (Throwable t) {_			markFailed(t)__			ExceptionUtils.rethrow(t)__		}_	};deploys,the,execution,to,the,previously,assigned,resource,throws,job,exception,if,the,execution,cannot,be,deployed,to,the,assigned,resource;public,void,deploy,throws,job,exception,assert,running,in,job,master,main,thread,final,logical,slot,slot,assigned,resource,check,not,null,slot,in,order,to,deploy,the,execution,we,first,have,to,assign,a,resource,via,try,assign,resource,if,slot,is,alive,throw,new,job,exception,target,slot,task,manager,for,deployment,is,no,longer,alive,execution,state,previous,this,state,if,previous,scheduled,previous,created,if,transition,state,previous,deploying,throw,new,illegal,state,exception,cannot,deploy,task,concurrent,deployment,call,race,else,throw,new,illegal,state,exception,the,vertex,must,be,in,created,or,scheduled,state,to,be,deployed,found,state,previous,if,this,slot,get,payload,throw,new,illegal,state,exception,string,format,the,execution,s,has,not,been,assigned,to,the,assigned,slot,this,try,if,this,state,deploying,slot,release,slot,new,flink,exception,actual,state,of,execution,this,state,does,not,match,expected,state,deploying,return,if,log,is,info,enabled,log,info,string,format,deploying,s,attempt,d,to,s,vertex,get,task,name,with,subtask,index,attempt,number,get,assigned,resource,location,final,task,deployment,descriptor,deployment,vertex,create,deployment,descriptor,attempt,id,slot,task,restore,attempt,number,task,restore,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,completable,future,acknowledge,submit,result,future,task,manager,gateway,submit,task,deployment,rpc,timeout,component,main,thread,executor,job,master,main,thread,executor,vertex,get,execution,graph,get,job,master,main,thread,executor,future,utils,when,complete,async,if,not,done,submit,result,future,job,master,main,thread,executor,ack,failure,if,failure,null,if,failure,instanceof,timeout,exception,string,taskname,vertex,get,task,name,with,subtask,index,attempt,id,mark,failed,new,exception,cannot,deploy,task,taskname,task,manager,get,assigned,resource,location,not,responding,after,a,rpc,timeout,of,rpc,timeout,failure,else,mark,failed,failure,catch,throwable,t,mark,failed,t,exception,utils,rethrow,t
Execution -> public void deploy() throws JobException;1550220073;Deploys the execution to the previously assigned resource.__@throws JobException if the execution cannot be deployed to the assigned resource;public void deploy() throws JobException {_		assertRunningInJobMasterMainThread()___		final LogicalSlot slot  = assignedResource___		checkNotNull(slot, "In order to deploy the execution we first have to assign a resource via tryAssignResource.")___		_		_		_		if (!slot.isAlive()) {_			throw new JobException("Target slot (TaskManager) for deployment is no longer alive.")__		}__		_		_		ExecutionState previous = this.state__		if (previous == SCHEDULED || previous == CREATED) {_			if (!transitionState(previous, DEPLOYING)) {_				_				_				throw new IllegalStateException("Cannot deploy task: Concurrent deployment call race.")__			}_		}_		else {_			_			throw new IllegalStateException("The vertex must be in CREATED or SCHEDULED state to be deployed. Found state " + previous)__		}__		if (this != slot.getPayload()) {_			throw new IllegalStateException(_				String.format("The execution %s has not been assigned to the assigned slot.", this))__		}__		try {__			_			if (this.state != DEPLOYING) {_				slot.releaseSlot(new FlinkException("Actual state of execution " + this + " (" + state + ") does not match expected state DEPLOYING."))__				return__			}__			if (LOG.isInfoEnabled()) {_				LOG.info(String.format("Deploying %s (attempt #%d) to %s", vertex.getTaskNameWithSubtaskIndex(),_						attemptNumber, getAssignedResourceLocation()))__			}__			final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(_				attemptId,_				slot,_				taskRestore,_				attemptNumber)___			_			taskRestore = null___			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			final CompletableFuture<Acknowledge> submitResultFuture = taskManagerGateway.submitTask(deployment, rpcTimeout)__			ComponentMainThreadExecutor jobMasterMainThreadExecutor =_				vertex.getExecutionGraph().getJobMasterMainThreadExecutor()___			FutureUtils.whenCompleteAsyncIfNotDone(_				submitResultFuture,_				jobMasterMainThreadExecutor,_				(ack, failure) -> {_					_					if (failure != null) {_						if (failure instanceof TimeoutException) {_							String taskname = vertex.getTaskNameWithSubtaskIndex() + " (" + attemptId + ')'___							markFailed(new Exception(_								"Cannot deploy task " + taskname + " - TaskManager (" + getAssignedResourceLocation()_									+ ") not responding after a rpcTimeout of " + rpcTimeout, failure))__						} else {_							markFailed(failure)__						}_					}_				})__		}_		catch (Throwable t) {_			markFailed(t)__			ExceptionUtils.rethrow(t)__		}_	};deploys,the,execution,to,the,previously,assigned,resource,throws,job,exception,if,the,execution,cannot,be,deployed,to,the,assigned,resource;public,void,deploy,throws,job,exception,assert,running,in,job,master,main,thread,final,logical,slot,slot,assigned,resource,check,not,null,slot,in,order,to,deploy,the,execution,we,first,have,to,assign,a,resource,via,try,assign,resource,if,slot,is,alive,throw,new,job,exception,target,slot,task,manager,for,deployment,is,no,longer,alive,execution,state,previous,this,state,if,previous,scheduled,previous,created,if,transition,state,previous,deploying,throw,new,illegal,state,exception,cannot,deploy,task,concurrent,deployment,call,race,else,throw,new,illegal,state,exception,the,vertex,must,be,in,created,or,scheduled,state,to,be,deployed,found,state,previous,if,this,slot,get,payload,throw,new,illegal,state,exception,string,format,the,execution,s,has,not,been,assigned,to,the,assigned,slot,this,try,if,this,state,deploying,slot,release,slot,new,flink,exception,actual,state,of,execution,this,state,does,not,match,expected,state,deploying,return,if,log,is,info,enabled,log,info,string,format,deploying,s,attempt,d,to,s,vertex,get,task,name,with,subtask,index,attempt,number,get,assigned,resource,location,final,task,deployment,descriptor,deployment,vertex,create,deployment,descriptor,attempt,id,slot,task,restore,attempt,number,task,restore,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,completable,future,acknowledge,submit,result,future,task,manager,gateway,submit,task,deployment,rpc,timeout,component,main,thread,executor,job,master,main,thread,executor,vertex,get,execution,graph,get,job,master,main,thread,executor,future,utils,when,complete,async,if,not,done,submit,result,future,job,master,main,thread,executor,ack,failure,if,failure,null,if,failure,instanceof,timeout,exception,string,taskname,vertex,get,task,name,with,subtask,index,attempt,id,mark,failed,new,exception,cannot,deploy,task,taskname,task,manager,get,assigned,resource,location,not,responding,after,a,rpc,timeout,of,rpc,timeout,failure,else,mark,failed,failure,catch,throwable,t,mark,failed,t,exception,utils,rethrow,t
Execution -> public void deploy() throws JobException;1550654143;Deploys the execution to the previously assigned resource.__@throws JobException if the execution cannot be deployed to the assigned resource;public void deploy() throws JobException {_		assertRunningInJobMasterMainThread()___		final LogicalSlot slot  = assignedResource___		checkNotNull(slot, "In order to deploy the execution we first have to assign a resource via tryAssignResource.")___		_		_		_		if (!slot.isAlive()) {_			throw new JobException("Target slot (TaskManager) for deployment is no longer alive.")__		}__		_		_		ExecutionState previous = this.state__		if (previous == SCHEDULED || previous == CREATED) {_			if (!transitionState(previous, DEPLOYING)) {_				_				_				throw new IllegalStateException("Cannot deploy task: Concurrent deployment call race.")__			}_		}_		else {_			_			throw new IllegalStateException("The vertex must be in CREATED or SCHEDULED state to be deployed. Found state " + previous)__		}__		if (this != slot.getPayload()) {_			throw new IllegalStateException(_				String.format("The execution %s has not been assigned to the assigned slot.", this))__		}__		try {__			_			if (this.state != DEPLOYING) {_				slot.releaseSlot(new FlinkException("Actual state of execution " + this + " (" + state + ") does not match expected state DEPLOYING."))__				return__			}__			if (LOG.isInfoEnabled()) {_				LOG.info(String.format("Deploying %s (attempt #%d) to %s", vertex.getTaskNameWithSubtaskIndex(),_						attemptNumber, getAssignedResourceLocation()))__			}__			final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(_				attemptId,_				slot,_				taskRestore,_				attemptNumber)___			_			taskRestore = null___			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			final CompletableFuture<Acknowledge> submitResultFuture = taskManagerGateway.submitTask(deployment, rpcTimeout)__			ComponentMainThreadExecutor jobMasterMainThreadExecutor =_				vertex.getExecutionGraph().getJobMasterMainThreadExecutor()___			FutureUtils.whenCompleteAsyncIfNotDone(_				submitResultFuture,_				jobMasterMainThreadExecutor,_				(ack, failure) -> {_					_					if (failure != null) {_						if (failure instanceof TimeoutException) {_							String taskname = vertex.getTaskNameWithSubtaskIndex() + " (" + attemptId + ')'___							markFailed(new Exception(_								"Cannot deploy task " + taskname + " - TaskManager (" + getAssignedResourceLocation()_									+ ") not responding after a rpcTimeout of " + rpcTimeout, failure))__						} else {_							markFailed(failure)__						}_					}_				})__		}_		catch (Throwable t) {_			markFailed(t)__			ExceptionUtils.rethrow(t)__		}_	};deploys,the,execution,to,the,previously,assigned,resource,throws,job,exception,if,the,execution,cannot,be,deployed,to,the,assigned,resource;public,void,deploy,throws,job,exception,assert,running,in,job,master,main,thread,final,logical,slot,slot,assigned,resource,check,not,null,slot,in,order,to,deploy,the,execution,we,first,have,to,assign,a,resource,via,try,assign,resource,if,slot,is,alive,throw,new,job,exception,target,slot,task,manager,for,deployment,is,no,longer,alive,execution,state,previous,this,state,if,previous,scheduled,previous,created,if,transition,state,previous,deploying,throw,new,illegal,state,exception,cannot,deploy,task,concurrent,deployment,call,race,else,throw,new,illegal,state,exception,the,vertex,must,be,in,created,or,scheduled,state,to,be,deployed,found,state,previous,if,this,slot,get,payload,throw,new,illegal,state,exception,string,format,the,execution,s,has,not,been,assigned,to,the,assigned,slot,this,try,if,this,state,deploying,slot,release,slot,new,flink,exception,actual,state,of,execution,this,state,does,not,match,expected,state,deploying,return,if,log,is,info,enabled,log,info,string,format,deploying,s,attempt,d,to,s,vertex,get,task,name,with,subtask,index,attempt,number,get,assigned,resource,location,final,task,deployment,descriptor,deployment,vertex,create,deployment,descriptor,attempt,id,slot,task,restore,attempt,number,task,restore,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,completable,future,acknowledge,submit,result,future,task,manager,gateway,submit,task,deployment,rpc,timeout,component,main,thread,executor,job,master,main,thread,executor,vertex,get,execution,graph,get,job,master,main,thread,executor,future,utils,when,complete,async,if,not,done,submit,result,future,job,master,main,thread,executor,ack,failure,if,failure,null,if,failure,instanceof,timeout,exception,string,taskname,vertex,get,task,name,with,subtask,index,attempt,id,mark,failed,new,exception,cannot,deploy,task,taskname,task,manager,get,assigned,resource,location,not,responding,after,a,rpc,timeout,of,rpc,timeout,failure,else,mark,failed,failure,catch,throwable,t,mark,failed,t,exception,utils,rethrow,t
Execution -> public void deploy() throws JobException;1550683188;Deploys the execution to the previously assigned resource.__@throws JobException if the execution cannot be deployed to the assigned resource;public void deploy() throws JobException {_		assertRunningInJobMasterMainThread()___		final LogicalSlot slot  = assignedResource___		checkNotNull(slot, "In order to deploy the execution we first have to assign a resource via tryAssignResource.")___		_		_		_		if (!slot.isAlive()) {_			throw new JobException("Target slot (TaskManager) for deployment is no longer alive.")__		}__		_		_		ExecutionState previous = this.state__		if (previous == SCHEDULED || previous == CREATED) {_			if (!transitionState(previous, DEPLOYING)) {_				_				_				throw new IllegalStateException("Cannot deploy task: Concurrent deployment call race.")__			}_		}_		else {_			_			throw new IllegalStateException("The vertex must be in CREATED or SCHEDULED state to be deployed. Found state " + previous)__		}__		if (this != slot.getPayload()) {_			throw new IllegalStateException(_				String.format("The execution %s has not been assigned to the assigned slot.", this))__		}__		try {__			_			if (this.state != DEPLOYING) {_				slot.releaseSlot(new FlinkException("Actual state of execution " + this + " (" + state + ") does not match expected state DEPLOYING."))__				return__			}__			if (LOG.isInfoEnabled()) {_				LOG.info(String.format("Deploying %s (attempt #%d) to %s", vertex.getTaskNameWithSubtaskIndex(),_						attemptNumber, getAssignedResourceLocation()))__			}__			final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(_				attemptId,_				slot,_				taskRestore,_				attemptNumber)___			_			taskRestore = null___			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			final CompletableFuture<Acknowledge> submitResultFuture = taskManagerGateway.submitTask(deployment, rpcTimeout)__			ComponentMainThreadExecutor jobMasterMainThreadExecutor =_				vertex.getExecutionGraph().getJobMasterMainThreadExecutor()___			FutureUtils.whenCompleteAsyncIfNotDone(_				submitResultFuture,_				jobMasterMainThreadExecutor,_				(ack, failure) -> {_					_					if (failure != null) {_						if (failure instanceof TimeoutException) {_							String taskname = vertex.getTaskNameWithSubtaskIndex() + " (" + attemptId + ')'___							markFailed(new Exception(_								"Cannot deploy task " + taskname + " - TaskManager (" + getAssignedResourceLocation()_									+ ") not responding after a rpcTimeout of " + rpcTimeout, failure))__						} else {_							markFailed(failure)__						}_					}_				})__		}_		catch (Throwable t) {_			markFailed(t)__			ExceptionUtils.rethrow(t)__		}_	};deploys,the,execution,to,the,previously,assigned,resource,throws,job,exception,if,the,execution,cannot,be,deployed,to,the,assigned,resource;public,void,deploy,throws,job,exception,assert,running,in,job,master,main,thread,final,logical,slot,slot,assigned,resource,check,not,null,slot,in,order,to,deploy,the,execution,we,first,have,to,assign,a,resource,via,try,assign,resource,if,slot,is,alive,throw,new,job,exception,target,slot,task,manager,for,deployment,is,no,longer,alive,execution,state,previous,this,state,if,previous,scheduled,previous,created,if,transition,state,previous,deploying,throw,new,illegal,state,exception,cannot,deploy,task,concurrent,deployment,call,race,else,throw,new,illegal,state,exception,the,vertex,must,be,in,created,or,scheduled,state,to,be,deployed,found,state,previous,if,this,slot,get,payload,throw,new,illegal,state,exception,string,format,the,execution,s,has,not,been,assigned,to,the,assigned,slot,this,try,if,this,state,deploying,slot,release,slot,new,flink,exception,actual,state,of,execution,this,state,does,not,match,expected,state,deploying,return,if,log,is,info,enabled,log,info,string,format,deploying,s,attempt,d,to,s,vertex,get,task,name,with,subtask,index,attempt,number,get,assigned,resource,location,final,task,deployment,descriptor,deployment,vertex,create,deployment,descriptor,attempt,id,slot,task,restore,attempt,number,task,restore,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,completable,future,acknowledge,submit,result,future,task,manager,gateway,submit,task,deployment,rpc,timeout,component,main,thread,executor,job,master,main,thread,executor,vertex,get,execution,graph,get,job,master,main,thread,executor,future,utils,when,complete,async,if,not,done,submit,result,future,job,master,main,thread,executor,ack,failure,if,failure,null,if,failure,instanceof,timeout,exception,string,taskname,vertex,get,task,name,with,subtask,index,attempt,id,mark,failed,new,exception,cannot,deploy,task,taskname,task,manager,get,assigned,resource,location,not,responding,after,a,rpc,timeout,of,rpc,timeout,failure,else,mark,failed,failure,catch,throwable,t,mark,failed,t,exception,utils,rethrow,t
Execution -> public void deploy() throws JobException;1550855836;Deploys the execution to the previously assigned resource.__@throws JobException if the execution cannot be deployed to the assigned resource;public void deploy() throws JobException {_		assertRunningInJobMasterMainThread()___		final LogicalSlot slot  = assignedResource___		checkNotNull(slot, "In order to deploy the execution we first have to assign a resource via tryAssignResource.")___		_		_		_		if (!slot.isAlive()) {_			throw new JobException("Target slot (TaskManager) for deployment is no longer alive.")__		}__		_		_		ExecutionState previous = this.state__		if (previous == SCHEDULED || previous == CREATED) {_			if (!transitionState(previous, DEPLOYING)) {_				_				_				throw new IllegalStateException("Cannot deploy task: Concurrent deployment call race.")__			}_		}_		else {_			_			throw new IllegalStateException("The vertex must be in CREATED or SCHEDULED state to be deployed. Found state " + previous)__		}__		if (this != slot.getPayload()) {_			throw new IllegalStateException(_				String.format("The execution %s has not been assigned to the assigned slot.", this))__		}__		try {__			_			if (this.state != DEPLOYING) {_				slot.releaseSlot(new FlinkException("Actual state of execution " + this + " (" + state + ") does not match expected state DEPLOYING."))__				return__			}__			if (LOG.isInfoEnabled()) {_				LOG.info(String.format("Deploying %s (attempt #%d) to %s", vertex.getTaskNameWithSubtaskIndex(),_						attemptNumber, getAssignedResourceLocation()))__			}__			final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(_				attemptId,_				slot,_				taskRestore,_				attemptNumber)___			_			taskRestore = null___			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			final ComponentMainThreadExecutor jobMasterMainThreadExecutor =_				vertex.getExecutionGraph().getJobMasterMainThreadExecutor()____			_			_			CompletableFuture.supplyAsync(() -> taskManagerGateway.submitTask(deployment, rpcTimeout), executor)_				.thenCompose(Function.identity())_				.whenCompleteAsync(_					(ack, failure) -> {_						_						if (failure != null) {_							if (failure instanceof TimeoutException) {_								String taskname = vertex.getTaskNameWithSubtaskIndex() + " (" + attemptId + ')'___								markFailed(new Exception(_									"Cannot deploy task " + taskname + " - TaskManager (" + getAssignedResourceLocation()_										+ ") not responding after a rpcTimeout of " + rpcTimeout, failure))__							} else {_								markFailed(failure)__							}_						}_					},_					jobMasterMainThreadExecutor)___		}_		catch (Throwable t) {_			markFailed(t)__			ExceptionUtils.rethrow(t)__		}_	};deploys,the,execution,to,the,previously,assigned,resource,throws,job,exception,if,the,execution,cannot,be,deployed,to,the,assigned,resource;public,void,deploy,throws,job,exception,assert,running,in,job,master,main,thread,final,logical,slot,slot,assigned,resource,check,not,null,slot,in,order,to,deploy,the,execution,we,first,have,to,assign,a,resource,via,try,assign,resource,if,slot,is,alive,throw,new,job,exception,target,slot,task,manager,for,deployment,is,no,longer,alive,execution,state,previous,this,state,if,previous,scheduled,previous,created,if,transition,state,previous,deploying,throw,new,illegal,state,exception,cannot,deploy,task,concurrent,deployment,call,race,else,throw,new,illegal,state,exception,the,vertex,must,be,in,created,or,scheduled,state,to,be,deployed,found,state,previous,if,this,slot,get,payload,throw,new,illegal,state,exception,string,format,the,execution,s,has,not,been,assigned,to,the,assigned,slot,this,try,if,this,state,deploying,slot,release,slot,new,flink,exception,actual,state,of,execution,this,state,does,not,match,expected,state,deploying,return,if,log,is,info,enabled,log,info,string,format,deploying,s,attempt,d,to,s,vertex,get,task,name,with,subtask,index,attempt,number,get,assigned,resource,location,final,task,deployment,descriptor,deployment,vertex,create,deployment,descriptor,attempt,id,slot,task,restore,attempt,number,task,restore,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,component,main,thread,executor,job,master,main,thread,executor,vertex,get,execution,graph,get,job,master,main,thread,executor,completable,future,supply,async,task,manager,gateway,submit,task,deployment,rpc,timeout,executor,then,compose,function,identity,when,complete,async,ack,failure,if,failure,null,if,failure,instanceof,timeout,exception,string,taskname,vertex,get,task,name,with,subtask,index,attempt,id,mark,failed,new,exception,cannot,deploy,task,taskname,task,manager,get,assigned,resource,location,not,responding,after,a,rpc,timeout,of,rpc,timeout,failure,else,mark,failed,failure,job,master,main,thread,executor,catch,throwable,t,mark,failed,t,exception,utils,rethrow,t
Execution -> public void setInitialState(@Nullable JobManagerTaskRestore taskRestore);1516626397;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param taskRestore information to restore the state;public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskRestore = taskRestore__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,task,restore,information,to,restore,the,state;public,void,set,initial,state,nullable,job,manager,task,restore,task,restore,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,restore,task,restore
Execution -> public void setInitialState(@Nullable JobManagerTaskRestore taskRestore);1518680774;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param taskRestore information to restore the state;public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskRestore = taskRestore__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,task,restore,information,to,restore,the,state;public,void,set,initial,state,nullable,job,manager,task,restore,task,restore,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,restore,task,restore
Execution -> public void setInitialState(@Nullable JobManagerTaskRestore taskRestore);1518712478;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param taskRestore information to restore the state;public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskRestore = taskRestore__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,task,restore,information,to,restore,the,state;public,void,set,initial,state,nullable,job,manager,task,restore,task,restore,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,restore,task,restore
Execution -> public void setInitialState(@Nullable JobManagerTaskRestore taskRestore);1519316529;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param taskRestore information to restore the state;public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskRestore = taskRestore__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,task,restore,information,to,restore,the,state;public,void,set,initial,state,nullable,job,manager,task,restore,task,restore,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,restore,task,restore
Execution -> public void setInitialState(@Nullable JobManagerTaskRestore taskRestore);1519481114;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param taskRestore information to restore the state;public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskRestore = taskRestore__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,task,restore,information,to,restore,the,state;public,void,set,initial,state,nullable,job,manager,task,restore,task,restore,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,restore,task,restore
Execution -> public void setInitialState(@Nullable JobManagerTaskRestore taskRestore);1519568061;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param taskRestore information to restore the state;public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskRestore = taskRestore__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,task,restore,information,to,restore,the,state;public,void,set,initial,state,nullable,job,manager,task,restore,task,restore,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,restore,task,restore
Execution -> public void setInitialState(@Nullable JobManagerTaskRestore taskRestore);1519655521;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param taskRestore information to restore the state;public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskRestore = taskRestore__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,task,restore,information,to,restore,the,state;public,void,set,initial,state,nullable,job,manager,task,restore,task,restore,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,restore,task,restore
Execution -> public void setInitialState(@Nullable JobManagerTaskRestore taskRestore);1522049586;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param taskRestore information to restore the state;public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskRestore = taskRestore__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,task,restore,information,to,restore,the,state;public,void,set,initial,state,nullable,job,manager,task,restore,task,restore,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,restore,task,restore
Execution -> public void setInitialState(@Nullable JobManagerTaskRestore taskRestore);1522249273;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param taskRestore information to restore the state;public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskRestore = taskRestore__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,task,restore,information,to,restore,the,state;public,void,set,initial,state,nullable,job,manager,task,restore,task,restore,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,restore,task,restore
Execution -> public void setInitialState(@Nullable JobManagerTaskRestore taskRestore);1530712207;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param taskRestore information to restore the state;public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskRestore = taskRestore__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,task,restore,information,to,restore,the,state;public,void,set,initial,state,nullable,job,manager,task,restore,task,restore,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,restore,task,restore
Execution -> public void setInitialState(@Nullable JobManagerTaskRestore taskRestore);1532383539;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param taskRestore information to restore the state;public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskRestore = taskRestore__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,task,restore,information,to,restore,the,state;public,void,set,initial,state,nullable,job,manager,task,restore,task,restore,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,restore,task,restore
Execution -> public void setInitialState(@Nullable JobManagerTaskRestore taskRestore);1532383539;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param taskRestore information to restore the state;public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskRestore = taskRestore__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,task,restore,information,to,restore,the,state;public,void,set,initial,state,nullable,job,manager,task,restore,task,restore,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,restore,task,restore
Execution -> public void setInitialState(@Nullable JobManagerTaskRestore taskRestore);1532383539;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param taskRestore information to restore the state;public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskRestore = taskRestore__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,task,restore,information,to,restore,the,state;public,void,set,initial,state,nullable,job,manager,task,restore,task,restore,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,restore,task,restore
Execution -> public void setInitialState(@Nullable JobManagerTaskRestore taskRestore);1540920690;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param taskRestore information to restore the state;public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskRestore = taskRestore__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,task,restore,information,to,restore,the,state;public,void,set,initial,state,nullable,job,manager,task,restore,task,restore,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,restore,task,restore
Execution -> public void setInitialState(@Nullable JobManagerTaskRestore taskRestore);1542356428;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param taskRestore information to restore the state;public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskRestore = taskRestore__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,task,restore,information,to,restore,the,state;public,void,set,initial,state,nullable,job,manager,task,restore,task,restore,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,restore,task,restore
Execution -> public void setInitialState(@Nullable JobManagerTaskRestore taskRestore);1546870832;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param taskRestore information to restore the state;public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskRestore = taskRestore__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,task,restore,information,to,restore,the,state;public,void,set,initial,state,nullable,job,manager,task,restore,task,restore,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,restore,task,restore
Execution -> public void setInitialState(@Nullable JobManagerTaskRestore taskRestore);1547644408;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param taskRestore information to restore the state;public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskRestore = taskRestore__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,task,restore,information,to,restore,the,state;public,void,set,initial,state,nullable,job,manager,task,restore,task,restore,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,restore,task,restore
Execution -> public void setInitialState(@Nullable JobManagerTaskRestore taskRestore);1549365080;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param taskRestore information to restore the state;public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskRestore = taskRestore__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,task,restore,information,to,restore,the,state;public,void,set,initial,state,nullable,job,manager,task,restore,task,restore,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,restore,task,restore
Execution -> public void setInitialState(@Nullable JobManagerTaskRestore taskRestore);1550220073;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param taskRestore information to restore the state;public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskRestore = taskRestore__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,task,restore,information,to,restore,the,state;public,void,set,initial,state,nullable,job,manager,task,restore,task,restore,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,restore,task,restore
Execution -> public void setInitialState(@Nullable JobManagerTaskRestore taskRestore);1550654143;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param taskRestore information to restore the state;public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskRestore = taskRestore__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,task,restore,information,to,restore,the,state;public,void,set,initial,state,nullable,job,manager,task,restore,task,restore,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,restore,task,restore
Execution -> public void setInitialState(@Nullable JobManagerTaskRestore taskRestore);1550683188;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param taskRestore information to restore the state;public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskRestore = taskRestore__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,task,restore,information,to,restore,the,state;public,void,set,initial,state,nullable,job,manager,task,restore,task,restore,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,restore,task,restore
Execution -> public void setInitialState(@Nullable JobManagerTaskRestore taskRestore);1550855836;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param taskRestore information to restore the state;public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskRestore = taskRestore__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,task,restore,information,to,restore,the,state;public,void,set,initial,state,nullable,job,manager,task,restore,task,restore,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,restore,task,restore
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final SimpleSlot consumerSlot, 			final UpdatePartitionInfo updatePartitionInfo);1436802871;Sends an UpdatePartitionInfo message to the instance of the consumerSlot.__@param consumerSlot Slot to whose instance the message will be sent_@param updatePartitionInfo UpdatePartitionInfo message;private void sendUpdatePartitionInfoRpcCall(_			final SimpleSlot consumerSlot,_			final UpdatePartitionInfo updatePartitionInfo) {__		if (consumerSlot != null) {_			final Instance instance = consumerSlot.getInstance()__			final InstanceGateway gateway = instance.getInstanceGateway()___			Future<Object> futureUpdate = gateway.ask(updatePartitionInfo, timeout)___			futureUpdate.onFailure(new OnFailure() {_				@Override_				public void onFailure(Throwable failure) throws Throwable {_					fail(new IllegalStateException("Update task on instance " + instance +_							" failed due to:", failure))__				}_			}, executionContext)__		}_	};sends,an,update,partition,info,message,to,the,instance,of,the,consumer,slot,param,consumer,slot,slot,to,whose,instance,the,message,will,be,sent,param,update,partition,info,update,partition,info,message;private,void,send,update,partition,info,rpc,call,final,simple,slot,consumer,slot,final,update,partition,info,update,partition,info,if,consumer,slot,null,final,instance,instance,consumer,slot,get,instance,final,instance,gateway,gateway,instance,get,instance,gateway,future,object,future,update,gateway,ask,update,partition,info,timeout,future,update,on,failure,new,on,failure,override,public,void,on,failure,throwable,failure,throws,throwable,fail,new,illegal,state,exception,update,task,on,instance,instance,failed,due,to,failure,execution,context
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final SimpleSlot consumerSlot, 			final UpdatePartitionInfo updatePartitionInfo);1436966346;Sends an UpdatePartitionInfo message to the instance of the consumerSlot.__@param consumerSlot Slot to whose instance the message will be sent_@param updatePartitionInfo UpdatePartitionInfo message;private void sendUpdatePartitionInfoRpcCall(_			final SimpleSlot consumerSlot,_			final UpdatePartitionInfo updatePartitionInfo) {__		if (consumerSlot != null) {_			final Instance instance = consumerSlot.getInstance()__			final InstanceGateway gateway = instance.getInstanceGateway()___			Future<Object> futureUpdate = gateway.ask(updatePartitionInfo, timeout)___			futureUpdate.onFailure(new OnFailure() {_				@Override_				public void onFailure(Throwable failure) throws Throwable {_					fail(new IllegalStateException("Update task on instance " + instance +_							" failed due to:", failure))__				}_			}, executionContext)__		}_	};sends,an,update,partition,info,message,to,the,instance,of,the,consumer,slot,param,consumer,slot,slot,to,whose,instance,the,message,will,be,sent,param,update,partition,info,update,partition,info,message;private,void,send,update,partition,info,rpc,call,final,simple,slot,consumer,slot,final,update,partition,info,update,partition,info,if,consumer,slot,null,final,instance,instance,consumer,slot,get,instance,final,instance,gateway,gateway,instance,get,instance,gateway,future,object,future,update,gateway,ask,update,partition,info,timeout,future,update,on,failure,new,on,failure,override,public,void,on,failure,throwable,failure,throws,throwable,fail,new,illegal,state,exception,update,task,on,instance,instance,failed,due,to,failure,execution,context
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final SimpleSlot consumerSlot, 			final UpdatePartitionInfo updatePartitionInfo);1437665997;Sends an UpdatePartitionInfo message to the instance of the consumerSlot.__@param consumerSlot Slot to whose instance the message will be sent_@param updatePartitionInfo UpdatePartitionInfo message;private void sendUpdatePartitionInfoRpcCall(_			final SimpleSlot consumerSlot,_			final UpdatePartitionInfo updatePartitionInfo) {__		if (consumerSlot != null) {_			final Instance instance = consumerSlot.getInstance()__			final ActorGateway gateway = instance.getActorGateway()___			Future<Object> futureUpdate = gateway.ask(updatePartitionInfo, timeout)___			futureUpdate.onFailure(new OnFailure() {_				@Override_				public void onFailure(Throwable failure) throws Throwable {_					fail(new IllegalStateException("Update task on instance " + instance +_							" failed due to:", failure))__				}_			}, executionContext)__		}_	};sends,an,update,partition,info,message,to,the,instance,of,the,consumer,slot,param,consumer,slot,slot,to,whose,instance,the,message,will,be,sent,param,update,partition,info,update,partition,info,message;private,void,send,update,partition,info,rpc,call,final,simple,slot,consumer,slot,final,update,partition,info,update,partition,info,if,consumer,slot,null,final,instance,instance,consumer,slot,get,instance,final,actor,gateway,gateway,instance,get,actor,gateway,future,object,future,update,gateway,ask,update,partition,info,timeout,future,update,on,failure,new,on,failure,override,public,void,on,failure,throwable,failure,throws,throwable,fail,new,illegal,state,exception,update,task,on,instance,instance,failed,due,to,failure,execution,context
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final SimpleSlot consumerSlot, 			final UpdatePartitionInfo updatePartitionInfo);1439908661;Sends an UpdatePartitionInfo message to the instance of the consumerSlot.__@param consumerSlot Slot to whose instance the message will be sent_@param updatePartitionInfo UpdatePartitionInfo message;private void sendUpdatePartitionInfoRpcCall(_			final SimpleSlot consumerSlot,_			final UpdatePartitionInfo updatePartitionInfo) {__		if (consumerSlot != null) {_			final Instance instance = consumerSlot.getInstance()__			final ActorGateway gateway = instance.getActorGateway()___			Future<Object> futureUpdate = gateway.ask(updatePartitionInfo, timeout)___			futureUpdate.onFailure(new OnFailure() {_				@Override_				public void onFailure(Throwable failure) throws Throwable {_					fail(new IllegalStateException("Update task on instance " + instance +_							" failed due to:", failure))__				}_			}, executionContext)__		}_	};sends,an,update,partition,info,message,to,the,instance,of,the,consumer,slot,param,consumer,slot,slot,to,whose,instance,the,message,will,be,sent,param,update,partition,info,update,partition,info,message;private,void,send,update,partition,info,rpc,call,final,simple,slot,consumer,slot,final,update,partition,info,update,partition,info,if,consumer,slot,null,final,instance,instance,consumer,slot,get,instance,final,actor,gateway,gateway,instance,get,actor,gateway,future,object,future,update,gateway,ask,update,partition,info,timeout,future,update,on,failure,new,on,failure,override,public,void,on,failure,throwable,failure,throws,throwable,fail,new,illegal,state,exception,update,task,on,instance,instance,failed,due,to,failure,execution,context
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final SimpleSlot consumerSlot, 			final UpdatePartitionInfo updatePartitionInfo);1440782435;Sends an UpdatePartitionInfo message to the instance of the consumerSlot.__@param consumerSlot Slot to whose instance the message will be sent_@param updatePartitionInfo UpdatePartitionInfo message;private void sendUpdatePartitionInfoRpcCall(_			final SimpleSlot consumerSlot,_			final UpdatePartitionInfo updatePartitionInfo) {__		if (consumerSlot != null) {_			final Instance instance = consumerSlot.getInstance()__			final ActorGateway gateway = instance.getActorGateway()___			Future<Object> futureUpdate = gateway.ask(updatePartitionInfo, timeout)___			futureUpdate.onFailure(new OnFailure() {_				@Override_				public void onFailure(Throwable failure) throws Throwable {_					fail(new IllegalStateException("Update task on instance " + instance +_							" failed due to:", failure))__				}_			}, executionContext)__		}_	};sends,an,update,partition,info,message,to,the,instance,of,the,consumer,slot,param,consumer,slot,slot,to,whose,instance,the,message,will,be,sent,param,update,partition,info,update,partition,info,message;private,void,send,update,partition,info,rpc,call,final,simple,slot,consumer,slot,final,update,partition,info,update,partition,info,if,consumer,slot,null,final,instance,instance,consumer,slot,get,instance,final,actor,gateway,gateway,instance,get,actor,gateway,future,object,future,update,gateway,ask,update,partition,info,timeout,future,update,on,failure,new,on,failure,override,public,void,on,failure,throwable,failure,throws,throwable,fail,new,illegal,state,exception,update,task,on,instance,instance,failed,due,to,failure,execution,context
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final SimpleSlot consumerSlot, 			final UpdatePartitionInfo updatePartitionInfo);1440951699;Sends an UpdatePartitionInfo message to the instance of the consumerSlot.__@param consumerSlot Slot to whose instance the message will be sent_@param updatePartitionInfo UpdatePartitionInfo message;private void sendUpdatePartitionInfoRpcCall(_			final SimpleSlot consumerSlot,_			final UpdatePartitionInfo updatePartitionInfo) {__		if (consumerSlot != null) {_			final Instance instance = consumerSlot.getInstance()__			final ActorGateway gateway = instance.getActorGateway()___			Future<Object> futureUpdate = gateway.ask(updatePartitionInfo, timeout)___			futureUpdate.onFailure(new OnFailure() {_				@Override_				public void onFailure(Throwable failure) throws Throwable {_					fail(new IllegalStateException("Update task on instance " + instance +_							" failed due to:", failure))__				}_			}, executionContext)__		}_	};sends,an,update,partition,info,message,to,the,instance,of,the,consumer,slot,param,consumer,slot,slot,to,whose,instance,the,message,will,be,sent,param,update,partition,info,update,partition,info,message;private,void,send,update,partition,info,rpc,call,final,simple,slot,consumer,slot,final,update,partition,info,update,partition,info,if,consumer,slot,null,final,instance,instance,consumer,slot,get,instance,final,actor,gateway,gateway,instance,get,actor,gateway,future,object,future,update,gateway,ask,update,partition,info,timeout,future,update,on,failure,new,on,failure,override,public,void,on,failure,throwable,failure,throws,throwable,fail,new,illegal,state,exception,update,task,on,instance,instance,failed,due,to,failure,execution,context
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final SimpleSlot consumerSlot, 			final UpdatePartitionInfo updatePartitionInfo);1441011751;Sends an UpdatePartitionInfo message to the instance of the consumerSlot.__@param consumerSlot Slot to whose instance the message will be sent_@param updatePartitionInfo UpdatePartitionInfo message;private void sendUpdatePartitionInfoRpcCall(_			final SimpleSlot consumerSlot,_			final UpdatePartitionInfo updatePartitionInfo) {__		if (consumerSlot != null) {_			final Instance instance = consumerSlot.getInstance()__			final ActorGateway gateway = instance.getActorGateway()___			Future<Object> futureUpdate = gateway.ask(updatePartitionInfo, timeout)___			futureUpdate.onFailure(new OnFailure() {_				@Override_				public void onFailure(Throwable failure) throws Throwable {_					fail(new IllegalStateException("Update task on instance " + instance +_							" failed due to:", failure))__				}_			}, executionContext)__		}_	};sends,an,update,partition,info,message,to,the,instance,of,the,consumer,slot,param,consumer,slot,slot,to,whose,instance,the,message,will,be,sent,param,update,partition,info,update,partition,info,message;private,void,send,update,partition,info,rpc,call,final,simple,slot,consumer,slot,final,update,partition,info,update,partition,info,if,consumer,slot,null,final,instance,instance,consumer,slot,get,instance,final,actor,gateway,gateway,instance,get,actor,gateway,future,object,future,update,gateway,ask,update,partition,info,timeout,future,update,on,failure,new,on,failure,override,public,void,on,failure,throwable,failure,throws,throwable,fail,new,illegal,state,exception,update,task,on,instance,instance,failed,due,to,failure,execution,context
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final SimpleSlot consumerSlot, 			final UpdatePartitionInfo updatePartitionInfo);1442492512;Sends an UpdatePartitionInfo message to the instance of the consumerSlot.__@param consumerSlot Slot to whose instance the message will be sent_@param updatePartitionInfo UpdatePartitionInfo message;private void sendUpdatePartitionInfoRpcCall(_			final SimpleSlot consumerSlot,_			final UpdatePartitionInfo updatePartitionInfo) {__		if (consumerSlot != null) {_			final Instance instance = consumerSlot.getInstance()__			final ActorGateway gateway = instance.getActorGateway()___			Future<Object> futureUpdate = gateway.ask(updatePartitionInfo, timeout)___			futureUpdate.onFailure(new OnFailure() {_				@Override_				public void onFailure(Throwable failure) throws Throwable {_					fail(new IllegalStateException("Update task on instance " + instance +_							" failed due to:", failure))__				}_			}, executionContext)__		}_	};sends,an,update,partition,info,message,to,the,instance,of,the,consumer,slot,param,consumer,slot,slot,to,whose,instance,the,message,will,be,sent,param,update,partition,info,update,partition,info,message;private,void,send,update,partition,info,rpc,call,final,simple,slot,consumer,slot,final,update,partition,info,update,partition,info,if,consumer,slot,null,final,instance,instance,consumer,slot,get,instance,final,actor,gateway,gateway,instance,get,actor,gateway,future,object,future,update,gateway,ask,update,partition,info,timeout,future,update,on,failure,new,on,failure,override,public,void,on,failure,throwable,failure,throws,throwable,fail,new,illegal,state,exception,update,task,on,instance,instance,failed,due,to,failure,execution,context
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final SimpleSlot consumerSlot, 			final UpdatePartitionInfo updatePartitionInfo);1448353719;Sends an UpdatePartitionInfo message to the instance of the consumerSlot.__@param consumerSlot Slot to whose instance the message will be sent_@param updatePartitionInfo UpdatePartitionInfo message;private void sendUpdatePartitionInfoRpcCall(_			final SimpleSlot consumerSlot,_			final UpdatePartitionInfo updatePartitionInfo) {__		if (consumerSlot != null) {_			final Instance instance = consumerSlot.getInstance()__			final ActorGateway gateway = instance.getActorGateway()___			Future<Object> futureUpdate = gateway.ask(updatePartitionInfo, timeout)___			futureUpdate.onFailure(new OnFailure() {_				@Override_				public void onFailure(Throwable failure) throws Throwable {_					fail(new IllegalStateException("Update task on instance " + instance +_							" failed due to:", failure))__				}_			}, executionContext)__		}_	};sends,an,update,partition,info,message,to,the,instance,of,the,consumer,slot,param,consumer,slot,slot,to,whose,instance,the,message,will,be,sent,param,update,partition,info,update,partition,info,message;private,void,send,update,partition,info,rpc,call,final,simple,slot,consumer,slot,final,update,partition,info,update,partition,info,if,consumer,slot,null,final,instance,instance,consumer,slot,get,instance,final,actor,gateway,gateway,instance,get,actor,gateway,future,object,future,update,gateway,ask,update,partition,info,timeout,future,update,on,failure,new,on,failure,override,public,void,on,failure,throwable,failure,throws,throwable,fail,new,illegal,state,exception,update,task,on,instance,instance,failed,due,to,failure,execution,context
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final SimpleSlot consumerSlot, 			final UpdatePartitionInfo updatePartitionInfo);1448353719;Sends an UpdatePartitionInfo message to the instance of the consumerSlot.__@param consumerSlot Slot to whose instance the message will be sent_@param updatePartitionInfo UpdatePartitionInfo message;private void sendUpdatePartitionInfoRpcCall(_			final SimpleSlot consumerSlot,_			final UpdatePartitionInfo updatePartitionInfo) {__		if (consumerSlot != null) {_			final Instance instance = consumerSlot.getInstance()__			final ActorGateway gateway = instance.getActorGateway()___			Future<Object> futureUpdate = gateway.ask(updatePartitionInfo, timeout)___			futureUpdate.onFailure(new OnFailure() {_				@Override_				public void onFailure(Throwable failure) throws Throwable {_					fail(new IllegalStateException("Update task on instance " + instance +_							" failed due to:", failure))__				}_			}, executionContext)__		}_	};sends,an,update,partition,info,message,to,the,instance,of,the,consumer,slot,param,consumer,slot,slot,to,whose,instance,the,message,will,be,sent,param,update,partition,info,update,partition,info,message;private,void,send,update,partition,info,rpc,call,final,simple,slot,consumer,slot,final,update,partition,info,update,partition,info,if,consumer,slot,null,final,instance,instance,consumer,slot,get,instance,final,actor,gateway,gateway,instance,get,actor,gateway,future,object,future,update,gateway,ask,update,partition,info,timeout,future,update,on,failure,new,on,failure,override,public,void,on,failure,throwable,failure,throws,throwable,fail,new,illegal,state,exception,update,task,on,instance,instance,failed,due,to,failure,execution,context
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final SimpleSlot consumerSlot, 			final UpdatePartitionInfo updatePartitionInfo);1449496469;Sends an UpdatePartitionInfo message to the instance of the consumerSlot.__@param consumerSlot Slot to whose instance the message will be sent_@param updatePartitionInfo UpdatePartitionInfo message;private void sendUpdatePartitionInfoRpcCall(_			final SimpleSlot consumerSlot,_			final UpdatePartitionInfo updatePartitionInfo) {__		if (consumerSlot != null) {_			final Instance instance = consumerSlot.getInstance()__			final ActorGateway gateway = instance.getActorGateway()___			Future<Object> futureUpdate = gateway.ask(updatePartitionInfo, timeout)___			futureUpdate.onFailure(new OnFailure() {_				@Override_				public void onFailure(Throwable failure) throws Throwable {_					fail(new IllegalStateException("Update task on instance " + instance +_							" failed due to:", failure))__				}_			}, executionContext)__		}_	};sends,an,update,partition,info,message,to,the,instance,of,the,consumer,slot,param,consumer,slot,slot,to,whose,instance,the,message,will,be,sent,param,update,partition,info,update,partition,info,message;private,void,send,update,partition,info,rpc,call,final,simple,slot,consumer,slot,final,update,partition,info,update,partition,info,if,consumer,slot,null,final,instance,instance,consumer,slot,get,instance,final,actor,gateway,gateway,instance,get,actor,gateway,future,object,future,update,gateway,ask,update,partition,info,timeout,future,update,on,failure,new,on,failure,override,public,void,on,failure,throwable,failure,throws,throwable,fail,new,illegal,state,exception,update,task,on,instance,instance,failed,due,to,failure,execution,context
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final SimpleSlot consumerSlot, 			final UpdatePartitionInfo updatePartitionInfo);1455114877;Sends an UpdatePartitionInfo message to the instance of the consumerSlot.__@param consumerSlot Slot to whose instance the message will be sent_@param updatePartitionInfo UpdatePartitionInfo message;private void sendUpdatePartitionInfoRpcCall(_			final SimpleSlot consumerSlot,_			final UpdatePartitionInfo updatePartitionInfo) {__		if (consumerSlot != null) {_			final Instance instance = consumerSlot.getInstance()__			final ActorGateway gateway = instance.getActorGateway()___			Future<Object> futureUpdate = gateway.ask(updatePartitionInfo, timeout)___			futureUpdate.onFailure(new OnFailure() {_				@Override_				public void onFailure(Throwable failure) throws Throwable {_					fail(new IllegalStateException("Update task on instance " + instance +_							" failed due to:", failure))__				}_			}, executionContext)__		}_	};sends,an,update,partition,info,message,to,the,instance,of,the,consumer,slot,param,consumer,slot,slot,to,whose,instance,the,message,will,be,sent,param,update,partition,info,update,partition,info,message;private,void,send,update,partition,info,rpc,call,final,simple,slot,consumer,slot,final,update,partition,info,update,partition,info,if,consumer,slot,null,final,instance,instance,consumer,slot,get,instance,final,actor,gateway,gateway,instance,get,actor,gateway,future,object,future,update,gateway,ask,update,partition,info,timeout,future,update,on,failure,new,on,failure,override,public,void,on,failure,throwable,failure,throws,throwable,fail,new,illegal,state,exception,update,task,on,instance,instance,failed,due,to,failure,execution,context
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final SimpleSlot consumerSlot, 			final UpdatePartitionInfo updatePartitionInfo);1455549373;Sends an UpdatePartitionInfo message to the instance of the consumerSlot.__@param consumerSlot Slot to whose instance the message will be sent_@param updatePartitionInfo UpdatePartitionInfo message;private void sendUpdatePartitionInfoRpcCall(_			final SimpleSlot consumerSlot,_			final UpdatePartitionInfo updatePartitionInfo) {__		if (consumerSlot != null) {_			final Instance instance = consumerSlot.getInstance()__			final ActorGateway gateway = instance.getActorGateway()___			Future<Object> futureUpdate = gateway.ask(updatePartitionInfo, timeout)___			futureUpdate.onFailure(new OnFailure() {_				@Override_				public void onFailure(Throwable failure) throws Throwable {_					fail(new IllegalStateException("Update task on instance " + instance +_							" failed due to:", failure))__				}_			}, executionContext)__		}_	};sends,an,update,partition,info,message,to,the,instance,of,the,consumer,slot,param,consumer,slot,slot,to,whose,instance,the,message,will,be,sent,param,update,partition,info,update,partition,info,message;private,void,send,update,partition,info,rpc,call,final,simple,slot,consumer,slot,final,update,partition,info,update,partition,info,if,consumer,slot,null,final,instance,instance,consumer,slot,get,instance,final,actor,gateway,gateway,instance,get,actor,gateway,future,object,future,update,gateway,ask,update,partition,info,timeout,future,update,on,failure,new,on,failure,override,public,void,on,failure,throwable,failure,throws,throwable,fail,new,illegal,state,exception,update,task,on,instance,instance,failed,due,to,failure,execution,context
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final SimpleSlot consumerSlot, 			final UpdatePartitionInfo updatePartitionInfo);1456772768;Sends an UpdatePartitionInfo message to the instance of the consumerSlot.__@param consumerSlot Slot to whose instance the message will be sent_@param updatePartitionInfo UpdatePartitionInfo message;private void sendUpdatePartitionInfoRpcCall(_			final SimpleSlot consumerSlot,_			final UpdatePartitionInfo updatePartitionInfo) {__		if (consumerSlot != null) {_			final Instance instance = consumerSlot.getInstance()__			final ActorGateway gateway = instance.getActorGateway()___			Future<Object> futureUpdate = gateway.ask(updatePartitionInfo, timeout)___			futureUpdate.onFailure(new OnFailure() {_				@Override_				public void onFailure(Throwable failure) throws Throwable {_					fail(new IllegalStateException("Update task on instance " + instance +_							" failed due to:", failure))__				}_			}, executionContext)__		}_	};sends,an,update,partition,info,message,to,the,instance,of,the,consumer,slot,param,consumer,slot,slot,to,whose,instance,the,message,will,be,sent,param,update,partition,info,update,partition,info,message;private,void,send,update,partition,info,rpc,call,final,simple,slot,consumer,slot,final,update,partition,info,update,partition,info,if,consumer,slot,null,final,instance,instance,consumer,slot,get,instance,final,actor,gateway,gateway,instance,get,actor,gateway,future,object,future,update,gateway,ask,update,partition,info,timeout,future,update,on,failure,new,on,failure,override,public,void,on,failure,throwable,failure,throws,throwable,fail,new,illegal,state,exception,update,task,on,instance,instance,failed,due,to,failure,execution,context
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final SimpleSlot consumerSlot, 			final UpdatePartitionInfo updatePartitionInfo);1461666173;Sends an UpdatePartitionInfo message to the instance of the consumerSlot.__@param consumerSlot Slot to whose instance the message will be sent_@param updatePartitionInfo UpdatePartitionInfo message;private void sendUpdatePartitionInfoRpcCall(_			final SimpleSlot consumerSlot,_			final UpdatePartitionInfo updatePartitionInfo) {__		if (consumerSlot != null) {_			final Instance instance = consumerSlot.getInstance()__			final ActorGateway gateway = instance.getActorGateway()___			Future<Object> futureUpdate = gateway.ask(updatePartitionInfo, timeout)___			futureUpdate.onFailure(new OnFailure() {_				@Override_				public void onFailure(Throwable failure) throws Throwable {_					fail(new IllegalStateException("Update task on instance " + instance +_							" failed due to:", failure))__				}_			}, executionContext)__		}_	};sends,an,update,partition,info,message,to,the,instance,of,the,consumer,slot,param,consumer,slot,slot,to,whose,instance,the,message,will,be,sent,param,update,partition,info,update,partition,info,message;private,void,send,update,partition,info,rpc,call,final,simple,slot,consumer,slot,final,update,partition,info,update,partition,info,if,consumer,slot,null,final,instance,instance,consumer,slot,get,instance,final,actor,gateway,gateway,instance,get,actor,gateway,future,object,future,update,gateway,ask,update,partition,info,timeout,future,update,on,failure,new,on,failure,override,public,void,on,failure,throwable,failure,throws,throwable,fail,new,illegal,state,exception,update,task,on,instance,instance,failed,due,to,failure,execution,context
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final SimpleSlot consumerSlot, 			final UpdatePartitionInfo updatePartitionInfo);1464612094;Sends an UpdatePartitionInfo message to the instance of the consumerSlot.__@param consumerSlot Slot to whose instance the message will be sent_@param updatePartitionInfo UpdatePartitionInfo message;private void sendUpdatePartitionInfoRpcCall(_			final SimpleSlot consumerSlot,_			final UpdatePartitionInfo updatePartitionInfo) {__		if (consumerSlot != null) {_			final Instance instance = consumerSlot.getInstance()__			final ActorGateway gateway = instance.getActorGateway()___			Future<Object> futureUpdate = gateway.ask(updatePartitionInfo, timeout)___			futureUpdate.onFailure(new OnFailure() {_				@Override_				public void onFailure(Throwable failure) throws Throwable {_					fail(new IllegalStateException("Update task on instance " + instance +_							" failed due to:", failure))__				}_			}, executionContext)__		}_	};sends,an,update,partition,info,message,to,the,instance,of,the,consumer,slot,param,consumer,slot,slot,to,whose,instance,the,message,will,be,sent,param,update,partition,info,update,partition,info,message;private,void,send,update,partition,info,rpc,call,final,simple,slot,consumer,slot,final,update,partition,info,update,partition,info,if,consumer,slot,null,final,instance,instance,consumer,slot,get,instance,final,actor,gateway,gateway,instance,get,actor,gateway,future,object,future,update,gateway,ask,update,partition,info,timeout,future,update,on,failure,new,on,failure,override,public,void,on,failure,throwable,failure,throws,throwable,fail,new,illegal,state,exception,update,task,on,instance,instance,failed,due,to,failure,execution,context
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final SimpleSlot consumerSlot, 			final UpdatePartitionInfo updatePartitionInfo);1465991918;Sends an UpdatePartitionInfo message to the instance of the consumerSlot.__@param consumerSlot Slot to whose instance the message will be sent_@param updatePartitionInfo UpdatePartitionInfo message;private void sendUpdatePartitionInfoRpcCall(_			final SimpleSlot consumerSlot,_			final UpdatePartitionInfo updatePartitionInfo) {__		if (consumerSlot != null) {_			final Instance instance = consumerSlot.getInstance()__			final ActorGateway gateway = instance.getActorGateway()___			Future<Object> futureUpdate = gateway.ask(updatePartitionInfo, timeout)___			futureUpdate.onFailure(new OnFailure() {_				@Override_				public void onFailure(Throwable failure) throws Throwable {_					fail(new IllegalStateException("Update task on instance " + instance +_							" failed due to:", failure))__				}_			}, executionContext)__		}_	};sends,an,update,partition,info,message,to,the,instance,of,the,consumer,slot,param,consumer,slot,slot,to,whose,instance,the,message,will,be,sent,param,update,partition,info,update,partition,info,message;private,void,send,update,partition,info,rpc,call,final,simple,slot,consumer,slot,final,update,partition,info,update,partition,info,if,consumer,slot,null,final,instance,instance,consumer,slot,get,instance,final,actor,gateway,gateway,instance,get,actor,gateway,future,object,future,update,gateway,ask,update,partition,info,timeout,future,update,on,failure,new,on,failure,override,public,void,on,failure,throwable,failure,throws,throwable,fail,new,illegal,state,exception,update,task,on,instance,instance,failed,due,to,failure,execution,context
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final SimpleSlot consumerSlot, 			final UpdatePartitionInfo updatePartitionInfo);1468523508;Sends an UpdatePartitionInfo message to the instance of the consumerSlot.__@param consumerSlot Slot to whose instance the message will be sent_@param updatePartitionInfo UpdatePartitionInfo message;private void sendUpdatePartitionInfoRpcCall(_			final SimpleSlot consumerSlot,_			final UpdatePartitionInfo updatePartitionInfo) {__		if (consumerSlot != null) {_			final Instance instance = consumerSlot.getInstance()__			final ActorGateway gateway = instance.getActorGateway()___			Future<Object> futureUpdate = gateway.ask(updatePartitionInfo, timeout)___			futureUpdate.onFailure(new OnFailure() {_				@Override_				public void onFailure(Throwable failure) throws Throwable {_					fail(new IllegalStateException("Update task on instance " + instance +_							" failed due to:", failure))__				}_			}, executionContext)__		}_	};sends,an,update,partition,info,message,to,the,instance,of,the,consumer,slot,param,consumer,slot,slot,to,whose,instance,the,message,will,be,sent,param,update,partition,info,update,partition,info,message;private,void,send,update,partition,info,rpc,call,final,simple,slot,consumer,slot,final,update,partition,info,update,partition,info,if,consumer,slot,null,final,instance,instance,consumer,slot,get,instance,final,actor,gateway,gateway,instance,get,actor,gateway,future,object,future,update,gateway,ask,update,partition,info,timeout,future,update,on,failure,new,on,failure,override,public,void,on,failure,throwable,failure,throws,throwable,fail,new,illegal,state,exception,update,task,on,instance,instance,failed,due,to,failure,execution,context
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final SimpleSlot consumerSlot, 			final UpdatePartitionInfo updatePartitionInfo);1470070623;Sends an UpdatePartitionInfo message to the instance of the consumerSlot.__@param consumerSlot Slot to whose instance the message will be sent_@param updatePartitionInfo UpdatePartitionInfo message;private void sendUpdatePartitionInfoRpcCall(_			final SimpleSlot consumerSlot,_			final UpdatePartitionInfo updatePartitionInfo) {__		if (consumerSlot != null) {_			final Instance instance = consumerSlot.getInstance()__			final ActorGateway gateway = instance.getActorGateway()___			Future<Object> futureUpdate = gateway.ask(updatePartitionInfo, timeout)___			futureUpdate.onFailure(new OnFailure() {_				@Override_				public void onFailure(Throwable failure) throws Throwable {_					fail(new IllegalStateException("Update task on instance " + instance +_							" failed due to:", failure))__				}_			}, executionContext)__		}_	};sends,an,update,partition,info,message,to,the,instance,of,the,consumer,slot,param,consumer,slot,slot,to,whose,instance,the,message,will,be,sent,param,update,partition,info,update,partition,info,message;private,void,send,update,partition,info,rpc,call,final,simple,slot,consumer,slot,final,update,partition,info,update,partition,info,if,consumer,slot,null,final,instance,instance,consumer,slot,get,instance,final,actor,gateway,gateway,instance,get,actor,gateway,future,object,future,update,gateway,ask,update,partition,info,timeout,future,update,on,failure,new,on,failure,override,public,void,on,failure,throwable,failure,throws,throwable,fail,new,illegal,state,exception,update,task,on,instance,instance,failed,due,to,failure,execution,context
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final SimpleSlot consumerSlot, 			final UpdatePartitionInfo updatePartitionInfo);1470419821;Sends an UpdatePartitionInfo message to the instance of the consumerSlot.__@param consumerSlot Slot to whose instance the message will be sent_@param updatePartitionInfo UpdatePartitionInfo message;private void sendUpdatePartitionInfoRpcCall(_			final SimpleSlot consumerSlot,_			final UpdatePartitionInfo updatePartitionInfo) {__		if (consumerSlot != null) {_			final Instance instance = consumerSlot.getInstance()__			final ActorGateway gateway = instance.getActorGateway()___			Future<Object> futureUpdate = gateway.ask(updatePartitionInfo, timeout)___			futureUpdate.onFailure(new OnFailure() {_				@Override_				public void onFailure(Throwable failure) throws Throwable {_					fail(new IllegalStateException("Update task on instance " + instance +_							" failed due to:", failure))__				}_			}, executionContext)__		}_	};sends,an,update,partition,info,message,to,the,instance,of,the,consumer,slot,param,consumer,slot,slot,to,whose,instance,the,message,will,be,sent,param,update,partition,info,update,partition,info,message;private,void,send,update,partition,info,rpc,call,final,simple,slot,consumer,slot,final,update,partition,info,update,partition,info,if,consumer,slot,null,final,instance,instance,consumer,slot,get,instance,final,actor,gateway,gateway,instance,get,actor,gateway,future,object,future,update,gateway,ask,update,partition,info,timeout,future,update,on,failure,new,on,failure,override,public,void,on,failure,throwable,failure,throws,throwable,fail,new,illegal,state,exception,update,task,on,instance,instance,failed,due,to,failure,execution,context
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final SimpleSlot consumerSlot, 			final UpdatePartitionInfo updatePartitionInfo);1472663401;Sends an UpdatePartitionInfo message to the instance of the consumerSlot.__@param consumerSlot Slot to whose instance the message will be sent_@param updatePartitionInfo UpdatePartitionInfo message;private void sendUpdatePartitionInfoRpcCall(_			final SimpleSlot consumerSlot,_			final UpdatePartitionInfo updatePartitionInfo) {__		if (consumerSlot != null) {_			final Instance instance = consumerSlot.getInstance()__			final ActorGateway gateway = instance.getActorGateway()___			Future<Object> futureUpdate = gateway.ask(updatePartitionInfo, timeout)___			futureUpdate.onFailure(new OnFailure() {_				@Override_				public void onFailure(Throwable failure) throws Throwable {_					fail(new IllegalStateException("Update task on instance " + instance +_							" failed due to:", failure))__				}_			}, executionContext)__		}_	};sends,an,update,partition,info,message,to,the,instance,of,the,consumer,slot,param,consumer,slot,slot,to,whose,instance,the,message,will,be,sent,param,update,partition,info,update,partition,info,message;private,void,send,update,partition,info,rpc,call,final,simple,slot,consumer,slot,final,update,partition,info,update,partition,info,if,consumer,slot,null,final,instance,instance,consumer,slot,get,instance,final,actor,gateway,gateway,instance,get,actor,gateway,future,object,future,update,gateway,ask,update,partition,info,timeout,future,update,on,failure,new,on,failure,override,public,void,on,failure,throwable,failure,throws,throwable,fail,new,illegal,state,exception,update,task,on,instance,instance,failed,due,to,failure,execution,context
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final SimpleSlot consumerSlot, 			final UpdatePartitionInfo updatePartitionInfo);1472663402;Sends an UpdatePartitionInfo message to the instance of the consumerSlot.__@param consumerSlot Slot to whose instance the message will be sent_@param updatePartitionInfo UpdatePartitionInfo message;private void sendUpdatePartitionInfoRpcCall(_			final SimpleSlot consumerSlot,_			final UpdatePartitionInfo updatePartitionInfo) {__		if (consumerSlot != null) {_			final Instance instance = consumerSlot.getInstance()__			final ActorGateway gateway = instance.getActorGateway()___			Future<Object> futureUpdate = gateway.ask(updatePartitionInfo, timeout)___			futureUpdate.onFailure(new OnFailure() {_				@Override_				public void onFailure(Throwable failure) throws Throwable {_					fail(new IllegalStateException("Update task on instance " + instance +_							" failed due to:", failure))__				}_			}, executionContext)__		}_	};sends,an,update,partition,info,message,to,the,instance,of,the,consumer,slot,param,consumer,slot,slot,to,whose,instance,the,message,will,be,sent,param,update,partition,info,update,partition,info,message;private,void,send,update,partition,info,rpc,call,final,simple,slot,consumer,slot,final,update,partition,info,update,partition,info,if,consumer,slot,null,final,instance,instance,consumer,slot,get,instance,final,actor,gateway,gateway,instance,get,actor,gateway,future,object,future,update,gateway,ask,update,partition,info,timeout,future,update,on,failure,new,on,failure,override,public,void,on,failure,throwable,failure,throws,throwable,fail,new,illegal,state,exception,update,task,on,instance,instance,failed,due,to,failure,execution,context
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final SimpleSlot consumerSlot, 			final UpdatePartitionInfo updatePartitionInfo);1472830377;Sends an UpdatePartitionInfo message to the instance of the consumerSlot.__@param consumerSlot Slot to whose instance the message will be sent_@param updatePartitionInfo UpdatePartitionInfo message;private void sendUpdatePartitionInfoRpcCall(_			final SimpleSlot consumerSlot,_			final UpdatePartitionInfo updatePartitionInfo) {__		if (consumerSlot != null) {_			final Instance instance = consumerSlot.getInstance()__			final ActorGateway gateway = instance.getActorGateway()___			Future<Object> futureUpdate = gateway.ask(updatePartitionInfo, timeout)___			futureUpdate.onFailure(new OnFailure() {_				@Override_				public void onFailure(Throwable failure) throws Throwable {_					fail(new IllegalStateException("Update task on instance " + instance +_							" failed due to:", failure))__				}_			}, executionContext)__		}_	};sends,an,update,partition,info,message,to,the,instance,of,the,consumer,slot,param,consumer,slot,slot,to,whose,instance,the,message,will,be,sent,param,update,partition,info,update,partition,info,message;private,void,send,update,partition,info,rpc,call,final,simple,slot,consumer,slot,final,update,partition,info,update,partition,info,if,consumer,slot,null,final,instance,instance,consumer,slot,get,instance,final,actor,gateway,gateway,instance,get,actor,gateway,future,object,future,update,gateway,ask,update,partition,info,timeout,future,update,on,failure,new,on,failure,override,public,void,on,failure,throwable,failure,throws,throwable,fail,new,illegal,state,exception,update,task,on,instance,instance,failed,due,to,failure,execution,context
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final SimpleSlot consumerSlot, 			final UpdatePartitionInfo updatePartitionInfo);1472830377;Sends an UpdatePartitionInfo message to the instance of the consumerSlot.__@param consumerSlot Slot to whose instance the message will be sent_@param updatePartitionInfo UpdatePartitionInfo message;private void sendUpdatePartitionInfoRpcCall(_			final SimpleSlot consumerSlot,_			final UpdatePartitionInfo updatePartitionInfo) {__		if (consumerSlot != null) {_			final ActorGateway gateway = consumerSlot.getTaskManagerActorGateway()__			final TaskManagerLocation taskManagerLocation = consumerSlot.getTaskManagerLocation()___			Future<Object> futureUpdate = gateway.ask(updatePartitionInfo, timeout)___			futureUpdate.onFailure(new OnFailure() {_				@Override_				public void onFailure(Throwable failure) throws Throwable {_					fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__				}_			}, executionContext)__		}_	};sends,an,update,partition,info,message,to,the,instance,of,the,consumer,slot,param,consumer,slot,slot,to,whose,instance,the,message,will,be,sent,param,update,partition,info,update,partition,info,message;private,void,send,update,partition,info,rpc,call,final,simple,slot,consumer,slot,final,update,partition,info,update,partition,info,if,consumer,slot,null,final,actor,gateway,gateway,consumer,slot,get,task,manager,actor,gateway,final,task,manager,location,task,manager,location,consumer,slot,get,task,manager,location,future,object,future,update,gateway,ask,update,partition,info,timeout,future,update,on,failure,new,on,failure,override,public,void,on,failure,throwable,failure,throws,throwable,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,execution,context
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final SimpleSlot consumerSlot, 			final UpdatePartitionInfo updatePartitionInfo);1473023399;Sends an UpdatePartitionInfo message to the instance of the consumerSlot.__@param consumerSlot Slot to whose instance the message will be sent_@param updatePartitionInfo UpdatePartitionInfo message;private void sendUpdatePartitionInfoRpcCall(_			final SimpleSlot consumerSlot,_			final UpdatePartitionInfo updatePartitionInfo) {__		if (consumerSlot != null) {_			final ActorGateway gateway = consumerSlot.getTaskManagerActorGateway()__			final TaskManagerLocation taskManagerLocation = consumerSlot.getTaskManagerLocation()___			Future<Object> futureUpdate = gateway.ask(updatePartitionInfo, timeout)___			futureUpdate.onFailure(new OnFailure() {_				@Override_				public void onFailure(Throwable failure) throws Throwable {_					fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__				}_			}, executionContext)__		}_	};sends,an,update,partition,info,message,to,the,instance,of,the,consumer,slot,param,consumer,slot,slot,to,whose,instance,the,message,will,be,sent,param,update,partition,info,update,partition,info,message;private,void,send,update,partition,info,rpc,call,final,simple,slot,consumer,slot,final,update,partition,info,update,partition,info,if,consumer,slot,null,final,actor,gateway,gateway,consumer,slot,get,task,manager,actor,gateway,final,task,manager,location,task,manager,location,consumer,slot,get,task,manager,location,future,object,future,update,gateway,ask,update,partition,info,timeout,future,update,on,failure,new,on,failure,override,public,void,on,failure,throwable,failure,throws,throwable,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,execution,context
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final SimpleSlot consumerSlot, 			final UpdatePartitionInfo updatePartitionInfo);1474994376;Sends an UpdatePartitionInfo message to the instance of the consumerSlot.__@param consumerSlot Slot to whose instance the message will be sent_@param updatePartitionInfo UpdatePartitionInfo message;private void sendUpdatePartitionInfoRpcCall(_			final SimpleSlot consumerSlot,_			final UpdatePartitionInfo updatePartitionInfo) {__		if (consumerSlot != null) {_			final ActorGateway gateway = consumerSlot.getTaskManagerActorGateway()__			final TaskManagerLocation taskManagerLocation = consumerSlot.getTaskManagerLocation()___			scala.concurrent.Future<Object> futureUpdate = gateway.ask(updatePartitionInfo, timeout)___			futureUpdate.onFailure(new OnFailure() {_				@Override_				public void onFailure(Throwable failure) throws Throwable {_					fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__				}_			}, executionContext)__		}_	};sends,an,update,partition,info,message,to,the,instance,of,the,consumer,slot,param,consumer,slot,slot,to,whose,instance,the,message,will,be,sent,param,update,partition,info,update,partition,info,message;private,void,send,update,partition,info,rpc,call,final,simple,slot,consumer,slot,final,update,partition,info,update,partition,info,if,consumer,slot,null,final,actor,gateway,gateway,consumer,slot,get,task,manager,actor,gateway,final,task,manager,location,task,manager,location,consumer,slot,get,task,manager,location,scala,concurrent,future,object,future,update,gateway,ask,update,partition,info,timeout,future,update,on,failure,new,on,failure,override,public,void,on,failure,throwable,failure,throws,throwable,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,execution,context
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final SimpleSlot consumerSlot, 			final UpdatePartitionInfo updatePartitionInfo);1474994376;Sends an UpdatePartitionInfo message to the instance of the consumerSlot.__@param consumerSlot Slot to whose instance the message will be sent_@param updatePartitionInfo UpdatePartitionInfo message;private void sendUpdatePartitionInfoRpcCall(_			final SimpleSlot consumerSlot,_			final UpdatePartitionInfo updatePartitionInfo) {__		if (consumerSlot != null) {_			final ActorGateway gateway = consumerSlot.getTaskManagerActorGateway()__			final TaskManagerLocation taskManagerLocation = consumerSlot.getTaskManagerLocation()___			scala.concurrent.Future<Object> futureUpdate = gateway.ask(updatePartitionInfo, timeout)___			futureUpdate.onFailure(new OnFailure() {_				@Override_				public void onFailure(Throwable failure) throws Throwable {_					fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__				}_			}, executionContext)__		}_	};sends,an,update,partition,info,message,to,the,instance,of,the,consumer,slot,param,consumer,slot,slot,to,whose,instance,the,message,will,be,sent,param,update,partition,info,update,partition,info,message;private,void,send,update,partition,info,rpc,call,final,simple,slot,consumer,slot,final,update,partition,info,update,partition,info,if,consumer,slot,null,final,actor,gateway,gateway,consumer,slot,get,task,manager,actor,gateway,final,task,manager,location,task,manager,location,consumer,slot,get,task,manager,location,scala,concurrent,future,object,future,update,gateway,ask,update,partition,info,timeout,future,update,on,failure,new,on,failure,override,public,void,on,failure,throwable,failure,throws,throwable,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,execution,context
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final SimpleSlot consumerSlot, 			final UpdatePartitionInfo updatePartitionInfo);1475231926;Sends an UpdatePartitionInfo message to the instance of the consumerSlot.__@param consumerSlot Slot to whose instance the message will be sent_@param updatePartitionInfo UpdatePartitionInfo message;private void sendUpdatePartitionInfoRpcCall(_			final SimpleSlot consumerSlot,_			final UpdatePartitionInfo updatePartitionInfo) {__		if (consumerSlot != null) {_			final ActorGateway gateway = consumerSlot.getTaskManagerActorGateway()__			final TaskManagerLocation taskManagerLocation = consumerSlot.getTaskManagerLocation()___			scala.concurrent.Future<Object> futureUpdate = gateway.ask(updatePartitionInfo, timeout)___			futureUpdate.onFailure(new OnFailure() {_				@Override_				public void onFailure(Throwable failure) throws Throwable {_					fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__				}_			}, executionContext)__		}_	};sends,an,update,partition,info,message,to,the,instance,of,the,consumer,slot,param,consumer,slot,slot,to,whose,instance,the,message,will,be,sent,param,update,partition,info,update,partition,info,message;private,void,send,update,partition,info,rpc,call,final,simple,slot,consumer,slot,final,update,partition,info,update,partition,info,if,consumer,slot,null,final,actor,gateway,gateway,consumer,slot,get,task,manager,actor,gateway,final,task,manager,location,task,manager,location,consumer,slot,get,task,manager,location,scala,concurrent,future,object,future,update,gateway,ask,update,partition,info,timeout,future,update,on,failure,new,on,failure,override,public,void,on,failure,throwable,failure,throws,throwable,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,execution,context
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final SimpleSlot consumerSlot, 			final UpdatePartitionInfo updatePartitionInfo);1476446128;Sends an UpdatePartitionInfo message to the instance of the consumerSlot.__@param consumerSlot Slot to whose instance the message will be sent_@param updatePartitionInfo UpdatePartitionInfo message;private void sendUpdatePartitionInfoRpcCall(_			final SimpleSlot consumerSlot,_			final UpdatePartitionInfo updatePartitionInfo) {__		if (consumerSlot != null) {_			final ActorGateway gateway = consumerSlot.getTaskManagerActorGateway()__			final TaskManagerLocation taskManagerLocation = consumerSlot.getTaskManagerLocation()___			scala.concurrent.Future<Object> futureUpdate = gateway.ask(updatePartitionInfo, timeout)___			futureUpdate.onFailure(new OnFailure() {_				@Override_				public void onFailure(Throwable failure) throws Throwable {_					fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__				}_			}, executionContext)__		}_	};sends,an,update,partition,info,message,to,the,instance,of,the,consumer,slot,param,consumer,slot,slot,to,whose,instance,the,message,will,be,sent,param,update,partition,info,update,partition,info,message;private,void,send,update,partition,info,rpc,call,final,simple,slot,consumer,slot,final,update,partition,info,update,partition,info,if,consumer,slot,null,final,actor,gateway,gateway,consumer,slot,get,task,manager,actor,gateway,final,task,manager,location,task,manager,location,consumer,slot,get,task,manager,location,scala,concurrent,future,object,future,update,gateway,ask,update,partition,info,timeout,future,update,on,failure,new,on,failure,override,public,void,on,failure,throwable,failure,throws,throwable,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,execution,context
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final SimpleSlot consumerSlot, 			final UpdatePartitionInfo updatePartitionInfo);1476972861;Sends an UpdatePartitionInfo message to the instance of the consumerSlot.__@param consumerSlot Slot to whose instance the message will be sent_@param updatePartitionInfo UpdatePartitionInfo message;private void sendUpdatePartitionInfoRpcCall(_			final SimpleSlot consumerSlot,_			final UpdatePartitionInfo updatePartitionInfo) {__		if (consumerSlot != null) {_			final ActorGateway gateway = consumerSlot.getTaskManagerActorGateway()__			final TaskManagerLocation taskManagerLocation = consumerSlot.getTaskManagerLocation()___			scala.concurrent.Future<Object> futureUpdate = gateway.ask(updatePartitionInfo, timeout)___			futureUpdate.onFailure(new OnFailure() {_				@Override_				public void onFailure(Throwable failure) throws Throwable {_					fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__				}_			}, executionContext)__		}_	};sends,an,update,partition,info,message,to,the,instance,of,the,consumer,slot,param,consumer,slot,slot,to,whose,instance,the,message,will,be,sent,param,update,partition,info,update,partition,info,message;private,void,send,update,partition,info,rpc,call,final,simple,slot,consumer,slot,final,update,partition,info,update,partition,info,if,consumer,slot,null,final,actor,gateway,gateway,consumer,slot,get,task,manager,actor,gateway,final,task,manager,location,task,manager,location,consumer,slot,get,task,manager,location,scala,concurrent,future,object,future,update,gateway,ask,update,partition,info,timeout,future,update,on,failure,new,on,failure,override,public,void,on,failure,throwable,failure,throws,throwable,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,execution,context
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final SimpleSlot consumerSlot, 			final UpdatePartitionInfo updatePartitionInfo);1477923124;Sends an UpdatePartitionInfo message to the instance of the consumerSlot.__@param consumerSlot Slot to whose instance the message will be sent_@param updatePartitionInfo UpdatePartitionInfo message;private void sendUpdatePartitionInfoRpcCall(_			final SimpleSlot consumerSlot,_			final UpdatePartitionInfo updatePartitionInfo) {__		if (consumerSlot != null) {_			final ActorGateway gateway = consumerSlot.getTaskManagerActorGateway()__			final TaskManagerLocation taskManagerLocation = consumerSlot.getTaskManagerLocation()___			scala.concurrent.Future<Object> futureUpdate = gateway.ask(updatePartitionInfo, timeout)___			futureUpdate.onFailure(new OnFailure() {_				@Override_				public void onFailure(Throwable failure) throws Throwable {_					fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__				}_			}, executionContext)__		}_	};sends,an,update,partition,info,message,to,the,instance,of,the,consumer,slot,param,consumer,slot,slot,to,whose,instance,the,message,will,be,sent,param,update,partition,info,update,partition,info,message;private,void,send,update,partition,info,rpc,call,final,simple,slot,consumer,slot,final,update,partition,info,update,partition,info,if,consumer,slot,null,final,actor,gateway,gateway,consumer,slot,get,task,manager,actor,gateway,final,task,manager,location,task,manager,location,consumer,slot,get,task,manager,location,scala,concurrent,future,object,future,update,gateway,ask,update,partition,info,timeout,future,update,on,failure,new,on,failure,override,public,void,on,failure,throwable,failure,throws,throwable,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,execution,context
Execution -> public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued);1486740510;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling.;public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) {_		if (slotProvider == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			final Future<SimpleSlot> slotAllocationFuture = slotProvider.allocateSlot(toSchedule, queued)___			_			_			_			final Future<Void> deploymentFuture = slotAllocationFuture.handle(new BiFunction<SimpleSlot, Throwable, Void>() {_				@Override_				public Void apply(SimpleSlot simpleSlot, Throwable throwable) {_					if (simpleSlot != null) {_						try {_							deployToSlot(simpleSlot)__						} catch (Throwable t) {_							try {_								simpleSlot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_					else {_						markFailed(throwable)__					}_					return null__				}_			})___			_			_			if (!queued) {_				if (!deploymentFuture.isDone()) {_					markFailed(new IllegalArgumentException("The slot allocation future has not been completed yet."))__				}_			}_			_			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,if,slot,provider,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,final,future,simple,slot,slot,allocation,future,slot,provider,allocate,slot,to,schedule,queued,final,future,void,deployment,future,slot,allocation,future,handle,new,bi,function,simple,slot,throwable,void,override,public,void,apply,simple,slot,simple,slot,throwable,throwable,if,simple,slot,null,try,deploy,to,slot,simple,slot,catch,throwable,t,try,simple,slot,release,slot,finally,mark,failed,t,else,mark,failed,throwable,return,null,if,queued,if,deployment,future,is,done,mark,failed,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,true,else,return,false
Execution -> public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued);1487548884;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling.;public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) {_		try {_			final Future<SimpleSlot> slotAllocationFuture = allocateSlotForExecution(slotProvider, queued)___			_			_			_			final Future<Void> deploymentFuture = slotAllocationFuture.handle(new BiFunction<SimpleSlot, Throwable, Void>() {_				@Override_				public Void apply(SimpleSlot simpleSlot, Throwable throwable) {_					if (simpleSlot != null) {_						try {_							deployToSlot(simpleSlot)__						} catch (Throwable t) {_							try {_								simpleSlot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_					else {_						markFailed(throwable)__					}_					return null__				}_			})___			_			if (!queued && !deploymentFuture.isDone()) {_				markFailed(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return true__		}_		catch (IllegalExecutionStateException e) {_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,try,final,future,simple,slot,slot,allocation,future,allocate,slot,for,execution,slot,provider,queued,final,future,void,deployment,future,slot,allocation,future,handle,new,bi,function,simple,slot,throwable,void,override,public,void,apply,simple,slot,simple,slot,throwable,throwable,if,simple,slot,null,try,deploy,to,slot,simple,slot,catch,throwable,t,try,simple,slot,release,slot,finally,mark,failed,t,else,mark,failed,throwable,return,null,if,queued,deployment,future,is,done,mark,failed,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,true,catch,illegal,execution,state,exception,e,return,false
Execution -> public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued);1487871589;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling.;public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) {_		try {_			final Future<SimpleSlot> slotAllocationFuture = allocateSlotForExecution(slotProvider, queued)___			_			_			_			final Future<Void> deploymentFuture = slotAllocationFuture.handle(new BiFunction<SimpleSlot, Throwable, Void>() {_				@Override_				public Void apply(SimpleSlot simpleSlot, Throwable throwable) {_					if (simpleSlot != null) {_						try {_							deployToSlot(simpleSlot)__						} catch (Throwable t) {_							try {_								simpleSlot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_					else {_						markFailed(throwable)__					}_					return null__				}_			})___			_			if (!queued && !deploymentFuture.isDone()) {_				markFailed(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return true__		}_		catch (IllegalExecutionStateException e) {_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,try,final,future,simple,slot,slot,allocation,future,allocate,slot,for,execution,slot,provider,queued,final,future,void,deployment,future,slot,allocation,future,handle,new,bi,function,simple,slot,throwable,void,override,public,void,apply,simple,slot,simple,slot,throwable,throwable,if,simple,slot,null,try,deploy,to,slot,simple,slot,catch,throwable,t,try,simple,slot,release,slot,finally,mark,failed,t,else,mark,failed,throwable,return,null,if,queued,deployment,future,is,done,mark,failed,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,true,catch,illegal,execution,state,exception,e,return,false
Execution -> public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued);1488878443;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling.;public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) {_		try {_			final Future<SimpleSlot> slotAllocationFuture = allocateSlotForExecution(slotProvider, queued)___			_			_			_			final Future<Void> deploymentFuture = slotAllocationFuture.handle(new BiFunction<SimpleSlot, Throwable, Void>() {_				@Override_				public Void apply(SimpleSlot simpleSlot, Throwable throwable) {_					if (simpleSlot != null) {_						try {_							deployToSlot(simpleSlot)__						} catch (Throwable t) {_							try {_								simpleSlot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_					else {_						markFailed(throwable)__					}_					return null__				}_			})___			_			if (!queued && !deploymentFuture.isDone()) {_				markFailed(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return true__		}_		catch (IllegalExecutionStateException e) {_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,try,final,future,simple,slot,slot,allocation,future,allocate,slot,for,execution,slot,provider,queued,final,future,void,deployment,future,slot,allocation,future,handle,new,bi,function,simple,slot,throwable,void,override,public,void,apply,simple,slot,simple,slot,throwable,throwable,if,simple,slot,null,try,deploy,to,slot,simple,slot,catch,throwable,t,try,simple,slot,release,slot,finally,mark,failed,t,else,mark,failed,throwable,return,null,if,queued,deployment,future,is,done,mark,failed,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,true,catch,illegal,execution,state,exception,e,return,false
Execution -> public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued);1490800309;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling.;public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) {_		try {_			final Future<SimpleSlot> slotAllocationFuture = allocateSlotForExecution(slotProvider, queued)___			_			_			_			final Future<Void> deploymentFuture = slotAllocationFuture.handle(new BiFunction<SimpleSlot, Throwable, Void>() {_				@Override_				public Void apply(SimpleSlot simpleSlot, Throwable throwable) {_					if (simpleSlot != null) {_						try {_							deployToSlot(simpleSlot)__						} catch (Throwable t) {_							try {_								simpleSlot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_					else {_						markFailed(throwable)__					}_					return null__				}_			})___			_			if (!queued && !deploymentFuture.isDone()) {_				markFailed(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return true__		}_		catch (IllegalExecutionStateException e) {_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,try,final,future,simple,slot,slot,allocation,future,allocate,slot,for,execution,slot,provider,queued,final,future,void,deployment,future,slot,allocation,future,handle,new,bi,function,simple,slot,throwable,void,override,public,void,apply,simple,slot,simple,slot,throwable,throwable,if,simple,slot,null,try,deploy,to,slot,simple,slot,catch,throwable,t,try,simple,slot,release,slot,finally,mark,failed,t,else,mark,failed,throwable,return,null,if,queued,deployment,future,is,done,mark,failed,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,true,catch,illegal,execution,state,exception,e,return,false
Execution -> public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued);1490819573;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling.;public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) {_		try {_			final Future<SimpleSlot> slotAllocationFuture = allocateSlotForExecution(slotProvider, queued)___			_			_			_			final Future<Void> deploymentFuture = slotAllocationFuture.handle(new BiFunction<SimpleSlot, Throwable, Void>() {_				@Override_				public Void apply(SimpleSlot simpleSlot, Throwable throwable) {_					if (simpleSlot != null) {_						try {_							deployToSlot(simpleSlot)__						} catch (Throwable t) {_							try {_								simpleSlot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_					else {_						markFailed(throwable)__					}_					return null__				}_			})___			_			if (!queued && !deploymentFuture.isDone()) {_				markFailed(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return true__		}_		catch (IllegalExecutionStateException e) {_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,try,final,future,simple,slot,slot,allocation,future,allocate,slot,for,execution,slot,provider,queued,final,future,void,deployment,future,slot,allocation,future,handle,new,bi,function,simple,slot,throwable,void,override,public,void,apply,simple,slot,simple,slot,throwable,throwable,if,simple,slot,null,try,deploy,to,slot,simple,slot,catch,throwable,t,try,simple,slot,release,slot,finally,mark,failed,t,else,mark,failed,throwable,return,null,if,queued,deployment,future,is,done,mark,failed,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,true,catch,illegal,execution,state,exception,e,return,false
Execution -> public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued);1493831843;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling.;public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) {_		try {_			final Future<SimpleSlot> slotAllocationFuture = allocateSlotForExecution(slotProvider, queued)___			_			_			_			final Future<Void> deploymentFuture = slotAllocationFuture.handle(new BiFunction<SimpleSlot, Throwable, Void>() {_				@Override_				public Void apply(SimpleSlot simpleSlot, Throwable throwable) {_					if (simpleSlot != null) {_						try {_							deployToSlot(simpleSlot)__						} catch (Throwable t) {_							try {_								simpleSlot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_					else {_						markFailed(throwable)__					}_					return null__				}_			})___			_			if (!queued && !deploymentFuture.isDone()) {_				markFailed(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return true__		}_		catch (IllegalExecutionStateException e) {_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,try,final,future,simple,slot,slot,allocation,future,allocate,slot,for,execution,slot,provider,queued,final,future,void,deployment,future,slot,allocation,future,handle,new,bi,function,simple,slot,throwable,void,override,public,void,apply,simple,slot,simple,slot,throwable,throwable,if,simple,slot,null,try,deploy,to,slot,simple,slot,catch,throwable,t,try,simple,slot,release,slot,finally,mark,failed,t,else,mark,failed,throwable,return,null,if,queued,deployment,future,is,done,mark,failed,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,true,catch,illegal,execution,state,exception,e,return,false
Execution -> public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued);1493831843;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling.;public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) {_		try {_			final Future<SimpleSlot> slotAllocationFuture = allocateSlotForExecution(slotProvider, queued)___			_			_			_			final Future<Void> deploymentFuture = slotAllocationFuture.handle(new BiFunction<SimpleSlot, Throwable, Void>() {_				@Override_				public Void apply(SimpleSlot simpleSlot, Throwable throwable) {_					if (simpleSlot != null) {_						try {_							deployToSlot(simpleSlot)__						} catch (Throwable t) {_							try {_								simpleSlot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_					else {_						markFailed(throwable)__					}_					return null__				}_			})___			_			if (!queued && !deploymentFuture.isDone()) {_				markFailed(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return true__		}_		catch (IllegalExecutionStateException e) {_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,try,final,future,simple,slot,slot,allocation,future,allocate,slot,for,execution,slot,provider,queued,final,future,void,deployment,future,slot,allocation,future,handle,new,bi,function,simple,slot,throwable,void,override,public,void,apply,simple,slot,simple,slot,throwable,throwable,if,simple,slot,null,try,deploy,to,slot,simple,slot,catch,throwable,t,try,simple,slot,release,slot,finally,mark,failed,t,else,mark,failed,throwable,return,null,if,queued,deployment,future,is,done,mark,failed,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,true,catch,illegal,execution,state,exception,e,return,false
Execution -> public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued);1501622876;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling.;public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) {_		try {_			final CompletableFuture<SimpleSlot> slotAllocationFuture = allocateSlotForExecution(slotProvider, queued)___			_			_			_			final CompletableFuture<Void> deploymentFuture = slotAllocationFuture.handle(_				(simpleSlot, throwable) ->  {_					if (simpleSlot != null) {_						try {_							deployToSlot(simpleSlot)__						} catch (Throwable t) {_							try {_								simpleSlot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_					else {_						markFailed(throwable)__					}_					return null__				}_			)___			_			if (!queued && !deploymentFuture.isDone()) {_				markFailed(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return true__		}_		catch (IllegalExecutionStateException e) {_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,try,final,completable,future,simple,slot,slot,allocation,future,allocate,slot,for,execution,slot,provider,queued,final,completable,future,void,deployment,future,slot,allocation,future,handle,simple,slot,throwable,if,simple,slot,null,try,deploy,to,slot,simple,slot,catch,throwable,t,try,simple,slot,release,slot,finally,mark,failed,t,else,mark,failed,throwable,return,null,if,queued,deployment,future,is,done,mark,failed,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,true,catch,illegal,execution,state,exception,e,return,false
Execution -> public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued);1501665499;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling.;public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) {_		try {_			final CompletableFuture<SimpleSlot> slotAllocationFuture = allocateSlotForExecution(slotProvider, queued)___			_			_			_			final CompletableFuture<Void> deploymentFuture = slotAllocationFuture.handle(_				(simpleSlot, throwable) ->  {_					if (simpleSlot != null) {_						try {_							deployToSlot(simpleSlot)__						} catch (Throwable t) {_							try {_								simpleSlot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_					else {_						markFailed(throwable)__					}_					return null__				}_			)___			_			if (!queued && !deploymentFuture.isDone()) {_				markFailed(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return true__		}_		catch (IllegalExecutionStateException e) {_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,try,final,completable,future,simple,slot,slot,allocation,future,allocate,slot,for,execution,slot,provider,queued,final,completable,future,void,deployment,future,slot,allocation,future,handle,simple,slot,throwable,if,simple,slot,null,try,deploy,to,slot,simple,slot,catch,throwable,t,try,simple,slot,release,slot,finally,mark,failed,t,else,mark,failed,throwable,return,null,if,queued,deployment,future,is,done,mark,failed,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,true,catch,illegal,execution,state,exception,e,return,false
Execution -> public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued);1501760738;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling.;public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) {_		try {_			final CompletableFuture<SimpleSlot> slotAllocationFuture = allocateSlotForExecution(slotProvider, queued)___			_			_			_			final CompletableFuture<Void> deploymentFuture = slotAllocationFuture.handle(_				(simpleSlot, throwable) ->  {_					if (simpleSlot != null) {_						try {_							deployToSlot(simpleSlot)__						} catch (Throwable t) {_							try {_								simpleSlot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_					else {_						markFailed(throwable)__					}_					return null__				}_			)___			_			if (!queued && !deploymentFuture.isDone()) {_				markFailed(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return true__		}_		catch (IllegalExecutionStateException e) {_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,try,final,completable,future,simple,slot,slot,allocation,future,allocate,slot,for,execution,slot,provider,queued,final,completable,future,void,deployment,future,slot,allocation,future,handle,simple,slot,throwable,if,simple,slot,null,try,deploy,to,slot,simple,slot,catch,throwable,t,try,simple,slot,release,slot,finally,mark,failed,t,else,mark,failed,throwable,return,null,if,queued,deployment,future,is,done,mark,failed,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,true,catch,illegal,execution,state,exception,e,return,false
Execution -> public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued);1502801814;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling.;public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) {_		try {_			final CompletableFuture<SimpleSlot> slotAllocationFuture = allocateSlotForExecution(slotProvider, queued)___			_			_			_			final CompletableFuture<Void> deploymentFuture = slotAllocationFuture.handle(_				(simpleSlot, throwable) ->  {_					if (simpleSlot != null) {_						try {_							deployToSlot(simpleSlot)__						} catch (Throwable t) {_							try {_								simpleSlot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_					else {_						markFailed(throwable)__					}_					return null__				}_			)___			_			if (!queued && !deploymentFuture.isDone()) {_				markFailed(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return true__		}_		catch (IllegalExecutionStateException e) {_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,try,final,completable,future,simple,slot,slot,allocation,future,allocate,slot,for,execution,slot,provider,queued,final,completable,future,void,deployment,future,slot,allocation,future,handle,simple,slot,throwable,if,simple,slot,null,try,deploy,to,slot,simple,slot,catch,throwable,t,try,simple,slot,release,slot,finally,mark,failed,t,else,mark,failed,throwable,return,null,if,queued,deployment,future,is,done,mark,failed,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,true,catch,illegal,execution,state,exception,e,return,false
Execution -> public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued);1509125300;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling.;public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) {_		try {_			final CompletableFuture<SimpleSlot> slotAllocationFuture = allocateSlotForExecution(slotProvider, queued)___			_			_			_			final CompletableFuture<Void> deploymentFuture = slotAllocationFuture.handle(_				(simpleSlot, throwable) ->  {_					if (simpleSlot != null) {_						try {_							deployToSlot(simpleSlot)__						} catch (Throwable t) {_							try {_								simpleSlot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_					else {_						markFailed(throwable)__					}_					return null__				}_			)___			_			if (!queued && !deploymentFuture.isDone()) {_				markFailed(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return true__		}_		catch (IllegalExecutionStateException e) {_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,try,final,completable,future,simple,slot,slot,allocation,future,allocate,slot,for,execution,slot,provider,queued,final,completable,future,void,deployment,future,slot,allocation,future,handle,simple,slot,throwable,if,simple,slot,null,try,deploy,to,slot,simple,slot,catch,throwable,t,try,simple,slot,release,slot,finally,mark,failed,t,else,mark,failed,throwable,return,null,if,queued,deployment,future,is,done,mark,failed,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,true,catch,illegal,execution,state,exception,e,return,false
Execution -> public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued);1509631297;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling.;public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) {_		try {_			final CompletableFuture<SimpleSlot> slotAllocationFuture = allocateSlotForExecution(slotProvider, queued)___			_			_			_			final CompletableFuture<Void> deploymentFuture = slotAllocationFuture.handle(_				(simpleSlot, throwable) ->  {_					if (simpleSlot != null) {_						try {_							deployToSlot(simpleSlot)__						} catch (Throwable t) {_							try {_								simpleSlot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_					else {_						markFailed(throwable)__					}_					return null__				}_			)___			_			if (!queued && !deploymentFuture.isDone()) {_				markFailed(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return true__		}_		catch (IllegalExecutionStateException e) {_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,try,final,completable,future,simple,slot,slot,allocation,future,allocate,slot,for,execution,slot,provider,queued,final,completable,future,void,deployment,future,slot,allocation,future,handle,simple,slot,throwable,if,simple,slot,null,try,deploy,to,slot,simple,slot,catch,throwable,t,try,simple,slot,release,slot,finally,mark,failed,t,else,mark,failed,throwable,return,null,if,queued,deployment,future,is,done,mark,failed,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,true,catch,illegal,execution,state,exception,e,return,false
Execution -> public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued);1509638684;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling.;public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) {_		try {_			final CompletableFuture<Execution> allocationFuture = allocateAndAssignSlotForExecution(slotProvider, queued)___			_			_			_			final CompletableFuture<Void> deploymentFuture = allocationFuture.handle(_				(Execution ignored, Throwable throwable) ->  {_					if (throwable != null) {_						markFailed(ExceptionUtils.stripCompletionException(throwable))__					}_					else {_						try {_							deploy()__						} catch (Throwable t) {_							markFailed(ExceptionUtils.stripCompletionException(t))__						}_					}_					return null__				}_			)___			_			if (!queued && !deploymentFuture.isDone()) {_				markFailed(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return true__		}_		catch (IllegalExecutionStateException e) {_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,try,final,completable,future,execution,allocation,future,allocate,and,assign,slot,for,execution,slot,provider,queued,final,completable,future,void,deployment,future,allocation,future,handle,execution,ignored,throwable,throwable,if,throwable,null,mark,failed,exception,utils,strip,completion,exception,throwable,else,try,deploy,catch,throwable,t,mark,failed,exception,utils,strip,completion,exception,t,return,null,if,queued,deployment,future,is,done,mark,failed,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,true,catch,illegal,execution,state,exception,e,return,false
Execution -> public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) throws NoResourceAvailableException;1473023399;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) throws NoResourceAvailableException {_		if (slotProvider == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			final SlotAllocationFuture future = slotProvider.allocateSlot(toSchedule, queued)__			if (queued) {_				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = future.get()__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,throws,no,resource,available,exception,if,slot,provider,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,final,slot,allocation,future,future,slot,provider,allocate,slot,to,schedule,queued,if,queued,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,future,get,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) throws NoResourceAvailableException;1474994376;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) throws NoResourceAvailableException {_		if (slotProvider == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			final Future<SimpleSlot> future = slotProvider.allocateSlot(toSchedule, queued)___			if (queued) {_				future.handleAsync(new BiFunction<SimpleSlot, Throwable, Void>() {_					@Override_					public Void apply(SimpleSlot simpleSlot, Throwable throwable) {_						if (simpleSlot != null) {_							try {_								deployToSlot(simpleSlot)__							} catch (Throwable t) {_								try {_									simpleSlot.releaseSlot()__								} finally {_									markFailed(t)__								}_							}_						}_						else {_							markFailed(throwable)__						}_						return null__					}_				}, ExecutionContext$.MODULE$.global())__			}_			else {_				SimpleSlot slot = null__				try {_					_					_					slot = checkNotNull(future.getNow(null))__					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						if (slot != null) {_							slot.releaseSlot()__						}_					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,throws,no,resource,available,exception,if,slot,provider,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,final,future,simple,slot,future,slot,provider,allocate,slot,to,schedule,queued,if,queued,future,handle,async,new,bi,function,simple,slot,throwable,void,override,public,void,apply,simple,slot,simple,slot,throwable,throwable,if,simple,slot,null,try,deploy,to,slot,simple,slot,catch,throwable,t,try,simple,slot,release,slot,finally,mark,failed,t,else,mark,failed,throwable,return,null,execution,context,module,global,else,simple,slot,slot,null,try,slot,check,not,null,future,get,now,null,deploy,to,slot,slot,catch,throwable,t,try,if,slot,null,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) throws NoResourceAvailableException;1474994376;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) throws NoResourceAvailableException {_		if (slotProvider == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			final Future<SimpleSlot> slotAllocationFuture = slotProvider.allocateSlot(toSchedule, queued)___			_			_			final Future<Void> deploymentFuture = slotAllocationFuture.handleAsync(new BiFunction<SimpleSlot, Throwable, Void>() {_				@Override_				public Void apply(SimpleSlot simpleSlot, Throwable throwable) {_					if (simpleSlot != null) {_						try {_							deployToSlot(simpleSlot)__						} catch (Throwable t) {_							try {_								simpleSlot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_					else {_						markFailed(throwable)__					}_					return null__				}_			}, Executors.directExecutor())___			_			if (!queued) {_				if (!deploymentFuture.isDone()) {_					markFailed(new IllegalArgumentException("The slot allocation future has not been completed yet."))__				}_			}_			_			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,throws,no,resource,available,exception,if,slot,provider,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,final,future,simple,slot,slot,allocation,future,slot,provider,allocate,slot,to,schedule,queued,final,future,void,deployment,future,slot,allocation,future,handle,async,new,bi,function,simple,slot,throwable,void,override,public,void,apply,simple,slot,simple,slot,throwable,throwable,if,simple,slot,null,try,deploy,to,slot,simple,slot,catch,throwable,t,try,simple,slot,release,slot,finally,mark,failed,t,else,mark,failed,throwable,return,null,executors,direct,executor,if,queued,if,deployment,future,is,done,mark,failed,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,true,else,return,false
Execution -> public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) throws NoResourceAvailableException;1475231926;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) throws NoResourceAvailableException {_		if (slotProvider == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			final Future<SimpleSlot> slotAllocationFuture = slotProvider.allocateSlot(toSchedule, queued)___			_			_			final Future<Void> deploymentFuture = slotAllocationFuture.handleAsync(new BiFunction<SimpleSlot, Throwable, Void>() {_				@Override_				public Void apply(SimpleSlot simpleSlot, Throwable throwable) {_					if (simpleSlot != null) {_						try {_							deployToSlot(simpleSlot)__						} catch (Throwable t) {_							try {_								simpleSlot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_					else {_						markFailed(throwable)__					}_					return null__				}_			}, Executors.directExecutor())___			_			if (!queued) {_				if (!deploymentFuture.isDone()) {_					markFailed(new IllegalArgumentException("The slot allocation future has not been completed yet."))__				}_			}_			_			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,throws,no,resource,available,exception,if,slot,provider,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,final,future,simple,slot,slot,allocation,future,slot,provider,allocate,slot,to,schedule,queued,final,future,void,deployment,future,slot,allocation,future,handle,async,new,bi,function,simple,slot,throwable,void,override,public,void,apply,simple,slot,simple,slot,throwable,throwable,if,simple,slot,null,try,deploy,to,slot,simple,slot,catch,throwable,t,try,simple,slot,release,slot,finally,mark,failed,t,else,mark,failed,throwable,return,null,executors,direct,executor,if,queued,if,deployment,future,is,done,mark,failed,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,true,else,return,false
Execution -> public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) throws NoResourceAvailableException;1476446128;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) throws NoResourceAvailableException {_		if (slotProvider == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			final Future<SimpleSlot> slotAllocationFuture = slotProvider.allocateSlot(toSchedule, queued)___			_			_			final Future<Void> deploymentFuture = slotAllocationFuture.handleAsync(new BiFunction<SimpleSlot, Throwable, Void>() {_				@Override_				public Void apply(SimpleSlot simpleSlot, Throwable throwable) {_					if (simpleSlot != null) {_						try {_							deployToSlot(simpleSlot)__						} catch (Throwable t) {_							try {_								simpleSlot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_					else {_						markFailed(throwable)__					}_					return null__				}_			}, Executors.directExecutor())___			_			if (!queued) {_				if (!deploymentFuture.isDone()) {_					markFailed(new IllegalArgumentException("The slot allocation future has not been completed yet."))__				}_			}_			_			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,throws,no,resource,available,exception,if,slot,provider,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,final,future,simple,slot,slot,allocation,future,slot,provider,allocate,slot,to,schedule,queued,final,future,void,deployment,future,slot,allocation,future,handle,async,new,bi,function,simple,slot,throwable,void,override,public,void,apply,simple,slot,simple,slot,throwable,throwable,if,simple,slot,null,try,deploy,to,slot,simple,slot,catch,throwable,t,try,simple,slot,release,slot,finally,mark,failed,t,else,mark,failed,throwable,return,null,executors,direct,executor,if,queued,if,deployment,future,is,done,mark,failed,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,true,else,return,false
Execution -> public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) throws NoResourceAvailableException;1476972861;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) throws NoResourceAvailableException {_		if (slotProvider == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			final Future<SimpleSlot> slotAllocationFuture = slotProvider.allocateSlot(toSchedule, queued)___			_			_			final Future<Void> deploymentFuture = slotAllocationFuture.handleAsync(new BiFunction<SimpleSlot, Throwable, Void>() {_				@Override_				public Void apply(SimpleSlot simpleSlot, Throwable throwable) {_					if (simpleSlot != null) {_						try {_							deployToSlot(simpleSlot)__						} catch (Throwable t) {_							try {_								simpleSlot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_					else {_						markFailed(throwable)__					}_					return null__				}_			}, Executors.directExecutor())___			_			if (!queued) {_				if (!deploymentFuture.isDone()) {_					markFailed(new IllegalArgumentException("The slot allocation future has not been completed yet."))__				}_			}_			_			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,throws,no,resource,available,exception,if,slot,provider,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,final,future,simple,slot,slot,allocation,future,slot,provider,allocate,slot,to,schedule,queued,final,future,void,deployment,future,slot,allocation,future,handle,async,new,bi,function,simple,slot,throwable,void,override,public,void,apply,simple,slot,simple,slot,throwable,throwable,if,simple,slot,null,try,deploy,to,slot,simple,slot,catch,throwable,t,try,simple,slot,release,slot,finally,mark,failed,t,else,mark,failed,throwable,return,null,executors,direct,executor,if,queued,if,deployment,future,is,done,mark,failed,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,true,else,return,false
Execution -> public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) throws NoResourceAvailableException;1477923124;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) throws NoResourceAvailableException {_		if (slotProvider == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			final Future<SimpleSlot> slotAllocationFuture = slotProvider.allocateSlot(toSchedule, queued)___			_			_			final Future<Void> deploymentFuture = slotAllocationFuture.handleAsync(new BiFunction<SimpleSlot, Throwable, Void>() {_				@Override_				public Void apply(SimpleSlot simpleSlot, Throwable throwable) {_					if (simpleSlot != null) {_						try {_							deployToSlot(simpleSlot)__						} catch (Throwable t) {_							try {_								simpleSlot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_					else {_						markFailed(throwable)__					}_					return null__				}_			}, Executors.directExecutor())___			_			if (!queued) {_				if (!deploymentFuture.isDone()) {_					markFailed(new IllegalArgumentException("The slot allocation future has not been completed yet."))__				}_			}_			_			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,throws,no,resource,available,exception,if,slot,provider,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,final,future,simple,slot,slot,allocation,future,slot,provider,allocate,slot,to,schedule,queued,final,future,void,deployment,future,slot,allocation,future,handle,async,new,bi,function,simple,slot,throwable,void,override,public,void,apply,simple,slot,simple,slot,throwable,throwable,if,simple,slot,null,try,deploy,to,slot,simple,slot,catch,throwable,t,try,simple,slot,release,slot,finally,mark,failed,t,else,mark,failed,throwable,return,null,executors,direct,executor,if,queued,if,deployment,future,is,done,mark,failed,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,true,else,return,false
Execution -> public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) throws NoResourceAvailableException;1477989375;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) throws NoResourceAvailableException {_		if (slotProvider == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			final Future<SimpleSlot> slotAllocationFuture = slotProvider.allocateSlot(toSchedule, queued)___			_			_			_			final Future<Void> deploymentFuture = slotAllocationFuture.handle(new BiFunction<SimpleSlot, Throwable, Void>() {_				@Override_				public Void apply(SimpleSlot simpleSlot, Throwable throwable) {_					if (simpleSlot != null) {_						try {_							deployToSlot(simpleSlot)__						} catch (Throwable t) {_							try {_								simpleSlot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_					else {_						markFailed(throwable)__					}_					return null__				}_			})___			_			if (!queued) {_				if (!deploymentFuture.isDone()) {_					markFailed(new IllegalArgumentException("The slot allocation future has not been completed yet."))__				}_			}_			_			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,throws,no,resource,available,exception,if,slot,provider,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,final,future,simple,slot,slot,allocation,future,slot,provider,allocate,slot,to,schedule,queued,final,future,void,deployment,future,slot,allocation,future,handle,new,bi,function,simple,slot,throwable,void,override,public,void,apply,simple,slot,simple,slot,throwable,throwable,if,simple,slot,null,try,deploy,to,slot,simple,slot,catch,throwable,t,try,simple,slot,release,slot,finally,mark,failed,t,else,mark,failed,throwable,return,null,if,queued,if,deployment,future,is,done,mark,failed,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,true,else,return,false
Execution -> public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) throws NoResourceAvailableException;1478800024;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) throws NoResourceAvailableException {_		if (slotProvider == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			final Future<SimpleSlot> slotAllocationFuture = slotProvider.allocateSlot(toSchedule, queued)___			_			_			_			final Future<Void> deploymentFuture = slotAllocationFuture.handle(new BiFunction<SimpleSlot, Throwable, Void>() {_				@Override_				public Void apply(SimpleSlot simpleSlot, Throwable throwable) {_					if (simpleSlot != null) {_						try {_							deployToSlot(simpleSlot)__						} catch (Throwable t) {_							try {_								simpleSlot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_					else {_						markFailed(throwable)__					}_					return null__				}_			})___			_			if (!queued) {_				if (!deploymentFuture.isDone()) {_					markFailed(new IllegalArgumentException("The slot allocation future has not been completed yet."))__				}_			}_			_			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,throws,no,resource,available,exception,if,slot,provider,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,final,future,simple,slot,slot,allocation,future,slot,provider,allocate,slot,to,schedule,queued,final,future,void,deployment,future,slot,allocation,future,handle,new,bi,function,simple,slot,throwable,void,override,public,void,apply,simple,slot,simple,slot,throwable,throwable,if,simple,slot,null,try,deploy,to,slot,simple,slot,catch,throwable,t,try,simple,slot,release,slot,finally,mark,failed,t,else,mark,failed,throwable,return,null,if,queued,if,deployment,future,is,done,mark,failed,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,true,else,return,false
Execution -> public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) throws NoResourceAvailableException;1481290933;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) throws NoResourceAvailableException {_		if (slotProvider == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			final Future<SimpleSlot> slotAllocationFuture = slotProvider.allocateSlot(toSchedule, queued)___			_			_			_			final Future<Void> deploymentFuture = slotAllocationFuture.handle(new BiFunction<SimpleSlot, Throwable, Void>() {_				@Override_				public Void apply(SimpleSlot simpleSlot, Throwable throwable) {_					if (simpleSlot != null) {_						try {_							deployToSlot(simpleSlot)__						} catch (Throwable t) {_							try {_								simpleSlot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_					else {_						markFailed(throwable)__					}_					return null__				}_			})___			_			if (!queued) {_				if (!deploymentFuture.isDone()) {_					markFailed(new IllegalArgumentException("The slot allocation future has not been completed yet."))__				}_			}_			_			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,throws,no,resource,available,exception,if,slot,provider,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,final,future,simple,slot,slot,allocation,future,slot,provider,allocate,slot,to,schedule,queued,final,future,void,deployment,future,slot,allocation,future,handle,new,bi,function,simple,slot,throwable,void,override,public,void,apply,simple,slot,simple,slot,throwable,throwable,if,simple,slot,null,try,deploy,to,slot,simple,slot,catch,throwable,t,try,simple,slot,release,slot,finally,mark,failed,t,else,mark,failed,throwable,return,null,if,queued,if,deployment,future,is,done,mark,failed,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,true,else,return,false
Execution -> public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) throws NoResourceAvailableException;1482522865;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) throws NoResourceAvailableException {_		if (slotProvider == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			final Future<SimpleSlot> slotAllocationFuture = slotProvider.allocateSlot(toSchedule, queued)___			_			_			_			final Future<Void> deploymentFuture = slotAllocationFuture.handle(new BiFunction<SimpleSlot, Throwable, Void>() {_				@Override_				public Void apply(SimpleSlot simpleSlot, Throwable throwable) {_					if (simpleSlot != null) {_						try {_							deployToSlot(simpleSlot)__						} catch (Throwable t) {_							try {_								simpleSlot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_					else {_						markFailed(throwable)__					}_					return null__				}_			})___			_			_			if (!queued) {_				if (!deploymentFuture.isDone()) {_					markFailed(new IllegalArgumentException("The slot allocation future has not been completed yet."))__				}_			}_			_			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,throws,no,resource,available,exception,if,slot,provider,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,final,future,simple,slot,slot,allocation,future,slot,provider,allocate,slot,to,schedule,queued,final,future,void,deployment,future,slot,allocation,future,handle,new,bi,function,simple,slot,throwable,void,override,public,void,apply,simple,slot,simple,slot,throwable,throwable,if,simple,slot,null,try,deploy,to,slot,simple,slot,catch,throwable,t,try,simple,slot,release,slot,finally,mark,failed,t,else,mark,failed,throwable,return,null,if,queued,if,deployment,future,is,done,mark,failed,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,true,else,return,false
Execution -> public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) throws NoResourceAvailableException;1486114103;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) throws NoResourceAvailableException {_		if (slotProvider == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			final Future<SimpleSlot> slotAllocationFuture = slotProvider.allocateSlot(toSchedule, queued)___			_			_			_			final Future<Void> deploymentFuture = slotAllocationFuture.handle(new BiFunction<SimpleSlot, Throwable, Void>() {_				@Override_				public Void apply(SimpleSlot simpleSlot, Throwable throwable) {_					if (simpleSlot != null) {_						try {_							deployToSlot(simpleSlot)__						} catch (Throwable t) {_							try {_								simpleSlot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_					else {_						markFailed(throwable)__					}_					return null__				}_			})___			_			_			if (!queued) {_				if (!deploymentFuture.isDone()) {_					markFailed(new IllegalArgumentException("The slot allocation future has not been completed yet."))__				}_			}_			_			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,throws,no,resource,available,exception,if,slot,provider,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,final,future,simple,slot,slot,allocation,future,slot,provider,allocate,slot,to,schedule,queued,final,future,void,deployment,future,slot,allocation,future,handle,new,bi,function,simple,slot,throwable,void,override,public,void,apply,simple,slot,simple,slot,throwable,throwable,if,simple,slot,null,try,deploy,to,slot,simple,slot,catch,throwable,t,try,simple,slot,release,slot,finally,mark,failed,t,else,mark,failed,throwable,return,null,if,queued,if,deployment,future,is,done,mark,failed,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,true,else,return,false
Execution -> public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) throws NoResourceAvailableException;1486114103;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(SlotProvider slotProvider, boolean queued) throws NoResourceAvailableException {_		if (slotProvider == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			final Future<SimpleSlot> slotAllocationFuture = slotProvider.allocateSlot(toSchedule, queued)___			_			_			_			final Future<Void> deploymentFuture = slotAllocationFuture.handle(new BiFunction<SimpleSlot, Throwable, Void>() {_				@Override_				public Void apply(SimpleSlot simpleSlot, Throwable throwable) {_					if (simpleSlot != null) {_						try {_							deployToSlot(simpleSlot)__						} catch (Throwable t) {_							try {_								simpleSlot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_					else {_						markFailed(throwable)__					}_					return null__				}_			})___			_			_			if (!queued) {_				if (!deploymentFuture.isDone()) {_					markFailed(new IllegalArgumentException("The slot allocation future has not been completed yet."))__				}_			}_			_			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,throws,no,resource,available,exception,if,slot,provider,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,final,future,simple,slot,slot,allocation,future,slot,provider,allocate,slot,to,schedule,queued,final,future,void,deployment,future,slot,allocation,future,handle,new,bi,function,simple,slot,throwable,void,override,public,void,apply,simple,slot,simple,slot,throwable,throwable,if,simple,slot,null,try,deploy,to,slot,simple,slot,catch,throwable,t,try,simple,slot,release,slot,finally,mark,failed,t,else,mark,failed,throwable,return,null,if,queued,if,deployment,future,is,done,mark,failed,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1421050512;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new NullPointerException()__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(AllocatedSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				AllocatedSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,null,pointer,exception,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,allocated,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,allocated,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1422007786;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new NullPointerException()__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(AllocatedSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				AllocatedSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,null,pointer,exception,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,allocated,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,allocated,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1423135035;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new NullPointerException()__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing not allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,null,pointer,exception,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,not,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1423135035;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new NullPointerException()__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing not allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,null,pointer,exception,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,not,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1423144032;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new NullPointerException()__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing not allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,null,pointer,exception,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,not,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1423672458;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new NullPointerException()__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing not allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,null,pointer,exception,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,not,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1423847366;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new NullPointerException()__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing not allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,null,pointer,exception,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,not,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1423927053;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new NullPointerException()__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing not allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,null,pointer,exception,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,not,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1424171945;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new NullPointerException()__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing not allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,null,pointer,exception,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,not,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1424732907;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new NullPointerException()__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing not allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,null,pointer,exception,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,not,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1424858532;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new NullPointerException()__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing not allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,null,pointer,exception,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,not,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1424858532;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new NullPointerException()__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing not allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,null,pointer,exception,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,not,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1425489637;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new NullPointerException()__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing not allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,null,pointer,exception,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,not,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1425601895;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing not allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,not,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1425995928;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing not allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,not,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1425995929;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing not allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,not,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1425995929;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing not allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,not,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1426697080;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1426783962;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1426860022;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1428327044;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1430296839;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1430296839;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1431432049;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1431459357;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1431459358;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1432031793;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1432295874;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1432629253;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1433537224;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1436802871;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1436966346;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1437665997;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1439908661;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1440782435;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1440951699;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1441011751;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1442492512;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1448353719;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1448353719;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1449496469;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1455114877;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1455549373;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1456772768;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1461666173;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1464612094;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1465991918;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1468523508;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1470070623;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1470419821;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1472663401;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1472663402;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1472830377;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1472830377;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler The scheduler to use to schedule this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it.__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.")__		}__		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		if (transitionState(CREATED, SCHEDULED)) {__			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)___			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)___				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(SimpleSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}__			return true__		}_		else {_			_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,the,scheduler,to,use,to,schedule,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,boolean,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,illegal,argument,exception,cannot,send,null,scheduler,when,scheduling,execution,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,simple,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,simple,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,return,true,else,return,false
Execution -> public CompletableFuture<ExecutionState> getTerminationFuture();1501622876;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached.__@return A future for the execution's termination;public CompletableFuture<ExecutionState> getTerminationFuture() {_		return terminationFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,return,a,future,for,the,execution,s,termination;public,completable,future,execution,state,get,termination,future,return,termination,future
Execution -> public CompletableFuture<ExecutionState> getTerminationFuture();1501665499;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached.__@return A future for the execution's termination;public CompletableFuture<ExecutionState> getTerminationFuture() {_		return terminationFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,return,a,future,for,the,execution,s,termination;public,completable,future,execution,state,get,termination,future,return,termination,future
Execution -> public CompletableFuture<ExecutionState> getTerminationFuture();1501760738;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached.__@return A future for the execution's termination;public CompletableFuture<ExecutionState> getTerminationFuture() {_		return terminationFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,return,a,future,for,the,execution,s,termination;public,completable,future,execution,state,get,termination,future,return,termination,future
Execution -> public CompletableFuture<ExecutionState> getTerminationFuture();1502801814;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached.__@return A future for the execution's termination;public CompletableFuture<ExecutionState> getTerminationFuture() {_		return terminationFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,return,a,future,for,the,execution,s,termination;public,completable,future,execution,state,get,termination,future,return,termination,future
Execution -> public CompletableFuture<ExecutionState> getTerminationFuture();1509125300;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached.__@return A future for the execution's termination;public CompletableFuture<ExecutionState> getTerminationFuture() {_		return terminationFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,return,a,future,for,the,execution,s,termination;public,completable,future,execution,state,get,termination,future,return,termination,future
Execution -> public CompletableFuture<ExecutionState> getTerminationFuture();1509631297;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached.__@return A future for the execution's termination;public CompletableFuture<ExecutionState> getTerminationFuture() {_		return terminationFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,return,a,future,for,the,execution,s,termination;public,completable,future,execution,state,get,termination,future,return,termination,future
Execution -> public CompletableFuture<ExecutionState> getTerminationFuture();1509638684;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached.__@return A future for the execution's termination;public CompletableFuture<ExecutionState> getTerminationFuture() {_		return terminationFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,return,a,future,for,the,execution,s,termination;public,completable,future,execution,state,get,termination,future,return,termination,future
Execution -> public CompletableFuture<ExecutionState> getTerminationFuture();1509638685;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached.__@return A future for the execution's termination;public CompletableFuture<ExecutionState> getTerminationFuture() {_		return terminationFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,return,a,future,for,the,execution,s,termination;public,completable,future,execution,state,get,termination,future,return,termination,future
Execution -> public CompletableFuture<ExecutionState> getTerminationFuture();1513201052;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached.__@return A future for the execution's termination;public CompletableFuture<ExecutionState> getTerminationFuture() {_		return terminationFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,return,a,future,for,the,execution,s,termination;public,completable,future,execution,state,get,termination,future,return,termination,future
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time timeout);1493831843;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param timeout_The timeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time timeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.timeout = checkNotNull(timeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(ExecutionState.CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminationFuture = new FlinkCompletableFuture<>()__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,timeout,the,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,timeout,check,not,null,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,execution,state,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,termination,future,new,flink,completable,future
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time timeout);1501622876;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param timeout_The timeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time timeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.timeout = checkNotNull(timeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(ExecutionState.CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminationFuture = new CompletableFuture<>()__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,timeout,the,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,timeout,check,not,null,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,execution,state,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,termination,future,new,completable,future
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time timeout);1501665499;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param timeout_The timeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time timeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.timeout = checkNotNull(timeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(ExecutionState.CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminationFuture = new CompletableFuture<>()__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,timeout,the,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,timeout,check,not,null,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,execution,state,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,termination,future,new,completable,future
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time timeout);1501760738;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param timeout_The timeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time timeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.timeout = checkNotNull(timeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(ExecutionState.CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminationFuture = new CompletableFuture<>()__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,timeout,the,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,timeout,check,not,null,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,execution,state,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,termination,future,new,completable,future
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time timeout);1502801814;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param timeout_The timeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time timeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.timeout = checkNotNull(timeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(ExecutionState.CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminationFuture = new CompletableFuture<>()__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,timeout,the,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,timeout,check,not,null,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,execution,state,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,termination,future,new,completable,future
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time timeout);1509125300;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param timeout_The timeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time timeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.timeout = checkNotNull(timeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(ExecutionState.CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminationFuture = new CompletableFuture<>()__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,timeout,the,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,timeout,check,not,null,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,execution,state,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,termination,future,new,completable,future
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time timeout);1509631297;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param timeout_The timeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time timeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.timeout = checkNotNull(timeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(ExecutionState.CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminationFuture = new CompletableFuture<>()__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,timeout,the,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,timeout,check,not,null,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,execution,state,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,termination,future,new,completable,future
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time timeout);1509638684;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param timeout_The timeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time timeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.timeout = checkNotNull(timeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(ExecutionState.CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminationFuture = new CompletableFuture<>()__		this.taskManagerLocationFuture = new CompletableFuture<>()___		this.assignedResource = new AtomicReference<>()__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,timeout,the,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,timeout,check,not,null,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,execution,state,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,termination,future,new,completable,future,this,task,manager,location,future,new,completable,future,this,assigned,resource,new,atomic,reference
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time timeout);1509638685;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param timeout_The timeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time timeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.timeout = checkNotNull(timeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(ExecutionState.CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminationFuture = new CompletableFuture<>()__		this.taskManagerLocationFuture = new CompletableFuture<>()___		this.assignedResource = null__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,timeout,the,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,timeout,check,not,null,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,execution,state,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,termination,future,new,completable,future,this,task,manager,location,future,new,completable,future,this,assigned,resource,null
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time timeout);1513201052;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param timeout_The timeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time timeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.timeout = checkNotNull(timeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(ExecutionState.CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminationFuture = new CompletableFuture<>()__		this.taskManagerLocationFuture = new CompletableFuture<>()___		this.assignedResource = null__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,timeout,the,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,timeout,check,not,null,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,execution,state,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,termination,future,new,completable,future,this,task,manager,location,future,new,completable,future,this,assigned,resource,null
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time timeout);1513201070;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param timeout_The timeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time timeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.timeout = checkNotNull(timeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(ExecutionState.CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminalStateFuture = new CompletableFuture<>()__		this.releaseFuture = new CompletableFuture<>()__		this.taskManagerLocationFuture = new CompletableFuture<>()___		this.assignedResource = null__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,timeout,the,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,timeout,check,not,null,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,execution,state,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,terminal,state,future,new,completable,future,this,release,future,new,completable,future,this,task,manager,location,future,new,completable,future,this,assigned,resource,null
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time timeout);1513261599;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param timeout_The timeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time timeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.timeout = checkNotNull(timeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(ExecutionState.CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminalStateFuture = new CompletableFuture<>()__		this.releaseFuture = new CompletableFuture<>()__		this.taskManagerLocationFuture = new CompletableFuture<>()___		this.assignedResource = null__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,timeout,the,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,timeout,check,not,null,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,execution,state,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,terminal,state,future,new,completable,future,this,release,future,new,completable,future,this,task,manager,location,future,new,completable,future,this,assigned,resource,null
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time timeout);1515177485;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param timeout_The timeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time timeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.timeout = checkNotNull(timeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(ExecutionState.CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminalStateFuture = new CompletableFuture<>()__		this.releaseFuture = new CompletableFuture<>()__		this.taskManagerLocationFuture = new CompletableFuture<>()___		this.assignedResource = null__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,timeout,the,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,timeout,check,not,null,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,execution,state,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,terminal,state,future,new,completable,future,this,release,future,new,completable,future,this,task,manager,location,future,new,completable,future,this,assigned,resource,null
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time timeout);1516626377;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param timeout_The timeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time timeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.timeout = checkNotNull(timeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(ExecutionState.CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminalStateFuture = new CompletableFuture<>()__		this.releaseFuture = new CompletableFuture<>()__		this.taskManagerLocationFuture = new CompletableFuture<>()___		this.assignedResource = null__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,timeout,the,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,timeout,check,not,null,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,execution,state,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,terminal,state,future,new,completable,future,this,release,future,new,completable,future,this,task,manager,location,future,new,completable,future,this,assigned,resource,null
Execution -> public Execution( 			Executor executor, 			ExecutionVertex vertex, 			int attemptNumber, 			long globalModVersion, 			long startTimestamp, 			Time timeout);1516626397;Creates a new Execution attempt.__@param executor_The executor used to dispatch callbacks from futures and asynchronous RPC calls._@param vertex_The execution vertex to which this Execution belongs_@param attemptNumber_The execution attempt number._@param globalModVersion_The global modification version of the execution graph when this execution was created_@param startTimestamp_The timestamp that marks the creation of this Execution_@param timeout_The timeout for RPC calls like deploy/cancel/stop.;public Execution(_			Executor executor,_			ExecutionVertex vertex,_			int attemptNumber,_			long globalModVersion,_			long startTimestamp,_			Time timeout) {__		this.executor = checkNotNull(executor)__		this.vertex = checkNotNull(vertex)__		this.attemptId = new ExecutionAttemptID()__		this.timeout = checkNotNull(timeout)___		this.globalModVersion = globalModVersion__		this.attemptNumber = attemptNumber___		this.stateTimestamps = new long[ExecutionState.values().length]__		markTimestamp(ExecutionState.CREATED, startTimestamp)___		this.partialInputChannelDeploymentDescriptors = new ConcurrentLinkedQueue<>()__		this.terminalStateFuture = new CompletableFuture<>()__		this.releaseFuture = new CompletableFuture<>()__		this.taskManagerLocationFuture = new CompletableFuture<>()___		this.assignedResource = null__	};creates,a,new,execution,attempt,param,executor,the,executor,used,to,dispatch,callbacks,from,futures,and,asynchronous,rpc,calls,param,vertex,the,execution,vertex,to,which,this,execution,belongs,param,attempt,number,the,execution,attempt,number,param,global,mod,version,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,param,start,timestamp,the,timestamp,that,marks,the,creation,of,this,execution,param,timeout,the,timeout,for,rpc,calls,like,deploy,cancel,stop;public,execution,executor,executor,execution,vertex,vertex,int,attempt,number,long,global,mod,version,long,start,timestamp,time,timeout,this,executor,check,not,null,executor,this,vertex,check,not,null,vertex,this,attempt,id,new,execution,attempt,id,this,timeout,check,not,null,timeout,this,global,mod,version,global,mod,version,this,attempt,number,attempt,number,this,state,timestamps,new,long,execution,state,values,length,mark,timestamp,execution,state,created,start,timestamp,this,partial,input,channel,deployment,descriptors,new,concurrent,linked,queue,this,terminal,state,future,new,completable,future,this,release,future,new,completable,future,this,task,manager,location,future,new,completable,future,this,assigned,resource,null
Execution -> public boolean scheduleForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint);1518680774;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it._@param locationPreferenceConstraint constraint for the location preferences_@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling.;public boolean scheduleForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) {_		try {_			final Time allocationTimeout = vertex.getExecutionGraph().getAllocationTimeout()__			final CompletableFuture<Execution> allocationFuture = allocateAndAssignSlotForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint,_				allocationTimeout)___			_			_			_			final CompletableFuture<Void> deploymentFuture = allocationFuture.handle(_				(Execution ignored, Throwable throwable) ->  {_					if (throwable != null) {_						markFailed(ExceptionUtils.stripCompletionException(throwable))__					}_					else {_						try {_							deploy()__						} catch (Throwable t) {_							markFailed(ExceptionUtils.stripCompletionException(t))__						}_					}_					return null__				}_			)___			_			if (!queued && !deploymentFuture.isDone()) {_				allocationFuture.completeExceptionally(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return true__		}_		catch (IllegalExecutionStateException e) {_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,param,location,preference,constraint,constraint,for,the,location,preferences,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,try,final,time,allocation,timeout,vertex,get,execution,graph,get,allocation,timeout,final,completable,future,execution,allocation,future,allocate,and,assign,slot,for,execution,slot,provider,queued,location,preference,constraint,allocation,timeout,final,completable,future,void,deployment,future,allocation,future,handle,execution,ignored,throwable,throwable,if,throwable,null,mark,failed,exception,utils,strip,completion,exception,throwable,else,try,deploy,catch,throwable,t,mark,failed,exception,utils,strip,completion,exception,t,return,null,if,queued,deployment,future,is,done,allocation,future,complete,exceptionally,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,true,catch,illegal,execution,state,exception,e,return,false
Execution -> public boolean scheduleForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint);1518712478;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it._@param locationPreferenceConstraint constraint for the location preferences_@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling.;public boolean scheduleForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) {_		try {_			final Time allocationTimeout = vertex.getExecutionGraph().getAllocationTimeout()__			final CompletableFuture<Execution> allocationFuture = allocateAndAssignSlotForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint,_				allocationTimeout)___			_			_			_			final CompletableFuture<Void> deploymentFuture = allocationFuture.handle(_				(Execution ignored, Throwable throwable) ->  {_					if (throwable != null) {_						markFailed(ExceptionUtils.stripCompletionException(throwable))__					}_					else {_						try {_							deploy()__						} catch (Throwable t) {_							markFailed(ExceptionUtils.stripCompletionException(t))__						}_					}_					return null__				}_			)___			_			if (!queued && !deploymentFuture.isDone()) {_				allocationFuture.completeExceptionally(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return true__		}_		catch (IllegalExecutionStateException e) {_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,param,location,preference,constraint,constraint,for,the,location,preferences,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,try,final,time,allocation,timeout,vertex,get,execution,graph,get,allocation,timeout,final,completable,future,execution,allocation,future,allocate,and,assign,slot,for,execution,slot,provider,queued,location,preference,constraint,allocation,timeout,final,completable,future,void,deployment,future,allocation,future,handle,execution,ignored,throwable,throwable,if,throwable,null,mark,failed,exception,utils,strip,completion,exception,throwable,else,try,deploy,catch,throwable,t,mark,failed,exception,utils,strip,completion,exception,t,return,null,if,queued,deployment,future,is,done,allocation,future,complete,exceptionally,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,true,catch,illegal,execution,state,exception,e,return,false
Execution -> @VisibleForTesting 	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint);1509638685;Calculates the preferred locations based on the location preference constraint.__@param locationPreferenceConstraint constraint for the location preference_@return Future containing the collection of preferred locations. This might not be completed if not all inputs_have been a resource assigned.;@VisibleForTesting_	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {_		final Collection<CompletableFuture<TaskManagerLocation>> preferredLocationFutures = getVertex().getPreferredLocationsBasedOnInputs()__		final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture___		switch(locationPreferenceConstraint) {_			case ALL:_				preferredLocationsFuture = FutureUtils.combineAll(preferredLocationFutures)__				break__			case ANY:_				final ArrayList<TaskManagerLocation> completedTaskManagerLocations = new ArrayList<>(preferredLocationFutures.size())___				for (CompletableFuture<TaskManagerLocation> preferredLocationFuture : preferredLocationFutures) {_					if (preferredLocationFuture.isDone() && !preferredLocationFuture.isCompletedExceptionally()) {_						final TaskManagerLocation taskManagerLocation = preferredLocationFuture.getNow(null)___						if (taskManagerLocation == null) {_							throw new FlinkRuntimeException("TaskManagerLocationFuture was completed with null. This indicates a programming bug.")__						}__						completedTaskManagerLocations.add(taskManagerLocation)__					}_				}__				preferredLocationsFuture = CompletableFuture.completedFuture(completedTaskManagerLocations)__				break__			default:_				throw new RuntimeException("Unknown LocationPreferenceConstraint " + locationPreferenceConstraint + '.')__		}__		return preferredLocationsFuture__	};calculates,the,preferred,locations,based,on,the,location,preference,constraint,param,location,preference,constraint,constraint,for,the,location,preference,return,future,containing,the,collection,of,preferred,locations,this,might,not,be,completed,if,not,all,inputs,have,been,a,resource,assigned;visible,for,testing,public,completable,future,collection,task,manager,location,calculate,preferred,locations,location,preference,constraint,location,preference,constraint,final,collection,completable,future,task,manager,location,preferred,location,futures,get,vertex,get,preferred,locations,based,on,inputs,final,completable,future,collection,task,manager,location,preferred,locations,future,switch,location,preference,constraint,case,all,preferred,locations,future,future,utils,combine,all,preferred,location,futures,break,case,any,final,array,list,task,manager,location,completed,task,manager,locations,new,array,list,preferred,location,futures,size,for,completable,future,task,manager,location,preferred,location,future,preferred,location,futures,if,preferred,location,future,is,done,preferred,location,future,is,completed,exceptionally,final,task,manager,location,task,manager,location,preferred,location,future,get,now,null,if,task,manager,location,null,throw,new,flink,runtime,exception,task,manager,location,future,was,completed,with,null,this,indicates,a,programming,bug,completed,task,manager,locations,add,task,manager,location,preferred,locations,future,completable,future,completed,future,completed,task,manager,locations,break,default,throw,new,runtime,exception,unknown,location,preference,constraint,location,preference,constraint,return,preferred,locations,future
Execution -> @VisibleForTesting 	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint);1513201052;Calculates the preferred locations based on the location preference constraint.__@param locationPreferenceConstraint constraint for the location preference_@return Future containing the collection of preferred locations. This might not be completed if not all inputs_have been a resource assigned.;@VisibleForTesting_	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {_		final Collection<CompletableFuture<TaskManagerLocation>> preferredLocationFutures = getVertex().getPreferredLocationsBasedOnInputs()__		final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture___		switch(locationPreferenceConstraint) {_			case ALL:_				preferredLocationsFuture = FutureUtils.combineAll(preferredLocationFutures)__				break__			case ANY:_				final ArrayList<TaskManagerLocation> completedTaskManagerLocations = new ArrayList<>(preferredLocationFutures.size())___				for (CompletableFuture<TaskManagerLocation> preferredLocationFuture : preferredLocationFutures) {_					if (preferredLocationFuture.isDone() && !preferredLocationFuture.isCompletedExceptionally()) {_						final TaskManagerLocation taskManagerLocation = preferredLocationFuture.getNow(null)___						if (taskManagerLocation == null) {_							throw new FlinkRuntimeException("TaskManagerLocationFuture was completed with null. This indicates a programming bug.")__						}__						completedTaskManagerLocations.add(taskManagerLocation)__					}_				}__				preferredLocationsFuture = CompletableFuture.completedFuture(completedTaskManagerLocations)__				break__			default:_				throw new RuntimeException("Unknown LocationPreferenceConstraint " + locationPreferenceConstraint + '.')__		}__		return preferredLocationsFuture__	};calculates,the,preferred,locations,based,on,the,location,preference,constraint,param,location,preference,constraint,constraint,for,the,location,preference,return,future,containing,the,collection,of,preferred,locations,this,might,not,be,completed,if,not,all,inputs,have,been,a,resource,assigned;visible,for,testing,public,completable,future,collection,task,manager,location,calculate,preferred,locations,location,preference,constraint,location,preference,constraint,final,collection,completable,future,task,manager,location,preferred,location,futures,get,vertex,get,preferred,locations,based,on,inputs,final,completable,future,collection,task,manager,location,preferred,locations,future,switch,location,preference,constraint,case,all,preferred,locations,future,future,utils,combine,all,preferred,location,futures,break,case,any,final,array,list,task,manager,location,completed,task,manager,locations,new,array,list,preferred,location,futures,size,for,completable,future,task,manager,location,preferred,location,future,preferred,location,futures,if,preferred,location,future,is,done,preferred,location,future,is,completed,exceptionally,final,task,manager,location,task,manager,location,preferred,location,future,get,now,null,if,task,manager,location,null,throw,new,flink,runtime,exception,task,manager,location,future,was,completed,with,null,this,indicates,a,programming,bug,completed,task,manager,locations,add,task,manager,location,preferred,locations,future,completable,future,completed,future,completed,task,manager,locations,break,default,throw,new,runtime,exception,unknown,location,preference,constraint,location,preference,constraint,return,preferred,locations,future
Execution -> @VisibleForTesting 	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint);1513201070;Calculates the preferred locations based on the location preference constraint.__@param locationPreferenceConstraint constraint for the location preference_@return Future containing the collection of preferred locations. This might not be completed if not all inputs_have been a resource assigned.;@VisibleForTesting_	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {_		final Collection<CompletableFuture<TaskManagerLocation>> preferredLocationFutures = getVertex().getPreferredLocationsBasedOnInputs()__		final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture___		switch(locationPreferenceConstraint) {_			case ALL:_				preferredLocationsFuture = FutureUtils.combineAll(preferredLocationFutures)__				break__			case ANY:_				final ArrayList<TaskManagerLocation> completedTaskManagerLocations = new ArrayList<>(preferredLocationFutures.size())___				for (CompletableFuture<TaskManagerLocation> preferredLocationFuture : preferredLocationFutures) {_					if (preferredLocationFuture.isDone() && !preferredLocationFuture.isCompletedExceptionally()) {_						final TaskManagerLocation taskManagerLocation = preferredLocationFuture.getNow(null)___						if (taskManagerLocation == null) {_							throw new FlinkRuntimeException("TaskManagerLocationFuture was completed with null. This indicates a programming bug.")__						}__						completedTaskManagerLocations.add(taskManagerLocation)__					}_				}__				preferredLocationsFuture = CompletableFuture.completedFuture(completedTaskManagerLocations)__				break__			default:_				throw new RuntimeException("Unknown LocationPreferenceConstraint " + locationPreferenceConstraint + '.')__		}__		return preferredLocationsFuture__	};calculates,the,preferred,locations,based,on,the,location,preference,constraint,param,location,preference,constraint,constraint,for,the,location,preference,return,future,containing,the,collection,of,preferred,locations,this,might,not,be,completed,if,not,all,inputs,have,been,a,resource,assigned;visible,for,testing,public,completable,future,collection,task,manager,location,calculate,preferred,locations,location,preference,constraint,location,preference,constraint,final,collection,completable,future,task,manager,location,preferred,location,futures,get,vertex,get,preferred,locations,based,on,inputs,final,completable,future,collection,task,manager,location,preferred,locations,future,switch,location,preference,constraint,case,all,preferred,locations,future,future,utils,combine,all,preferred,location,futures,break,case,any,final,array,list,task,manager,location,completed,task,manager,locations,new,array,list,preferred,location,futures,size,for,completable,future,task,manager,location,preferred,location,future,preferred,location,futures,if,preferred,location,future,is,done,preferred,location,future,is,completed,exceptionally,final,task,manager,location,task,manager,location,preferred,location,future,get,now,null,if,task,manager,location,null,throw,new,flink,runtime,exception,task,manager,location,future,was,completed,with,null,this,indicates,a,programming,bug,completed,task,manager,locations,add,task,manager,location,preferred,locations,future,completable,future,completed,future,completed,task,manager,locations,break,default,throw,new,runtime,exception,unknown,location,preference,constraint,location,preference,constraint,return,preferred,locations,future
Execution -> @VisibleForTesting 	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint);1513261599;Calculates the preferred locations based on the location preference constraint.__@param locationPreferenceConstraint constraint for the location preference_@return Future containing the collection of preferred locations. This might not be completed if not all inputs_have been a resource assigned.;@VisibleForTesting_	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {_		final Collection<CompletableFuture<TaskManagerLocation>> preferredLocationFutures = getVertex().getPreferredLocationsBasedOnInputs()__		final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture___		switch(locationPreferenceConstraint) {_			case ALL:_				preferredLocationsFuture = FutureUtils.combineAll(preferredLocationFutures)__				break__			case ANY:_				final ArrayList<TaskManagerLocation> completedTaskManagerLocations = new ArrayList<>(preferredLocationFutures.size())___				for (CompletableFuture<TaskManagerLocation> preferredLocationFuture : preferredLocationFutures) {_					if (preferredLocationFuture.isDone() && !preferredLocationFuture.isCompletedExceptionally()) {_						final TaskManagerLocation taskManagerLocation = preferredLocationFuture.getNow(null)___						if (taskManagerLocation == null) {_							throw new FlinkRuntimeException("TaskManagerLocationFuture was completed with null. This indicates a programming bug.")__						}__						completedTaskManagerLocations.add(taskManagerLocation)__					}_				}__				preferredLocationsFuture = CompletableFuture.completedFuture(completedTaskManagerLocations)__				break__			default:_				throw new RuntimeException("Unknown LocationPreferenceConstraint " + locationPreferenceConstraint + '.')__		}__		return preferredLocationsFuture__	};calculates,the,preferred,locations,based,on,the,location,preference,constraint,param,location,preference,constraint,constraint,for,the,location,preference,return,future,containing,the,collection,of,preferred,locations,this,might,not,be,completed,if,not,all,inputs,have,been,a,resource,assigned;visible,for,testing,public,completable,future,collection,task,manager,location,calculate,preferred,locations,location,preference,constraint,location,preference,constraint,final,collection,completable,future,task,manager,location,preferred,location,futures,get,vertex,get,preferred,locations,based,on,inputs,final,completable,future,collection,task,manager,location,preferred,locations,future,switch,location,preference,constraint,case,all,preferred,locations,future,future,utils,combine,all,preferred,location,futures,break,case,any,final,array,list,task,manager,location,completed,task,manager,locations,new,array,list,preferred,location,futures,size,for,completable,future,task,manager,location,preferred,location,future,preferred,location,futures,if,preferred,location,future,is,done,preferred,location,future,is,completed,exceptionally,final,task,manager,location,task,manager,location,preferred,location,future,get,now,null,if,task,manager,location,null,throw,new,flink,runtime,exception,task,manager,location,future,was,completed,with,null,this,indicates,a,programming,bug,completed,task,manager,locations,add,task,manager,location,preferred,locations,future,completable,future,completed,future,completed,task,manager,locations,break,default,throw,new,runtime,exception,unknown,location,preference,constraint,location,preference,constraint,return,preferred,locations,future
Execution -> @VisibleForTesting 	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint);1515177485;Calculates the preferred locations based on the location preference constraint.__@param locationPreferenceConstraint constraint for the location preference_@return Future containing the collection of preferred locations. This might not be completed if not all inputs_have been a resource assigned.;@VisibleForTesting_	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {_		final Collection<CompletableFuture<TaskManagerLocation>> preferredLocationFutures = getVertex().getPreferredLocationsBasedOnInputs()__		final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture___		switch(locationPreferenceConstraint) {_			case ALL:_				preferredLocationsFuture = FutureUtils.combineAll(preferredLocationFutures)__				break__			case ANY:_				final ArrayList<TaskManagerLocation> completedTaskManagerLocations = new ArrayList<>(preferredLocationFutures.size())___				for (CompletableFuture<TaskManagerLocation> preferredLocationFuture : preferredLocationFutures) {_					if (preferredLocationFuture.isDone() && !preferredLocationFuture.isCompletedExceptionally()) {_						final TaskManagerLocation taskManagerLocation = preferredLocationFuture.getNow(null)___						if (taskManagerLocation == null) {_							throw new FlinkRuntimeException("TaskManagerLocationFuture was completed with null. This indicates a programming bug.")__						}__						completedTaskManagerLocations.add(taskManagerLocation)__					}_				}__				preferredLocationsFuture = CompletableFuture.completedFuture(completedTaskManagerLocations)__				break__			default:_				throw new RuntimeException("Unknown LocationPreferenceConstraint " + locationPreferenceConstraint + '.')__		}__		return preferredLocationsFuture__	};calculates,the,preferred,locations,based,on,the,location,preference,constraint,param,location,preference,constraint,constraint,for,the,location,preference,return,future,containing,the,collection,of,preferred,locations,this,might,not,be,completed,if,not,all,inputs,have,been,a,resource,assigned;visible,for,testing,public,completable,future,collection,task,manager,location,calculate,preferred,locations,location,preference,constraint,location,preference,constraint,final,collection,completable,future,task,manager,location,preferred,location,futures,get,vertex,get,preferred,locations,based,on,inputs,final,completable,future,collection,task,manager,location,preferred,locations,future,switch,location,preference,constraint,case,all,preferred,locations,future,future,utils,combine,all,preferred,location,futures,break,case,any,final,array,list,task,manager,location,completed,task,manager,locations,new,array,list,preferred,location,futures,size,for,completable,future,task,manager,location,preferred,location,future,preferred,location,futures,if,preferred,location,future,is,done,preferred,location,future,is,completed,exceptionally,final,task,manager,location,task,manager,location,preferred,location,future,get,now,null,if,task,manager,location,null,throw,new,flink,runtime,exception,task,manager,location,future,was,completed,with,null,this,indicates,a,programming,bug,completed,task,manager,locations,add,task,manager,location,preferred,locations,future,completable,future,completed,future,completed,task,manager,locations,break,default,throw,new,runtime,exception,unknown,location,preference,constraint,location,preference,constraint,return,preferred,locations,future
Execution -> @VisibleForTesting 	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint);1516626377;Calculates the preferred locations based on the location preference constraint.__@param locationPreferenceConstraint constraint for the location preference_@return Future containing the collection of preferred locations. This might not be completed if not all inputs_have been a resource assigned.;@VisibleForTesting_	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {_		final Collection<CompletableFuture<TaskManagerLocation>> preferredLocationFutures = getVertex().getPreferredLocationsBasedOnInputs()__		final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture___		switch(locationPreferenceConstraint) {_			case ALL:_				preferredLocationsFuture = FutureUtils.combineAll(preferredLocationFutures)__				break__			case ANY:_				final ArrayList<TaskManagerLocation> completedTaskManagerLocations = new ArrayList<>(preferredLocationFutures.size())___				for (CompletableFuture<TaskManagerLocation> preferredLocationFuture : preferredLocationFutures) {_					if (preferredLocationFuture.isDone() && !preferredLocationFuture.isCompletedExceptionally()) {_						final TaskManagerLocation taskManagerLocation = preferredLocationFuture.getNow(null)___						if (taskManagerLocation == null) {_							throw new FlinkRuntimeException("TaskManagerLocationFuture was completed with null. This indicates a programming bug.")__						}__						completedTaskManagerLocations.add(taskManagerLocation)__					}_				}__				preferredLocationsFuture = CompletableFuture.completedFuture(completedTaskManagerLocations)__				break__			default:_				throw new RuntimeException("Unknown LocationPreferenceConstraint " + locationPreferenceConstraint + '.')__		}__		return preferredLocationsFuture__	};calculates,the,preferred,locations,based,on,the,location,preference,constraint,param,location,preference,constraint,constraint,for,the,location,preference,return,future,containing,the,collection,of,preferred,locations,this,might,not,be,completed,if,not,all,inputs,have,been,a,resource,assigned;visible,for,testing,public,completable,future,collection,task,manager,location,calculate,preferred,locations,location,preference,constraint,location,preference,constraint,final,collection,completable,future,task,manager,location,preferred,location,futures,get,vertex,get,preferred,locations,based,on,inputs,final,completable,future,collection,task,manager,location,preferred,locations,future,switch,location,preference,constraint,case,all,preferred,locations,future,future,utils,combine,all,preferred,location,futures,break,case,any,final,array,list,task,manager,location,completed,task,manager,locations,new,array,list,preferred,location,futures,size,for,completable,future,task,manager,location,preferred,location,future,preferred,location,futures,if,preferred,location,future,is,done,preferred,location,future,is,completed,exceptionally,final,task,manager,location,task,manager,location,preferred,location,future,get,now,null,if,task,manager,location,null,throw,new,flink,runtime,exception,task,manager,location,future,was,completed,with,null,this,indicates,a,programming,bug,completed,task,manager,locations,add,task,manager,location,preferred,locations,future,completable,future,completed,future,completed,task,manager,locations,break,default,throw,new,runtime,exception,unknown,location,preference,constraint,location,preference,constraint,return,preferred,locations,future
Execution -> @VisibleForTesting 	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint);1516626397;Calculates the preferred locations based on the location preference constraint.__@param locationPreferenceConstraint constraint for the location preference_@return Future containing the collection of preferred locations. This might not be completed if not all inputs_have been a resource assigned.;@VisibleForTesting_	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {_		final Collection<CompletableFuture<TaskManagerLocation>> preferredLocationFutures = getVertex().getPreferredLocationsBasedOnInputs()__		final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture___		switch(locationPreferenceConstraint) {_			case ALL:_				preferredLocationsFuture = FutureUtils.combineAll(preferredLocationFutures)__				break__			case ANY:_				final ArrayList<TaskManagerLocation> completedTaskManagerLocations = new ArrayList<>(preferredLocationFutures.size())___				for (CompletableFuture<TaskManagerLocation> preferredLocationFuture : preferredLocationFutures) {_					if (preferredLocationFuture.isDone() && !preferredLocationFuture.isCompletedExceptionally()) {_						final TaskManagerLocation taskManagerLocation = preferredLocationFuture.getNow(null)___						if (taskManagerLocation == null) {_							throw new FlinkRuntimeException("TaskManagerLocationFuture was completed with null. This indicates a programming bug.")__						}__						completedTaskManagerLocations.add(taskManagerLocation)__					}_				}__				preferredLocationsFuture = CompletableFuture.completedFuture(completedTaskManagerLocations)__				break__			default:_				throw new RuntimeException("Unknown LocationPreferenceConstraint " + locationPreferenceConstraint + '.')__		}__		return preferredLocationsFuture__	};calculates,the,preferred,locations,based,on,the,location,preference,constraint,param,location,preference,constraint,constraint,for,the,location,preference,return,future,containing,the,collection,of,preferred,locations,this,might,not,be,completed,if,not,all,inputs,have,been,a,resource,assigned;visible,for,testing,public,completable,future,collection,task,manager,location,calculate,preferred,locations,location,preference,constraint,location,preference,constraint,final,collection,completable,future,task,manager,location,preferred,location,futures,get,vertex,get,preferred,locations,based,on,inputs,final,completable,future,collection,task,manager,location,preferred,locations,future,switch,location,preference,constraint,case,all,preferred,locations,future,future,utils,combine,all,preferred,location,futures,break,case,any,final,array,list,task,manager,location,completed,task,manager,locations,new,array,list,preferred,location,futures,size,for,completable,future,task,manager,location,preferred,location,future,preferred,location,futures,if,preferred,location,future,is,done,preferred,location,future,is,completed,exceptionally,final,task,manager,location,task,manager,location,preferred,location,future,get,now,null,if,task,manager,location,null,throw,new,flink,runtime,exception,task,manager,location,future,was,completed,with,null,this,indicates,a,programming,bug,completed,task,manager,locations,add,task,manager,location,preferred,locations,future,completable,future,completed,future,completed,task,manager,locations,break,default,throw,new,runtime,exception,unknown,location,preference,constraint,location,preference,constraint,return,preferred,locations,future
Execution -> @VisibleForTesting 	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint);1518680774;Calculates the preferred locations based on the location preference constraint.__@param locationPreferenceConstraint constraint for the location preference_@return Future containing the collection of preferred locations. This might not be completed if not all inputs_have been a resource assigned.;@VisibleForTesting_	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {_		final Collection<CompletableFuture<TaskManagerLocation>> preferredLocationFutures = getVertex().getPreferredLocationsBasedOnInputs()__		final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture___		switch(locationPreferenceConstraint) {_			case ALL:_				preferredLocationsFuture = FutureUtils.combineAll(preferredLocationFutures)__				break__			case ANY:_				final ArrayList<TaskManagerLocation> completedTaskManagerLocations = new ArrayList<>(preferredLocationFutures.size())___				for (CompletableFuture<TaskManagerLocation> preferredLocationFuture : preferredLocationFutures) {_					if (preferredLocationFuture.isDone() && !preferredLocationFuture.isCompletedExceptionally()) {_						final TaskManagerLocation taskManagerLocation = preferredLocationFuture.getNow(null)___						if (taskManagerLocation == null) {_							throw new FlinkRuntimeException("TaskManagerLocationFuture was completed with null. This indicates a programming bug.")__						}__						completedTaskManagerLocations.add(taskManagerLocation)__					}_				}__				preferredLocationsFuture = CompletableFuture.completedFuture(completedTaskManagerLocations)__				break__			default:_				throw new RuntimeException("Unknown LocationPreferenceConstraint " + locationPreferenceConstraint + '.')__		}__		return preferredLocationsFuture__	};calculates,the,preferred,locations,based,on,the,location,preference,constraint,param,location,preference,constraint,constraint,for,the,location,preference,return,future,containing,the,collection,of,preferred,locations,this,might,not,be,completed,if,not,all,inputs,have,been,a,resource,assigned;visible,for,testing,public,completable,future,collection,task,manager,location,calculate,preferred,locations,location,preference,constraint,location,preference,constraint,final,collection,completable,future,task,manager,location,preferred,location,futures,get,vertex,get,preferred,locations,based,on,inputs,final,completable,future,collection,task,manager,location,preferred,locations,future,switch,location,preference,constraint,case,all,preferred,locations,future,future,utils,combine,all,preferred,location,futures,break,case,any,final,array,list,task,manager,location,completed,task,manager,locations,new,array,list,preferred,location,futures,size,for,completable,future,task,manager,location,preferred,location,future,preferred,location,futures,if,preferred,location,future,is,done,preferred,location,future,is,completed,exceptionally,final,task,manager,location,task,manager,location,preferred,location,future,get,now,null,if,task,manager,location,null,throw,new,flink,runtime,exception,task,manager,location,future,was,completed,with,null,this,indicates,a,programming,bug,completed,task,manager,locations,add,task,manager,location,preferred,locations,future,completable,future,completed,future,completed,task,manager,locations,break,default,throw,new,runtime,exception,unknown,location,preference,constraint,location,preference,constraint,return,preferred,locations,future
Execution -> @VisibleForTesting 	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint);1518712478;Calculates the preferred locations based on the location preference constraint.__@param locationPreferenceConstraint constraint for the location preference_@return Future containing the collection of preferred locations. This might not be completed if not all inputs_have been a resource assigned.;@VisibleForTesting_	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {_		final Collection<CompletableFuture<TaskManagerLocation>> preferredLocationFutures = getVertex().getPreferredLocationsBasedOnInputs()__		final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture___		switch(locationPreferenceConstraint) {_			case ALL:_				preferredLocationsFuture = FutureUtils.combineAll(preferredLocationFutures)__				break__			case ANY:_				final ArrayList<TaskManagerLocation> completedTaskManagerLocations = new ArrayList<>(preferredLocationFutures.size())___				for (CompletableFuture<TaskManagerLocation> preferredLocationFuture : preferredLocationFutures) {_					if (preferredLocationFuture.isDone() && !preferredLocationFuture.isCompletedExceptionally()) {_						final TaskManagerLocation taskManagerLocation = preferredLocationFuture.getNow(null)___						if (taskManagerLocation == null) {_							throw new FlinkRuntimeException("TaskManagerLocationFuture was completed with null. This indicates a programming bug.")__						}__						completedTaskManagerLocations.add(taskManagerLocation)__					}_				}__				preferredLocationsFuture = CompletableFuture.completedFuture(completedTaskManagerLocations)__				break__			default:_				throw new RuntimeException("Unknown LocationPreferenceConstraint " + locationPreferenceConstraint + '.')__		}__		return preferredLocationsFuture__	};calculates,the,preferred,locations,based,on,the,location,preference,constraint,param,location,preference,constraint,constraint,for,the,location,preference,return,future,containing,the,collection,of,preferred,locations,this,might,not,be,completed,if,not,all,inputs,have,been,a,resource,assigned;visible,for,testing,public,completable,future,collection,task,manager,location,calculate,preferred,locations,location,preference,constraint,location,preference,constraint,final,collection,completable,future,task,manager,location,preferred,location,futures,get,vertex,get,preferred,locations,based,on,inputs,final,completable,future,collection,task,manager,location,preferred,locations,future,switch,location,preference,constraint,case,all,preferred,locations,future,future,utils,combine,all,preferred,location,futures,break,case,any,final,array,list,task,manager,location,completed,task,manager,locations,new,array,list,preferred,location,futures,size,for,completable,future,task,manager,location,preferred,location,future,preferred,location,futures,if,preferred,location,future,is,done,preferred,location,future,is,completed,exceptionally,final,task,manager,location,task,manager,location,preferred,location,future,get,now,null,if,task,manager,location,null,throw,new,flink,runtime,exception,task,manager,location,future,was,completed,with,null,this,indicates,a,programming,bug,completed,task,manager,locations,add,task,manager,location,preferred,locations,future,completable,future,completed,future,completed,task,manager,locations,break,default,throw,new,runtime,exception,unknown,location,preference,constraint,location,preference,constraint,return,preferred,locations,future
Execution -> @VisibleForTesting 	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint);1519316529;Calculates the preferred locations based on the location preference constraint.__@param locationPreferenceConstraint constraint for the location preference_@return Future containing the collection of preferred locations. This might not be completed if not all inputs_have been a resource assigned.;@VisibleForTesting_	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {_		final Collection<CompletableFuture<TaskManagerLocation>> preferredLocationFutures = getVertex().getPreferredLocationsBasedOnInputs()__		final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture___		switch(locationPreferenceConstraint) {_			case ALL:_				preferredLocationsFuture = FutureUtils.combineAll(preferredLocationFutures)__				break__			case ANY:_				final ArrayList<TaskManagerLocation> completedTaskManagerLocations = new ArrayList<>(preferredLocationFutures.size())___				for (CompletableFuture<TaskManagerLocation> preferredLocationFuture : preferredLocationFutures) {_					if (preferredLocationFuture.isDone() && !preferredLocationFuture.isCompletedExceptionally()) {_						final TaskManagerLocation taskManagerLocation = preferredLocationFuture.getNow(null)___						if (taskManagerLocation == null) {_							throw new FlinkRuntimeException("TaskManagerLocationFuture was completed with null. This indicates a programming bug.")__						}__						completedTaskManagerLocations.add(taskManagerLocation)__					}_				}__				preferredLocationsFuture = CompletableFuture.completedFuture(completedTaskManagerLocations)__				break__			default:_				throw new RuntimeException("Unknown LocationPreferenceConstraint " + locationPreferenceConstraint + '.')__		}__		return preferredLocationsFuture__	};calculates,the,preferred,locations,based,on,the,location,preference,constraint,param,location,preference,constraint,constraint,for,the,location,preference,return,future,containing,the,collection,of,preferred,locations,this,might,not,be,completed,if,not,all,inputs,have,been,a,resource,assigned;visible,for,testing,public,completable,future,collection,task,manager,location,calculate,preferred,locations,location,preference,constraint,location,preference,constraint,final,collection,completable,future,task,manager,location,preferred,location,futures,get,vertex,get,preferred,locations,based,on,inputs,final,completable,future,collection,task,manager,location,preferred,locations,future,switch,location,preference,constraint,case,all,preferred,locations,future,future,utils,combine,all,preferred,location,futures,break,case,any,final,array,list,task,manager,location,completed,task,manager,locations,new,array,list,preferred,location,futures,size,for,completable,future,task,manager,location,preferred,location,future,preferred,location,futures,if,preferred,location,future,is,done,preferred,location,future,is,completed,exceptionally,final,task,manager,location,task,manager,location,preferred,location,future,get,now,null,if,task,manager,location,null,throw,new,flink,runtime,exception,task,manager,location,future,was,completed,with,null,this,indicates,a,programming,bug,completed,task,manager,locations,add,task,manager,location,preferred,locations,future,completable,future,completed,future,completed,task,manager,locations,break,default,throw,new,runtime,exception,unknown,location,preference,constraint,location,preference,constraint,return,preferred,locations,future
Execution -> @VisibleForTesting 	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint);1519481114;Calculates the preferred locations based on the location preference constraint.__@param locationPreferenceConstraint constraint for the location preference_@return Future containing the collection of preferred locations. This might not be completed if not all inputs_have been a resource assigned.;@VisibleForTesting_	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {_		final Collection<CompletableFuture<TaskManagerLocation>> preferredLocationFutures = getVertex().getPreferredLocationsBasedOnInputs()__		final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture___		switch(locationPreferenceConstraint) {_			case ALL:_				preferredLocationsFuture = FutureUtils.combineAll(preferredLocationFutures)__				break__			case ANY:_				final ArrayList<TaskManagerLocation> completedTaskManagerLocations = new ArrayList<>(preferredLocationFutures.size())___				for (CompletableFuture<TaskManagerLocation> preferredLocationFuture : preferredLocationFutures) {_					if (preferredLocationFuture.isDone() && !preferredLocationFuture.isCompletedExceptionally()) {_						final TaskManagerLocation taskManagerLocation = preferredLocationFuture.getNow(null)___						if (taskManagerLocation == null) {_							throw new FlinkRuntimeException("TaskManagerLocationFuture was completed with null. This indicates a programming bug.")__						}__						completedTaskManagerLocations.add(taskManagerLocation)__					}_				}__				preferredLocationsFuture = CompletableFuture.completedFuture(completedTaskManagerLocations)__				break__			default:_				throw new RuntimeException("Unknown LocationPreferenceConstraint " + locationPreferenceConstraint + '.')__		}__		return preferredLocationsFuture__	};calculates,the,preferred,locations,based,on,the,location,preference,constraint,param,location,preference,constraint,constraint,for,the,location,preference,return,future,containing,the,collection,of,preferred,locations,this,might,not,be,completed,if,not,all,inputs,have,been,a,resource,assigned;visible,for,testing,public,completable,future,collection,task,manager,location,calculate,preferred,locations,location,preference,constraint,location,preference,constraint,final,collection,completable,future,task,manager,location,preferred,location,futures,get,vertex,get,preferred,locations,based,on,inputs,final,completable,future,collection,task,manager,location,preferred,locations,future,switch,location,preference,constraint,case,all,preferred,locations,future,future,utils,combine,all,preferred,location,futures,break,case,any,final,array,list,task,manager,location,completed,task,manager,locations,new,array,list,preferred,location,futures,size,for,completable,future,task,manager,location,preferred,location,future,preferred,location,futures,if,preferred,location,future,is,done,preferred,location,future,is,completed,exceptionally,final,task,manager,location,task,manager,location,preferred,location,future,get,now,null,if,task,manager,location,null,throw,new,flink,runtime,exception,task,manager,location,future,was,completed,with,null,this,indicates,a,programming,bug,completed,task,manager,locations,add,task,manager,location,preferred,locations,future,completable,future,completed,future,completed,task,manager,locations,break,default,throw,new,runtime,exception,unknown,location,preference,constraint,location,preference,constraint,return,preferred,locations,future
Execution -> @VisibleForTesting 	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint);1519568061;Calculates the preferred locations based on the location preference constraint.__@param locationPreferenceConstraint constraint for the location preference_@return Future containing the collection of preferred locations. This might not be completed if not all inputs_have been a resource assigned.;@VisibleForTesting_	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {_		final Collection<CompletableFuture<TaskManagerLocation>> preferredLocationFutures = getVertex().getPreferredLocations()__		final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture___		switch(locationPreferenceConstraint) {_			case ALL:_				preferredLocationsFuture = FutureUtils.combineAll(preferredLocationFutures)__				break__			case ANY:_				final ArrayList<TaskManagerLocation> completedTaskManagerLocations = new ArrayList<>(preferredLocationFutures.size())___				for (CompletableFuture<TaskManagerLocation> preferredLocationFuture : preferredLocationFutures) {_					if (preferredLocationFuture.isDone() && !preferredLocationFuture.isCompletedExceptionally()) {_						final TaskManagerLocation taskManagerLocation = preferredLocationFuture.getNow(null)___						if (taskManagerLocation == null) {_							throw new FlinkRuntimeException("TaskManagerLocationFuture was completed with null. This indicates a programming bug.")__						}__						completedTaskManagerLocations.add(taskManagerLocation)__					}_				}__				preferredLocationsFuture = CompletableFuture.completedFuture(completedTaskManagerLocations)__				break__			default:_				throw new RuntimeException("Unknown LocationPreferenceConstraint " + locationPreferenceConstraint + '.')__		}__		return preferredLocationsFuture__	};calculates,the,preferred,locations,based,on,the,location,preference,constraint,param,location,preference,constraint,constraint,for,the,location,preference,return,future,containing,the,collection,of,preferred,locations,this,might,not,be,completed,if,not,all,inputs,have,been,a,resource,assigned;visible,for,testing,public,completable,future,collection,task,manager,location,calculate,preferred,locations,location,preference,constraint,location,preference,constraint,final,collection,completable,future,task,manager,location,preferred,location,futures,get,vertex,get,preferred,locations,final,completable,future,collection,task,manager,location,preferred,locations,future,switch,location,preference,constraint,case,all,preferred,locations,future,future,utils,combine,all,preferred,location,futures,break,case,any,final,array,list,task,manager,location,completed,task,manager,locations,new,array,list,preferred,location,futures,size,for,completable,future,task,manager,location,preferred,location,future,preferred,location,futures,if,preferred,location,future,is,done,preferred,location,future,is,completed,exceptionally,final,task,manager,location,task,manager,location,preferred,location,future,get,now,null,if,task,manager,location,null,throw,new,flink,runtime,exception,task,manager,location,future,was,completed,with,null,this,indicates,a,programming,bug,completed,task,manager,locations,add,task,manager,location,preferred,locations,future,completable,future,completed,future,completed,task,manager,locations,break,default,throw,new,runtime,exception,unknown,location,preference,constraint,location,preference,constraint,return,preferred,locations,future
Execution -> @VisibleForTesting 	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint);1519655521;Calculates the preferred locations based on the location preference constraint.__@param locationPreferenceConstraint constraint for the location preference_@return Future containing the collection of preferred locations. This might not be completed if not all inputs_have been a resource assigned.;@VisibleForTesting_	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {_		final Collection<CompletableFuture<TaskManagerLocation>> preferredLocationFutures = getVertex().getPreferredLocations()__		final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture___		switch(locationPreferenceConstraint) {_			case ALL:_				preferredLocationsFuture = FutureUtils.combineAll(preferredLocationFutures)__				break__			case ANY:_				final ArrayList<TaskManagerLocation> completedTaskManagerLocations = new ArrayList<>(preferredLocationFutures.size())___				for (CompletableFuture<TaskManagerLocation> preferredLocationFuture : preferredLocationFutures) {_					if (preferredLocationFuture.isDone() && !preferredLocationFuture.isCompletedExceptionally()) {_						final TaskManagerLocation taskManagerLocation = preferredLocationFuture.getNow(null)___						if (taskManagerLocation == null) {_							throw new FlinkRuntimeException("TaskManagerLocationFuture was completed with null. This indicates a programming bug.")__						}__						completedTaskManagerLocations.add(taskManagerLocation)__					}_				}__				preferredLocationsFuture = CompletableFuture.completedFuture(completedTaskManagerLocations)__				break__			default:_				throw new RuntimeException("Unknown LocationPreferenceConstraint " + locationPreferenceConstraint + '.')__		}__		return preferredLocationsFuture__	};calculates,the,preferred,locations,based,on,the,location,preference,constraint,param,location,preference,constraint,constraint,for,the,location,preference,return,future,containing,the,collection,of,preferred,locations,this,might,not,be,completed,if,not,all,inputs,have,been,a,resource,assigned;visible,for,testing,public,completable,future,collection,task,manager,location,calculate,preferred,locations,location,preference,constraint,location,preference,constraint,final,collection,completable,future,task,manager,location,preferred,location,futures,get,vertex,get,preferred,locations,final,completable,future,collection,task,manager,location,preferred,locations,future,switch,location,preference,constraint,case,all,preferred,locations,future,future,utils,combine,all,preferred,location,futures,break,case,any,final,array,list,task,manager,location,completed,task,manager,locations,new,array,list,preferred,location,futures,size,for,completable,future,task,manager,location,preferred,location,future,preferred,location,futures,if,preferred,location,future,is,done,preferred,location,future,is,completed,exceptionally,final,task,manager,location,task,manager,location,preferred,location,future,get,now,null,if,task,manager,location,null,throw,new,flink,runtime,exception,task,manager,location,future,was,completed,with,null,this,indicates,a,programming,bug,completed,task,manager,locations,add,task,manager,location,preferred,locations,future,completable,future,completed,future,completed,task,manager,locations,break,default,throw,new,runtime,exception,unknown,location,preference,constraint,location,preference,constraint,return,preferred,locations,future
Execution -> @VisibleForTesting 	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint);1522049586;Calculates the preferred locations based on the location preference constraint.__@param locationPreferenceConstraint constraint for the location preference_@return Future containing the collection of preferred locations. This might not be completed if not all inputs_have been a resource assigned.;@VisibleForTesting_	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {_		final Collection<CompletableFuture<TaskManagerLocation>> preferredLocationFutures = getVertex().getPreferredLocations()__		final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture___		switch(locationPreferenceConstraint) {_			case ALL:_				preferredLocationsFuture = FutureUtils.combineAll(preferredLocationFutures)__				break__			case ANY:_				final ArrayList<TaskManagerLocation> completedTaskManagerLocations = new ArrayList<>(preferredLocationFutures.size())___				for (CompletableFuture<TaskManagerLocation> preferredLocationFuture : preferredLocationFutures) {_					if (preferredLocationFuture.isDone() && !preferredLocationFuture.isCompletedExceptionally()) {_						final TaskManagerLocation taskManagerLocation = preferredLocationFuture.getNow(null)___						if (taskManagerLocation == null) {_							throw new FlinkRuntimeException("TaskManagerLocationFuture was completed with null. This indicates a programming bug.")__						}__						completedTaskManagerLocations.add(taskManagerLocation)__					}_				}__				preferredLocationsFuture = CompletableFuture.completedFuture(completedTaskManagerLocations)__				break__			default:_				throw new RuntimeException("Unknown LocationPreferenceConstraint " + locationPreferenceConstraint + '.')__		}__		return preferredLocationsFuture__	};calculates,the,preferred,locations,based,on,the,location,preference,constraint,param,location,preference,constraint,constraint,for,the,location,preference,return,future,containing,the,collection,of,preferred,locations,this,might,not,be,completed,if,not,all,inputs,have,been,a,resource,assigned;visible,for,testing,public,completable,future,collection,task,manager,location,calculate,preferred,locations,location,preference,constraint,location,preference,constraint,final,collection,completable,future,task,manager,location,preferred,location,futures,get,vertex,get,preferred,locations,final,completable,future,collection,task,manager,location,preferred,locations,future,switch,location,preference,constraint,case,all,preferred,locations,future,future,utils,combine,all,preferred,location,futures,break,case,any,final,array,list,task,manager,location,completed,task,manager,locations,new,array,list,preferred,location,futures,size,for,completable,future,task,manager,location,preferred,location,future,preferred,location,futures,if,preferred,location,future,is,done,preferred,location,future,is,completed,exceptionally,final,task,manager,location,task,manager,location,preferred,location,future,get,now,null,if,task,manager,location,null,throw,new,flink,runtime,exception,task,manager,location,future,was,completed,with,null,this,indicates,a,programming,bug,completed,task,manager,locations,add,task,manager,location,preferred,locations,future,completable,future,completed,future,completed,task,manager,locations,break,default,throw,new,runtime,exception,unknown,location,preference,constraint,location,preference,constraint,return,preferred,locations,future
Execution -> @VisibleForTesting 	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint);1522249273;Calculates the preferred locations based on the location preference constraint.__@param locationPreferenceConstraint constraint for the location preference_@return Future containing the collection of preferred locations. This might not be completed if not all inputs_have been a resource assigned.;@VisibleForTesting_	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {_		final Collection<CompletableFuture<TaskManagerLocation>> preferredLocationFutures = getVertex().getPreferredLocations()__		final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture___		switch(locationPreferenceConstraint) {_			case ALL:_				preferredLocationsFuture = FutureUtils.combineAll(preferredLocationFutures)__				break__			case ANY:_				final ArrayList<TaskManagerLocation> completedTaskManagerLocations = new ArrayList<>(preferredLocationFutures.size())___				for (CompletableFuture<TaskManagerLocation> preferredLocationFuture : preferredLocationFutures) {_					if (preferredLocationFuture.isDone() && !preferredLocationFuture.isCompletedExceptionally()) {_						final TaskManagerLocation taskManagerLocation = preferredLocationFuture.getNow(null)___						if (taskManagerLocation == null) {_							throw new FlinkRuntimeException("TaskManagerLocationFuture was completed with null. This indicates a programming bug.")__						}__						completedTaskManagerLocations.add(taskManagerLocation)__					}_				}__				preferredLocationsFuture = CompletableFuture.completedFuture(completedTaskManagerLocations)__				break__			default:_				throw new RuntimeException("Unknown LocationPreferenceConstraint " + locationPreferenceConstraint + '.')__		}__		return preferredLocationsFuture__	};calculates,the,preferred,locations,based,on,the,location,preference,constraint,param,location,preference,constraint,constraint,for,the,location,preference,return,future,containing,the,collection,of,preferred,locations,this,might,not,be,completed,if,not,all,inputs,have,been,a,resource,assigned;visible,for,testing,public,completable,future,collection,task,manager,location,calculate,preferred,locations,location,preference,constraint,location,preference,constraint,final,collection,completable,future,task,manager,location,preferred,location,futures,get,vertex,get,preferred,locations,final,completable,future,collection,task,manager,location,preferred,locations,future,switch,location,preference,constraint,case,all,preferred,locations,future,future,utils,combine,all,preferred,location,futures,break,case,any,final,array,list,task,manager,location,completed,task,manager,locations,new,array,list,preferred,location,futures,size,for,completable,future,task,manager,location,preferred,location,future,preferred,location,futures,if,preferred,location,future,is,done,preferred,location,future,is,completed,exceptionally,final,task,manager,location,task,manager,location,preferred,location,future,get,now,null,if,task,manager,location,null,throw,new,flink,runtime,exception,task,manager,location,future,was,completed,with,null,this,indicates,a,programming,bug,completed,task,manager,locations,add,task,manager,location,preferred,locations,future,completable,future,completed,future,completed,task,manager,locations,break,default,throw,new,runtime,exception,unknown,location,preference,constraint,location,preference,constraint,return,preferred,locations,future
Execution -> @VisibleForTesting 	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint);1530712207;Calculates the preferred locations based on the location preference constraint.__@param locationPreferenceConstraint constraint for the location preference_@return Future containing the collection of preferred locations. This might not be completed if not all inputs_have been a resource assigned.;@VisibleForTesting_	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {_		final Collection<CompletableFuture<TaskManagerLocation>> preferredLocationFutures = getVertex().getPreferredLocations()__		final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture___		switch(locationPreferenceConstraint) {_			case ALL:_				preferredLocationsFuture = FutureUtils.combineAll(preferredLocationFutures)__				break__			case ANY:_				final ArrayList<TaskManagerLocation> completedTaskManagerLocations = new ArrayList<>(preferredLocationFutures.size())___				for (CompletableFuture<TaskManagerLocation> preferredLocationFuture : preferredLocationFutures) {_					if (preferredLocationFuture.isDone() && !preferredLocationFuture.isCompletedExceptionally()) {_						final TaskManagerLocation taskManagerLocation = preferredLocationFuture.getNow(null)___						if (taskManagerLocation == null) {_							throw new FlinkRuntimeException("TaskManagerLocationFuture was completed with null. This indicates a programming bug.")__						}__						completedTaskManagerLocations.add(taskManagerLocation)__					}_				}__				preferredLocationsFuture = CompletableFuture.completedFuture(completedTaskManagerLocations)__				break__			default:_				throw new RuntimeException("Unknown LocationPreferenceConstraint " + locationPreferenceConstraint + '.')__		}__		return preferredLocationsFuture__	};calculates,the,preferred,locations,based,on,the,location,preference,constraint,param,location,preference,constraint,constraint,for,the,location,preference,return,future,containing,the,collection,of,preferred,locations,this,might,not,be,completed,if,not,all,inputs,have,been,a,resource,assigned;visible,for,testing,public,completable,future,collection,task,manager,location,calculate,preferred,locations,location,preference,constraint,location,preference,constraint,final,collection,completable,future,task,manager,location,preferred,location,futures,get,vertex,get,preferred,locations,final,completable,future,collection,task,manager,location,preferred,locations,future,switch,location,preference,constraint,case,all,preferred,locations,future,future,utils,combine,all,preferred,location,futures,break,case,any,final,array,list,task,manager,location,completed,task,manager,locations,new,array,list,preferred,location,futures,size,for,completable,future,task,manager,location,preferred,location,future,preferred,location,futures,if,preferred,location,future,is,done,preferred,location,future,is,completed,exceptionally,final,task,manager,location,task,manager,location,preferred,location,future,get,now,null,if,task,manager,location,null,throw,new,flink,runtime,exception,task,manager,location,future,was,completed,with,null,this,indicates,a,programming,bug,completed,task,manager,locations,add,task,manager,location,preferred,locations,future,completable,future,completed,future,completed,task,manager,locations,break,default,throw,new,runtime,exception,unknown,location,preference,constraint,location,preference,constraint,return,preferred,locations,future
Execution -> @VisibleForTesting 	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint);1532383539;Calculates the preferred locations based on the location preference constraint.__@param locationPreferenceConstraint constraint for the location preference_@return Future containing the collection of preferred locations. This might not be completed if not all inputs_have been a resource assigned.;@VisibleForTesting_	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {_		final Collection<CompletableFuture<TaskManagerLocation>> preferredLocationFutures = getVertex().getPreferredLocations()__		final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture___		switch(locationPreferenceConstraint) {_			case ALL:_				preferredLocationsFuture = FutureUtils.combineAll(preferredLocationFutures)__				break__			case ANY:_				final ArrayList<TaskManagerLocation> completedTaskManagerLocations = new ArrayList<>(preferredLocationFutures.size())___				for (CompletableFuture<TaskManagerLocation> preferredLocationFuture : preferredLocationFutures) {_					if (preferredLocationFuture.isDone() && !preferredLocationFuture.isCompletedExceptionally()) {_						final TaskManagerLocation taskManagerLocation = preferredLocationFuture.getNow(null)___						if (taskManagerLocation == null) {_							throw new FlinkRuntimeException("TaskManagerLocationFuture was completed with null. This indicates a programming bug.")__						}__						completedTaskManagerLocations.add(taskManagerLocation)__					}_				}__				preferredLocationsFuture = CompletableFuture.completedFuture(completedTaskManagerLocations)__				break__			default:_				throw new RuntimeException("Unknown LocationPreferenceConstraint " + locationPreferenceConstraint + '.')__		}__		return preferredLocationsFuture__	};calculates,the,preferred,locations,based,on,the,location,preference,constraint,param,location,preference,constraint,constraint,for,the,location,preference,return,future,containing,the,collection,of,preferred,locations,this,might,not,be,completed,if,not,all,inputs,have,been,a,resource,assigned;visible,for,testing,public,completable,future,collection,task,manager,location,calculate,preferred,locations,location,preference,constraint,location,preference,constraint,final,collection,completable,future,task,manager,location,preferred,location,futures,get,vertex,get,preferred,locations,final,completable,future,collection,task,manager,location,preferred,locations,future,switch,location,preference,constraint,case,all,preferred,locations,future,future,utils,combine,all,preferred,location,futures,break,case,any,final,array,list,task,manager,location,completed,task,manager,locations,new,array,list,preferred,location,futures,size,for,completable,future,task,manager,location,preferred,location,future,preferred,location,futures,if,preferred,location,future,is,done,preferred,location,future,is,completed,exceptionally,final,task,manager,location,task,manager,location,preferred,location,future,get,now,null,if,task,manager,location,null,throw,new,flink,runtime,exception,task,manager,location,future,was,completed,with,null,this,indicates,a,programming,bug,completed,task,manager,locations,add,task,manager,location,preferred,locations,future,completable,future,completed,future,completed,task,manager,locations,break,default,throw,new,runtime,exception,unknown,location,preference,constraint,location,preference,constraint,return,preferred,locations,future
Execution -> @VisibleForTesting 	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint);1532383539;Calculates the preferred locations based on the location preference constraint.__@param locationPreferenceConstraint constraint for the location preference_@return Future containing the collection of preferred locations. This might not be completed if not all inputs_have been a resource assigned.;@VisibleForTesting_	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {_		final Collection<CompletableFuture<TaskManagerLocation>> preferredLocationFutures = getVertex().getPreferredLocations()__		final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture___		switch(locationPreferenceConstraint) {_			case ALL:_				preferredLocationsFuture = FutureUtils.combineAll(preferredLocationFutures)__				break__			case ANY:_				final ArrayList<TaskManagerLocation> completedTaskManagerLocations = new ArrayList<>(preferredLocationFutures.size())___				for (CompletableFuture<TaskManagerLocation> preferredLocationFuture : preferredLocationFutures) {_					if (preferredLocationFuture.isDone() && !preferredLocationFuture.isCompletedExceptionally()) {_						final TaskManagerLocation taskManagerLocation = preferredLocationFuture.getNow(null)___						if (taskManagerLocation == null) {_							throw new FlinkRuntimeException("TaskManagerLocationFuture was completed with null. This indicates a programming bug.")__						}__						completedTaskManagerLocations.add(taskManagerLocation)__					}_				}__				preferredLocationsFuture = CompletableFuture.completedFuture(completedTaskManagerLocations)__				break__			default:_				throw new RuntimeException("Unknown LocationPreferenceConstraint " + locationPreferenceConstraint + '.')__		}__		return preferredLocationsFuture__	};calculates,the,preferred,locations,based,on,the,location,preference,constraint,param,location,preference,constraint,constraint,for,the,location,preference,return,future,containing,the,collection,of,preferred,locations,this,might,not,be,completed,if,not,all,inputs,have,been,a,resource,assigned;visible,for,testing,public,completable,future,collection,task,manager,location,calculate,preferred,locations,location,preference,constraint,location,preference,constraint,final,collection,completable,future,task,manager,location,preferred,location,futures,get,vertex,get,preferred,locations,final,completable,future,collection,task,manager,location,preferred,locations,future,switch,location,preference,constraint,case,all,preferred,locations,future,future,utils,combine,all,preferred,location,futures,break,case,any,final,array,list,task,manager,location,completed,task,manager,locations,new,array,list,preferred,location,futures,size,for,completable,future,task,manager,location,preferred,location,future,preferred,location,futures,if,preferred,location,future,is,done,preferred,location,future,is,completed,exceptionally,final,task,manager,location,task,manager,location,preferred,location,future,get,now,null,if,task,manager,location,null,throw,new,flink,runtime,exception,task,manager,location,future,was,completed,with,null,this,indicates,a,programming,bug,completed,task,manager,locations,add,task,manager,location,preferred,locations,future,completable,future,completed,future,completed,task,manager,locations,break,default,throw,new,runtime,exception,unknown,location,preference,constraint,location,preference,constraint,return,preferred,locations,future
Execution -> @VisibleForTesting 	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint);1532383539;Calculates the preferred locations based on the location preference constraint.__@param locationPreferenceConstraint constraint for the location preference_@return Future containing the collection of preferred locations. This might not be completed if not all inputs_have been a resource assigned.;@VisibleForTesting_	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {_		final Collection<CompletableFuture<TaskManagerLocation>> preferredLocationFutures = getVertex().getPreferredLocations()__		final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture___		switch(locationPreferenceConstraint) {_			case ALL:_				preferredLocationsFuture = FutureUtils.combineAll(preferredLocationFutures)__				break__			case ANY:_				final ArrayList<TaskManagerLocation> completedTaskManagerLocations = new ArrayList<>(preferredLocationFutures.size())___				for (CompletableFuture<TaskManagerLocation> preferredLocationFuture : preferredLocationFutures) {_					if (preferredLocationFuture.isDone() && !preferredLocationFuture.isCompletedExceptionally()) {_						final TaskManagerLocation taskManagerLocation = preferredLocationFuture.getNow(null)___						if (taskManagerLocation == null) {_							throw new FlinkRuntimeException("TaskManagerLocationFuture was completed with null. This indicates a programming bug.")__						}__						completedTaskManagerLocations.add(taskManagerLocation)__					}_				}__				preferredLocationsFuture = CompletableFuture.completedFuture(completedTaskManagerLocations)__				break__			default:_				throw new RuntimeException("Unknown LocationPreferenceConstraint " + locationPreferenceConstraint + '.')__		}__		return preferredLocationsFuture__	};calculates,the,preferred,locations,based,on,the,location,preference,constraint,param,location,preference,constraint,constraint,for,the,location,preference,return,future,containing,the,collection,of,preferred,locations,this,might,not,be,completed,if,not,all,inputs,have,been,a,resource,assigned;visible,for,testing,public,completable,future,collection,task,manager,location,calculate,preferred,locations,location,preference,constraint,location,preference,constraint,final,collection,completable,future,task,manager,location,preferred,location,futures,get,vertex,get,preferred,locations,final,completable,future,collection,task,manager,location,preferred,locations,future,switch,location,preference,constraint,case,all,preferred,locations,future,future,utils,combine,all,preferred,location,futures,break,case,any,final,array,list,task,manager,location,completed,task,manager,locations,new,array,list,preferred,location,futures,size,for,completable,future,task,manager,location,preferred,location,future,preferred,location,futures,if,preferred,location,future,is,done,preferred,location,future,is,completed,exceptionally,final,task,manager,location,task,manager,location,preferred,location,future,get,now,null,if,task,manager,location,null,throw,new,flink,runtime,exception,task,manager,location,future,was,completed,with,null,this,indicates,a,programming,bug,completed,task,manager,locations,add,task,manager,location,preferred,locations,future,completable,future,completed,future,completed,task,manager,locations,break,default,throw,new,runtime,exception,unknown,location,preference,constraint,location,preference,constraint,return,preferred,locations,future
Execution -> @VisibleForTesting 	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint);1540920690;Calculates the preferred locations based on the location preference constraint.__@param locationPreferenceConstraint constraint for the location preference_@return Future containing the collection of preferred locations. This might not be completed if not all inputs_have been a resource assigned.;@VisibleForTesting_	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {_		final Collection<CompletableFuture<TaskManagerLocation>> preferredLocationFutures = getVertex().getPreferredLocations()__		final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture___		switch(locationPreferenceConstraint) {_			case ALL:_				preferredLocationsFuture = FutureUtils.combineAll(preferredLocationFutures)__				break__			case ANY:_				final ArrayList<TaskManagerLocation> completedTaskManagerLocations = new ArrayList<>(preferredLocationFutures.size())___				for (CompletableFuture<TaskManagerLocation> preferredLocationFuture : preferredLocationFutures) {_					if (preferredLocationFuture.isDone() && !preferredLocationFuture.isCompletedExceptionally()) {_						final TaskManagerLocation taskManagerLocation = preferredLocationFuture.getNow(null)___						if (taskManagerLocation == null) {_							throw new FlinkRuntimeException("TaskManagerLocationFuture was completed with null. This indicates a programming bug.")__						}__						completedTaskManagerLocations.add(taskManagerLocation)__					}_				}__				preferredLocationsFuture = CompletableFuture.completedFuture(completedTaskManagerLocations)__				break__			default:_				throw new RuntimeException("Unknown LocationPreferenceConstraint " + locationPreferenceConstraint + '.')__		}__		return preferredLocationsFuture__	};calculates,the,preferred,locations,based,on,the,location,preference,constraint,param,location,preference,constraint,constraint,for,the,location,preference,return,future,containing,the,collection,of,preferred,locations,this,might,not,be,completed,if,not,all,inputs,have,been,a,resource,assigned;visible,for,testing,public,completable,future,collection,task,manager,location,calculate,preferred,locations,location,preference,constraint,location,preference,constraint,final,collection,completable,future,task,manager,location,preferred,location,futures,get,vertex,get,preferred,locations,final,completable,future,collection,task,manager,location,preferred,locations,future,switch,location,preference,constraint,case,all,preferred,locations,future,future,utils,combine,all,preferred,location,futures,break,case,any,final,array,list,task,manager,location,completed,task,manager,locations,new,array,list,preferred,location,futures,size,for,completable,future,task,manager,location,preferred,location,future,preferred,location,futures,if,preferred,location,future,is,done,preferred,location,future,is,completed,exceptionally,final,task,manager,location,task,manager,location,preferred,location,future,get,now,null,if,task,manager,location,null,throw,new,flink,runtime,exception,task,manager,location,future,was,completed,with,null,this,indicates,a,programming,bug,completed,task,manager,locations,add,task,manager,location,preferred,locations,future,completable,future,completed,future,completed,task,manager,locations,break,default,throw,new,runtime,exception,unknown,location,preference,constraint,location,preference,constraint,return,preferred,locations,future
Execution -> @VisibleForTesting 	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint);1542356428;Calculates the preferred locations based on the location preference constraint.__@param locationPreferenceConstraint constraint for the location preference_@return Future containing the collection of preferred locations. This might not be completed if not all inputs_have been a resource assigned.;@VisibleForTesting_	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {_		final Collection<CompletableFuture<TaskManagerLocation>> preferredLocationFutures = getVertex().getPreferredLocations()__		final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture___		switch(locationPreferenceConstraint) {_			case ALL:_				preferredLocationsFuture = FutureUtils.combineAll(preferredLocationFutures)__				break__			case ANY:_				final ArrayList<TaskManagerLocation> completedTaskManagerLocations = new ArrayList<>(preferredLocationFutures.size())___				for (CompletableFuture<TaskManagerLocation> preferredLocationFuture : preferredLocationFutures) {_					if (preferredLocationFuture.isDone() && !preferredLocationFuture.isCompletedExceptionally()) {_						final TaskManagerLocation taskManagerLocation = preferredLocationFuture.getNow(null)___						if (taskManagerLocation == null) {_							throw new FlinkRuntimeException("TaskManagerLocationFuture was completed with null. This indicates a programming bug.")__						}__						completedTaskManagerLocations.add(taskManagerLocation)__					}_				}__				preferredLocationsFuture = CompletableFuture.completedFuture(completedTaskManagerLocations)__				break__			default:_				throw new RuntimeException("Unknown LocationPreferenceConstraint " + locationPreferenceConstraint + '.')__		}__		return preferredLocationsFuture__	};calculates,the,preferred,locations,based,on,the,location,preference,constraint,param,location,preference,constraint,constraint,for,the,location,preference,return,future,containing,the,collection,of,preferred,locations,this,might,not,be,completed,if,not,all,inputs,have,been,a,resource,assigned;visible,for,testing,public,completable,future,collection,task,manager,location,calculate,preferred,locations,location,preference,constraint,location,preference,constraint,final,collection,completable,future,task,manager,location,preferred,location,futures,get,vertex,get,preferred,locations,final,completable,future,collection,task,manager,location,preferred,locations,future,switch,location,preference,constraint,case,all,preferred,locations,future,future,utils,combine,all,preferred,location,futures,break,case,any,final,array,list,task,manager,location,completed,task,manager,locations,new,array,list,preferred,location,futures,size,for,completable,future,task,manager,location,preferred,location,future,preferred,location,futures,if,preferred,location,future,is,done,preferred,location,future,is,completed,exceptionally,final,task,manager,location,task,manager,location,preferred,location,future,get,now,null,if,task,manager,location,null,throw,new,flink,runtime,exception,task,manager,location,future,was,completed,with,null,this,indicates,a,programming,bug,completed,task,manager,locations,add,task,manager,location,preferred,locations,future,completable,future,completed,future,completed,task,manager,locations,break,default,throw,new,runtime,exception,unknown,location,preference,constraint,location,preference,constraint,return,preferred,locations,future
Execution -> @VisibleForTesting 	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint);1546870832;Calculates the preferred locations based on the location preference constraint.__@param locationPreferenceConstraint constraint for the location preference_@return Future containing the collection of preferred locations. This might not be completed if not all inputs_have been a resource assigned.;@VisibleForTesting_	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {_		final Collection<CompletableFuture<TaskManagerLocation>> preferredLocationFutures = getVertex().getPreferredLocations()__		final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture___		switch(locationPreferenceConstraint) {_			case ALL:_				preferredLocationsFuture = FutureUtils.combineAll(preferredLocationFutures)__				break__			case ANY:_				final ArrayList<TaskManagerLocation> completedTaskManagerLocations = new ArrayList<>(preferredLocationFutures.size())___				for (CompletableFuture<TaskManagerLocation> preferredLocationFuture : preferredLocationFutures) {_					if (preferredLocationFuture.isDone() && !preferredLocationFuture.isCompletedExceptionally()) {_						final TaskManagerLocation taskManagerLocation = preferredLocationFuture.getNow(null)___						if (taskManagerLocation == null) {_							throw new FlinkRuntimeException("TaskManagerLocationFuture was completed with null. This indicates a programming bug.")__						}__						completedTaskManagerLocations.add(taskManagerLocation)__					}_				}__				preferredLocationsFuture = CompletableFuture.completedFuture(completedTaskManagerLocations)__				break__			default:_				throw new RuntimeException("Unknown LocationPreferenceConstraint " + locationPreferenceConstraint + '.')__		}__		return preferredLocationsFuture__	};calculates,the,preferred,locations,based,on,the,location,preference,constraint,param,location,preference,constraint,constraint,for,the,location,preference,return,future,containing,the,collection,of,preferred,locations,this,might,not,be,completed,if,not,all,inputs,have,been,a,resource,assigned;visible,for,testing,public,completable,future,collection,task,manager,location,calculate,preferred,locations,location,preference,constraint,location,preference,constraint,final,collection,completable,future,task,manager,location,preferred,location,futures,get,vertex,get,preferred,locations,final,completable,future,collection,task,manager,location,preferred,locations,future,switch,location,preference,constraint,case,all,preferred,locations,future,future,utils,combine,all,preferred,location,futures,break,case,any,final,array,list,task,manager,location,completed,task,manager,locations,new,array,list,preferred,location,futures,size,for,completable,future,task,manager,location,preferred,location,future,preferred,location,futures,if,preferred,location,future,is,done,preferred,location,future,is,completed,exceptionally,final,task,manager,location,task,manager,location,preferred,location,future,get,now,null,if,task,manager,location,null,throw,new,flink,runtime,exception,task,manager,location,future,was,completed,with,null,this,indicates,a,programming,bug,completed,task,manager,locations,add,task,manager,location,preferred,locations,future,completable,future,completed,future,completed,task,manager,locations,break,default,throw,new,runtime,exception,unknown,location,preference,constraint,location,preference,constraint,return,preferred,locations,future
Execution -> @VisibleForTesting 	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint);1547644408;Calculates the preferred locations based on the location preference constraint.__@param locationPreferenceConstraint constraint for the location preference_@return Future containing the collection of preferred locations. This might not be completed if not all inputs_have been a resource assigned.;@VisibleForTesting_	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {_		final Collection<CompletableFuture<TaskManagerLocation>> preferredLocationFutures = getVertex().getPreferredLocations()__		final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture___		switch(locationPreferenceConstraint) {_			case ALL:_				preferredLocationsFuture = FutureUtils.combineAll(preferredLocationFutures)__				break__			case ANY:_				final ArrayList<TaskManagerLocation> completedTaskManagerLocations = new ArrayList<>(preferredLocationFutures.size())___				for (CompletableFuture<TaskManagerLocation> preferredLocationFuture : preferredLocationFutures) {_					if (preferredLocationFuture.isDone() && !preferredLocationFuture.isCompletedExceptionally()) {_						final TaskManagerLocation taskManagerLocation = preferredLocationFuture.getNow(null)___						if (taskManagerLocation == null) {_							throw new FlinkRuntimeException("TaskManagerLocationFuture was completed with null. This indicates a programming bug.")__						}__						completedTaskManagerLocations.add(taskManagerLocation)__					}_				}__				preferredLocationsFuture = CompletableFuture.completedFuture(completedTaskManagerLocations)__				break__			default:_				throw new RuntimeException("Unknown LocationPreferenceConstraint " + locationPreferenceConstraint + '.')__		}__		return preferredLocationsFuture__	};calculates,the,preferred,locations,based,on,the,location,preference,constraint,param,location,preference,constraint,constraint,for,the,location,preference,return,future,containing,the,collection,of,preferred,locations,this,might,not,be,completed,if,not,all,inputs,have,been,a,resource,assigned;visible,for,testing,public,completable,future,collection,task,manager,location,calculate,preferred,locations,location,preference,constraint,location,preference,constraint,final,collection,completable,future,task,manager,location,preferred,location,futures,get,vertex,get,preferred,locations,final,completable,future,collection,task,manager,location,preferred,locations,future,switch,location,preference,constraint,case,all,preferred,locations,future,future,utils,combine,all,preferred,location,futures,break,case,any,final,array,list,task,manager,location,completed,task,manager,locations,new,array,list,preferred,location,futures,size,for,completable,future,task,manager,location,preferred,location,future,preferred,location,futures,if,preferred,location,future,is,done,preferred,location,future,is,completed,exceptionally,final,task,manager,location,task,manager,location,preferred,location,future,get,now,null,if,task,manager,location,null,throw,new,flink,runtime,exception,task,manager,location,future,was,completed,with,null,this,indicates,a,programming,bug,completed,task,manager,locations,add,task,manager,location,preferred,locations,future,completable,future,completed,future,completed,task,manager,locations,break,default,throw,new,runtime,exception,unknown,location,preference,constraint,location,preference,constraint,return,preferred,locations,future
Execution -> @VisibleForTesting 	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint);1549365080;Calculates the preferred locations based on the location preference constraint.__@param locationPreferenceConstraint constraint for the location preference_@return Future containing the collection of preferred locations. This might not be completed if not all inputs_have been a resource assigned.;@VisibleForTesting_	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {_		final Collection<CompletableFuture<TaskManagerLocation>> preferredLocationFutures = getVertex().getPreferredLocations()__		final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture___		switch(locationPreferenceConstraint) {_			case ALL:_				preferredLocationsFuture = FutureUtils.combineAll(preferredLocationFutures)__				break__			case ANY:_				final ArrayList<TaskManagerLocation> completedTaskManagerLocations = new ArrayList<>(preferredLocationFutures.size())___				for (CompletableFuture<TaskManagerLocation> preferredLocationFuture : preferredLocationFutures) {_					if (preferredLocationFuture.isDone() && !preferredLocationFuture.isCompletedExceptionally()) {_						final TaskManagerLocation taskManagerLocation = preferredLocationFuture.getNow(null)___						if (taskManagerLocation == null) {_							throw new FlinkRuntimeException("TaskManagerLocationFuture was completed with null. This indicates a programming bug.")__						}__						completedTaskManagerLocations.add(taskManagerLocation)__					}_				}__				preferredLocationsFuture = CompletableFuture.completedFuture(completedTaskManagerLocations)__				break__			default:_				throw new RuntimeException("Unknown LocationPreferenceConstraint " + locationPreferenceConstraint + '.')__		}__		return preferredLocationsFuture__	};calculates,the,preferred,locations,based,on,the,location,preference,constraint,param,location,preference,constraint,constraint,for,the,location,preference,return,future,containing,the,collection,of,preferred,locations,this,might,not,be,completed,if,not,all,inputs,have,been,a,resource,assigned;visible,for,testing,public,completable,future,collection,task,manager,location,calculate,preferred,locations,location,preference,constraint,location,preference,constraint,final,collection,completable,future,task,manager,location,preferred,location,futures,get,vertex,get,preferred,locations,final,completable,future,collection,task,manager,location,preferred,locations,future,switch,location,preference,constraint,case,all,preferred,locations,future,future,utils,combine,all,preferred,location,futures,break,case,any,final,array,list,task,manager,location,completed,task,manager,locations,new,array,list,preferred,location,futures,size,for,completable,future,task,manager,location,preferred,location,future,preferred,location,futures,if,preferred,location,future,is,done,preferred,location,future,is,completed,exceptionally,final,task,manager,location,task,manager,location,preferred,location,future,get,now,null,if,task,manager,location,null,throw,new,flink,runtime,exception,task,manager,location,future,was,completed,with,null,this,indicates,a,programming,bug,completed,task,manager,locations,add,task,manager,location,preferred,locations,future,completable,future,completed,future,completed,task,manager,locations,break,default,throw,new,runtime,exception,unknown,location,preference,constraint,location,preference,constraint,return,preferred,locations,future
Execution -> @VisibleForTesting 	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint);1550220073;Calculates the preferred locations based on the location preference constraint.__@param locationPreferenceConstraint constraint for the location preference_@return Future containing the collection of preferred locations. This might not be completed if not all inputs_have been a resource assigned.;@VisibleForTesting_	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {_		final Collection<CompletableFuture<TaskManagerLocation>> preferredLocationFutures = getVertex().getPreferredLocations()__		final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture___		switch(locationPreferenceConstraint) {_			case ALL:_				preferredLocationsFuture = FutureUtils.combineAll(preferredLocationFutures)__				break__			case ANY:_				final ArrayList<TaskManagerLocation> completedTaskManagerLocations = new ArrayList<>(preferredLocationFutures.size())___				for (CompletableFuture<TaskManagerLocation> preferredLocationFuture : preferredLocationFutures) {_					if (preferredLocationFuture.isDone() && !preferredLocationFuture.isCompletedExceptionally()) {_						final TaskManagerLocation taskManagerLocation = preferredLocationFuture.getNow(null)___						if (taskManagerLocation == null) {_							throw new FlinkRuntimeException("TaskManagerLocationFuture was completed with null. This indicates a programming bug.")__						}__						completedTaskManagerLocations.add(taskManagerLocation)__					}_				}__				preferredLocationsFuture = CompletableFuture.completedFuture(completedTaskManagerLocations)__				break__			default:_				throw new RuntimeException("Unknown LocationPreferenceConstraint " + locationPreferenceConstraint + '.')__		}__		return preferredLocationsFuture__	};calculates,the,preferred,locations,based,on,the,location,preference,constraint,param,location,preference,constraint,constraint,for,the,location,preference,return,future,containing,the,collection,of,preferred,locations,this,might,not,be,completed,if,not,all,inputs,have,been,a,resource,assigned;visible,for,testing,public,completable,future,collection,task,manager,location,calculate,preferred,locations,location,preference,constraint,location,preference,constraint,final,collection,completable,future,task,manager,location,preferred,location,futures,get,vertex,get,preferred,locations,final,completable,future,collection,task,manager,location,preferred,locations,future,switch,location,preference,constraint,case,all,preferred,locations,future,future,utils,combine,all,preferred,location,futures,break,case,any,final,array,list,task,manager,location,completed,task,manager,locations,new,array,list,preferred,location,futures,size,for,completable,future,task,manager,location,preferred,location,future,preferred,location,futures,if,preferred,location,future,is,done,preferred,location,future,is,completed,exceptionally,final,task,manager,location,task,manager,location,preferred,location,future,get,now,null,if,task,manager,location,null,throw,new,flink,runtime,exception,task,manager,location,future,was,completed,with,null,this,indicates,a,programming,bug,completed,task,manager,locations,add,task,manager,location,preferred,locations,future,completable,future,completed,future,completed,task,manager,locations,break,default,throw,new,runtime,exception,unknown,location,preference,constraint,location,preference,constraint,return,preferred,locations,future
Execution -> @VisibleForTesting 	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint);1550654143;Calculates the preferred locations based on the location preference constraint.__@param locationPreferenceConstraint constraint for the location preference_@return Future containing the collection of preferred locations. This might not be completed if not all inputs_have been a resource assigned.;@VisibleForTesting_	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {_		final Collection<CompletableFuture<TaskManagerLocation>> preferredLocationFutures = getVertex().getPreferredLocations()__		final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture___		switch(locationPreferenceConstraint) {_			case ALL:_				preferredLocationsFuture = FutureUtils.combineAll(preferredLocationFutures)__				break__			case ANY:_				final ArrayList<TaskManagerLocation> completedTaskManagerLocations = new ArrayList<>(preferredLocationFutures.size())___				for (CompletableFuture<TaskManagerLocation> preferredLocationFuture : preferredLocationFutures) {_					if (preferredLocationFuture.isDone() && !preferredLocationFuture.isCompletedExceptionally()) {_						final TaskManagerLocation taskManagerLocation = preferredLocationFuture.getNow(null)___						if (taskManagerLocation == null) {_							throw new FlinkRuntimeException("TaskManagerLocationFuture was completed with null. This indicates a programming bug.")__						}__						completedTaskManagerLocations.add(taskManagerLocation)__					}_				}__				preferredLocationsFuture = CompletableFuture.completedFuture(completedTaskManagerLocations)__				break__			default:_				throw new RuntimeException("Unknown LocationPreferenceConstraint " + locationPreferenceConstraint + '.')__		}__		return preferredLocationsFuture__	};calculates,the,preferred,locations,based,on,the,location,preference,constraint,param,location,preference,constraint,constraint,for,the,location,preference,return,future,containing,the,collection,of,preferred,locations,this,might,not,be,completed,if,not,all,inputs,have,been,a,resource,assigned;visible,for,testing,public,completable,future,collection,task,manager,location,calculate,preferred,locations,location,preference,constraint,location,preference,constraint,final,collection,completable,future,task,manager,location,preferred,location,futures,get,vertex,get,preferred,locations,final,completable,future,collection,task,manager,location,preferred,locations,future,switch,location,preference,constraint,case,all,preferred,locations,future,future,utils,combine,all,preferred,location,futures,break,case,any,final,array,list,task,manager,location,completed,task,manager,locations,new,array,list,preferred,location,futures,size,for,completable,future,task,manager,location,preferred,location,future,preferred,location,futures,if,preferred,location,future,is,done,preferred,location,future,is,completed,exceptionally,final,task,manager,location,task,manager,location,preferred,location,future,get,now,null,if,task,manager,location,null,throw,new,flink,runtime,exception,task,manager,location,future,was,completed,with,null,this,indicates,a,programming,bug,completed,task,manager,locations,add,task,manager,location,preferred,locations,future,completable,future,completed,future,completed,task,manager,locations,break,default,throw,new,runtime,exception,unknown,location,preference,constraint,location,preference,constraint,return,preferred,locations,future
Execution -> @VisibleForTesting 	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint);1550683188;Calculates the preferred locations based on the location preference constraint.__@param locationPreferenceConstraint constraint for the location preference_@return Future containing the collection of preferred locations. This might not be completed if not all inputs_have been a resource assigned.;@VisibleForTesting_	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {_		final Collection<CompletableFuture<TaskManagerLocation>> preferredLocationFutures = getVertex().getPreferredLocations()__		final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture___		switch(locationPreferenceConstraint) {_			case ALL:_				preferredLocationsFuture = FutureUtils.combineAll(preferredLocationFutures)__				break__			case ANY:_				final ArrayList<TaskManagerLocation> completedTaskManagerLocations = new ArrayList<>(preferredLocationFutures.size())___				for (CompletableFuture<TaskManagerLocation> preferredLocationFuture : preferredLocationFutures) {_					if (preferredLocationFuture.isDone() && !preferredLocationFuture.isCompletedExceptionally()) {_						final TaskManagerLocation taskManagerLocation = preferredLocationFuture.getNow(null)___						if (taskManagerLocation == null) {_							throw new FlinkRuntimeException("TaskManagerLocationFuture was completed with null. This indicates a programming bug.")__						}__						completedTaskManagerLocations.add(taskManagerLocation)__					}_				}__				preferredLocationsFuture = CompletableFuture.completedFuture(completedTaskManagerLocations)__				break__			default:_				throw new RuntimeException("Unknown LocationPreferenceConstraint " + locationPreferenceConstraint + '.')__		}__		return preferredLocationsFuture__	};calculates,the,preferred,locations,based,on,the,location,preference,constraint,param,location,preference,constraint,constraint,for,the,location,preference,return,future,containing,the,collection,of,preferred,locations,this,might,not,be,completed,if,not,all,inputs,have,been,a,resource,assigned;visible,for,testing,public,completable,future,collection,task,manager,location,calculate,preferred,locations,location,preference,constraint,location,preference,constraint,final,collection,completable,future,task,manager,location,preferred,location,futures,get,vertex,get,preferred,locations,final,completable,future,collection,task,manager,location,preferred,locations,future,switch,location,preference,constraint,case,all,preferred,locations,future,future,utils,combine,all,preferred,location,futures,break,case,any,final,array,list,task,manager,location,completed,task,manager,locations,new,array,list,preferred,location,futures,size,for,completable,future,task,manager,location,preferred,location,future,preferred,location,futures,if,preferred,location,future,is,done,preferred,location,future,is,completed,exceptionally,final,task,manager,location,task,manager,location,preferred,location,future,get,now,null,if,task,manager,location,null,throw,new,flink,runtime,exception,task,manager,location,future,was,completed,with,null,this,indicates,a,programming,bug,completed,task,manager,locations,add,task,manager,location,preferred,locations,future,completable,future,completed,future,completed,task,manager,locations,break,default,throw,new,runtime,exception,unknown,location,preference,constraint,location,preference,constraint,return,preferred,locations,future
Execution -> @VisibleForTesting 	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint);1550855836;Calculates the preferred locations based on the location preference constraint.__@param locationPreferenceConstraint constraint for the location preference_@return Future containing the collection of preferred locations. This might not be completed if not all inputs_have been a resource assigned.;@VisibleForTesting_	public CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {_		final Collection<CompletableFuture<TaskManagerLocation>> preferredLocationFutures = getVertex().getPreferredLocations()__		final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture___		switch(locationPreferenceConstraint) {_			case ALL:_				preferredLocationsFuture = FutureUtils.combineAll(preferredLocationFutures)__				break__			case ANY:_				final ArrayList<TaskManagerLocation> completedTaskManagerLocations = new ArrayList<>(preferredLocationFutures.size())___				for (CompletableFuture<TaskManagerLocation> preferredLocationFuture : preferredLocationFutures) {_					if (preferredLocationFuture.isDone() && !preferredLocationFuture.isCompletedExceptionally()) {_						final TaskManagerLocation taskManagerLocation = preferredLocationFuture.getNow(null)___						if (taskManagerLocation == null) {_							throw new FlinkRuntimeException("TaskManagerLocationFuture was completed with null. This indicates a programming bug.")__						}__						completedTaskManagerLocations.add(taskManagerLocation)__					}_				}__				preferredLocationsFuture = CompletableFuture.completedFuture(completedTaskManagerLocations)__				break__			default:_				throw new RuntimeException("Unknown LocationPreferenceConstraint " + locationPreferenceConstraint + '.')__		}__		return preferredLocationsFuture__	};calculates,the,preferred,locations,based,on,the,location,preference,constraint,param,location,preference,constraint,constraint,for,the,location,preference,return,future,containing,the,collection,of,preferred,locations,this,might,not,be,completed,if,not,all,inputs,have,been,a,resource,assigned;visible,for,testing,public,completable,future,collection,task,manager,location,calculate,preferred,locations,location,preference,constraint,location,preference,constraint,final,collection,completable,future,task,manager,location,preferred,location,futures,get,vertex,get,preferred,locations,final,completable,future,collection,task,manager,location,preferred,locations,future,switch,location,preference,constraint,case,all,preferred,locations,future,future,utils,combine,all,preferred,location,futures,break,case,any,final,array,list,task,manager,location,completed,task,manager,locations,new,array,list,preferred,location,futures,size,for,completable,future,task,manager,location,preferred,location,future,preferred,location,futures,if,preferred,location,future,is,done,preferred,location,future,is,completed,exceptionally,final,task,manager,location,task,manager,location,preferred,location,future,get,now,null,if,task,manager,location,null,throw,new,flink,runtime,exception,task,manager,location,future,was,completed,with,null,this,indicates,a,programming,bug,completed,task,manager,locations,add,task,manager,location,preferred,locations,future,completable,future,completed,future,completed,task,manager,locations,break,default,throw,new,runtime,exception,unknown,location,preference,constraint,location,preference,constraint,return,preferred,locations,future
Execution -> public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStrackTraceDepth, 			Time timeout);1501622876;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStrackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStrackTraceDepth,_			Time timeout) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return FutureUtils.toJava(_				taskManagerGateway.requestStackTraceSample(_					attemptId,_					sampleId,_					numSamples,_					delayBetweenSamples,_					maxStrackTraceDepth,_					timeout))__		} else {_			CompletableFuture<StackTraceSampleResponse> result = new CompletableFuture<>()__			result.completeExceptionally(new Exception("The execution has no slot assigned."))___			return result__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,strack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,completable,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,strack,trace,depth,time,timeout,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,future,utils,to,java,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,strack,trace,depth,timeout,else,completable,future,stack,trace,sample,response,result,new,completable,future,result,complete,exceptionally,new,exception,the,execution,has,no,slot,assigned,return,result
Execution -> public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStrackTraceDepth, 			Time timeout);1501665499;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStrackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStrackTraceDepth,_			Time timeout) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return FutureUtils.toJava(_				taskManagerGateway.requestStackTraceSample(_					attemptId,_					sampleId,_					numSamples,_					delayBetweenSamples,_					maxStrackTraceDepth,_					timeout))__		} else {_			return FutureUtils.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,strack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,completable,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,strack,trace,depth,time,timeout,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,future,utils,to,java,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,strack,trace,depth,timeout,else,return,future,utils,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStrackTraceDepth, 			Time timeout);1501760738;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStrackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStrackTraceDepth,_			Time timeout) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStrackTraceDepth,_				timeout)__		} else {_			return FutureUtils.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,strack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,completable,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,strack,trace,depth,time,timeout,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,strack,trace,depth,timeout,else,return,future,utils,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStrackTraceDepth, 			Time timeout);1502801814;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStrackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStrackTraceDepth,_			Time timeout) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStrackTraceDepth,_				timeout)__		} else {_			return FutureUtils.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,strack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,completable,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,strack,trace,depth,time,timeout,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,strack,trace,depth,timeout,else,return,future,utils,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStrackTraceDepth, 			Time timeout);1509125300;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStrackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStrackTraceDepth,_			Time timeout) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStrackTraceDepth,_				timeout)__		} else {_			return FutureUtils.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,strack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,completable,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,strack,trace,depth,time,timeout,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,strack,trace,depth,timeout,else,return,future,utils,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStrackTraceDepth, 			Time timeout);1509631297;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStrackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStrackTraceDepth,_			Time timeout) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStrackTraceDepth,_				timeout)__		} else {_			return FutureUtils.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,strack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,completable,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,strack,trace,depth,time,timeout,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,strack,trace,depth,timeout,else,return,future,utils,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStrackTraceDepth, 			Time timeout);1509638684;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStrackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStrackTraceDepth,_			Time timeout) {__		final SimpleSlot slot = assignedResource.get()___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStrackTraceDepth,_				timeout)__		} else {_			return FutureUtils.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,strack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,completable,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,strack,trace,depth,time,timeout,final,simple,slot,slot,assigned,resource,get,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,strack,trace,depth,timeout,else,return,future,utils,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStrackTraceDepth, 			Time timeout);1509638685;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStrackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStrackTraceDepth,_			Time timeout) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStrackTraceDepth,_				timeout)__		} else {_			return FutureUtils.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,strack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,completable,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,strack,trace,depth,time,timeout,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,strack,trace,depth,timeout,else,return,future,utils,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStrackTraceDepth, 			Time timeout);1513201052;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStrackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStrackTraceDepth,_			Time timeout) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStrackTraceDepth,_				timeout)__		} else {_			return FutureUtils.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,strack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,completable,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,strack,trace,depth,time,timeout,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,strack,trace,depth,timeout,else,return,future,utils,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStrackTraceDepth, 			Time timeout);1513201070;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStrackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStrackTraceDepth,_			Time timeout) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStrackTraceDepth,_				timeout)__		} else {_			return FutureUtils.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,strack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,completable,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,strack,trace,depth,time,timeout,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,strack,trace,depth,timeout,else,return,future,utils,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStrackTraceDepth, 			Time timeout);1513261599;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStrackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStrackTraceDepth,_			Time timeout) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStrackTraceDepth,_				timeout)__		} else {_			return FutureUtils.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,strack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,completable,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,strack,trace,depth,time,timeout,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,strack,trace,depth,timeout,else,return,future,utils,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public void setInitialState( 		ChainedStateHandle<StreamStateHandle> chainedStateHandle, 			List<KeyGroupsStateHandle> keyGroupsStateHandles);1472663401;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param chainedStateHandle Chained operator state_@param keyGroupsStateHandles Key-group state (= partitioned state);public void setInitialState(_		ChainedStateHandle<StreamStateHandle> chainedStateHandle,_			List<KeyGroupsStateHandle> keyGroupsStateHandles) {__		if (state != ExecutionState.CREATED) {_			throw new IllegalArgumentException("Can only assign operator state when execution attempt is in CREATED")__		}_		this.chainedStateHandle = chainedStateHandle__		this.keyGroupsStateHandles = keyGroupsStateHandles__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,chained,state,handle,chained,operator,state,param,key,groups,state,handles,key,group,state,partitioned,state;public,void,set,initial,state,chained,state,handle,stream,state,handle,chained,state,handle,list,key,groups,state,handle,key,groups,state,handles,if,state,execution,state,created,throw,new,illegal,argument,exception,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,chained,state,handle,chained,state,handle,this,key,groups,state,handles,key,groups,state,handles
Execution -> public void setInitialState( 		ChainedStateHandle<StreamStateHandle> chainedStateHandle, 			List<KeyGroupsStateHandle> keyGroupsStateHandles);1472663402;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param chainedStateHandle Chained operator state_@param keyGroupsStateHandles Key-group state (= partitioned state);public void setInitialState(_		ChainedStateHandle<StreamStateHandle> chainedStateHandle,_			List<KeyGroupsStateHandle> keyGroupsStateHandles) {__		if (state != ExecutionState.CREATED) {_			throw new IllegalArgumentException("Can only assign operator state when execution attempt is in CREATED")__		}_		this.chainedStateHandle = chainedStateHandle__		this.keyGroupsStateHandles = keyGroupsStateHandles__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,chained,state,handle,chained,operator,state,param,key,groups,state,handles,key,group,state,partitioned,state;public,void,set,initial,state,chained,state,handle,stream,state,handle,chained,state,handle,list,key,groups,state,handle,key,groups,state,handles,if,state,execution,state,created,throw,new,illegal,argument,exception,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,chained,state,handle,chained,state,handle,this,key,groups,state,handles,key,groups,state,handles
Execution -> public void setInitialState( 		ChainedStateHandle<StreamStateHandle> chainedStateHandle, 			List<KeyGroupsStateHandle> keyGroupsStateHandles);1472830377;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param chainedStateHandle Chained operator state_@param keyGroupsStateHandles Key-group state (= partitioned state);public void setInitialState(_		ChainedStateHandle<StreamStateHandle> chainedStateHandle,_			List<KeyGroupsStateHandle> keyGroupsStateHandles) {__		if (state != ExecutionState.CREATED) {_			throw new IllegalArgumentException("Can only assign operator state when execution attempt is in CREATED")__		}_		this.chainedStateHandle = chainedStateHandle__		this.keyGroupsStateHandles = keyGroupsStateHandles__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,chained,state,handle,chained,operator,state,param,key,groups,state,handles,key,group,state,partitioned,state;public,void,set,initial,state,chained,state,handle,stream,state,handle,chained,state,handle,list,key,groups,state,handle,key,groups,state,handles,if,state,execution,state,created,throw,new,illegal,argument,exception,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,chained,state,handle,chained,state,handle,this,key,groups,state,handles,key,groups,state,handles
Execution -> public void setInitialState( 		ChainedStateHandle<StreamStateHandle> chainedStateHandle, 			List<KeyGroupsStateHandle> keyGroupsStateHandles);1472830377;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param chainedStateHandle Chained operator state_@param keyGroupsStateHandles Key-group state (= partitioned state);public void setInitialState(_		ChainedStateHandle<StreamStateHandle> chainedStateHandle,_			List<KeyGroupsStateHandle> keyGroupsStateHandles) {__		if (state != ExecutionState.CREATED) {_			throw new IllegalArgumentException("Can only assign operator state when execution attempt is in CREATED")__		}_		this.chainedStateHandle = chainedStateHandle__		this.keyGroupsStateHandles = keyGroupsStateHandles__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,chained,state,handle,chained,operator,state,param,key,groups,state,handles,key,group,state,partitioned,state;public,void,set,initial,state,chained,state,handle,stream,state,handle,chained,state,handle,list,key,groups,state,handle,key,groups,state,handles,if,state,execution,state,created,throw,new,illegal,argument,exception,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,chained,state,handle,chained,state,handle,this,key,groups,state,handles,key,groups,state,handles
Execution -> public void setInitialState( 		ChainedStateHandle<StreamStateHandle> chainedStateHandle, 			List<KeyGroupsStateHandle> keyGroupsStateHandles);1473023399;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param chainedStateHandle Chained operator state_@param keyGroupsStateHandles Key-group state (= partitioned state);public void setInitialState(_		ChainedStateHandle<StreamStateHandle> chainedStateHandle,_			List<KeyGroupsStateHandle> keyGroupsStateHandles) {__		if (state != ExecutionState.CREATED) {_			throw new IllegalArgumentException("Can only assign operator state when execution attempt is in CREATED")__		}_		this.chainedStateHandle = chainedStateHandle__		this.keyGroupsStateHandles = keyGroupsStateHandles__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,chained,state,handle,chained,operator,state,param,key,groups,state,handles,key,group,state,partitioned,state;public,void,set,initial,state,chained,state,handle,stream,state,handle,chained,state,handle,list,key,groups,state,handle,key,groups,state,handles,if,state,execution,state,created,throw,new,illegal,argument,exception,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,chained,state,handle,chained,state,handle,this,key,groups,state,handles,key,groups,state,handles
Execution -> public void setInitialState( 		ChainedStateHandle<StreamStateHandle> chainedStateHandle, 			List<KeyGroupsStateHandle> keyGroupsStateHandles);1474994376;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param chainedStateHandle Chained operator state_@param keyGroupsStateHandles Key-group state (= partitioned state);public void setInitialState(_		ChainedStateHandle<StreamStateHandle> chainedStateHandle,_			List<KeyGroupsStateHandle> keyGroupsStateHandles) {__		if (state != ExecutionState.CREATED) {_			throw new IllegalArgumentException("Can only assign operator state when execution attempt is in CREATED")__		}_		this.chainedStateHandle = chainedStateHandle__		this.keyGroupsStateHandles = keyGroupsStateHandles__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,chained,state,handle,chained,operator,state,param,key,groups,state,handles,key,group,state,partitioned,state;public,void,set,initial,state,chained,state,handle,stream,state,handle,chained,state,handle,list,key,groups,state,handle,key,groups,state,handles,if,state,execution,state,created,throw,new,illegal,argument,exception,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,chained,state,handle,chained,state,handle,this,key,groups,state,handles,key,groups,state,handles
Execution -> public void setInitialState( 		ChainedStateHandle<StreamStateHandle> chainedStateHandle, 			List<KeyGroupsStateHandle> keyGroupsStateHandles);1474994376;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param chainedStateHandle Chained operator state_@param keyGroupsStateHandles Key-group state (= partitioned state);public void setInitialState(_		ChainedStateHandle<StreamStateHandle> chainedStateHandle,_			List<KeyGroupsStateHandle> keyGroupsStateHandles) {__		if (state != ExecutionState.CREATED) {_			throw new IllegalArgumentException("Can only assign operator state when execution attempt is in CREATED")__		}_		this.chainedStateHandle = chainedStateHandle__		this.keyGroupsStateHandles = keyGroupsStateHandles__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,chained,state,handle,chained,operator,state,param,key,groups,state,handles,key,group,state,partitioned,state;public,void,set,initial,state,chained,state,handle,stream,state,handle,chained,state,handle,list,key,groups,state,handle,key,groups,state,handles,if,state,execution,state,created,throw,new,illegal,argument,exception,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,chained,state,handle,chained,state,handle,this,key,groups,state,handles,key,groups,state,handles
Execution -> public boolean scheduleForExecution( 		SlotProvider slotProvider, 		boolean queued, 		LocationPreferenceConstraint locationPreferenceConstraint);1509638685;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it._@param locationPreferenceConstraint constraint for the location preferences__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling.;public boolean scheduleForExecution(_		SlotProvider slotProvider,_		boolean queued,_		LocationPreferenceConstraint locationPreferenceConstraint) {_		try {_			final CompletableFuture<Execution> allocationFuture = allocateAndAssignSlotForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint)___			_			_			_			final CompletableFuture<Void> deploymentFuture = allocationFuture.handle(_				(Execution ignored, Throwable throwable) ->  {_					if (throwable != null) {_						markFailed(ExceptionUtils.stripCompletionException(throwable))__					}_					else {_						try {_							deploy()__						} catch (Throwable t) {_							markFailed(ExceptionUtils.stripCompletionException(t))__						}_					}_					return null__				}_			)___			_			if (!queued && !deploymentFuture.isDone()) {_				markFailed(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return true__		}_		catch (IllegalExecutionStateException e) {_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,param,location,preference,constraint,constraint,for,the,location,preferences,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,try,final,completable,future,execution,allocation,future,allocate,and,assign,slot,for,execution,slot,provider,queued,location,preference,constraint,final,completable,future,void,deployment,future,allocation,future,handle,execution,ignored,throwable,throwable,if,throwable,null,mark,failed,exception,utils,strip,completion,exception,throwable,else,try,deploy,catch,throwable,t,mark,failed,exception,utils,strip,completion,exception,t,return,null,if,queued,deployment,future,is,done,mark,failed,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,true,catch,illegal,execution,state,exception,e,return,false
Execution -> public boolean scheduleForExecution( 		SlotProvider slotProvider, 		boolean queued, 		LocationPreferenceConstraint locationPreferenceConstraint);1513201052;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it._@param locationPreferenceConstraint constraint for the location preferences__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling.;public boolean scheduleForExecution(_		SlotProvider slotProvider,_		boolean queued,_		LocationPreferenceConstraint locationPreferenceConstraint) {_		try {_			final CompletableFuture<Execution> allocationFuture = allocateAndAssignSlotForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint)___			_			_			_			final CompletableFuture<Void> deploymentFuture = allocationFuture.handle(_				(Execution ignored, Throwable throwable) ->  {_					if (throwable != null) {_						markFailed(ExceptionUtils.stripCompletionException(throwable))__					}_					else {_						try {_							deploy()__						} catch (Throwable t) {_							markFailed(ExceptionUtils.stripCompletionException(t))__						}_					}_					return null__				}_			)___			_			if (!queued && !deploymentFuture.isDone()) {_				markFailed(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return true__		}_		catch (IllegalExecutionStateException e) {_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,param,location,preference,constraint,constraint,for,the,location,preferences,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,try,final,completable,future,execution,allocation,future,allocate,and,assign,slot,for,execution,slot,provider,queued,location,preference,constraint,final,completable,future,void,deployment,future,allocation,future,handle,execution,ignored,throwable,throwable,if,throwable,null,mark,failed,exception,utils,strip,completion,exception,throwable,else,try,deploy,catch,throwable,t,mark,failed,exception,utils,strip,completion,exception,t,return,null,if,queued,deployment,future,is,done,mark,failed,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,true,catch,illegal,execution,state,exception,e,return,false
Execution -> public boolean scheduleForExecution( 		SlotProvider slotProvider, 		boolean queued, 		LocationPreferenceConstraint locationPreferenceConstraint);1513201070;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it._@param locationPreferenceConstraint constraint for the location preferences__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling.;public boolean scheduleForExecution(_		SlotProvider slotProvider,_		boolean queued,_		LocationPreferenceConstraint locationPreferenceConstraint) {_		try {_			final CompletableFuture<Execution> allocationFuture = allocateAndAssignSlotForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint)___			_			_			_			final CompletableFuture<Void> deploymentFuture = allocationFuture.handle(_				(Execution ignored, Throwable throwable) ->  {_					if (throwable != null) {_						markFailed(ExceptionUtils.stripCompletionException(throwable))__					}_					else {_						try {_							deploy()__						} catch (Throwable t) {_							markFailed(ExceptionUtils.stripCompletionException(t))__						}_					}_					return null__				}_			)___			_			if (!queued && !deploymentFuture.isDone()) {_				markFailed(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return true__		}_		catch (IllegalExecutionStateException e) {_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,param,location,preference,constraint,constraint,for,the,location,preferences,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,try,final,completable,future,execution,allocation,future,allocate,and,assign,slot,for,execution,slot,provider,queued,location,preference,constraint,final,completable,future,void,deployment,future,allocation,future,handle,execution,ignored,throwable,throwable,if,throwable,null,mark,failed,exception,utils,strip,completion,exception,throwable,else,try,deploy,catch,throwable,t,mark,failed,exception,utils,strip,completion,exception,t,return,null,if,queued,deployment,future,is,done,mark,failed,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,true,catch,illegal,execution,state,exception,e,return,false
Execution -> public boolean scheduleForExecution( 		SlotProvider slotProvider, 		boolean queued, 		LocationPreferenceConstraint locationPreferenceConstraint);1513261599;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it._@param locationPreferenceConstraint constraint for the location preferences__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling.;public boolean scheduleForExecution(_		SlotProvider slotProvider,_		boolean queued,_		LocationPreferenceConstraint locationPreferenceConstraint) {_		try {_			final CompletableFuture<Execution> allocationFuture = allocateAndAssignSlotForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint)___			_			_			_			final CompletableFuture<Void> deploymentFuture = allocationFuture.handle(_				(Execution ignored, Throwable throwable) ->  {_					if (throwable != null) {_						markFailed(ExceptionUtils.stripCompletionException(throwable))__					}_					else {_						try {_							deploy()__						} catch (Throwable t) {_							markFailed(ExceptionUtils.stripCompletionException(t))__						}_					}_					return null__				}_			)___			_			if (!queued && !deploymentFuture.isDone()) {_				markFailed(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return true__		}_		catch (IllegalExecutionStateException e) {_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,param,location,preference,constraint,constraint,for,the,location,preferences,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,try,final,completable,future,execution,allocation,future,allocate,and,assign,slot,for,execution,slot,provider,queued,location,preference,constraint,final,completable,future,void,deployment,future,allocation,future,handle,execution,ignored,throwable,throwable,if,throwable,null,mark,failed,exception,utils,strip,completion,exception,throwable,else,try,deploy,catch,throwable,t,mark,failed,exception,utils,strip,completion,exception,t,return,null,if,queued,deployment,future,is,done,mark,failed,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,true,catch,illegal,execution,state,exception,e,return,false
Execution -> public boolean scheduleForExecution( 		SlotProvider slotProvider, 		boolean queued, 		LocationPreferenceConstraint locationPreferenceConstraint);1515177485;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it._@param locationPreferenceConstraint constraint for the location preferences__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling.;public boolean scheduleForExecution(_		SlotProvider slotProvider,_		boolean queued,_		LocationPreferenceConstraint locationPreferenceConstraint) {_		try {_			final CompletableFuture<Execution> allocationFuture = allocateAndAssignSlotForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint)___			_			_			_			final CompletableFuture<Void> deploymentFuture = allocationFuture.handle(_				(Execution ignored, Throwable throwable) ->  {_					if (throwable != null) {_						markFailed(ExceptionUtils.stripCompletionException(throwable))__					}_					else {_						try {_							deploy()__						} catch (Throwable t) {_							markFailed(ExceptionUtils.stripCompletionException(t))__						}_					}_					return null__				}_			)___			_			if (!queued && !deploymentFuture.isDone()) {_				markFailed(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return true__		}_		catch (IllegalExecutionStateException e) {_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,param,location,preference,constraint,constraint,for,the,location,preferences,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,try,final,completable,future,execution,allocation,future,allocate,and,assign,slot,for,execution,slot,provider,queued,location,preference,constraint,final,completable,future,void,deployment,future,allocation,future,handle,execution,ignored,throwable,throwable,if,throwable,null,mark,failed,exception,utils,strip,completion,exception,throwable,else,try,deploy,catch,throwable,t,mark,failed,exception,utils,strip,completion,exception,t,return,null,if,queued,deployment,future,is,done,mark,failed,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,true,catch,illegal,execution,state,exception,e,return,false
Execution -> public boolean scheduleForExecution( 		SlotProvider slotProvider, 		boolean queued, 		LocationPreferenceConstraint locationPreferenceConstraint);1516626377;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it._@param locationPreferenceConstraint constraint for the location preferences__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling.;public boolean scheduleForExecution(_		SlotProvider slotProvider,_		boolean queued,_		LocationPreferenceConstraint locationPreferenceConstraint) {_		try {_			final CompletableFuture<Execution> allocationFuture = allocateAndAssignSlotForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint)___			_			_			_			final CompletableFuture<Void> deploymentFuture = allocationFuture.handle(_				(Execution ignored, Throwable throwable) ->  {_					if (throwable != null) {_						markFailed(ExceptionUtils.stripCompletionException(throwable))__					}_					else {_						try {_							deploy()__						} catch (Throwable t) {_							markFailed(ExceptionUtils.stripCompletionException(t))__						}_					}_					return null__				}_			)___			_			if (!queued && !deploymentFuture.isDone()) {_				markFailed(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return true__		}_		catch (IllegalExecutionStateException e) {_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,param,location,preference,constraint,constraint,for,the,location,preferences,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,try,final,completable,future,execution,allocation,future,allocate,and,assign,slot,for,execution,slot,provider,queued,location,preference,constraint,final,completable,future,void,deployment,future,allocation,future,handle,execution,ignored,throwable,throwable,if,throwable,null,mark,failed,exception,utils,strip,completion,exception,throwable,else,try,deploy,catch,throwable,t,mark,failed,exception,utils,strip,completion,exception,t,return,null,if,queued,deployment,future,is,done,mark,failed,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,true,catch,illegal,execution,state,exception,e,return,false
Execution -> public boolean scheduleForExecution( 		SlotProvider slotProvider, 		boolean queued, 		LocationPreferenceConstraint locationPreferenceConstraint);1516626397;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it._@param locationPreferenceConstraint constraint for the location preferences__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling.;public boolean scheduleForExecution(_		SlotProvider slotProvider,_		boolean queued,_		LocationPreferenceConstraint locationPreferenceConstraint) {_		try {_			final CompletableFuture<Execution> allocationFuture = allocateAndAssignSlotForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint)___			_			_			_			final CompletableFuture<Void> deploymentFuture = allocationFuture.handle(_				(Execution ignored, Throwable throwable) ->  {_					if (throwable != null) {_						markFailed(ExceptionUtils.stripCompletionException(throwable))__					}_					else {_						try {_							deploy()__						} catch (Throwable t) {_							markFailed(ExceptionUtils.stripCompletionException(t))__						}_					}_					return null__				}_			)___			_			if (!queued && !deploymentFuture.isDone()) {_				markFailed(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return true__		}_		catch (IllegalExecutionStateException e) {_			return false__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,param,location,preference,constraint,constraint,for,the,location,preferences,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling;public,boolean,schedule,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,try,final,completable,future,execution,allocation,future,allocate,and,assign,slot,for,execution,slot,provider,queued,location,preference,constraint,final,completable,future,void,deployment,future,allocation,future,handle,execution,ignored,throwable,throwable,if,throwable,null,mark,failed,exception,utils,strip,completion,exception,throwable,else,try,deploy,catch,throwable,t,mark,failed,exception,utils,strip,completion,exception,t,return,null,if,queued,deployment,future,is,done,mark,failed,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,true,catch,illegal,execution,state,exception,e,return,false
Execution -> public void scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1411236169;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public void scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new NullPointerException()__		}_		_		if (transitionState(CREATED, SCHEDULED)) {_			_			ScheduledUnit toSchedule = new ScheduledUnit(this, vertex.getJobVertex().getSlotSharingGroup())__		_			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)__				_				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(AllocatedSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				AllocatedSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}_		}_		else if (this.state == CANCELED) {_			_			_			return__		}_		else {_			throw new IllegalStateException("The vertex must be in CREATED state to be scheduled.")__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,void,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,null,pointer,exception,if,transition,state,created,scheduled,scheduled,unit,to,schedule,new,scheduled,unit,this,vertex,get,job,vertex,get,slot,sharing,group,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,allocated,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,allocated,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,if,this,state,canceled,return,else,throw,new,illegal,state,exception,the,vertex,must,be,in,created,state,to,be,scheduled
Execution -> public void scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1411236170;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public void scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new NullPointerException()__		}_		_		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()__		_		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}_				_		if (transitionState(CREATED, SCHEDULED)) {_			_			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)__		_			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)__				_				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(AllocatedSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				AllocatedSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}_		}_		else if (this.state == CANCELED) {_			_			_			return__		}_		else {_			throw new IllegalStateException("The vertex must be in CREATED state to be scheduled.")__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,void,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,null,pointer,exception,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,allocated,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,allocated,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,if,this,state,canceled,return,else,throw,new,illegal,state,exception,the,vertex,must,be,in,created,state,to,be,scheduled
Execution -> public void scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1411237261;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public void scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new NullPointerException()__		}_		_		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()__		_		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}_				_		if (transitionState(CREATED, SCHEDULED)) {_			_			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)__		_			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)__				_				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(AllocatedSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				AllocatedSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}_		}_		else if (this.state == CANCELED) {_			_			_			return__		}_		else {_			throw new IllegalStateException("The vertex must be in CREATED state to be scheduled.")__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,void,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,null,pointer,exception,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,allocated,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,allocated,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,if,this,state,canceled,return,else,throw,new,illegal,state,exception,the,vertex,must,be,in,created,state,to,be,scheduled
Execution -> public void scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1411237262;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public void scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new NullPointerException()__		}_		_		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()__		_		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}_		_		if (transitionState(CREATED, SCHEDULED)) {_			_			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)__		_			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)__				_				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(AllocatedSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				AllocatedSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}_		}_		else {_			_			return__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,void,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,null,pointer,exception,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,allocated,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,allocated,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,return
Execution -> public void scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1411473593;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public void scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new NullPointerException()__		}_		_		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()__		_		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}_		_		if (transitionState(CREATED, SCHEDULED)) {_			_			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)__		_			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)__				_				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(AllocatedSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				AllocatedSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}_		}_		else {_			_			return__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,void,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,null,pointer,exception,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,allocated,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,allocated,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,return
Execution -> public void scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1412605211;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public void scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new NullPointerException()__		}_		_		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()__		_		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}_		_		if (transitionState(CREATED, SCHEDULED)) {_			_			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)__		_			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)__				_				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(AllocatedSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				AllocatedSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}_		}_		else {_			_			return__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,void,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,null,pointer,exception,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,allocated,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,allocated,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,return
Execution -> public void scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1415027294;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public void scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new NullPointerException()__		}_		_		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()__		_		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}_		_		if (transitionState(CREATED, SCHEDULED)) {_			_			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)__		_			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)__				_				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(AllocatedSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				AllocatedSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}_		}_		else {_			_			return__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,void,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,null,pointer,exception,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,allocated,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,allocated,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,return
Execution -> public void scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1415278814;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public void scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new NullPointerException()__		}_		_		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()__		_		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}_		_		if (transitionState(CREATED, SCHEDULED)) {_			_			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)__		_			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)__				_				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(AllocatedSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				AllocatedSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}_		}_		else {_			_			return__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,void,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,null,pointer,exception,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,allocated,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,allocated,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,return
Execution -> public void scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1418925507;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public void scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new NullPointerException()__		}_		_		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()__		_		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}_		_		if (transitionState(CREATED, SCHEDULED)) {_			_			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)__		_			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)__				_				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(AllocatedSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				AllocatedSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}_		}_		else {_			_			return__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,void,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,null,pointer,exception,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,allocated,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,allocated,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,return
Execution -> public void scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1418925508;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public void scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new NullPointerException()__		}_		_		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()__		_		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}_		_		if (transitionState(CREATED, SCHEDULED)) {_			_			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)__		_			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)__				_				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(AllocatedSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				AllocatedSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}_		}_		else {_			_			return__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,void,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,null,pointer,exception,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,allocated,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,allocated,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,return
Execution -> public void scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1418925510;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public void scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new NullPointerException()__		}_		_		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()__		_		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}_		_		if (transitionState(CREATED, SCHEDULED)) {_			_			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)__		_			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)__				_				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(AllocatedSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				AllocatedSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}_		}_		else {_			_			return__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,void,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,null,pointer,exception,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,allocated,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,allocated,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,return
Execution -> public void scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1418925510;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public void scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new NullPointerException()__		}_		_		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()__		_		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}_		_		if (transitionState(CREATED, SCHEDULED)) {_			_			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)__		_			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)__				_				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(AllocatedSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				AllocatedSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}_		}_		else {_			_			return__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,void,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,null,pointer,exception,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,allocated,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,allocated,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,return
Execution -> public void scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1418925511;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public void scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new NullPointerException()__		}_		_		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()__		_		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}_		_		if (transitionState(CREATED, SCHEDULED)) {_			_			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)__		_			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)__				_				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(AllocatedSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				AllocatedSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}_		}_		else {_			_			return__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,void,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,null,pointer,exception,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,allocated,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,allocated,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,return
Execution -> public void scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1418925511;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public void scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new NullPointerException()__		}_		_		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()__		_		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}_		_		if (transitionState(CREATED, SCHEDULED)) {_			_			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)__		_			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)__				_				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(AllocatedSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				AllocatedSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}_		}_		else {_			_			return__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,void,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,null,pointer,exception,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,allocated,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,allocated,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,return
Execution -> public void scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException;1420538822;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param scheduler__@throws IllegalStateException Thrown, if the vertex is not in CREATED state, which is the only state that permits scheduling._@throws NoResourceAvailableException Thrown is no queued scheduling is allowed and no resources are currently available.;public void scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {_		if (scheduler == null) {_			throw new NullPointerException()__		}_		_		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()__		_		_		if (locationConstraint != null && sharingGroup == null) {_			throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.")__		}_		_		if (transitionState(CREATED, SCHEDULED)) {_			_			ScheduledUnit toSchedule = locationConstraint == null ?_				new ScheduledUnit(this, sharingGroup) :_				new ScheduledUnit(this, sharingGroup, locationConstraint)__		_			_			_			if (queued) {_				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule)__				_				future.setFutureAction(new SlotAllocationFutureAction() {_					@Override_					public void slotAllocated(AllocatedSlot slot) {_						try {_							deployToSlot(slot)__						}_						catch (Throwable t) {_							try {_								slot.releaseSlot()__							} finally {_								markFailed(t)__							}_						}_					}_				})__			}_			else {_				AllocatedSlot slot = scheduler.scheduleImmediately(toSchedule)__				try {_					deployToSlot(slot)__				}_				catch (Throwable t) {_					try {_						slot.releaseSlot()__					} finally {_						markFailed(t)__					}_				}_			}_		}_		else {_			_			return__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,scheduler,throws,illegal,state,exception,thrown,if,the,vertex,is,not,in,created,state,which,is,the,only,state,that,permits,scheduling,throws,no,resource,available,exception,thrown,is,no,queued,scheduling,is,allowed,and,no,resources,are,currently,available;public,void,schedule,for,execution,scheduler,scheduler,boolean,queued,throws,no,resource,available,exception,if,scheduler,null,throw,new,null,pointer,exception,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,runtime,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,sharing,group,new,scheduled,unit,this,sharing,group,location,constraint,if,queued,slot,allocation,future,future,scheduler,schedule,queued,to,schedule,future,set,future,action,new,slot,allocation,future,action,override,public,void,slot,allocated,allocated,slot,slot,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,allocated,slot,slot,scheduler,schedule,immediately,to,schedule,try,deploy,to,slot,slot,catch,throwable,t,try,slot,release,slot,finally,mark,failed,t,else,return
Execution -> public Future<ExecutionState> getTerminationFuture();1493831843;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached.__@return A future for the execution's termination;public Future<ExecutionState> getTerminationFuture() {_		return terminationFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,return,a,future,for,the,execution,s,termination;public,future,execution,state,get,termination,future,return,termination,future
Execution -> public Future<ExecutionState> getTerminationFuture();1493831843;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached.__@return A future for the execution's termination;public Future<ExecutionState> getTerminationFuture() {_		return terminationFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,return,a,future,for,the,execution,s,termination;public,future,execution,state,get,termination,future,return,termination,future
Execution -> @Override 	public void fail(Throwable t);1513201070;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;@Override_	public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;override,public,void,fail,throwable,t,process,fail,t,false
Execution -> @Override 	public void fail(Throwable t);1513261599;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;@Override_	public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;override,public,void,fail,throwable,t,process,fail,t,false
Execution -> @Override 	public void fail(Throwable t);1515177485;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;@Override_	public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;override,public,void,fail,throwable,t,process,fail,t,false
Execution -> @Override 	public void fail(Throwable t);1516626377;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;@Override_	public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;override,public,void,fail,throwable,t,process,fail,t,false
Execution -> @Override 	public void fail(Throwable t);1516626397;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;@Override_	public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;override,public,void,fail,throwable,t,process,fail,t,false
Execution -> @Override 	public void fail(Throwable t);1518680774;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;@Override_	public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;override,public,void,fail,throwable,t,process,fail,t,false
Execution -> @Override 	public void fail(Throwable t);1518712478;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;@Override_	public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;override,public,void,fail,throwable,t,process,fail,t,false
Execution -> @Override 	public void fail(Throwable t);1519316529;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;@Override_	public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;override,public,void,fail,throwable,t,process,fail,t,false
Execution -> @Override 	public void fail(Throwable t);1519481114;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;@Override_	public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;override,public,void,fail,throwable,t,process,fail,t,false
Execution -> @Override 	public void fail(Throwable t);1519568061;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;@Override_	public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;override,public,void,fail,throwable,t,process,fail,t,false
Execution -> @Override 	public void fail(Throwable t);1519655521;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;@Override_	public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;override,public,void,fail,throwable,t,process,fail,t,false
Execution -> @Override 	public void fail(Throwable t);1522049586;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;@Override_	public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;override,public,void,fail,throwable,t,process,fail,t,false
Execution -> @Override 	public void fail(Throwable t);1522249273;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;@Override_	public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;override,public,void,fail,throwable,t,process,fail,t,false
Execution -> @Override 	public void fail(Throwable t);1530712207;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;@Override_	public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;override,public,void,fail,throwable,t,process,fail,t,false
Execution -> @Override 	public void fail(Throwable t);1532383539;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;@Override_	public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;override,public,void,fail,throwable,t,process,fail,t,false
Execution -> @Override 	public void fail(Throwable t);1532383539;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;@Override_	public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;override,public,void,fail,throwable,t,process,fail,t,false
Execution -> @Override 	public void fail(Throwable t);1532383539;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;@Override_	public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;override,public,void,fail,throwable,t,process,fail,t,false
Execution -> @Override 	public void fail(Throwable t);1540920690;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;@Override_	public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;override,public,void,fail,throwable,t,process,fail,t,false
Execution -> @Override 	public void fail(Throwable t);1542356428;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;@Override_	public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;override,public,void,fail,throwable,t,process,fail,t,false
Execution -> @Override 	public void fail(Throwable t);1546870832;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;@Override_	public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;override,public,void,fail,throwable,t,process,fail,t,false
Execution -> @Override 	public void fail(Throwable t);1547644408;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;@Override_	public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;override,public,void,fail,throwable,t,process,fail,t,false
Execution -> @Override 	public void fail(Throwable t);1550220073;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;@Override_	public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;override,public,void,fail,throwable,t,process,fail,t,false
Execution -> @Override 	public void fail(Throwable t);1550654143;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;@Override_	public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;override,public,void,fail,throwable,t,process,fail,t,false
Execution -> @Override 	public void fail(Throwable t);1550683188;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;@Override_	public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;override,public,void,fail,throwable,t,process,fail,t,false
Execution -> @Override 	public void fail(Throwable t);1550855836;This method fails the vertex due to an external condition. The task will move to state FAILED._If the task was in state RUNNING or DEPLOYING before, it will send a cancel call to the TaskManager.__@param t The exception that caused the task to fail.;@Override_	public void fail(Throwable t) {_		processFail(t, false)__	};this,method,fails,the,vertex,due,to,an,external,condition,the,task,will,move,to,state,failed,if,the,task,was,in,state,running,or,deploying,before,it,will,send,a,cancel,call,to,the,task,manager,param,t,the,exception,that,caused,the,task,to,fail;override,public,void,fail,throwable,t,process,fail,t,false
Execution -> public CompletableFuture<?> getReleaseFuture();1513201070;Gets the release future which is completed once the execution reaches a terminal_state and the assigned resource has been released.__@return A future which is completed once the assigned resource has been released;public CompletableFuture<?> getReleaseFuture() {_		return releaseFuture__	};gets,the,release,future,which,is,completed,once,the,execution,reaches,a,terminal,state,and,the,assigned,resource,has,been,released,return,a,future,which,is,completed,once,the,assigned,resource,has,been,released;public,completable,future,get,release,future,return,release,future
Execution -> public CompletableFuture<?> getReleaseFuture();1513261599;Gets the release future which is completed once the execution reaches a terminal_state and the assigned resource has been released.__@return A future which is completed once the assigned resource has been released;public CompletableFuture<?> getReleaseFuture() {_		return releaseFuture__	};gets,the,release,future,which,is,completed,once,the,execution,reaches,a,terminal,state,and,the,assigned,resource,has,been,released,return,a,future,which,is,completed,once,the,assigned,resource,has,been,released;public,completable,future,get,release,future,return,release,future
Execution -> public CompletableFuture<?> getReleaseFuture();1515177485;Gets the release future which is completed once the execution reaches a terminal_state and the assigned resource has been released.__@return A future which is completed once the assigned resource has been released;public CompletableFuture<?> getReleaseFuture() {_		return releaseFuture__	};gets,the,release,future,which,is,completed,once,the,execution,reaches,a,terminal,state,and,the,assigned,resource,has,been,released,return,a,future,which,is,completed,once,the,assigned,resource,has,been,released;public,completable,future,get,release,future,return,release,future
Execution -> public CompletableFuture<?> getReleaseFuture();1516626377;Gets the release future which is completed once the execution reaches a terminal_state and the assigned resource has been released.__@return A future which is completed once the assigned resource has been released;public CompletableFuture<?> getReleaseFuture() {_		return releaseFuture__	};gets,the,release,future,which,is,completed,once,the,execution,reaches,a,terminal,state,and,the,assigned,resource,has,been,released,return,a,future,which,is,completed,once,the,assigned,resource,has,been,released;public,completable,future,get,release,future,return,release,future
Execution -> public CompletableFuture<?> getReleaseFuture();1516626397;Gets the release future which is completed once the execution reaches a terminal_state and the assigned resource has been released.__@return A future which is completed once the assigned resource has been released;public CompletableFuture<?> getReleaseFuture() {_		return releaseFuture__	};gets,the,release,future,which,is,completed,once,the,execution,reaches,a,terminal,state,and,the,assigned,resource,has,been,released,return,a,future,which,is,completed,once,the,assigned,resource,has,been,released;public,completable,future,get,release,future,return,release,future
Execution -> public CompletableFuture<?> getReleaseFuture();1518680774;Gets the release future which is completed once the execution reaches a terminal_state and the assigned resource has been released.__@return A future which is completed once the assigned resource has been released;public CompletableFuture<?> getReleaseFuture() {_		return releaseFuture__	};gets,the,release,future,which,is,completed,once,the,execution,reaches,a,terminal,state,and,the,assigned,resource,has,been,released,return,a,future,which,is,completed,once,the,assigned,resource,has,been,released;public,completable,future,get,release,future,return,release,future
Execution -> public CompletableFuture<?> getReleaseFuture();1518712478;Gets the release future which is completed once the execution reaches a terminal_state and the assigned resource has been released.__@return A future which is completed once the assigned resource has been released;public CompletableFuture<?> getReleaseFuture() {_		return releaseFuture__	};gets,the,release,future,which,is,completed,once,the,execution,reaches,a,terminal,state,and,the,assigned,resource,has,been,released,return,a,future,which,is,completed,once,the,assigned,resource,has,been,released;public,completable,future,get,release,future,return,release,future
Execution -> public CompletableFuture<?> getReleaseFuture();1519316529;Gets the release future which is completed once the execution reaches a terminal_state and the assigned resource has been released.__@return A future which is completed once the assigned resource has been released;public CompletableFuture<?> getReleaseFuture() {_		return releaseFuture__	};gets,the,release,future,which,is,completed,once,the,execution,reaches,a,terminal,state,and,the,assigned,resource,has,been,released,return,a,future,which,is,completed,once,the,assigned,resource,has,been,released;public,completable,future,get,release,future,return,release,future
Execution -> public CompletableFuture<?> getReleaseFuture();1519481114;Gets the release future which is completed once the execution reaches a terminal_state and the assigned resource has been released.__@return A future which is completed once the assigned resource has been released;public CompletableFuture<?> getReleaseFuture() {_		return releaseFuture__	};gets,the,release,future,which,is,completed,once,the,execution,reaches,a,terminal,state,and,the,assigned,resource,has,been,released,return,a,future,which,is,completed,once,the,assigned,resource,has,been,released;public,completable,future,get,release,future,return,release,future
Execution -> public CompletableFuture<?> getReleaseFuture();1519568061;Gets the release future which is completed once the execution reaches a terminal_state and the assigned resource has been released.__@return A future which is completed once the assigned resource has been released;public CompletableFuture<?> getReleaseFuture() {_		return releaseFuture__	};gets,the,release,future,which,is,completed,once,the,execution,reaches,a,terminal,state,and,the,assigned,resource,has,been,released,return,a,future,which,is,completed,once,the,assigned,resource,has,been,released;public,completable,future,get,release,future,return,release,future
Execution -> public CompletableFuture<?> getReleaseFuture();1519655521;Gets the release future which is completed once the execution reaches a terminal_state and the assigned resource has been released.__@return A future which is completed once the assigned resource has been released;public CompletableFuture<?> getReleaseFuture() {_		return releaseFuture__	};gets,the,release,future,which,is,completed,once,the,execution,reaches,a,terminal,state,and,the,assigned,resource,has,been,released,return,a,future,which,is,completed,once,the,assigned,resource,has,been,released;public,completable,future,get,release,future,return,release,future
Execution -> public CompletableFuture<?> getReleaseFuture();1522049586;Gets the release future which is completed once the execution reaches a terminal_state and the assigned resource has been released.__@return A future which is completed once the assigned resource has been released;public CompletableFuture<?> getReleaseFuture() {_		return releaseFuture__	};gets,the,release,future,which,is,completed,once,the,execution,reaches,a,terminal,state,and,the,assigned,resource,has,been,released,return,a,future,which,is,completed,once,the,assigned,resource,has,been,released;public,completable,future,get,release,future,return,release,future
Execution -> public CompletableFuture<?> getReleaseFuture();1522249273;Gets the release future which is completed once the execution reaches a terminal_state and the assigned resource has been released.__@return A future which is completed once the assigned resource has been released;public CompletableFuture<?> getReleaseFuture() {_		return releaseFuture__	};gets,the,release,future,which,is,completed,once,the,execution,reaches,a,terminal,state,and,the,assigned,resource,has,been,released,return,a,future,which,is,completed,once,the,assigned,resource,has,been,released;public,completable,future,get,release,future,return,release,future
Execution -> public CompletableFuture<?> getReleaseFuture();1530712207;Gets the release future which is completed once the execution reaches a terminal_state and the assigned resource has been released.__@return A future which is completed once the assigned resource has been released;public CompletableFuture<?> getReleaseFuture() {_		return releaseFuture__	};gets,the,release,future,which,is,completed,once,the,execution,reaches,a,terminal,state,and,the,assigned,resource,has,been,released,return,a,future,which,is,completed,once,the,assigned,resource,has,been,released;public,completable,future,get,release,future,return,release,future
Execution -> public CompletableFuture<?> getReleaseFuture();1532383539;Gets the release future which is completed once the execution reaches a terminal_state and the assigned resource has been released.__@return A future which is completed once the assigned resource has been released;public CompletableFuture<?> getReleaseFuture() {_		return releaseFuture__	};gets,the,release,future,which,is,completed,once,the,execution,reaches,a,terminal,state,and,the,assigned,resource,has,been,released,return,a,future,which,is,completed,once,the,assigned,resource,has,been,released;public,completable,future,get,release,future,return,release,future
Execution -> public CompletableFuture<?> getReleaseFuture();1532383539;Gets the release future which is completed once the execution reaches a terminal_state and the assigned resource has been released.__@return A future which is completed once the assigned resource has been released;public CompletableFuture<?> getReleaseFuture() {_		return releaseFuture__	};gets,the,release,future,which,is,completed,once,the,execution,reaches,a,terminal,state,and,the,assigned,resource,has,been,released,return,a,future,which,is,completed,once,the,assigned,resource,has,been,released;public,completable,future,get,release,future,return,release,future
Execution -> public CompletableFuture<?> getReleaseFuture();1532383539;Gets the release future which is completed once the execution reaches a terminal_state and the assigned resource has been released.__@return A future which is completed once the assigned resource has been released;public CompletableFuture<?> getReleaseFuture() {_		return releaseFuture__	};gets,the,release,future,which,is,completed,once,the,execution,reaches,a,terminal,state,and,the,assigned,resource,has,been,released,return,a,future,which,is,completed,once,the,assigned,resource,has,been,released;public,completable,future,get,release,future,return,release,future
Execution -> public CompletableFuture<?> getReleaseFuture();1540920690;Gets the release future which is completed once the execution reaches a terminal_state and the assigned resource has been released.__@return A future which is completed once the assigned resource has been released;public CompletableFuture<?> getReleaseFuture() {_		return releaseFuture__	};gets,the,release,future,which,is,completed,once,the,execution,reaches,a,terminal,state,and,the,assigned,resource,has,been,released,return,a,future,which,is,completed,once,the,assigned,resource,has,been,released;public,completable,future,get,release,future,return,release,future
Execution -> public CompletableFuture<?> getReleaseFuture();1542356428;Gets the release future which is completed once the execution reaches a terminal_state and the assigned resource has been released.__@return A future which is completed once the assigned resource has been released;public CompletableFuture<?> getReleaseFuture() {_		return releaseFuture__	};gets,the,release,future,which,is,completed,once,the,execution,reaches,a,terminal,state,and,the,assigned,resource,has,been,released,return,a,future,which,is,completed,once,the,assigned,resource,has,been,released;public,completable,future,get,release,future,return,release,future
Execution -> public CompletableFuture<?> getReleaseFuture();1546870832;Gets the release future which is completed once the execution reaches a terminal_state and the assigned resource has been released.__@return A future which is completed once the assigned resource has been released;public CompletableFuture<?> getReleaseFuture() {_		return releaseFuture__	};gets,the,release,future,which,is,completed,once,the,execution,reaches,a,terminal,state,and,the,assigned,resource,has,been,released,return,a,future,which,is,completed,once,the,assigned,resource,has,been,released;public,completable,future,get,release,future,return,release,future
Execution -> public CompletableFuture<?> getReleaseFuture();1547644408;Gets the release future which is completed once the execution reaches a terminal_state and the assigned resource has been released.__@return A future which is completed once the assigned resource has been released;public CompletableFuture<?> getReleaseFuture() {_		return releaseFuture__	};gets,the,release,future,which,is,completed,once,the,execution,reaches,a,terminal,state,and,the,assigned,resource,has,been,released,return,a,future,which,is,completed,once,the,assigned,resource,has,been,released;public,completable,future,get,release,future,return,release,future
Execution -> public CompletableFuture<?> getReleaseFuture();1549365080;Gets the release future which is completed once the execution reaches a terminal_state and the assigned resource has been released._This future is always completed from the job master's main thread.__@return A future which is completed once the assigned resource has been released;public CompletableFuture<?> getReleaseFuture() {_		return releaseFuture__	};gets,the,release,future,which,is,completed,once,the,execution,reaches,a,terminal,state,and,the,assigned,resource,has,been,released,this,future,is,always,completed,from,the,job,master,s,main,thread,return,a,future,which,is,completed,once,the,assigned,resource,has,been,released;public,completable,future,get,release,future,return,release,future
Execution -> public CompletableFuture<?> getReleaseFuture();1550220073;Gets the release future which is completed once the execution reaches a terminal_state and the assigned resource has been released._This future is always completed from the job master's main thread.__@return A future which is completed once the assigned resource has been released;public CompletableFuture<?> getReleaseFuture() {_		return releaseFuture__	};gets,the,release,future,which,is,completed,once,the,execution,reaches,a,terminal,state,and,the,assigned,resource,has,been,released,this,future,is,always,completed,from,the,job,master,s,main,thread,return,a,future,which,is,completed,once,the,assigned,resource,has,been,released;public,completable,future,get,release,future,return,release,future
Execution -> public CompletableFuture<?> getReleaseFuture();1550654143;Gets the release future which is completed once the execution reaches a terminal_state and the assigned resource has been released._This future is always completed from the job master's main thread.__@return A future which is completed once the assigned resource has been released;public CompletableFuture<?> getReleaseFuture() {_		return releaseFuture__	};gets,the,release,future,which,is,completed,once,the,execution,reaches,a,terminal,state,and,the,assigned,resource,has,been,released,this,future,is,always,completed,from,the,job,master,s,main,thread,return,a,future,which,is,completed,once,the,assigned,resource,has,been,released;public,completable,future,get,release,future,return,release,future
Execution -> public CompletableFuture<?> getReleaseFuture();1550683188;Gets the release future which is completed once the execution reaches a terminal_state and the assigned resource has been released._This future is always completed from the job master's main thread.__@return A future which is completed once the assigned resource has been released;public CompletableFuture<?> getReleaseFuture() {_		return releaseFuture__	};gets,the,release,future,which,is,completed,once,the,execution,reaches,a,terminal,state,and,the,assigned,resource,has,been,released,this,future,is,always,completed,from,the,job,master,s,main,thread,return,a,future,which,is,completed,once,the,assigned,resource,has,been,released;public,completable,future,get,release,future,return,release,future
Execution -> public CompletableFuture<?> getReleaseFuture();1550855836;Gets the release future which is completed once the execution reaches a terminal_state and the assigned resource has been released._This future is always completed from the job master's main thread.__@return A future which is completed once the assigned resource has been released;public CompletableFuture<?> getReleaseFuture() {_		return releaseFuture__	};gets,the,release,future,which,is,completed,once,the,execution,reaches,a,terminal,state,and,the,assigned,resource,has,been,released,this,future,is,always,completed,from,the,job,master,s,main,thread,return,a,future,which,is,completed,once,the,assigned,resource,has,been,released;public,completable,future,get,release,future,return,release,future
Execution -> void markFailed(Throwable t);1411236169;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		_		if (processFail(t, true)) {_			if (LOG.isErrorEnabled()) {_				LOG.error("Task " + getVertexWithAttempt() + " failed.", t)__			}_		}_	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,if,process,fail,t,true,if,log,is,error,enabled,log,error,task,get,vertex,with,attempt,failed,t
Execution -> void markFailed(Throwable t);1411236169;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1411236170;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1411237261;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1411237262;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1411473593;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1412605211;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1415027294;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1415278814;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1418925507;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1418925508;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1418925510;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1418925510;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1418925511;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1418925511;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1420538822;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1421050512;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1422007786;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1423135035;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1423135035;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1423144032;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1423672458;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1423847366;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1423927053;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1424171945;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1424732907;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1424858532;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1424858532;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1425489637;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1425601895;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1425995928;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1425995929;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1425995929;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1426697080;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1426783962;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1426860022;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1428327044;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1430296839;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1430296839;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1431432049;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1431459357;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1431459358;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1432031793;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1432295874;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1432629253;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1433537224;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1436802871;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1436966346;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1437665997;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1439908661;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1440782435;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1440951699;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1441011751;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1442492512;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1448353719;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1448353719;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1449496469;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1455114877;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1455549373;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1456772768;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1461666173;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1464612094;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1465991918;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1468523508;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1470070623;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1470419821;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1472663401;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1472663402;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1472830377;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1472830377;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1473023399;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1474994376;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1474994376;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1475231926;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1476446128;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1476972861;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1477923124;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1477989375;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1478800024;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1481290933;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1482522865;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1486114103;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1486114103;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1486740510;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1487548884;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1487871589;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1488878443;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1490800309;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1490819573;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1493831843;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1493831843;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1501622876;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1501665499;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1501760738;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1502801814;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1509125300;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1509631297;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1509638684;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1509638685;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1513201052;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1513201070;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1513261599;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1515177485;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1516626377;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1516626397;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1518680774;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1518712478;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1519316529;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1519481114;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1519568061;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1519655521;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1522049586;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1522249273;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1530712207;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1532383539;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1532383539;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1532383539;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1540920690;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1542356428;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1546870832;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1547644408;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1549365080;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1550220073;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1550654143;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1550683188;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> void markFailed(Throwable t);1550855836;This method marks the task as failed, but will make no attempt to remove task execution from the task manager._It is intended for cases where the task is known not to be running, or then the TaskManager reports failure_(in which case it has already removed the task).__@param t The exception that caused the task to fail.;void markFailed(Throwable t) {_		processFail(t, true)__	};this,method,marks,the,task,as,failed,but,will,make,no,attempt,to,remove,task,execution,from,the,task,manager,it,is,intended,for,cases,where,the,task,is,known,not,to,be,running,or,then,the,task,manager,reports,failure,in,which,case,it,has,already,removed,the,task,param,t,the,exception,that,caused,the,task,to,fail;void,mark,failed,throwable,t,process,fail,t,true
Execution -> public CompletableFuture<Execution> allocateAndAssignSlotForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			Time allocationTimeout) throws IllegalExecutionStateException;1518680774;Allocates and assigns a slot obtained from the slot provider to the execution.__@param slotProvider to obtain a new slot from_@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allocationTimeout rpcTimeout for allocating a new slot_@return Future which is completed with this execution once the slot has been assigned_or with an exception if an error occurred._@throws IllegalExecutionStateException if this method has been called while not being in the CREATED state;public CompletableFuture<Execution> allocateAndAssignSlotForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			Time allocationTimeout) throws IllegalExecutionStateException {__		checkNotNull(slotProvider)___		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new IllegalStateException(_					"Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		_		if (transitionState(CREATED, SCHEDULED)) {__			final SlotSharingGroupId slotSharingGroupId = sharingGroup != null ? sharingGroup.getSlotSharingGroupId() : null___			ScheduledUnit toSchedule = locationConstraint == null ?_					new ScheduledUnit(this, slotSharingGroupId) :_					new ScheduledUnit(this, slotSharingGroupId, locationConstraint)___			_			final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture = calculatePreferredLocations(locationPreferenceConstraint)___			return preferredLocationsFuture_				.thenCompose(_					(Collection<TaskManagerLocation> preferredLocations) ->_						slotProvider.allocateSlot(_							toSchedule,_							queued,_							preferredLocations,_							allocationTimeout))_				.thenApply(_					(LogicalSlot logicalSlot) -> {_						if (tryAssignResource(logicalSlot)) {_							return this__						} else {_							_							logicalSlot.releaseSlot(new FlinkException("Could not assign logical slot to execution " + this + '.'))___							throw new CompletionException(new FlinkException("Could not assign slot " + logicalSlot + " to execution " + this + " because it has already been assigned "))__						}_					})__		}_		else {_			_			throw new IllegalExecutionStateException(this, CREATED, state)__		}_	};allocates,and,assigns,a,slot,obtained,from,the,slot,provider,to,the,execution,param,slot,provider,to,obtain,a,new,slot,from,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,allocation,timeout,rpc,timeout,for,allocating,a,new,slot,return,future,which,is,completed,with,this,execution,once,the,slot,has,been,assigned,or,with,an,exception,if,an,error,occurred,throws,illegal,execution,state,exception,if,this,method,has,been,called,while,not,being,in,the,created,state;public,completable,future,execution,allocate,and,assign,slot,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,time,allocation,timeout,throws,illegal,execution,state,exception,check,not,null,slot,provider,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,illegal,state,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,final,slot,sharing,group,id,slot,sharing,group,id,sharing,group,null,sharing,group,get,slot,sharing,group,id,null,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,slot,sharing,group,id,new,scheduled,unit,this,slot,sharing,group,id,location,constraint,final,completable,future,collection,task,manager,location,preferred,locations,future,calculate,preferred,locations,location,preference,constraint,return,preferred,locations,future,then,compose,collection,task,manager,location,preferred,locations,slot,provider,allocate,slot,to,schedule,queued,preferred,locations,allocation,timeout,then,apply,logical,slot,logical,slot,if,try,assign,resource,logical,slot,return,this,else,logical,slot,release,slot,new,flink,exception,could,not,assign,logical,slot,to,execution,this,throw,new,completion,exception,new,flink,exception,could,not,assign,slot,logical,slot,to,execution,this,because,it,has,already,been,assigned,else,throw,new,illegal,execution,state,exception,this,created,state
Execution -> public CompletableFuture<Execution> allocateAndAssignSlotForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			Time allocationTimeout) throws IllegalExecutionStateException;1518712478;Allocates and assigns a slot obtained from the slot provider to the execution.__@param slotProvider to obtain a new slot from_@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allocationTimeout rpcTimeout for allocating a new slot_@return Future which is completed with this execution once the slot has been assigned_or with an exception if an error occurred._@throws IllegalExecutionStateException if this method has been called while not being in the CREATED state;public CompletableFuture<Execution> allocateAndAssignSlotForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			Time allocationTimeout) throws IllegalExecutionStateException {__		checkNotNull(slotProvider)___		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new IllegalStateException(_					"Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		_		if (transitionState(CREATED, SCHEDULED)) {__			final SlotSharingGroupId slotSharingGroupId = sharingGroup != null ? sharingGroup.getSlotSharingGroupId() : null___			ScheduledUnit toSchedule = locationConstraint == null ?_					new ScheduledUnit(this, slotSharingGroupId) :_					new ScheduledUnit(this, slotSharingGroupId, locationConstraint)___			_			final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture = calculatePreferredLocations(locationPreferenceConstraint)___			return preferredLocationsFuture_				.thenCompose(_					(Collection<TaskManagerLocation> preferredLocations) ->_						slotProvider.allocateSlot(_							toSchedule,_							queued,_							preferredLocations,_							allocationTimeout))_				.thenApply(_					(LogicalSlot logicalSlot) -> {_						if (tryAssignResource(logicalSlot)) {_							return this__						} else {_							_							logicalSlot.releaseSlot(new FlinkException("Could not assign logical slot to execution " + this + '.'))___							throw new CompletionException(new FlinkException("Could not assign slot " + logicalSlot + " to execution " + this + " because it has already been assigned "))__						}_					})__		}_		else {_			_			throw new IllegalExecutionStateException(this, CREATED, state)__		}_	};allocates,and,assigns,a,slot,obtained,from,the,slot,provider,to,the,execution,param,slot,provider,to,obtain,a,new,slot,from,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,allocation,timeout,rpc,timeout,for,allocating,a,new,slot,return,future,which,is,completed,with,this,execution,once,the,slot,has,been,assigned,or,with,an,exception,if,an,error,occurred,throws,illegal,execution,state,exception,if,this,method,has,been,called,while,not,being,in,the,created,state;public,completable,future,execution,allocate,and,assign,slot,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,time,allocation,timeout,throws,illegal,execution,state,exception,check,not,null,slot,provider,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,illegal,state,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,final,slot,sharing,group,id,slot,sharing,group,id,sharing,group,null,sharing,group,get,slot,sharing,group,id,null,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,slot,sharing,group,id,new,scheduled,unit,this,slot,sharing,group,id,location,constraint,final,completable,future,collection,task,manager,location,preferred,locations,future,calculate,preferred,locations,location,preference,constraint,return,preferred,locations,future,then,compose,collection,task,manager,location,preferred,locations,slot,provider,allocate,slot,to,schedule,queued,preferred,locations,allocation,timeout,then,apply,logical,slot,logical,slot,if,try,assign,resource,logical,slot,return,this,else,logical,slot,release,slot,new,flink,exception,could,not,assign,logical,slot,to,execution,this,throw,new,completion,exception,new,flink,exception,could,not,assign,slot,logical,slot,to,execution,this,because,it,has,already,been,assigned,else,throw,new,illegal,execution,state,exception,this,created,state
Execution -> public CompletableFuture<Execution> allocateAndAssignSlotForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			Time allocationTimeout) throws IllegalExecutionStateException;1519316529;Allocates and assigns a slot obtained from the slot provider to the execution.__@param slotProvider to obtain a new slot from_@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allocationTimeout rpcTimeout for allocating a new slot_@return Future which is completed with this execution once the slot has been assigned_or with an exception if an error occurred._@throws IllegalExecutionStateException if this method has been called while not being in the CREATED state;public CompletableFuture<Execution> allocateAndAssignSlotForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			Time allocationTimeout) throws IllegalExecutionStateException {__		checkNotNull(slotProvider)___		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new IllegalStateException(_					"Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		_		if (transitionState(CREATED, SCHEDULED)) {__			final SlotSharingGroupId slotSharingGroupId = sharingGroup != null ? sharingGroup.getSlotSharingGroupId() : null___			ScheduledUnit toSchedule = locationConstraint == null ?_					new ScheduledUnit(this, slotSharingGroupId) :_					new ScheduledUnit(this, slotSharingGroupId, locationConstraint)___			_			final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture = calculatePreferredLocations(locationPreferenceConstraint)___			return preferredLocationsFuture_				.thenCompose(_					(Collection<TaskManagerLocation> preferredLocations) ->_						slotProvider.allocateSlot(_							toSchedule,_							queued,_							preferredLocations,_							allocationTimeout))_				.thenApply(_					(LogicalSlot logicalSlot) -> {_						if (tryAssignResource(logicalSlot)) {_							return this__						} else {_							_							logicalSlot.releaseSlot(new FlinkException("Could not assign logical slot to execution " + this + '.'))___							throw new CompletionException(new FlinkException("Could not assign slot " + logicalSlot + " to execution " + this + " because it has already been assigned "))__						}_					})__		}_		else {_			_			throw new IllegalExecutionStateException(this, CREATED, state)__		}_	};allocates,and,assigns,a,slot,obtained,from,the,slot,provider,to,the,execution,param,slot,provider,to,obtain,a,new,slot,from,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,allocation,timeout,rpc,timeout,for,allocating,a,new,slot,return,future,which,is,completed,with,this,execution,once,the,slot,has,been,assigned,or,with,an,exception,if,an,error,occurred,throws,illegal,execution,state,exception,if,this,method,has,been,called,while,not,being,in,the,created,state;public,completable,future,execution,allocate,and,assign,slot,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,time,allocation,timeout,throws,illegal,execution,state,exception,check,not,null,slot,provider,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,illegal,state,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,final,slot,sharing,group,id,slot,sharing,group,id,sharing,group,null,sharing,group,get,slot,sharing,group,id,null,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,slot,sharing,group,id,new,scheduled,unit,this,slot,sharing,group,id,location,constraint,final,completable,future,collection,task,manager,location,preferred,locations,future,calculate,preferred,locations,location,preference,constraint,return,preferred,locations,future,then,compose,collection,task,manager,location,preferred,locations,slot,provider,allocate,slot,to,schedule,queued,preferred,locations,allocation,timeout,then,apply,logical,slot,logical,slot,if,try,assign,resource,logical,slot,return,this,else,logical,slot,release,slot,new,flink,exception,could,not,assign,logical,slot,to,execution,this,throw,new,completion,exception,new,flink,exception,could,not,assign,slot,logical,slot,to,execution,this,because,it,has,already,been,assigned,else,throw,new,illegal,execution,state,exception,this,created,state
Execution -> public CompletableFuture<Execution> allocateAndAssignSlotForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			Time allocationTimeout) throws IllegalExecutionStateException;1519481114;Allocates and assigns a slot obtained from the slot provider to the execution.__@param slotProvider to obtain a new slot from_@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allocationTimeout rpcTimeout for allocating a new slot_@return Future which is completed with this execution once the slot has been assigned_or with an exception if an error occurred._@throws IllegalExecutionStateException if this method has been called while not being in the CREATED state;public CompletableFuture<Execution> allocateAndAssignSlotForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			Time allocationTimeout) throws IllegalExecutionStateException {__		checkNotNull(slotProvider)___		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new IllegalStateException(_					"Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		_		if (transitionState(CREATED, SCHEDULED)) {__			final SlotSharingGroupId slotSharingGroupId = sharingGroup != null ? sharingGroup.getSlotSharingGroupId() : null___			ScheduledUnit toSchedule = locationConstraint == null ?_					new ScheduledUnit(this, slotSharingGroupId) :_					new ScheduledUnit(this, slotSharingGroupId, locationConstraint)___			_			final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture = calculatePreferredLocations(locationPreferenceConstraint)___			final SlotRequestId slotRequestId = new SlotRequestId()___			final CompletableFuture<LogicalSlot> logicalSlotFuture = preferredLocationsFuture_				.thenCompose(_					(Collection<TaskManagerLocation> preferredLocations) ->_						slotProvider.allocateSlot(_							slotRequestId,_							toSchedule,_							queued,_							preferredLocations,_							allocationTimeout))___			_			releaseFuture.whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (logicalSlotFuture.cancel(false)) {_						slotProvider.cancelSlotRequest(_							slotRequestId,_							slotSharingGroupId,_							new FlinkException("Execution " + this + " was released."))__					}_				})___			return logicalSlotFuture.thenApply(_				(LogicalSlot logicalSlot) -> {_					if (tryAssignResource(logicalSlot)) {_						return this__					} else {_						_						logicalSlot.releaseSlot(new FlinkException("Could not assign logical slot to execution " + this + '.'))___						throw new CompletionException(new FlinkException("Could not assign slot " + logicalSlot + " to execution " + this + " because it has already been assigned "))__					}_				})__		}_		else {_			_			throw new IllegalExecutionStateException(this, CREATED, state)__		}_	};allocates,and,assigns,a,slot,obtained,from,the,slot,provider,to,the,execution,param,slot,provider,to,obtain,a,new,slot,from,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,allocation,timeout,rpc,timeout,for,allocating,a,new,slot,return,future,which,is,completed,with,this,execution,once,the,slot,has,been,assigned,or,with,an,exception,if,an,error,occurred,throws,illegal,execution,state,exception,if,this,method,has,been,called,while,not,being,in,the,created,state;public,completable,future,execution,allocate,and,assign,slot,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,time,allocation,timeout,throws,illegal,execution,state,exception,check,not,null,slot,provider,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,illegal,state,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,final,slot,sharing,group,id,slot,sharing,group,id,sharing,group,null,sharing,group,get,slot,sharing,group,id,null,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,slot,sharing,group,id,new,scheduled,unit,this,slot,sharing,group,id,location,constraint,final,completable,future,collection,task,manager,location,preferred,locations,future,calculate,preferred,locations,location,preference,constraint,final,slot,request,id,slot,request,id,new,slot,request,id,final,completable,future,logical,slot,logical,slot,future,preferred,locations,future,then,compose,collection,task,manager,location,preferred,locations,slot,provider,allocate,slot,slot,request,id,to,schedule,queued,preferred,locations,allocation,timeout,release,future,when,complete,object,ignored,throwable,throwable,if,logical,slot,future,cancel,false,slot,provider,cancel,slot,request,slot,request,id,slot,sharing,group,id,new,flink,exception,execution,this,was,released,return,logical,slot,future,then,apply,logical,slot,logical,slot,if,try,assign,resource,logical,slot,return,this,else,logical,slot,release,slot,new,flink,exception,could,not,assign,logical,slot,to,execution,this,throw,new,completion,exception,new,flink,exception,could,not,assign,slot,logical,slot,to,execution,this,because,it,has,already,been,assigned,else,throw,new,illegal,execution,state,exception,this,created,state
Execution -> public CompletableFuture<Execution> allocateAndAssignSlotForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			Time allocationTimeout) throws IllegalExecutionStateException;1519568061;Allocates and assigns a slot obtained from the slot provider to the execution.__@param slotProvider to obtain a new slot from_@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allocationTimeout rpcTimeout for allocating a new slot_@return Future which is completed with this execution once the slot has been assigned_or with an exception if an error occurred._@throws IllegalExecutionStateException if this method has been called while not being in the CREATED state;public CompletableFuture<Execution> allocateAndAssignSlotForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			Time allocationTimeout) throws IllegalExecutionStateException {__		checkNotNull(slotProvider)___		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new IllegalStateException(_					"Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		_		if (transitionState(CREATED, SCHEDULED)) {__			final SlotSharingGroupId slotSharingGroupId = sharingGroup != null ? sharingGroup.getSlotSharingGroupId() : null___			ScheduledUnit toSchedule = locationConstraint == null ?_					new ScheduledUnit(this, slotSharingGroupId) :_					new ScheduledUnit(this, slotSharingGroupId, locationConstraint)___			_			final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture = calculatePreferredLocations(locationPreferenceConstraint)___			final SlotRequestId slotRequestId = new SlotRequestId()___			final CompletableFuture<LogicalSlot> logicalSlotFuture = preferredLocationsFuture_				.thenCompose(_					(Collection<TaskManagerLocation> preferredLocations) ->_						slotProvider.allocateSlot(_							slotRequestId,_							toSchedule,_							queued,_							preferredLocations,_							allocationTimeout))___			_			releaseFuture.whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (logicalSlotFuture.cancel(false)) {_						slotProvider.cancelSlotRequest(_							slotRequestId,_							slotSharingGroupId,_							new FlinkException("Execution " + this + " was released."))__					}_				})___			return logicalSlotFuture.thenApply(_				(LogicalSlot logicalSlot) -> {_					if (tryAssignResource(logicalSlot)) {_						return this__					} else {_						_						logicalSlot.releaseSlot(new FlinkException("Could not assign logical slot to execution " + this + '.'))___						throw new CompletionException(new FlinkException("Could not assign slot " + logicalSlot + " to execution " + this + " because it has already been assigned "))__					}_				})__		}_		else {_			_			throw new IllegalExecutionStateException(this, CREATED, state)__		}_	};allocates,and,assigns,a,slot,obtained,from,the,slot,provider,to,the,execution,param,slot,provider,to,obtain,a,new,slot,from,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,allocation,timeout,rpc,timeout,for,allocating,a,new,slot,return,future,which,is,completed,with,this,execution,once,the,slot,has,been,assigned,or,with,an,exception,if,an,error,occurred,throws,illegal,execution,state,exception,if,this,method,has,been,called,while,not,being,in,the,created,state;public,completable,future,execution,allocate,and,assign,slot,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,time,allocation,timeout,throws,illegal,execution,state,exception,check,not,null,slot,provider,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,illegal,state,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,final,slot,sharing,group,id,slot,sharing,group,id,sharing,group,null,sharing,group,get,slot,sharing,group,id,null,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,slot,sharing,group,id,new,scheduled,unit,this,slot,sharing,group,id,location,constraint,final,completable,future,collection,task,manager,location,preferred,locations,future,calculate,preferred,locations,location,preference,constraint,final,slot,request,id,slot,request,id,new,slot,request,id,final,completable,future,logical,slot,logical,slot,future,preferred,locations,future,then,compose,collection,task,manager,location,preferred,locations,slot,provider,allocate,slot,slot,request,id,to,schedule,queued,preferred,locations,allocation,timeout,release,future,when,complete,object,ignored,throwable,throwable,if,logical,slot,future,cancel,false,slot,provider,cancel,slot,request,slot,request,id,slot,sharing,group,id,new,flink,exception,execution,this,was,released,return,logical,slot,future,then,apply,logical,slot,logical,slot,if,try,assign,resource,logical,slot,return,this,else,logical,slot,release,slot,new,flink,exception,could,not,assign,logical,slot,to,execution,this,throw,new,completion,exception,new,flink,exception,could,not,assign,slot,logical,slot,to,execution,this,because,it,has,already,been,assigned,else,throw,new,illegal,execution,state,exception,this,created,state
Execution -> public CompletableFuture<Execution> allocateAndAssignSlotForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			Time allocationTimeout) throws IllegalExecutionStateException;1519655521;Allocates and assigns a slot obtained from the slot provider to the execution.__@param slotProvider to obtain a new slot from_@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allocationTimeout rpcTimeout for allocating a new slot_@return Future which is completed with this execution once the slot has been assigned_or with an exception if an error occurred._@throws IllegalExecutionStateException if this method has been called while not being in the CREATED state;public CompletableFuture<Execution> allocateAndAssignSlotForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			Time allocationTimeout) throws IllegalExecutionStateException {__		checkNotNull(slotProvider)___		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new IllegalStateException(_					"Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		_		if (transitionState(CREATED, SCHEDULED)) {__			final SlotSharingGroupId slotSharingGroupId = sharingGroup != null ? sharingGroup.getSlotSharingGroupId() : null___			ScheduledUnit toSchedule = locationConstraint == null ?_					new ScheduledUnit(this, slotSharingGroupId) :_					new ScheduledUnit(this, slotSharingGroupId, locationConstraint)___			_			ExecutionVertex executionVertex = getVertex()__			AllocationID lastAllocation = executionVertex.getLatestPriorAllocation()___			Collection<AllocationID> previousAllocationIDs =_				lastAllocation != null ? Collections.singletonList(lastAllocation) : Collections.emptyList()___			_			final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture =_				calculatePreferredLocations(locationPreferenceConstraint)___			final SlotRequestId slotRequestId = new SlotRequestId()___			final CompletableFuture<LogicalSlot> logicalSlotFuture = preferredLocationsFuture_				.thenCompose(_					(Collection<TaskManagerLocation> preferredLocations) ->_						slotProvider.allocateSlot(_							slotRequestId,_							toSchedule,_							queued,_							new SlotProfile(_								ResourceProfile.UNKNOWN,_								preferredLocations,_								previousAllocationIDs),_							allocationTimeout))___			_			releaseFuture.whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (logicalSlotFuture.cancel(false)) {_						slotProvider.cancelSlotRequest(_							slotRequestId,_							slotSharingGroupId,_							new FlinkException("Execution " + this + " was released."))__					}_				})___			return logicalSlotFuture.thenApply(_				(LogicalSlot logicalSlot) -> {_					if (tryAssignResource(logicalSlot)) {_						return this__					} else {_						_						logicalSlot.releaseSlot(new FlinkException("Could not assign logical slot to execution " + this + '.'))___						throw new CompletionException(new FlinkException("Could not assign slot " + logicalSlot + " to execution " + this + " because it has already been assigned "))__					}_				})__		}_		else {_			_			throw new IllegalExecutionStateException(this, CREATED, state)__		}_	};allocates,and,assigns,a,slot,obtained,from,the,slot,provider,to,the,execution,param,slot,provider,to,obtain,a,new,slot,from,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,allocation,timeout,rpc,timeout,for,allocating,a,new,slot,return,future,which,is,completed,with,this,execution,once,the,slot,has,been,assigned,or,with,an,exception,if,an,error,occurred,throws,illegal,execution,state,exception,if,this,method,has,been,called,while,not,being,in,the,created,state;public,completable,future,execution,allocate,and,assign,slot,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,time,allocation,timeout,throws,illegal,execution,state,exception,check,not,null,slot,provider,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,illegal,state,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,final,slot,sharing,group,id,slot,sharing,group,id,sharing,group,null,sharing,group,get,slot,sharing,group,id,null,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,slot,sharing,group,id,new,scheduled,unit,this,slot,sharing,group,id,location,constraint,execution,vertex,execution,vertex,get,vertex,allocation,id,last,allocation,execution,vertex,get,latest,prior,allocation,collection,allocation,id,previous,allocation,ids,last,allocation,null,collections,singleton,list,last,allocation,collections,empty,list,final,completable,future,collection,task,manager,location,preferred,locations,future,calculate,preferred,locations,location,preference,constraint,final,slot,request,id,slot,request,id,new,slot,request,id,final,completable,future,logical,slot,logical,slot,future,preferred,locations,future,then,compose,collection,task,manager,location,preferred,locations,slot,provider,allocate,slot,slot,request,id,to,schedule,queued,new,slot,profile,resource,profile,unknown,preferred,locations,previous,allocation,ids,allocation,timeout,release,future,when,complete,object,ignored,throwable,throwable,if,logical,slot,future,cancel,false,slot,provider,cancel,slot,request,slot,request,id,slot,sharing,group,id,new,flink,exception,execution,this,was,released,return,logical,slot,future,then,apply,logical,slot,logical,slot,if,try,assign,resource,logical,slot,return,this,else,logical,slot,release,slot,new,flink,exception,could,not,assign,logical,slot,to,execution,this,throw,new,completion,exception,new,flink,exception,could,not,assign,slot,logical,slot,to,execution,this,because,it,has,already,been,assigned,else,throw,new,illegal,execution,state,exception,this,created,state
Execution -> public CompletableFuture<Execution> allocateAndAssignSlotForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			Time allocationTimeout) throws IllegalExecutionStateException;1522049586;Allocates and assigns a slot obtained from the slot provider to the execution.__@param slotProvider to obtain a new slot from_@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allocationTimeout rpcTimeout for allocating a new slot_@return Future which is completed with this execution once the slot has been assigned_or with an exception if an error occurred._@throws IllegalExecutionStateException if this method has been called while not being in the CREATED state;public CompletableFuture<Execution> allocateAndAssignSlotForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			Time allocationTimeout) throws IllegalExecutionStateException {__		checkNotNull(slotProvider)___		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new IllegalStateException(_					"Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		_		if (transitionState(CREATED, SCHEDULED)) {__			final SlotSharingGroupId slotSharingGroupId = sharingGroup != null ? sharingGroup.getSlotSharingGroupId() : null___			ScheduledUnit toSchedule = locationConstraint == null ?_					new ScheduledUnit(this, slotSharingGroupId) :_					new ScheduledUnit(this, slotSharingGroupId, locationConstraint)___			_			ExecutionVertex executionVertex = getVertex()__			AllocationID lastAllocation = executionVertex.getLatestPriorAllocation()___			Collection<AllocationID> previousAllocationIDs =_				lastAllocation != null ? Collections.singletonList(lastAllocation) : Collections.emptyList()___			_			final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture =_				calculatePreferredLocations(locationPreferenceConstraint)___			final SlotRequestId slotRequestId = new SlotRequestId()___			final CompletableFuture<LogicalSlot> logicalSlotFuture = preferredLocationsFuture_				.thenCompose(_					(Collection<TaskManagerLocation> preferredLocations) ->_						slotProvider.allocateSlot(_							slotRequestId,_							toSchedule,_							queued,_							new SlotProfile(_								ResourceProfile.UNKNOWN,_								preferredLocations,_								previousAllocationIDs),_							allocationTimeout))___			_			releaseFuture.whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (logicalSlotFuture.cancel(false)) {_						slotProvider.cancelSlotRequest(_							slotRequestId,_							slotSharingGroupId,_							new FlinkException("Execution " + this + " was released."))__					}_				})___			return logicalSlotFuture.thenApply(_				(LogicalSlot logicalSlot) -> {_					if (tryAssignResource(logicalSlot)) {_						return this__					} else {_						_						logicalSlot.releaseSlot(new FlinkException("Could not assign logical slot to execution " + this + '.'))___						throw new CompletionException(new FlinkException("Could not assign slot " + logicalSlot + " to execution " + this + " because it has already been assigned "))__					}_				})__		}_		else {_			_			throw new IllegalExecutionStateException(this, CREATED, state)__		}_	};allocates,and,assigns,a,slot,obtained,from,the,slot,provider,to,the,execution,param,slot,provider,to,obtain,a,new,slot,from,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,allocation,timeout,rpc,timeout,for,allocating,a,new,slot,return,future,which,is,completed,with,this,execution,once,the,slot,has,been,assigned,or,with,an,exception,if,an,error,occurred,throws,illegal,execution,state,exception,if,this,method,has,been,called,while,not,being,in,the,created,state;public,completable,future,execution,allocate,and,assign,slot,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,time,allocation,timeout,throws,illegal,execution,state,exception,check,not,null,slot,provider,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,illegal,state,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,final,slot,sharing,group,id,slot,sharing,group,id,sharing,group,null,sharing,group,get,slot,sharing,group,id,null,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,slot,sharing,group,id,new,scheduled,unit,this,slot,sharing,group,id,location,constraint,execution,vertex,execution,vertex,get,vertex,allocation,id,last,allocation,execution,vertex,get,latest,prior,allocation,collection,allocation,id,previous,allocation,ids,last,allocation,null,collections,singleton,list,last,allocation,collections,empty,list,final,completable,future,collection,task,manager,location,preferred,locations,future,calculate,preferred,locations,location,preference,constraint,final,slot,request,id,slot,request,id,new,slot,request,id,final,completable,future,logical,slot,logical,slot,future,preferred,locations,future,then,compose,collection,task,manager,location,preferred,locations,slot,provider,allocate,slot,slot,request,id,to,schedule,queued,new,slot,profile,resource,profile,unknown,preferred,locations,previous,allocation,ids,allocation,timeout,release,future,when,complete,object,ignored,throwable,throwable,if,logical,slot,future,cancel,false,slot,provider,cancel,slot,request,slot,request,id,slot,sharing,group,id,new,flink,exception,execution,this,was,released,return,logical,slot,future,then,apply,logical,slot,logical,slot,if,try,assign,resource,logical,slot,return,this,else,logical,slot,release,slot,new,flink,exception,could,not,assign,logical,slot,to,execution,this,throw,new,completion,exception,new,flink,exception,could,not,assign,slot,logical,slot,to,execution,this,because,it,has,already,been,assigned,else,throw,new,illegal,execution,state,exception,this,created,state
Execution -> public CompletableFuture<Execution> allocateAndAssignSlotForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			Time allocationTimeout) throws IllegalExecutionStateException;1522249273;Allocates and assigns a slot obtained from the slot provider to the execution.__@param slotProvider to obtain a new slot from_@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allocationTimeout rpcTimeout for allocating a new slot_@return Future which is completed with this execution once the slot has been assigned_or with an exception if an error occurred._@throws IllegalExecutionStateException if this method has been called while not being in the CREATED state;public CompletableFuture<Execution> allocateAndAssignSlotForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			Time allocationTimeout) throws IllegalExecutionStateException {__		checkNotNull(slotProvider)___		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new IllegalStateException(_					"Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		_		if (transitionState(CREATED, SCHEDULED)) {__			final SlotSharingGroupId slotSharingGroupId = sharingGroup != null ? sharingGroup.getSlotSharingGroupId() : null___			ScheduledUnit toSchedule = locationConstraint == null ?_					new ScheduledUnit(this, slotSharingGroupId) :_					new ScheduledUnit(this, slotSharingGroupId, locationConstraint)___			_			ExecutionVertex executionVertex = getVertex()__			AllocationID lastAllocation = executionVertex.getLatestPriorAllocation()___			Collection<AllocationID> previousAllocationIDs =_				lastAllocation != null ? Collections.singletonList(lastAllocation) : Collections.emptyList()___			_			final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture =_				calculatePreferredLocations(locationPreferenceConstraint)___			final SlotRequestId slotRequestId = new SlotRequestId()___			final CompletableFuture<LogicalSlot> logicalSlotFuture = preferredLocationsFuture_				.thenCompose(_					(Collection<TaskManagerLocation> preferredLocations) ->_						slotProvider.allocateSlot(_							slotRequestId,_							toSchedule,_							queued,_							new SlotProfile(_								ResourceProfile.UNKNOWN,_								preferredLocations,_								previousAllocationIDs),_							allocationTimeout))___			_			releaseFuture.whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (logicalSlotFuture.cancel(false)) {_						slotProvider.cancelSlotRequest(_							slotRequestId,_							slotSharingGroupId,_							new FlinkException("Execution " + this + " was released."))__					}_				})___			return logicalSlotFuture.thenApply(_				(LogicalSlot logicalSlot) -> {_					if (tryAssignResource(logicalSlot)) {_						return this__					} else {_						_						logicalSlot.releaseSlot(new FlinkException("Could not assign logical slot to execution " + this + '.'))___						throw new CompletionException(new FlinkException("Could not assign slot " + logicalSlot + " to execution " + this + " because it has already been assigned "))__					}_				})__		}_		else {_			_			throw new IllegalExecutionStateException(this, CREATED, state)__		}_	};allocates,and,assigns,a,slot,obtained,from,the,slot,provider,to,the,execution,param,slot,provider,to,obtain,a,new,slot,from,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,allocation,timeout,rpc,timeout,for,allocating,a,new,slot,return,future,which,is,completed,with,this,execution,once,the,slot,has,been,assigned,or,with,an,exception,if,an,error,occurred,throws,illegal,execution,state,exception,if,this,method,has,been,called,while,not,being,in,the,created,state;public,completable,future,execution,allocate,and,assign,slot,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,time,allocation,timeout,throws,illegal,execution,state,exception,check,not,null,slot,provider,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,illegal,state,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,final,slot,sharing,group,id,slot,sharing,group,id,sharing,group,null,sharing,group,get,slot,sharing,group,id,null,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,slot,sharing,group,id,new,scheduled,unit,this,slot,sharing,group,id,location,constraint,execution,vertex,execution,vertex,get,vertex,allocation,id,last,allocation,execution,vertex,get,latest,prior,allocation,collection,allocation,id,previous,allocation,ids,last,allocation,null,collections,singleton,list,last,allocation,collections,empty,list,final,completable,future,collection,task,manager,location,preferred,locations,future,calculate,preferred,locations,location,preference,constraint,final,slot,request,id,slot,request,id,new,slot,request,id,final,completable,future,logical,slot,logical,slot,future,preferred,locations,future,then,compose,collection,task,manager,location,preferred,locations,slot,provider,allocate,slot,slot,request,id,to,schedule,queued,new,slot,profile,resource,profile,unknown,preferred,locations,previous,allocation,ids,allocation,timeout,release,future,when,complete,object,ignored,throwable,throwable,if,logical,slot,future,cancel,false,slot,provider,cancel,slot,request,slot,request,id,slot,sharing,group,id,new,flink,exception,execution,this,was,released,return,logical,slot,future,then,apply,logical,slot,logical,slot,if,try,assign,resource,logical,slot,return,this,else,logical,slot,release,slot,new,flink,exception,could,not,assign,logical,slot,to,execution,this,throw,new,completion,exception,new,flink,exception,could,not,assign,slot,logical,slot,to,execution,this,because,it,has,already,been,assigned,else,throw,new,illegal,execution,state,exception,this,created,state
Execution -> public CompletableFuture<Execution> allocateAndAssignSlotForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			Time allocationTimeout) throws IllegalExecutionStateException;1530712207;Allocates and assigns a slot obtained from the slot provider to the execution.__@param slotProvider to obtain a new slot from_@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allocationTimeout rpcTimeout for allocating a new slot_@return Future which is completed with this execution once the slot has been assigned_or with an exception if an error occurred._@throws IllegalExecutionStateException if this method has been called while not being in the CREATED state;public CompletableFuture<Execution> allocateAndAssignSlotForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			Time allocationTimeout) throws IllegalExecutionStateException {__		checkNotNull(slotProvider)___		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new IllegalStateException(_					"Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		_		if (transitionState(CREATED, SCHEDULED)) {__			final SlotSharingGroupId slotSharingGroupId = sharingGroup != null ? sharingGroup.getSlotSharingGroupId() : null___			ScheduledUnit toSchedule = locationConstraint == null ?_					new ScheduledUnit(this, slotSharingGroupId) :_					new ScheduledUnit(this, slotSharingGroupId, locationConstraint)___			_			ExecutionVertex executionVertex = getVertex()__			AllocationID lastAllocation = executionVertex.getLatestPriorAllocation()___			Collection<AllocationID> previousAllocationIDs =_				lastAllocation != null ? Collections.singletonList(lastAllocation) : Collections.emptyList()___			_			final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture =_				calculatePreferredLocations(locationPreferenceConstraint)___			final SlotRequestId slotRequestId = new SlotRequestId()___			final CompletableFuture<LogicalSlot> logicalSlotFuture = preferredLocationsFuture_				.thenCompose(_					(Collection<TaskManagerLocation> preferredLocations) ->_						slotProvider.allocateSlot(_							slotRequestId,_							toSchedule,_							queued,_							new SlotProfile(_								ResourceProfile.UNKNOWN,_								preferredLocations,_								previousAllocationIDs),_							allocationTimeout))___			_			releaseFuture.whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (logicalSlotFuture.cancel(false)) {_						slotProvider.cancelSlotRequest(_							slotRequestId,_							slotSharingGroupId,_							new FlinkException("Execution " + this + " was released."))__					}_				})___			return logicalSlotFuture.thenApply(_				(LogicalSlot logicalSlot) -> {_					if (tryAssignResource(logicalSlot)) {_						return this__					} else {_						_						logicalSlot.releaseSlot(new FlinkException("Could not assign logical slot to execution " + this + '.'))___						throw new CompletionException(new FlinkException("Could not assign slot " + logicalSlot + " to execution " + this + " because it has already been assigned "))__					}_				})__		}_		else {_			_			throw new IllegalExecutionStateException(this, CREATED, state)__		}_	};allocates,and,assigns,a,slot,obtained,from,the,slot,provider,to,the,execution,param,slot,provider,to,obtain,a,new,slot,from,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,allocation,timeout,rpc,timeout,for,allocating,a,new,slot,return,future,which,is,completed,with,this,execution,once,the,slot,has,been,assigned,or,with,an,exception,if,an,error,occurred,throws,illegal,execution,state,exception,if,this,method,has,been,called,while,not,being,in,the,created,state;public,completable,future,execution,allocate,and,assign,slot,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,time,allocation,timeout,throws,illegal,execution,state,exception,check,not,null,slot,provider,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,illegal,state,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,final,slot,sharing,group,id,slot,sharing,group,id,sharing,group,null,sharing,group,get,slot,sharing,group,id,null,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,slot,sharing,group,id,new,scheduled,unit,this,slot,sharing,group,id,location,constraint,execution,vertex,execution,vertex,get,vertex,allocation,id,last,allocation,execution,vertex,get,latest,prior,allocation,collection,allocation,id,previous,allocation,ids,last,allocation,null,collections,singleton,list,last,allocation,collections,empty,list,final,completable,future,collection,task,manager,location,preferred,locations,future,calculate,preferred,locations,location,preference,constraint,final,slot,request,id,slot,request,id,new,slot,request,id,final,completable,future,logical,slot,logical,slot,future,preferred,locations,future,then,compose,collection,task,manager,location,preferred,locations,slot,provider,allocate,slot,slot,request,id,to,schedule,queued,new,slot,profile,resource,profile,unknown,preferred,locations,previous,allocation,ids,allocation,timeout,release,future,when,complete,object,ignored,throwable,throwable,if,logical,slot,future,cancel,false,slot,provider,cancel,slot,request,slot,request,id,slot,sharing,group,id,new,flink,exception,execution,this,was,released,return,logical,slot,future,then,apply,logical,slot,logical,slot,if,try,assign,resource,logical,slot,return,this,else,logical,slot,release,slot,new,flink,exception,could,not,assign,logical,slot,to,execution,this,throw,new,completion,exception,new,flink,exception,could,not,assign,slot,logical,slot,to,execution,this,because,it,has,already,been,assigned,else,throw,new,illegal,execution,state,exception,this,created,state
Execution -> public CompletableFuture<Execution> allocateAndAssignSlotForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			Time allocationTimeout) throws IllegalExecutionStateException;1532383539;Allocates and assigns a slot obtained from the slot provider to the execution.__@param slotProvider to obtain a new slot from_@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allocationTimeout rpcTimeout for allocating a new slot_@return Future which is completed with this execution once the slot has been assigned_or with an exception if an error occurred._@throws IllegalExecutionStateException if this method has been called while not being in the CREATED state;public CompletableFuture<Execution> allocateAndAssignSlotForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			Time allocationTimeout) throws IllegalExecutionStateException {__		checkNotNull(slotProvider)___		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new IllegalStateException(_					"Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		_		if (transitionState(CREATED, SCHEDULED)) {__			final SlotSharingGroupId slotSharingGroupId = sharingGroup != null ? sharingGroup.getSlotSharingGroupId() : null___			ScheduledUnit toSchedule = locationConstraint == null ?_					new ScheduledUnit(this, slotSharingGroupId) :_					new ScheduledUnit(this, slotSharingGroupId, locationConstraint)___			_			ExecutionVertex executionVertex = getVertex()__			AllocationID lastAllocation = executionVertex.getLatestPriorAllocation()___			Collection<AllocationID> previousAllocationIDs =_				lastAllocation != null ? Collections.singletonList(lastAllocation) : Collections.emptyList()___			_			final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture =_				calculatePreferredLocations(locationPreferenceConstraint)___			final SlotRequestId slotRequestId = new SlotRequestId()___			final CompletableFuture<LogicalSlot> logicalSlotFuture = preferredLocationsFuture_				.thenCompose(_					(Collection<TaskManagerLocation> preferredLocations) ->_						slotProvider.allocateSlot(_							slotRequestId,_							toSchedule,_							queued,_							new SlotProfile(_								ResourceProfile.UNKNOWN,_								preferredLocations,_								previousAllocationIDs),_							allocationTimeout))___			_			releaseFuture.whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (logicalSlotFuture.cancel(false)) {_						slotProvider.cancelSlotRequest(_							slotRequestId,_							slotSharingGroupId,_							new FlinkException("Execution " + this + " was released."))__					}_				})___			return logicalSlotFuture.thenApply(_				(LogicalSlot logicalSlot) -> {_					if (tryAssignResource(logicalSlot)) {_						return this__					} else {_						_						logicalSlot.releaseSlot(new FlinkException("Could not assign logical slot to execution " + this + '.'))___						throw new CompletionException(new FlinkException("Could not assign slot " + logicalSlot + " to execution " + this + " because it has already been assigned "))__					}_				})__		}_		else {_			_			throw new IllegalExecutionStateException(this, CREATED, state)__		}_	};allocates,and,assigns,a,slot,obtained,from,the,slot,provider,to,the,execution,param,slot,provider,to,obtain,a,new,slot,from,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,allocation,timeout,rpc,timeout,for,allocating,a,new,slot,return,future,which,is,completed,with,this,execution,once,the,slot,has,been,assigned,or,with,an,exception,if,an,error,occurred,throws,illegal,execution,state,exception,if,this,method,has,been,called,while,not,being,in,the,created,state;public,completable,future,execution,allocate,and,assign,slot,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,time,allocation,timeout,throws,illegal,execution,state,exception,check,not,null,slot,provider,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,illegal,state,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,final,slot,sharing,group,id,slot,sharing,group,id,sharing,group,null,sharing,group,get,slot,sharing,group,id,null,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,slot,sharing,group,id,new,scheduled,unit,this,slot,sharing,group,id,location,constraint,execution,vertex,execution,vertex,get,vertex,allocation,id,last,allocation,execution,vertex,get,latest,prior,allocation,collection,allocation,id,previous,allocation,ids,last,allocation,null,collections,singleton,list,last,allocation,collections,empty,list,final,completable,future,collection,task,manager,location,preferred,locations,future,calculate,preferred,locations,location,preference,constraint,final,slot,request,id,slot,request,id,new,slot,request,id,final,completable,future,logical,slot,logical,slot,future,preferred,locations,future,then,compose,collection,task,manager,location,preferred,locations,slot,provider,allocate,slot,slot,request,id,to,schedule,queued,new,slot,profile,resource,profile,unknown,preferred,locations,previous,allocation,ids,allocation,timeout,release,future,when,complete,object,ignored,throwable,throwable,if,logical,slot,future,cancel,false,slot,provider,cancel,slot,request,slot,request,id,slot,sharing,group,id,new,flink,exception,execution,this,was,released,return,logical,slot,future,then,apply,logical,slot,logical,slot,if,try,assign,resource,logical,slot,return,this,else,logical,slot,release,slot,new,flink,exception,could,not,assign,logical,slot,to,execution,this,throw,new,completion,exception,new,flink,exception,could,not,assign,slot,logical,slot,to,execution,this,because,it,has,already,been,assigned,else,throw,new,illegal,execution,state,exception,this,created,state
Execution -> public CompletableFuture<Execution> allocateAndAssignSlotForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			Time allocationTimeout) throws IllegalExecutionStateException;1532383539;Allocates and assigns a slot obtained from the slot provider to the execution.__@param slotProvider to obtain a new slot from_@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allocationTimeout rpcTimeout for allocating a new slot_@return Future which is completed with this execution once the slot has been assigned_or with an exception if an error occurred._@throws IllegalExecutionStateException if this method has been called while not being in the CREATED state;public CompletableFuture<Execution> allocateAndAssignSlotForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			Time allocationTimeout) throws IllegalExecutionStateException {__		checkNotNull(slotProvider)___		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new IllegalStateException(_					"Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		_		if (transitionState(CREATED, SCHEDULED)) {__			final SlotSharingGroupId slotSharingGroupId = sharingGroup != null ? sharingGroup.getSlotSharingGroupId() : null___			ScheduledUnit toSchedule = locationConstraint == null ?_					new ScheduledUnit(this, slotSharingGroupId) :_					new ScheduledUnit(this, slotSharingGroupId, locationConstraint)___			_			ExecutionVertex executionVertex = getVertex()__			AllocationID lastAllocation = executionVertex.getLatestPriorAllocation()___			Collection<AllocationID> previousAllocationIDs =_				lastAllocation != null ? Collections.singletonList(lastAllocation) : Collections.emptyList()___			_			final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture =_				calculatePreferredLocations(locationPreferenceConstraint)___			final SlotRequestId slotRequestId = new SlotRequestId()___			final CompletableFuture<LogicalSlot> logicalSlotFuture = preferredLocationsFuture_				.thenCompose(_					(Collection<TaskManagerLocation> preferredLocations) ->_						slotProvider.allocateSlot(_							slotRequestId,_							toSchedule,_							queued,_							new SlotProfile(_								ResourceProfile.UNKNOWN,_								preferredLocations,_								previousAllocationIDs),_							allocationTimeout))___			_			releaseFuture.whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (logicalSlotFuture.cancel(false)) {_						slotProvider.cancelSlotRequest(_							slotRequestId,_							slotSharingGroupId,_							new FlinkException("Execution " + this + " was released."))__					}_				})___			return logicalSlotFuture.thenApply(_				(LogicalSlot logicalSlot) -> {_					if (tryAssignResource(logicalSlot)) {_						return this__					} else {_						_						logicalSlot.releaseSlot(new FlinkException("Could not assign logical slot to execution " + this + '.'))___						throw new CompletionException(new FlinkException("Could not assign slot " + logicalSlot + " to execution " + this + " because it has already been assigned "))__					}_				})__		}_		else {_			_			throw new IllegalExecutionStateException(this, CREATED, state)__		}_	};allocates,and,assigns,a,slot,obtained,from,the,slot,provider,to,the,execution,param,slot,provider,to,obtain,a,new,slot,from,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,allocation,timeout,rpc,timeout,for,allocating,a,new,slot,return,future,which,is,completed,with,this,execution,once,the,slot,has,been,assigned,or,with,an,exception,if,an,error,occurred,throws,illegal,execution,state,exception,if,this,method,has,been,called,while,not,being,in,the,created,state;public,completable,future,execution,allocate,and,assign,slot,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,time,allocation,timeout,throws,illegal,execution,state,exception,check,not,null,slot,provider,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,illegal,state,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,final,slot,sharing,group,id,slot,sharing,group,id,sharing,group,null,sharing,group,get,slot,sharing,group,id,null,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,slot,sharing,group,id,new,scheduled,unit,this,slot,sharing,group,id,location,constraint,execution,vertex,execution,vertex,get,vertex,allocation,id,last,allocation,execution,vertex,get,latest,prior,allocation,collection,allocation,id,previous,allocation,ids,last,allocation,null,collections,singleton,list,last,allocation,collections,empty,list,final,completable,future,collection,task,manager,location,preferred,locations,future,calculate,preferred,locations,location,preference,constraint,final,slot,request,id,slot,request,id,new,slot,request,id,final,completable,future,logical,slot,logical,slot,future,preferred,locations,future,then,compose,collection,task,manager,location,preferred,locations,slot,provider,allocate,slot,slot,request,id,to,schedule,queued,new,slot,profile,resource,profile,unknown,preferred,locations,previous,allocation,ids,allocation,timeout,release,future,when,complete,object,ignored,throwable,throwable,if,logical,slot,future,cancel,false,slot,provider,cancel,slot,request,slot,request,id,slot,sharing,group,id,new,flink,exception,execution,this,was,released,return,logical,slot,future,then,apply,logical,slot,logical,slot,if,try,assign,resource,logical,slot,return,this,else,logical,slot,release,slot,new,flink,exception,could,not,assign,logical,slot,to,execution,this,throw,new,completion,exception,new,flink,exception,could,not,assign,slot,logical,slot,to,execution,this,because,it,has,already,been,assigned,else,throw,new,illegal,execution,state,exception,this,created,state
Execution -> public CompletableFuture<Execution> allocateAndAssignSlotForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			Time allocationTimeout) throws IllegalExecutionStateException;1532383539;Allocates and assigns a slot obtained from the slot provider to the execution.__@param slotProvider to obtain a new slot from_@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allocationTimeout rpcTimeout for allocating a new slot_@return Future which is completed with this execution once the slot has been assigned_or with an exception if an error occurred._@throws IllegalExecutionStateException if this method has been called while not being in the CREATED state;public CompletableFuture<Execution> allocateAndAssignSlotForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			Time allocationTimeout) throws IllegalExecutionStateException {__		checkNotNull(slotProvider)___		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup()__		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint()___		_		if (locationConstraint != null && sharingGroup == null) {_			throw new IllegalStateException(_					"Trying to schedule with co-location constraint but without slot sharing allowed.")__		}__		_		if (transitionState(CREATED, SCHEDULED)) {__			final SlotSharingGroupId slotSharingGroupId = sharingGroup != null ? sharingGroup.getSlotSharingGroupId() : null___			ScheduledUnit toSchedule = locationConstraint == null ?_					new ScheduledUnit(this, slotSharingGroupId) :_					new ScheduledUnit(this, slotSharingGroupId, locationConstraint)___			_			ExecutionVertex executionVertex = getVertex()__			AllocationID lastAllocation = executionVertex.getLatestPriorAllocation()___			Collection<AllocationID> previousAllocationIDs =_				lastAllocation != null ? Collections.singletonList(lastAllocation) : Collections.emptyList()___			_			final CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture =_				calculatePreferredLocations(locationPreferenceConstraint)___			final SlotRequestId slotRequestId = new SlotRequestId()___			final CompletableFuture<LogicalSlot> logicalSlotFuture = preferredLocationsFuture_				.thenCompose(_					(Collection<TaskManagerLocation> preferredLocations) ->_						slotProvider.allocateSlot(_							slotRequestId,_							toSchedule,_							queued,_							new SlotProfile(_								ResourceProfile.UNKNOWN,_								preferredLocations,_								previousAllocationIDs),_							allocationTimeout))___			_			releaseFuture.whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (logicalSlotFuture.cancel(false)) {_						slotProvider.cancelSlotRequest(_							slotRequestId,_							slotSharingGroupId,_							new FlinkException("Execution " + this + " was released."))__					}_				})___			return logicalSlotFuture.thenApply(_				(LogicalSlot logicalSlot) -> {_					if (tryAssignResource(logicalSlot)) {_						return this__					} else {_						_						logicalSlot.releaseSlot(new FlinkException("Could not assign logical slot to execution " + this + '.'))___						throw new CompletionException(new FlinkException("Could not assign slot " + logicalSlot + " to execution " + this + " because it has already been assigned "))__					}_				})__		}_		else {_			_			throw new IllegalExecutionStateException(this, CREATED, state)__		}_	};allocates,and,assigns,a,slot,obtained,from,the,slot,provider,to,the,execution,param,slot,provider,to,obtain,a,new,slot,from,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,allocation,timeout,rpc,timeout,for,allocating,a,new,slot,return,future,which,is,completed,with,this,execution,once,the,slot,has,been,assigned,or,with,an,exception,if,an,error,occurred,throws,illegal,execution,state,exception,if,this,method,has,been,called,while,not,being,in,the,created,state;public,completable,future,execution,allocate,and,assign,slot,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,time,allocation,timeout,throws,illegal,execution,state,exception,check,not,null,slot,provider,final,slot,sharing,group,sharing,group,vertex,get,job,vertex,get,slot,sharing,group,final,co,location,constraint,location,constraint,vertex,get,location,constraint,if,location,constraint,null,sharing,group,null,throw,new,illegal,state,exception,trying,to,schedule,with,co,location,constraint,but,without,slot,sharing,allowed,if,transition,state,created,scheduled,final,slot,sharing,group,id,slot,sharing,group,id,sharing,group,null,sharing,group,get,slot,sharing,group,id,null,scheduled,unit,to,schedule,location,constraint,null,new,scheduled,unit,this,slot,sharing,group,id,new,scheduled,unit,this,slot,sharing,group,id,location,constraint,execution,vertex,execution,vertex,get,vertex,allocation,id,last,allocation,execution,vertex,get,latest,prior,allocation,collection,allocation,id,previous,allocation,ids,last,allocation,null,collections,singleton,list,last,allocation,collections,empty,list,final,completable,future,collection,task,manager,location,preferred,locations,future,calculate,preferred,locations,location,preference,constraint,final,slot,request,id,slot,request,id,new,slot,request,id,final,completable,future,logical,slot,logical,slot,future,preferred,locations,future,then,compose,collection,task,manager,location,preferred,locations,slot,provider,allocate,slot,slot,request,id,to,schedule,queued,new,slot,profile,resource,profile,unknown,preferred,locations,previous,allocation,ids,allocation,timeout,release,future,when,complete,object,ignored,throwable,throwable,if,logical,slot,future,cancel,false,slot,provider,cancel,slot,request,slot,request,id,slot,sharing,group,id,new,flink,exception,execution,this,was,released,return,logical,slot,future,then,apply,logical,slot,logical,slot,if,try,assign,resource,logical,slot,return,this,else,logical,slot,release,slot,new,flink,exception,could,not,assign,logical,slot,to,execution,this,throw,new,completion,exception,new,flink,exception,could,not,assign,slot,logical,slot,to,execution,this,because,it,has,already,been,assigned,else,throw,new,illegal,execution,state,exception,this,created,state
Execution -> public void setInitialState(CheckpointStateHandles checkpointStateHandles, List<Collection<OperatorStateHandle>> chainedPartitionableStateHandle);1475231926;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param checkpointStateHandles all checkpointed operator state;public void setInitialState(CheckpointStateHandles checkpointStateHandles, List<Collection<OperatorStateHandle>> chainedPartitionableStateHandle) {__		if (state != ExecutionState.CREATED) {_			throw new IllegalArgumentException("Can only assign operator state when execution attempt is in CREATED")__		}__		if(checkpointStateHandles != null) {_			this.chainedStateHandle = checkpointStateHandles.getNonPartitionedStateHandles()__			this.chainedPartitionableStateHandle = chainedPartitionableStateHandle__			this.keyGroupsStateHandles = checkpointStateHandles.getKeyGroupsStateHandle()__		}_	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,checkpoint,state,handles,all,checkpointed,operator,state;public,void,set,initial,state,checkpoint,state,handles,checkpoint,state,handles,list,collection,operator,state,handle,chained,partitionable,state,handle,if,state,execution,state,created,throw,new,illegal,argument,exception,can,only,assign,operator,state,when,execution,attempt,is,in,created,if,checkpoint,state,handles,null,this,chained,state,handle,checkpoint,state,handles,get,non,partitioned,state,handles,this,chained,partitionable,state,handle,chained,partitionable,state,handle,this,key,groups,state,handles,checkpoint,state,handles,get,key,groups,state,handle
Execution -> public void setInitialState(CheckpointStateHandles checkpointStateHandles, List<Collection<OperatorStateHandle>> chainedPartitionableStateHandle);1476446128;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param checkpointStateHandles all checkpointed operator state;public void setInitialState(CheckpointStateHandles checkpointStateHandles, List<Collection<OperatorStateHandle>> chainedPartitionableStateHandle) {__		if (state != ExecutionState.CREATED) {_			throw new IllegalArgumentException("Can only assign operator state when execution attempt is in CREATED")__		}__		if(checkpointStateHandles != null) {_			this.chainedStateHandle = checkpointStateHandles.getNonPartitionedStateHandles()__			this.chainedPartitionableStateHandle = chainedPartitionableStateHandle__			this.keyGroupsStateHandles = checkpointStateHandles.getKeyGroupsStateHandle()__		}_	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,checkpoint,state,handles,all,checkpointed,operator,state;public,void,set,initial,state,checkpoint,state,handles,checkpoint,state,handles,list,collection,operator,state,handle,chained,partitionable,state,handle,if,state,execution,state,created,throw,new,illegal,argument,exception,can,only,assign,operator,state,when,execution,attempt,is,in,created,if,checkpoint,state,handles,null,this,chained,state,handle,checkpoint,state,handles,get,non,partitioned,state,handles,this,chained,partitionable,state,handle,chained,partitionable,state,handle,this,key,groups,state,handles,checkpoint,state,handles,get,key,groups,state,handle
Execution -> private void sendCancelRpcCall();1436802871;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {__			final InstanceGateway gateway = slot.getInstance().getInstanceGateway()___			Future<Object> cancelResult = gateway.retry(_				new CancelTask(attemptId),_				NUM_CANCEL_CALL_TRIES,_				timeout,_				executionContext)___			cancelResult.onComplete(new OnComplete<Object>() {__				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.debug("Cancel task call did not find task. Probably akka message call" +_									" race.")__						}_					}_				}_			}, executionContext)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,instance,gateway,gateway,slot,get,instance,get,instance,gateway,future,object,cancel,result,gateway,retry,new,cancel,task,attempt,id,timeout,execution,context,cancel,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,debug,cancel,task,call,did,not,find,task,probably,akka,message,call,race,execution,context
Execution -> private void sendCancelRpcCall();1436966346;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {__			final InstanceGateway gateway = slot.getInstance().getInstanceGateway()___			Future<Object> cancelResult = gateway.retry(_				new CancelTask(attemptId),_				NUM_CANCEL_CALL_TRIES,_				timeout,_				executionContext)___			cancelResult.onComplete(new OnComplete<Object>() {__				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.debug("Cancel task call did not find task. Probably akka message call" +_									" race.")__						}_					}_				}_			}, executionContext)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,instance,gateway,gateway,slot,get,instance,get,instance,gateway,future,object,cancel,result,gateway,retry,new,cancel,task,attempt,id,timeout,execution,context,cancel,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,debug,cancel,task,call,did,not,find,task,probably,akka,message,call,race,execution,context
Execution -> private void sendCancelRpcCall();1437665997;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {__			final ActorGateway gateway = slot.getInstance().getActorGateway()___			Future<Object> cancelResult = gateway.retry(_				new CancelTask(attemptId),_				NUM_CANCEL_CALL_TRIES,_				timeout,_				executionContext)___			cancelResult.onComplete(new OnComplete<Object>() {__				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.debug("Cancel task call did not find task. Probably akka message call" +_									" race.")__						}_					}_				}_			}, executionContext)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,instance,get,actor,gateway,future,object,cancel,result,gateway,retry,new,cancel,task,attempt,id,timeout,execution,context,cancel,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,debug,cancel,task,call,did,not,find,task,probably,akka,message,call,race,execution,context
Execution -> private void sendCancelRpcCall();1439908661;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {__			final ActorGateway gateway = slot.getInstance().getActorGateway()___			Future<Object> cancelResult = gateway.retry(_				new CancelTask(attemptId),_				NUM_CANCEL_CALL_TRIES,_				timeout,_				executionContext)___			cancelResult.onComplete(new OnComplete<Object>() {__				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.debug("Cancel task call did not find task. Probably akka message call" +_									" race.")__						}_					}_				}_			}, executionContext)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,instance,get,actor,gateway,future,object,cancel,result,gateway,retry,new,cancel,task,attempt,id,timeout,execution,context,cancel,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,debug,cancel,task,call,did,not,find,task,probably,akka,message,call,race,execution,context
Execution -> private void sendCancelRpcCall();1440782435;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {__			final ActorGateway gateway = slot.getInstance().getActorGateway()___			Future<Object> cancelResult = gateway.retry(_				new CancelTask(attemptId),_				NUM_CANCEL_CALL_TRIES,_				timeout,_				executionContext)___			cancelResult.onComplete(new OnComplete<Object>() {__				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.debug("Cancel task call did not find task. Probably akka message call" +_									" race.")__						}_					}_				}_			}, executionContext)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,instance,get,actor,gateway,future,object,cancel,result,gateway,retry,new,cancel,task,attempt,id,timeout,execution,context,cancel,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,debug,cancel,task,call,did,not,find,task,probably,akka,message,call,race,execution,context
Execution -> private void sendCancelRpcCall();1440951699;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {__			final ActorGateway gateway = slot.getInstance().getActorGateway()___			Future<Object> cancelResult = gateway.retry(_				new CancelTask(attemptId),_				NUM_CANCEL_CALL_TRIES,_				timeout,_				executionContext)___			cancelResult.onComplete(new OnComplete<Object>() {__				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.debug("Cancel task call did not find task. Probably akka message call" +_									" race.")__						}_					}_				}_			}, executionContext)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,instance,get,actor,gateway,future,object,cancel,result,gateway,retry,new,cancel,task,attempt,id,timeout,execution,context,cancel,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,debug,cancel,task,call,did,not,find,task,probably,akka,message,call,race,execution,context
Execution -> private void sendCancelRpcCall();1441011751;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {__			final ActorGateway gateway = slot.getInstance().getActorGateway()___			Future<Object> cancelResult = gateway.retry(_				new CancelTask(attemptId),_				NUM_CANCEL_CALL_TRIES,_				timeout,_				executionContext)___			cancelResult.onComplete(new OnComplete<Object>() {__				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.debug("Cancel task call did not find task. Probably akka message call" +_									" race.")__						}_					}_				}_			}, executionContext)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,instance,get,actor,gateway,future,object,cancel,result,gateway,retry,new,cancel,task,attempt,id,timeout,execution,context,cancel,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,debug,cancel,task,call,did,not,find,task,probably,akka,message,call,race,execution,context
Execution -> private void sendCancelRpcCall();1442492512;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {__			final ActorGateway gateway = slot.getInstance().getActorGateway()___			Future<Object> cancelResult = gateway.retry(_				new CancelTask(attemptId),_				NUM_CANCEL_CALL_TRIES,_				timeout,_				executionContext)___			cancelResult.onComplete(new OnComplete<Object>() {__				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.debug("Cancel task call did not find task. Probably akka message call" +_									" race.")__						}_					}_				}_			}, executionContext)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,instance,get,actor,gateway,future,object,cancel,result,gateway,retry,new,cancel,task,attempt,id,timeout,execution,context,cancel,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,debug,cancel,task,call,did,not,find,task,probably,akka,message,call,race,execution,context
Execution -> private void sendCancelRpcCall();1448353719;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {__			final ActorGateway gateway = slot.getInstance().getActorGateway()___			Future<Object> cancelResult = gateway.retry(_				new CancelTask(attemptId),_				NUM_CANCEL_CALL_TRIES,_				timeout,_				executionContext)___			cancelResult.onComplete(new OnComplete<Object>() {__				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.debug("Cancel task call did not find task. Probably akka message call" +_									" race.")__						}_					}_				}_			}, executionContext)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,instance,get,actor,gateway,future,object,cancel,result,gateway,retry,new,cancel,task,attempt,id,timeout,execution,context,cancel,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,debug,cancel,task,call,did,not,find,task,probably,akka,message,call,race,execution,context
Execution -> private void sendCancelRpcCall();1448353719;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {__			final ActorGateway gateway = slot.getInstance().getActorGateway()___			Future<Object> cancelResult = gateway.retry(_				new CancelTask(attemptId),_				NUM_CANCEL_CALL_TRIES,_				timeout,_				executionContext)___			cancelResult.onComplete(new OnComplete<Object>() {__				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.debug("Cancel task call did not find task. Probably akka message call" +_									" race.")__						}_					}_				}_			}, executionContext)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,instance,get,actor,gateway,future,object,cancel,result,gateway,retry,new,cancel,task,attempt,id,timeout,execution,context,cancel,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,debug,cancel,task,call,did,not,find,task,probably,akka,message,call,race,execution,context
Execution -> private void sendCancelRpcCall();1449496469;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {__			final ActorGateway gateway = slot.getInstance().getActorGateway()___			Future<Object> cancelResult = gateway.retry(_				new CancelTask(attemptId),_				NUM_CANCEL_CALL_TRIES,_				timeout,_				executionContext)___			cancelResult.onComplete(new OnComplete<Object>() {__				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.debug("Cancel task call did not find task. Probably akka message call" +_									" race.")__						}_					}_				}_			}, executionContext)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,instance,get,actor,gateway,future,object,cancel,result,gateway,retry,new,cancel,task,attempt,id,timeout,execution,context,cancel,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,debug,cancel,task,call,did,not,find,task,probably,akka,message,call,race,execution,context
Execution -> private void sendCancelRpcCall();1455114877;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {__			final ActorGateway gateway = slot.getInstance().getActorGateway()___			Future<Object> cancelResult = gateway.retry(_				new CancelTask(attemptId),_				NUM_CANCEL_CALL_TRIES,_				timeout,_				executionContext)___			cancelResult.onComplete(new OnComplete<Object>() {__				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.debug("Cancel task call did not find task. Probably akka message call" +_									" race.")__						}_					}_				}_			}, executionContext)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,instance,get,actor,gateway,future,object,cancel,result,gateway,retry,new,cancel,task,attempt,id,timeout,execution,context,cancel,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,debug,cancel,task,call,did,not,find,task,probably,akka,message,call,race,execution,context
Execution -> private void sendCancelRpcCall();1455549373;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {__			final ActorGateway gateway = slot.getInstance().getActorGateway()___			Future<Object> cancelResult = gateway.retry(_				new CancelTask(attemptId),_				NUM_CANCEL_CALL_TRIES,_				timeout,_				executionContext)___			cancelResult.onComplete(new OnComplete<Object>() {__				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.debug("Cancel task call did not find task. Probably akka message call" +_									" race.")__						}_					}_				}_			}, executionContext)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,instance,get,actor,gateway,future,object,cancel,result,gateway,retry,new,cancel,task,attempt,id,timeout,execution,context,cancel,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,debug,cancel,task,call,did,not,find,task,probably,akka,message,call,race,execution,context
Execution -> private void sendCancelRpcCall();1456772768;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {__			final ActorGateway gateway = slot.getInstance().getActorGateway()___			Future<Object> cancelResult = gateway.retry(_				new CancelTask(attemptId),_				NUM_CANCEL_CALL_TRIES,_				timeout,_				executionContext)___			cancelResult.onComplete(new OnComplete<Object>() {__				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.debug("Cancel task call did not find task. Probably akka message call" +_									" race.")__						}_					}_				}_			}, executionContext)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,instance,get,actor,gateway,future,object,cancel,result,gateway,retry,new,cancel,task,attempt,id,timeout,execution,context,cancel,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,debug,cancel,task,call,did,not,find,task,probably,akka,message,call,race,execution,context
Execution -> private void sendCancelRpcCall();1461666173;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {__			final ActorGateway gateway = slot.getInstance().getActorGateway()___			Future<Object> cancelResult = gateway.retry(_				new CancelTask(attemptId),_				NUM_CANCEL_CALL_TRIES,_				timeout,_				executionContext)___			cancelResult.onComplete(new OnComplete<Object>() {__				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.debug("Cancel task call did not find task. Probably akka message call" +_									" race.")__						}_					}_				}_			}, executionContext)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,instance,get,actor,gateway,future,object,cancel,result,gateway,retry,new,cancel,task,attempt,id,timeout,execution,context,cancel,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,debug,cancel,task,call,did,not,find,task,probably,akka,message,call,race,execution,context
Execution -> private void sendCancelRpcCall();1464612094;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {__			final ActorGateway gateway = slot.getInstance().getActorGateway()___			Future<Object> cancelResult = gateway.retry(_				new CancelTask(attemptId),_				NUM_CANCEL_CALL_TRIES,_				timeout,_				executionContext)___			cancelResult.onComplete(new OnComplete<Object>() {__				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.debug("Cancel task call did not find task. Probably akka message call" +_									" race.")__						}_					}_				}_			}, executionContext)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,instance,get,actor,gateway,future,object,cancel,result,gateway,retry,new,cancel,task,attempt,id,timeout,execution,context,cancel,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,debug,cancel,task,call,did,not,find,task,probably,akka,message,call,race,execution,context
Execution -> private void sendCancelRpcCall();1465991918;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {__			final ActorGateway gateway = slot.getInstance().getActorGateway()___			Future<Object> cancelResult = gateway.retry(_				new CancelTask(attemptId),_				NUM_CANCEL_CALL_TRIES,_				timeout,_				executionContext)___			cancelResult.onComplete(new OnComplete<Object>() {__				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.debug("Cancel task call did not find task. Probably akka message call" +_									" race.")__						}_					}_				}_			}, executionContext)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,instance,get,actor,gateway,future,object,cancel,result,gateway,retry,new,cancel,task,attempt,id,timeout,execution,context,cancel,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,debug,cancel,task,call,did,not,find,task,probably,akka,message,call,race,execution,context
Execution -> private void sendCancelRpcCall();1468523508;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {__			final ActorGateway gateway = slot.getInstance().getActorGateway()___			Future<Object> cancelResult = gateway.retry(_				new CancelTask(attemptId),_				NUM_CANCEL_CALL_TRIES,_				timeout,_				executionContext)___			cancelResult.onComplete(new OnComplete<Object>() {__				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.debug("Cancel task call did not find task. Probably akka message call" +_									" race.")__						}_					}_				}_			}, executionContext)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,instance,get,actor,gateway,future,object,cancel,result,gateway,retry,new,cancel,task,attempt,id,timeout,execution,context,cancel,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,debug,cancel,task,call,did,not,find,task,probably,akka,message,call,race,execution,context
Execution -> private void sendCancelRpcCall();1470070623;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {__			final ActorGateway gateway = slot.getInstance().getActorGateway()___			Future<Object> cancelResult = gateway.retry(_				new CancelTask(attemptId),_				NUM_CANCEL_CALL_TRIES,_				timeout,_				executionContext)___			cancelResult.onComplete(new OnComplete<Object>() {__				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.debug("Cancel task call did not find task. Probably akka message call" +_									" race.")__						}_					}_				}_			}, executionContext)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,instance,get,actor,gateway,future,object,cancel,result,gateway,retry,new,cancel,task,attempt,id,timeout,execution,context,cancel,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,debug,cancel,task,call,did,not,find,task,probably,akka,message,call,race,execution,context
Execution -> private void sendCancelRpcCall();1470419821;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {__			final ActorGateway gateway = slot.getInstance().getActorGateway()___			Future<Object> cancelResult = gateway.retry(_				new CancelTask(attemptId),_				NUM_CANCEL_CALL_TRIES,_				timeout,_				executionContext)___			cancelResult.onComplete(new OnComplete<Object>() {__				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.debug("Cancel task call did not find task. Probably akka message call" +_									" race.")__						}_					}_				}_			}, executionContext)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,instance,get,actor,gateway,future,object,cancel,result,gateway,retry,new,cancel,task,attempt,id,timeout,execution,context,cancel,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,debug,cancel,task,call,did,not,find,task,probably,akka,message,call,race,execution,context
Execution -> private void sendCancelRpcCall();1472663401;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {__			final ActorGateway gateway = slot.getInstance().getActorGateway()___			Future<Object> cancelResult = gateway.retry(_				new CancelTask(attemptId),_				NUM_CANCEL_CALL_TRIES,_				timeout,_				executionContext)___			cancelResult.onComplete(new OnComplete<Object>() {__				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.debug("Cancel task call did not find task. Probably akka message call" +_									" race.")__						}_					}_				}_			}, executionContext)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,instance,get,actor,gateway,future,object,cancel,result,gateway,retry,new,cancel,task,attempt,id,timeout,execution,context,cancel,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,debug,cancel,task,call,did,not,find,task,probably,akka,message,call,race,execution,context
Execution -> private void sendCancelRpcCall();1472663402;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {__			final ActorGateway gateway = slot.getInstance().getActorGateway()___			Future<Object> cancelResult = gateway.retry(_				new CancelTask(attemptId),_				NUM_CANCEL_CALL_TRIES,_				timeout,_				executionContext)___			cancelResult.onComplete(new OnComplete<Object>() {__				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.debug("Cancel task call did not find task. Probably akka message call" +_									" race.")__						}_					}_				}_			}, executionContext)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,instance,get,actor,gateway,future,object,cancel,result,gateway,retry,new,cancel,task,attempt,id,timeout,execution,context,cancel,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,debug,cancel,task,call,did,not,find,task,probably,akka,message,call,race,execution,context
Execution -> private void sendCancelRpcCall();1472830377;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {__			final ActorGateway gateway = slot.getInstance().getActorGateway()___			Future<Object> cancelResult = gateway.retry(_				new CancelTask(attemptId),_				NUM_CANCEL_CALL_TRIES,_				timeout,_				executionContext)___			cancelResult.onComplete(new OnComplete<Object>() {__				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.debug("Cancel task call did not find task. Probably akka message call" +_									" race.")__						}_					}_				}_			}, executionContext)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,instance,get,actor,gateway,future,object,cancel,result,gateway,retry,new,cancel,task,attempt,id,timeout,execution,context,cancel,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,debug,cancel,task,call,did,not,find,task,probably,akka,message,call,race,execution,context
Execution -> private void sendCancelRpcCall();1472830377;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {__			final ActorGateway gateway = slot.getTaskManagerActorGateway()___			Future<Object> cancelResult = gateway.retry(_				new CancelTask(attemptId),_				NUM_CANCEL_CALL_TRIES,_				timeout,_				executionContext)___			cancelResult.onComplete(new OnComplete<Object>() {__				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.debug("Cancel task call did not find task. Probably akka message call" +_									" race.")__						}_					}_				}_			}, executionContext)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,task,manager,actor,gateway,future,object,cancel,result,gateway,retry,new,cancel,task,attempt,id,timeout,execution,context,cancel,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,debug,cancel,task,call,did,not,find,task,probably,akka,message,call,race,execution,context
Execution -> private void sendCancelRpcCall();1473023399;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {__			final ActorGateway gateway = slot.getTaskManagerActorGateway()___			Future<Object> cancelResult = gateway.retry(_				new CancelTask(attemptId),_				NUM_CANCEL_CALL_TRIES,_				timeout,_				executionContext)___			cancelResult.onComplete(new OnComplete<Object>() {__				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.debug("Cancel task call did not find task. Probably akka message call" +_									" race.")__						}_					}_				}_			}, executionContext)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,task,manager,actor,gateway,future,object,cancel,result,gateway,retry,new,cancel,task,attempt,id,timeout,execution,context,cancel,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,debug,cancel,task,call,did,not,find,task,probably,akka,message,call,race,execution,context
Execution -> private void sendCancelRpcCall();1474994376;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {__			final ActorGateway gateway = slot.getTaskManagerActorGateway()___			scala.concurrent.Future<Object> cancelResult = gateway.retry(_				new CancelTask(attemptId),_				NUM_CANCEL_CALL_TRIES,_				timeout,_				executionContext)___			cancelResult.onComplete(new OnComplete<Object>() {__				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.debug("Cancel task call did not find task. Probably akka message call" +_									" race.")__						}_					}_				}_			}, executionContext)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,task,manager,actor,gateway,scala,concurrent,future,object,cancel,result,gateway,retry,new,cancel,task,attempt,id,timeout,execution,context,cancel,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,debug,cancel,task,call,did,not,find,task,probably,akka,message,call,race,execution,context
Execution -> private void sendCancelRpcCall();1474994376;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {__			final ActorGateway gateway = slot.getTaskManagerActorGateway()___			scala.concurrent.Future<Object> cancelResult = gateway.retry(_				new CancelTask(attemptId),_				NUM_CANCEL_CALL_TRIES,_				timeout,_				executionContext)___			cancelResult.onComplete(new OnComplete<Object>() {__				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.debug("Cancel task call did not find task. Probably akka message call" +_									" race.")__						}_					}_				}_			}, executionContext)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,task,manager,actor,gateway,scala,concurrent,future,object,cancel,result,gateway,retry,new,cancel,task,attempt,id,timeout,execution,context,cancel,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,debug,cancel,task,call,did,not,find,task,probably,akka,message,call,race,execution,context
Execution -> private void sendCancelRpcCall();1475231926;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {__			final ActorGateway gateway = slot.getTaskManagerActorGateway()___			scala.concurrent.Future<Object> cancelResult = gateway.retry(_				new CancelTask(attemptId),_				NUM_CANCEL_CALL_TRIES,_				timeout,_				executionContext)___			cancelResult.onComplete(new OnComplete<Object>() {__				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.debug("Cancel task call did not find task. Probably akka message call" +_									" race.")__						}_					}_				}_			}, executionContext)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,task,manager,actor,gateway,scala,concurrent,future,object,cancel,result,gateway,retry,new,cancel,task,attempt,id,timeout,execution,context,cancel,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,debug,cancel,task,call,did,not,find,task,probably,akka,message,call,race,execution,context
Execution -> private void sendCancelRpcCall();1476446128;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {__			final ActorGateway gateway = slot.getTaskManagerActorGateway()___			scala.concurrent.Future<Object> cancelResult = gateway.retry(_				new CancelTask(attemptId),_				NUM_CANCEL_CALL_TRIES,_				timeout,_				executionContext)___			cancelResult.onComplete(new OnComplete<Object>() {__				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.debug("Cancel task call did not find task. Probably akka message call" +_									" race.")__						}_					}_				}_			}, executionContext)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,task,manager,actor,gateway,scala,concurrent,future,object,cancel,result,gateway,retry,new,cancel,task,attempt,id,timeout,execution,context,cancel,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,debug,cancel,task,call,did,not,find,task,probably,akka,message,call,race,execution,context
Execution -> private void sendCancelRpcCall();1476972861;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {__			final ActorGateway gateway = slot.getTaskManagerActorGateway()___			scala.concurrent.Future<Object> cancelResult = gateway.retry(_				new CancelTask(attemptId),_				NUM_CANCEL_CALL_TRIES,_				timeout,_				executionContext)___			cancelResult.onComplete(new OnComplete<Object>() {__				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.debug("Cancel task call did not find task. Probably akka message call" +_									" race.")__						}_					}_				}_			}, executionContext)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,task,manager,actor,gateway,scala,concurrent,future,object,cancel,result,gateway,retry,new,cancel,task,attempt,id,timeout,execution,context,cancel,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,debug,cancel,task,call,did,not,find,task,probably,akka,message,call,race,execution,context
Execution -> private void sendCancelRpcCall();1477923124;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {__			final ActorGateway gateway = slot.getTaskManagerActorGateway()___			scala.concurrent.Future<Object> cancelResult = gateway.retry(_				new CancelTask(attemptId),_				NUM_CANCEL_CALL_TRIES,_				timeout,_				executionContext)___			cancelResult.onComplete(new OnComplete<Object>() {__				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.debug("Cancel task call did not find task. Probably akka message call" +_									" race.")__						}_					}_				}_			}, executionContext)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,task,manager,actor,gateway,scala,concurrent,future,object,cancel,result,gateway,retry,new,cancel,task,attempt,id,timeout,execution,context,cancel,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,debug,cancel,task,call,did,not,find,task,probably,akka,message,call,race,execution,context
Execution -> private void sendCancelRpcCall();1477989375;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			Future<Acknowledge> cancelResultFuture = FutureUtils.retry(_				new Callable<Future<Acknowledge>>() {_					@Override_					public Future<Acknowledge> call() throws Exception {_						return taskManagerGateway.cancelTask(attemptId, timeout)__					}_				},_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					fail(new Exception("Task could not be canceled.", failure))__					return null__				}_			}, executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,future,acknowledge,cancel,result,future,future,utils,retry,new,callable,future,acknowledge,override,public,future,acknowledge,call,throws,exception,return,task,manager,gateway,cancel,task,attempt,id,timeout,executor,cancel,result,future,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,fail,new,exception,task,could,not,be,canceled,failure,return,null,executor
Execution -> private void sendCancelRpcCall();1478800024;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			Future<Acknowledge> cancelResultFuture = FutureUtils.retry(_				new Callable<Future<Acknowledge>>() {_					@Override_					public Future<Acknowledge> call() throws Exception {_						return taskManagerGateway.cancelTask(attemptId, timeout)__					}_				},_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					fail(new Exception("Task could not be canceled.", failure))__					return null__				}_			}, executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,future,acknowledge,cancel,result,future,future,utils,retry,new,callable,future,acknowledge,override,public,future,acknowledge,call,throws,exception,return,task,manager,gateway,cancel,task,attempt,id,timeout,executor,cancel,result,future,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,fail,new,exception,task,could,not,be,canceled,failure,return,null,executor
Execution -> private void sendCancelRpcCall();1481290933;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			Future<Acknowledge> cancelResultFuture = FutureUtils.retry(_				new Callable<Future<Acknowledge>>() {_					@Override_					public Future<Acknowledge> call() throws Exception {_						return taskManagerGateway.cancelTask(attemptId, timeout)__					}_				},_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					fail(new Exception("Task could not be canceled.", failure))__					return null__				}_			}, executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,future,acknowledge,cancel,result,future,future,utils,retry,new,callable,future,acknowledge,override,public,future,acknowledge,call,throws,exception,return,task,manager,gateway,cancel,task,attempt,id,timeout,executor,cancel,result,future,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,fail,new,exception,task,could,not,be,canceled,failure,return,null,executor
Execution -> private void sendCancelRpcCall();1482522865;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			Future<Acknowledge> cancelResultFuture = FutureUtils.retry(_				new Callable<Future<Acknowledge>>() {_					@Override_					public Future<Acknowledge> call() throws Exception {_						return taskManagerGateway.cancelTask(attemptId, timeout)__					}_				},_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					fail(new Exception("Task could not be canceled.", failure))__					return null__				}_			}, executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,future,acknowledge,cancel,result,future,future,utils,retry,new,callable,future,acknowledge,override,public,future,acknowledge,call,throws,exception,return,task,manager,gateway,cancel,task,attempt,id,timeout,executor,cancel,result,future,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,fail,new,exception,task,could,not,be,canceled,failure,return,null,executor
Execution -> private void sendCancelRpcCall();1486114103;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			Future<Acknowledge> cancelResultFuture = FutureUtils.retry(_				new Callable<Future<Acknowledge>>() {_					@Override_					public Future<Acknowledge> call() throws Exception {_						return taskManagerGateway.cancelTask(attemptId, timeout)__					}_				},_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					fail(new Exception("Task could not be canceled.", failure))__					return null__				}_			}, executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,future,acknowledge,cancel,result,future,future,utils,retry,new,callable,future,acknowledge,override,public,future,acknowledge,call,throws,exception,return,task,manager,gateway,cancel,task,attempt,id,timeout,executor,cancel,result,future,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,fail,new,exception,task,could,not,be,canceled,failure,return,null,executor
Execution -> private void sendCancelRpcCall();1486114103;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			Future<Acknowledge> cancelResultFuture = FutureUtils.retry(_				new Callable<Future<Acknowledge>>() {_					@Override_					public Future<Acknowledge> call() throws Exception {_						return taskManagerGateway.cancelTask(attemptId, timeout)__					}_				},_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					fail(new Exception("Task could not be canceled.", failure))__					return null__				}_			}, executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,future,acknowledge,cancel,result,future,future,utils,retry,new,callable,future,acknowledge,override,public,future,acknowledge,call,throws,exception,return,task,manager,gateway,cancel,task,attempt,id,timeout,executor,cancel,result,future,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,fail,new,exception,task,could,not,be,canceled,failure,return,null,executor
Execution -> private void sendCancelRpcCall();1486740510;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			Future<Acknowledge> cancelResultFuture = FutureUtils.retry(_				new Callable<Future<Acknowledge>>() {_					@Override_					public Future<Acknowledge> call() throws Exception {_						return taskManagerGateway.cancelTask(attemptId, timeout)__					}_				},_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					fail(new Exception("Task could not be canceled.", failure))__					return null__				}_			}, executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,future,acknowledge,cancel,result,future,future,utils,retry,new,callable,future,acknowledge,override,public,future,acknowledge,call,throws,exception,return,task,manager,gateway,cancel,task,attempt,id,timeout,executor,cancel,result,future,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,fail,new,exception,task,could,not,be,canceled,failure,return,null,executor
Execution -> private void sendCancelRpcCall();1487548884;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			Future<Acknowledge> cancelResultFuture = FutureUtils.retry(_				new Callable<Future<Acknowledge>>() {_					@Override_					public Future<Acknowledge> call() throws Exception {_						return taskManagerGateway.cancelTask(attemptId, timeout)__					}_				},_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					fail(new Exception("Task could not be canceled.", failure))__					return null__				}_			}, executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,future,acknowledge,cancel,result,future,future,utils,retry,new,callable,future,acknowledge,override,public,future,acknowledge,call,throws,exception,return,task,manager,gateway,cancel,task,attempt,id,timeout,executor,cancel,result,future,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,fail,new,exception,task,could,not,be,canceled,failure,return,null,executor
Execution -> private void sendCancelRpcCall();1487871589;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			Future<Acknowledge> cancelResultFuture = FutureUtils.retry(_				new Callable<Future<Acknowledge>>() {_					@Override_					public Future<Acknowledge> call() throws Exception {_						return taskManagerGateway.cancelTask(attemptId, timeout)__					}_				},_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					fail(new Exception("Task could not be canceled.", failure))__					return null__				}_			}, executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,future,acknowledge,cancel,result,future,future,utils,retry,new,callable,future,acknowledge,override,public,future,acknowledge,call,throws,exception,return,task,manager,gateway,cancel,task,attempt,id,timeout,executor,cancel,result,future,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,fail,new,exception,task,could,not,be,canceled,failure,return,null,executor
Execution -> private void sendCancelRpcCall();1488878443;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			Future<Acknowledge> cancelResultFuture = FutureUtils.retry(_				new Callable<Future<Acknowledge>>() {_					@Override_					public Future<Acknowledge> call() throws Exception {_						return taskManagerGateway.cancelTask(attemptId, timeout)__					}_				},_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					fail(new Exception("Task could not be canceled.", failure))__					return null__				}_			}, executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,future,acknowledge,cancel,result,future,future,utils,retry,new,callable,future,acknowledge,override,public,future,acknowledge,call,throws,exception,return,task,manager,gateway,cancel,task,attempt,id,timeout,executor,cancel,result,future,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,fail,new,exception,task,could,not,be,canceled,failure,return,null,executor
Execution -> private void sendCancelRpcCall();1490800309;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			Future<Acknowledge> cancelResultFuture = FutureUtils.retry(_				new Callable<Future<Acknowledge>>() {_					@Override_					public Future<Acknowledge> call() throws Exception {_						return taskManagerGateway.cancelTask(attemptId, timeout)__					}_				},_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					fail(new Exception("Task could not be canceled.", failure))__					return null__				}_			}, executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,future,acknowledge,cancel,result,future,future,utils,retry,new,callable,future,acknowledge,override,public,future,acknowledge,call,throws,exception,return,task,manager,gateway,cancel,task,attempt,id,timeout,executor,cancel,result,future,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,fail,new,exception,task,could,not,be,canceled,failure,return,null,executor
Execution -> private void sendCancelRpcCall();1490819573;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			Future<Acknowledge> cancelResultFuture = FutureUtils.retry(_				new Callable<Future<Acknowledge>>() {_					@Override_					public Future<Acknowledge> call() throws Exception {_						return taskManagerGateway.cancelTask(attemptId, timeout)__					}_				},_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					fail(new Exception("Task could not be canceled.", failure))__					return null__				}_			}, executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,future,acknowledge,cancel,result,future,future,utils,retry,new,callable,future,acknowledge,override,public,future,acknowledge,call,throws,exception,return,task,manager,gateway,cancel,task,attempt,id,timeout,executor,cancel,result,future,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,fail,new,exception,task,could,not,be,canceled,failure,return,null,executor
Execution -> private void sendCancelRpcCall();1493831843;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			Future<Acknowledge> cancelResultFuture = FutureUtils.retry(_				new Callable<Future<Acknowledge>>() {_					@Override_					public Future<Acknowledge> call() throws Exception {_						return taskManagerGateway.cancelTask(attemptId, timeout)__					}_				},_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					fail(new Exception("Task could not be canceled.", failure))__					return null__				}_			}, executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,future,acknowledge,cancel,result,future,future,utils,retry,new,callable,future,acknowledge,override,public,future,acknowledge,call,throws,exception,return,task,manager,gateway,cancel,task,attempt,id,timeout,executor,cancel,result,future,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,fail,new,exception,task,could,not,be,canceled,failure,return,null,executor
Execution -> private void sendCancelRpcCall();1493831843;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			Future<Acknowledge> cancelResultFuture = FutureUtils.retry(_				new Callable<Future<Acknowledge>>() {_					@Override_					public Future<Acknowledge> call() throws Exception {_						return taskManagerGateway.cancelTask(attemptId, timeout)__					}_				},_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					fail(new Exception("Task could not be canceled.", failure))__					return null__				}_			}, executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,future,acknowledge,cancel,result,future,future,utils,retry,new,callable,future,acknowledge,override,public,future,acknowledge,call,throws,exception,return,task,manager,gateway,cancel,task,attempt,id,timeout,executor,cancel,result,future,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,fail,new,exception,task,could,not,be,canceled,failure,return,null,executor
Execution -> private void sendCancelRpcCall();1501622876;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> cancelResultFuture = FutureUtils.retry(_				() -> FutureUtils.toJava(taskManagerGateway.cancelTask(attemptId, timeout)),_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					}_				},_				executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,cancel,result,future,future,utils,retry,future,utils,to,java,task,manager,gateway,cancel,task,attempt,id,timeout,executor,cancel,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,executor
Execution -> private void sendCancelRpcCall();1501665499;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> cancelResultFuture = FutureUtils.retry(_				() -> FutureUtils.toJava(taskManagerGateway.cancelTask(attemptId, timeout)),_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					}_				},_				executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,cancel,result,future,future,utils,retry,future,utils,to,java,task,manager,gateway,cancel,task,attempt,id,timeout,executor,cancel,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,executor
Execution -> private void sendCancelRpcCall();1501760738;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> cancelResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.cancelTask(attemptId, timeout),_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					}_				},_				executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,cancel,result,future,future,utils,retry,task,manager,gateway,cancel,task,attempt,id,timeout,executor,cancel,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,executor
Execution -> private void sendCancelRpcCall();1502801814;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> cancelResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.cancelTask(attemptId, timeout),_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					}_				},_				executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,cancel,result,future,future,utils,retry,task,manager,gateway,cancel,task,attempt,id,timeout,executor,cancel,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,executor
Execution -> private void sendCancelRpcCall();1509125300;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> cancelResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.cancelTask(attemptId, timeout),_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					}_				},_				executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,cancel,result,future,future,utils,retry,task,manager,gateway,cancel,task,attempt,id,timeout,executor,cancel,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,executor
Execution -> private void sendCancelRpcCall();1509631297;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> cancelResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.cancelTask(attemptId, timeout),_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					}_				},_				executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,cancel,result,future,future,utils,retry,task,manager,gateway,cancel,task,attempt,id,timeout,executor,cancel,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,executor
Execution -> private void sendCancelRpcCall();1509638684;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = assignedResource.get()___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> cancelResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.cancelTask(attemptId, timeout),_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					}_				},_				executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,assigned,resource,get,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,cancel,result,future,future,utils,retry,task,manager,gateway,cancel,task,attempt,id,timeout,executor,cancel,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,executor
Execution -> private void sendCancelRpcCall();1509638685;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> cancelResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.cancelTask(attemptId, timeout),_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					}_				},_				executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,cancel,result,future,future,utils,retry,task,manager,gateway,cancel,task,attempt,id,timeout,executor,cancel,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,executor
Execution -> private void sendCancelRpcCall();1513201052;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> cancelResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.cancelTask(attemptId, timeout),_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					}_				},_				executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,cancel,result,future,future,utils,retry,task,manager,gateway,cancel,task,attempt,id,timeout,executor,cancel,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,executor
Execution -> private void sendCancelRpcCall();1513201070;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> cancelResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.cancelTask(attemptId, timeout),_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					}_				},_				executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,cancel,result,future,future,utils,retry,task,manager,gateway,cancel,task,attempt,id,timeout,executor,cancel,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,executor
Execution -> private void sendCancelRpcCall();1513261599;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> cancelResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.cancelTask(attemptId, timeout),_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					}_				},_				executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,cancel,result,future,future,utils,retry,task,manager,gateway,cancel,task,attempt,id,timeout,executor,cancel,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,executor
Execution -> private void sendCancelRpcCall();1515177485;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> cancelResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.cancelTask(attemptId, timeout),_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					}_				},_				executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,cancel,result,future,future,utils,retry,task,manager,gateway,cancel,task,attempt,id,timeout,executor,cancel,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,executor
Execution -> private void sendCancelRpcCall();1516626377;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> cancelResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.cancelTask(attemptId, timeout),_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					}_				},_				executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,cancel,result,future,future,utils,retry,task,manager,gateway,cancel,task,attempt,id,timeout,executor,cancel,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,executor
Execution -> private void sendCancelRpcCall();1516626397;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> cancelResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.cancelTask(attemptId, timeout),_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					}_				},_				executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,cancel,result,future,future,utils,retry,task,manager,gateway,cancel,task,attempt,id,timeout,executor,cancel,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,executor
Execution -> private void sendCancelRpcCall();1518680774;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> cancelResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.cancelTask(attemptId, rpcTimeout),_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					}_				},_				executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,cancel,result,future,future,utils,retry,task,manager,gateway,cancel,task,attempt,id,rpc,timeout,executor,cancel,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,executor
Execution -> private void sendCancelRpcCall();1518712478;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> cancelResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.cancelTask(attemptId, rpcTimeout),_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					}_				},_				executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,cancel,result,future,future,utils,retry,task,manager,gateway,cancel,task,attempt,id,rpc,timeout,executor,cancel,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,executor
Execution -> private void sendCancelRpcCall();1519316529;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> cancelResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.cancelTask(attemptId, rpcTimeout),_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					}_				},_				executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,cancel,result,future,future,utils,retry,task,manager,gateway,cancel,task,attempt,id,rpc,timeout,executor,cancel,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,executor
Execution -> private void sendCancelRpcCall();1519481114;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> cancelResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.cancelTask(attemptId, rpcTimeout),_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					}_				},_				executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,cancel,result,future,future,utils,retry,task,manager,gateway,cancel,task,attempt,id,rpc,timeout,executor,cancel,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,executor
Execution -> private void sendCancelRpcCall();1519568061;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> cancelResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.cancelTask(attemptId, rpcTimeout),_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					}_				},_				executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,cancel,result,future,future,utils,retry,task,manager,gateway,cancel,task,attempt,id,rpc,timeout,executor,cancel,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,executor
Execution -> private void sendCancelRpcCall();1519655521;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> cancelResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.cancelTask(attemptId, rpcTimeout),_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					}_				},_				executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,cancel,result,future,future,utils,retry,task,manager,gateway,cancel,task,attempt,id,rpc,timeout,executor,cancel,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,executor
Execution -> private void sendCancelRpcCall();1522049586;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> cancelResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.cancelTask(attemptId, rpcTimeout),_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					}_				},_				executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,cancel,result,future,future,utils,retry,task,manager,gateway,cancel,task,attempt,id,rpc,timeout,executor,cancel,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,executor
Execution -> private void sendCancelRpcCall();1522249273;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> cancelResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.cancelTask(attemptId, rpcTimeout),_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					}_				},_				executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,cancel,result,future,future,utils,retry,task,manager,gateway,cancel,task,attempt,id,rpc,timeout,executor,cancel,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,executor
Execution -> private void sendCancelRpcCall();1530712207;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> cancelResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.cancelTask(attemptId, rpcTimeout),_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					}_				},_				executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,cancel,result,future,future,utils,retry,task,manager,gateway,cancel,task,attempt,id,rpc,timeout,executor,cancel,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,executor
Execution -> private void sendCancelRpcCall();1532383539;This method sends a CancelTask message to the instance of the assigned slot.__The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> cancelResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.cancelTask(attemptId, rpcTimeout),_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					}_				},_				executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,cancel,result,future,future,utils,retry,task,manager,gateway,cancel,task,attempt,id,rpc,timeout,executor,cancel,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,executor
Execution -> private void sendCancelRpcCall();1532383539;This method sends a CancelTask message to the instance of the assigned slot.__<p>The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> cancelResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.cancelTask(attemptId, rpcTimeout),_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					}_				},_				executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,p,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,cancel,result,future,future,utils,retry,task,manager,gateway,cancel,task,attempt,id,rpc,timeout,executor,cancel,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,executor
Execution -> private void sendCancelRpcCall();1532383539;This method sends a CancelTask message to the instance of the assigned slot.__<p>The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> cancelResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.cancelTask(attemptId, rpcTimeout),_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					}_				},_				executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,p,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,cancel,result,future,future,utils,retry,task,manager,gateway,cancel,task,attempt,id,rpc,timeout,executor,cancel,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,executor
Execution -> private void sendCancelRpcCall();1540920690;This method sends a CancelTask message to the instance of the assigned slot.__<p>The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> cancelResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.cancelTask(attemptId, rpcTimeout),_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					}_				},_				executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,p,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,cancel,result,future,future,utils,retry,task,manager,gateway,cancel,task,attempt,id,rpc,timeout,executor,cancel,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,executor
Execution -> private void sendCancelRpcCall();1542356428;This method sends a CancelTask message to the instance of the assigned slot.__<p>The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> cancelResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.cancelTask(attemptId, rpcTimeout),_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					}_				},_				executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,p,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,cancel,result,future,future,utils,retry,task,manager,gateway,cancel,task,attempt,id,rpc,timeout,executor,cancel,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,executor
Execution -> private void sendCancelRpcCall();1546870832;This method sends a CancelTask message to the instance of the assigned slot.__<p>The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> cancelResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.cancelTask(attemptId, rpcTimeout),_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					}_				},_				executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,p,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,cancel,result,future,future,utils,retry,task,manager,gateway,cancel,task,attempt,id,rpc,timeout,executor,cancel,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,executor
Execution -> private void sendCancelRpcCall();1547644408;This method sends a CancelTask message to the instance of the assigned slot.__<p>The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> cancelResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.cancelTask(attemptId, rpcTimeout),_				NUM_CANCEL_CALL_TRIES,_				executor)___			cancelResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					}_				},_				executor)__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,p,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,cancel,result,future,future,utils,retry,task,manager,gateway,cancel,task,attempt,id,rpc,timeout,executor,cancel,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure,executor
Execution -> private void sendCancelRpcCall();1549365080;This method sends a CancelTask message to the instance of the assigned slot.__<p>The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final ComponentMainThreadExecutor jobMasterMainThreadExecutor =_				getVertex().getExecutionGraph().getJobMasterMainThreadExecutor()___			CompletableFuture<Acknowledge> cancelResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.cancelTask(attemptId, rpcTimeout),_				NUM_CANCEL_CALL_TRIES,_				jobMasterMainThreadExecutor)___			cancelResultFuture.whenComplete(_				(ack, failure) -> {_					if (failure != null) {_						failSync(new Exception("Task could not be canceled.", failure))__					}_				})__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,p,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,component,main,thread,executor,job,master,main,thread,executor,get,vertex,get,execution,graph,get,job,master,main,thread,executor,completable,future,acknowledge,cancel,result,future,future,utils,retry,task,manager,gateway,cancel,task,attempt,id,rpc,timeout,job,master,main,thread,executor,cancel,result,future,when,complete,ack,failure,if,failure,null,fail,sync,new,exception,task,could,not,be,canceled,failure
Execution -> private void sendCancelRpcCall();1550220073;This method sends a CancelTask message to the instance of the assigned slot.__<p>The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final ComponentMainThreadExecutor jobMasterMainThreadExecutor =_				getVertex().getExecutionGraph().getJobMasterMainThreadExecutor()___			CompletableFuture<Acknowledge> cancelResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.cancelTask(attemptId, rpcTimeout),_				NUM_CANCEL_CALL_TRIES,_				jobMasterMainThreadExecutor)___			cancelResultFuture.whenComplete(_				(ack, failure) -> {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					}_				})__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,p,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,component,main,thread,executor,job,master,main,thread,executor,get,vertex,get,execution,graph,get,job,master,main,thread,executor,completable,future,acknowledge,cancel,result,future,future,utils,retry,task,manager,gateway,cancel,task,attempt,id,rpc,timeout,job,master,main,thread,executor,cancel,result,future,when,complete,ack,failure,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure
Execution -> private void sendCancelRpcCall();1550654143;This method sends a CancelTask message to the instance of the assigned slot.__<p>The sending is tried up to NUM_CANCEL_CALL_TRIES times.;private void sendCancelRpcCall() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final ComponentMainThreadExecutor jobMasterMainThreadExecutor =_				getVertex().getExecutionGraph().getJobMasterMainThreadExecutor()___			CompletableFuture<Acknowledge> cancelResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.cancelTask(attemptId, rpcTimeout),_				NUM_CANCEL_CALL_TRIES,_				jobMasterMainThreadExecutor)___			cancelResultFuture.whenComplete(_				(ack, failure) -> {_					if (failure != null) {_						fail(new Exception("Task could not be canceled.", failure))__					}_				})__		}_	};this,method,sends,a,cancel,task,message,to,the,instance,of,the,assigned,slot,p,the,sending,is,tried,up,to,times;private,void,send,cancel,rpc,call,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,component,main,thread,executor,job,master,main,thread,executor,get,vertex,get,execution,graph,get,job,master,main,thread,executor,completable,future,acknowledge,cancel,result,future,future,utils,retry,task,manager,gateway,cancel,task,attempt,id,rpc,timeout,job,master,main,thread,executor,cancel,result,future,when,complete,ack,failure,if,failure,null,fail,new,exception,task,could,not,be,canceled,failure
Execution -> public long getGlobalModVersion();1493831843;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public long getGlobalModVersion();1501622876;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public long getGlobalModVersion();1501665499;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public long getGlobalModVersion();1501760738;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public long getGlobalModVersion();1502801814;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public long getGlobalModVersion();1509125300;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public long getGlobalModVersion();1509631297;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public long getGlobalModVersion();1509638684;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public long getGlobalModVersion();1509638685;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public long getGlobalModVersion();1513201052;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public long getGlobalModVersion();1513201070;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public long getGlobalModVersion();1513261599;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public long getGlobalModVersion();1515177485;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public long getGlobalModVersion();1516626377;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public long getGlobalModVersion();1516626397;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public long getGlobalModVersion();1518680774;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public long getGlobalModVersion();1518712478;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public long getGlobalModVersion();1519316529;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public long getGlobalModVersion();1519481114;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public long getGlobalModVersion();1519568061;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public long getGlobalModVersion();1519655521;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public long getGlobalModVersion();1522049586;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public long getGlobalModVersion();1522249273;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public long getGlobalModVersion();1530712207;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public long getGlobalModVersion();1532383539;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public long getGlobalModVersion();1532383539;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public long getGlobalModVersion();1532383539;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public long getGlobalModVersion();1540920690;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public long getGlobalModVersion();1542356428;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public long getGlobalModVersion();1546870832;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public long getGlobalModVersion();1547644408;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public long getGlobalModVersion();1549365080;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public long getGlobalModVersion();1550220073;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public long getGlobalModVersion();1550654143;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public long getGlobalModVersion();1550683188;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public long getGlobalModVersion();1550855836;Gets the global modification version of the execution graph when this execution was created.__<p>This version is bumped in the ExecutionGraph whenever a global failover happens. It is used_to resolve conflicts between concurrent modification by global and local failover actions.;public long getGlobalModVersion() {_		return globalModVersion__	};gets,the,global,modification,version,of,the,execution,graph,when,this,execution,was,created,p,this,version,is,bumped,in,the,execution,graph,whenever,a,global,failover,happens,it,is,used,to,resolve,conflicts,between,concurrent,modification,by,global,and,local,failover,actions;public,long,get,global,mod,version,return,global,mod,version
Execution -> public CompletableFuture<Void> scheduleForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds);1540920690;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it._@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph._Can be empty if the allocation ids are not required for scheduling._@return Future which is completed once the Execution has been deployed;public CompletableFuture<Void> scheduleForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds) {_		final Time allocationTimeout = vertex.getExecutionGraph().getAllocationTimeout()__		try {_			final CompletableFuture<Execution> allocationFuture = allocateAndAssignSlotForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint,_				allPreviousExecutionGraphAllocationIds,_				allocationTimeout)___			_			_			_			final CompletableFuture<Void> deploymentFuture = allocationFuture.thenAccept(_				(FutureConsumerWithException<Execution, Exception>) value -> deploy())___			deploymentFuture.whenComplete(_				(Void ignored, Throwable failure) -> {_					if (failure != null) {_						markFailed(ExceptionUtils.stripCompletionException(failure))__					}_				})___			_			if (!queued && !deploymentFuture.isDone()) {_				deploymentFuture.completeExceptionally(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return deploymentFuture__		} catch (IllegalExecutionStateException e) {_			return FutureUtils.completedExceptionally(e)__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,set,with,all,previous,allocation,ids,in,the,job,graph,can,be,empty,if,the,allocation,ids,are,not,required,for,scheduling,return,future,which,is,completed,once,the,execution,has,been,deployed;public,completable,future,void,schedule,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,final,time,allocation,timeout,vertex,get,execution,graph,get,allocation,timeout,try,final,completable,future,execution,allocation,future,allocate,and,assign,slot,for,execution,slot,provider,queued,location,preference,constraint,all,previous,execution,graph,allocation,ids,allocation,timeout,final,completable,future,void,deployment,future,allocation,future,then,accept,future,consumer,with,exception,execution,exception,value,deploy,deployment,future,when,complete,void,ignored,throwable,failure,if,failure,null,mark,failed,exception,utils,strip,completion,exception,failure,if,queued,deployment,future,is,done,deployment,future,complete,exceptionally,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,deployment,future,catch,illegal,execution,state,exception,e,return,future,utils,completed,exceptionally,e
Execution -> public CompletableFuture<Void> scheduleForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds);1542356428;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it._@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph._Can be empty if the allocation ids are not required for scheduling._@return Future which is completed once the Execution has been deployed;public CompletableFuture<Void> scheduleForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds) {_		final Time allocationTimeout = vertex.getExecutionGraph().getAllocationTimeout()__		try {_			final CompletableFuture<Execution> allocationFuture = allocateAndAssignSlotForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint,_				allPreviousExecutionGraphAllocationIds,_				allocationTimeout)___			_			_			_			final CompletableFuture<Void> deploymentFuture = allocationFuture.thenAccept(_				(FutureConsumerWithException<Execution, Exception>) value -> deploy())___			deploymentFuture.whenComplete(_				(Void ignored, Throwable failure) -> {_					if (failure != null) {_						final Throwable stripCompletionException = ExceptionUtils.stripCompletionException(failure)__						final Throwable schedulingFailureCause___						if (stripCompletionException instanceof TimeoutException) {_							schedulingFailureCause = new NoResourceAvailableException(_								"Could not allocate enough slots within timeout of " + allocationTimeout + " to run the job. " +_									"Please make sure that the cluster has enough resources.")__						} else {_							schedulingFailureCause = stripCompletionException__						}__						markFailed(schedulingFailureCause)__					}_				})___			_			if (!queued && !deploymentFuture.isDone()) {_				deploymentFuture.completeExceptionally(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return deploymentFuture__		} catch (IllegalExecutionStateException e) {_			return FutureUtils.completedExceptionally(e)__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,set,with,all,previous,allocation,ids,in,the,job,graph,can,be,empty,if,the,allocation,ids,are,not,required,for,scheduling,return,future,which,is,completed,once,the,execution,has,been,deployed;public,completable,future,void,schedule,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,final,time,allocation,timeout,vertex,get,execution,graph,get,allocation,timeout,try,final,completable,future,execution,allocation,future,allocate,and,assign,slot,for,execution,slot,provider,queued,location,preference,constraint,all,previous,execution,graph,allocation,ids,allocation,timeout,final,completable,future,void,deployment,future,allocation,future,then,accept,future,consumer,with,exception,execution,exception,value,deploy,deployment,future,when,complete,void,ignored,throwable,failure,if,failure,null,final,throwable,strip,completion,exception,exception,utils,strip,completion,exception,failure,final,throwable,scheduling,failure,cause,if,strip,completion,exception,instanceof,timeout,exception,scheduling,failure,cause,new,no,resource,available,exception,could,not,allocate,enough,slots,within,timeout,of,allocation,timeout,to,run,the,job,please,make,sure,that,the,cluster,has,enough,resources,else,scheduling,failure,cause,strip,completion,exception,mark,failed,scheduling,failure,cause,if,queued,deployment,future,is,done,deployment,future,complete,exceptionally,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,deployment,future,catch,illegal,execution,state,exception,e,return,future,utils,completed,exceptionally,e
Execution -> public CompletableFuture<Void> scheduleForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds);1546870832;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it._@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph._Can be empty if the allocation ids are not required for scheduling._@return Future which is completed once the Execution has been deployed;public CompletableFuture<Void> scheduleForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds) {_		final Time allocationTimeout = vertex.getExecutionGraph().getAllocationTimeout()__		try {_			final CompletableFuture<Execution> allocationFuture = allocateAndAssignSlotForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint,_				allPreviousExecutionGraphAllocationIds,_				allocationTimeout)___			_			_			_			final CompletableFuture<Void> deploymentFuture = allocationFuture.thenAccept(_				(FutureConsumerWithException<Execution, Exception>) value -> deploy())___			deploymentFuture.whenComplete(_				(Void ignored, Throwable failure) -> {_					if (failure != null) {_						final Throwable stripCompletionException = ExceptionUtils.stripCompletionException(failure)__						final Throwable schedulingFailureCause___						if (stripCompletionException instanceof TimeoutException) {_							schedulingFailureCause = new NoResourceAvailableException(_								"Could not allocate enough slots within timeout of " + allocationTimeout + " to run the job. " +_									"Please make sure that the cluster has enough resources.")__						} else {_							schedulingFailureCause = stripCompletionException__						}__						markFailed(schedulingFailureCause)__					}_				})___			_			if (!queued && !deploymentFuture.isDone()) {_				deploymentFuture.completeExceptionally(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return deploymentFuture__		} catch (IllegalExecutionStateException e) {_			return FutureUtils.completedExceptionally(e)__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,set,with,all,previous,allocation,ids,in,the,job,graph,can,be,empty,if,the,allocation,ids,are,not,required,for,scheduling,return,future,which,is,completed,once,the,execution,has,been,deployed;public,completable,future,void,schedule,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,final,time,allocation,timeout,vertex,get,execution,graph,get,allocation,timeout,try,final,completable,future,execution,allocation,future,allocate,and,assign,slot,for,execution,slot,provider,queued,location,preference,constraint,all,previous,execution,graph,allocation,ids,allocation,timeout,final,completable,future,void,deployment,future,allocation,future,then,accept,future,consumer,with,exception,execution,exception,value,deploy,deployment,future,when,complete,void,ignored,throwable,failure,if,failure,null,final,throwable,strip,completion,exception,exception,utils,strip,completion,exception,failure,final,throwable,scheduling,failure,cause,if,strip,completion,exception,instanceof,timeout,exception,scheduling,failure,cause,new,no,resource,available,exception,could,not,allocate,enough,slots,within,timeout,of,allocation,timeout,to,run,the,job,please,make,sure,that,the,cluster,has,enough,resources,else,scheduling,failure,cause,strip,completion,exception,mark,failed,scheduling,failure,cause,if,queued,deployment,future,is,done,deployment,future,complete,exceptionally,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,deployment,future,catch,illegal,execution,state,exception,e,return,future,utils,completed,exceptionally,e
Execution -> public CompletableFuture<Void> scheduleForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds);1547644408;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it._@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph._Can be empty if the allocation ids are not required for scheduling._@return Future which is completed once the Execution has been deployed;public CompletableFuture<Void> scheduleForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds) {_		final Time allocationTimeout = vertex.getExecutionGraph().getAllocationTimeout()__		try {_			final CompletableFuture<Execution> allocationFuture = allocateAndAssignSlotForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint,_				allPreviousExecutionGraphAllocationIds,_				allocationTimeout)___			_			_			_			final CompletableFuture<Void> deploymentFuture = allocationFuture.thenAccept(_				(FutureConsumerWithException<Execution, Exception>) value -> deploy())___			deploymentFuture.whenComplete(_				(Void ignored, Throwable failure) -> {_					if (failure != null) {_						final Throwable stripCompletionException = ExceptionUtils.stripCompletionException(failure)__						final Throwable schedulingFailureCause___						if (stripCompletionException instanceof TimeoutException) {_							schedulingFailureCause = new NoResourceAvailableException(_								"Could not allocate enough slots within timeout of " + allocationTimeout + " to run the job. " +_									"Please make sure that the cluster has enough resources.")__						} else {_							schedulingFailureCause = stripCompletionException__						}__						markFailed(schedulingFailureCause)__					}_				})___			_			if (!queued && !deploymentFuture.isDone()) {_				deploymentFuture.completeExceptionally(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return deploymentFuture__		} catch (IllegalExecutionStateException e) {_			return FutureUtils.completedExceptionally(e)__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,set,with,all,previous,allocation,ids,in,the,job,graph,can,be,empty,if,the,allocation,ids,are,not,required,for,scheduling,return,future,which,is,completed,once,the,execution,has,been,deployed;public,completable,future,void,schedule,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,final,time,allocation,timeout,vertex,get,execution,graph,get,allocation,timeout,try,final,completable,future,execution,allocation,future,allocate,and,assign,slot,for,execution,slot,provider,queued,location,preference,constraint,all,previous,execution,graph,allocation,ids,allocation,timeout,final,completable,future,void,deployment,future,allocation,future,then,accept,future,consumer,with,exception,execution,exception,value,deploy,deployment,future,when,complete,void,ignored,throwable,failure,if,failure,null,final,throwable,strip,completion,exception,exception,utils,strip,completion,exception,failure,final,throwable,scheduling,failure,cause,if,strip,completion,exception,instanceof,timeout,exception,scheduling,failure,cause,new,no,resource,available,exception,could,not,allocate,enough,slots,within,timeout,of,allocation,timeout,to,run,the,job,please,make,sure,that,the,cluster,has,enough,resources,else,scheduling,failure,cause,strip,completion,exception,mark,failed,scheduling,failure,cause,if,queued,deployment,future,is,done,deployment,future,complete,exceptionally,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,deployment,future,catch,illegal,execution,state,exception,e,return,future,utils,completed,exceptionally,e
Execution -> public CompletableFuture<Void> scheduleForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds);1549365080;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it._@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph._Can be empty if the allocation ids are not required for scheduling._@return Future which is completed once the Execution has been deployed;public CompletableFuture<Void> scheduleForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds) {__		assertRunningInJobMasterMainThread()__		final ExecutionGraph executionGraph = vertex.getExecutionGraph()__		final Time allocationTimeout = executionGraph.getAllocationTimeout()__		try {_			final CompletableFuture<Execution> allocationFuture = allocateAndAssignSlotForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint,_				allPreviousExecutionGraphAllocationIds,_				allocationTimeout)___			final CompletableFuture<Void> deploymentFuture___			if (allocationFuture.isDone() || queued) {_				deploymentFuture = allocationFuture.thenRun(ThrowingRunnable.unchecked(this::deploy))__			} else {_				deploymentFuture = FutureUtils.completedExceptionally(_					new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			deploymentFuture.whenComplete(_				(Void ignored, Throwable failure) -> {_					if (failure != null) {_						final Throwable stripCompletionException = ExceptionUtils.stripCompletionException(failure)__						final Throwable schedulingFailureCause___						if (stripCompletionException instanceof TimeoutException) {_							schedulingFailureCause = new NoResourceAvailableException(_								"Could not allocate enough slots within timeout of " + allocationTimeout + " to run the job. " +_									"Please make sure that the cluster has enough resources.")__						} else {_							schedulingFailureCause = stripCompletionException__						}_						markFailed(schedulingFailureCause)__					}_				})___			return deploymentFuture__		} catch (IllegalExecutionStateException e) {_			return FutureUtils.completedExceptionally(e)__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,set,with,all,previous,allocation,ids,in,the,job,graph,can,be,empty,if,the,allocation,ids,are,not,required,for,scheduling,return,future,which,is,completed,once,the,execution,has,been,deployed;public,completable,future,void,schedule,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,assert,running,in,job,master,main,thread,final,execution,graph,execution,graph,vertex,get,execution,graph,final,time,allocation,timeout,execution,graph,get,allocation,timeout,try,final,completable,future,execution,allocation,future,allocate,and,assign,slot,for,execution,slot,provider,queued,location,preference,constraint,all,previous,execution,graph,allocation,ids,allocation,timeout,final,completable,future,void,deployment,future,if,allocation,future,is,done,queued,deployment,future,allocation,future,then,run,throwing,runnable,unchecked,this,deploy,else,deployment,future,future,utils,completed,exceptionally,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,deployment,future,when,complete,void,ignored,throwable,failure,if,failure,null,final,throwable,strip,completion,exception,exception,utils,strip,completion,exception,failure,final,throwable,scheduling,failure,cause,if,strip,completion,exception,instanceof,timeout,exception,scheduling,failure,cause,new,no,resource,available,exception,could,not,allocate,enough,slots,within,timeout,of,allocation,timeout,to,run,the,job,please,make,sure,that,the,cluster,has,enough,resources,else,scheduling,failure,cause,strip,completion,exception,mark,failed,scheduling,failure,cause,return,deployment,future,catch,illegal,execution,state,exception,e,return,future,utils,completed,exceptionally,e
Execution -> public CompletableFuture<Void> scheduleForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds);1550220073;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it._@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph._Can be empty if the allocation ids are not required for scheduling._@return Future which is completed once the Execution has been deployed;public CompletableFuture<Void> scheduleForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds) {__		assertRunningInJobMasterMainThread()__		final ExecutionGraph executionGraph = vertex.getExecutionGraph()__		final Time allocationTimeout = executionGraph.getAllocationTimeout()__		try {_			final CompletableFuture<Execution> allocationFuture = allocateAndAssignSlotForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint,_				allPreviousExecutionGraphAllocationIds,_				allocationTimeout)___			final CompletableFuture<Void> deploymentFuture___			if (allocationFuture.isDone() || queued) {_				deploymentFuture = allocationFuture.thenRun(ThrowingRunnable.unchecked(this::deploy))__			} else {_				deploymentFuture = FutureUtils.completedExceptionally(_					new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			deploymentFuture.whenComplete(_				(Void ignored, Throwable failure) -> {_					if (failure != null) {_						final Throwable stripCompletionException = ExceptionUtils.stripCompletionException(failure)__						final Throwable schedulingFailureCause___						if (stripCompletionException instanceof TimeoutException) {_							schedulingFailureCause = new NoResourceAvailableException(_								"Could not allocate enough slots within timeout of " + allocationTimeout + " to run the job. " +_									"Please make sure that the cluster has enough resources.")__						} else {_							schedulingFailureCause = stripCompletionException__						}_						markFailed(schedulingFailureCause)__					}_				})___			return deploymentFuture__		} catch (IllegalExecutionStateException e) {_			return FutureUtils.completedExceptionally(e)__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,set,with,all,previous,allocation,ids,in,the,job,graph,can,be,empty,if,the,allocation,ids,are,not,required,for,scheduling,return,future,which,is,completed,once,the,execution,has,been,deployed;public,completable,future,void,schedule,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,assert,running,in,job,master,main,thread,final,execution,graph,execution,graph,vertex,get,execution,graph,final,time,allocation,timeout,execution,graph,get,allocation,timeout,try,final,completable,future,execution,allocation,future,allocate,and,assign,slot,for,execution,slot,provider,queued,location,preference,constraint,all,previous,execution,graph,allocation,ids,allocation,timeout,final,completable,future,void,deployment,future,if,allocation,future,is,done,queued,deployment,future,allocation,future,then,run,throwing,runnable,unchecked,this,deploy,else,deployment,future,future,utils,completed,exceptionally,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,deployment,future,when,complete,void,ignored,throwable,failure,if,failure,null,final,throwable,strip,completion,exception,exception,utils,strip,completion,exception,failure,final,throwable,scheduling,failure,cause,if,strip,completion,exception,instanceof,timeout,exception,scheduling,failure,cause,new,no,resource,available,exception,could,not,allocate,enough,slots,within,timeout,of,allocation,timeout,to,run,the,job,please,make,sure,that,the,cluster,has,enough,resources,else,scheduling,failure,cause,strip,completion,exception,mark,failed,scheduling,failure,cause,return,deployment,future,catch,illegal,execution,state,exception,e,return,future,utils,completed,exceptionally,e
Execution -> public CompletableFuture<Void> scheduleForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds);1550654143;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it._@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph._Can be empty if the allocation ids are not required for scheduling._@return Future which is completed once the Execution has been deployed;public CompletableFuture<Void> scheduleForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds) {__		assertRunningInJobMasterMainThread()__		final ExecutionGraph executionGraph = vertex.getExecutionGraph()__		final Time allocationTimeout = executionGraph.getAllocationTimeout()__		try {_			final CompletableFuture<Execution> allocationFuture = allocateAndAssignSlotForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint,_				allPreviousExecutionGraphAllocationIds,_				allocationTimeout)___			final CompletableFuture<Void> deploymentFuture___			if (allocationFuture.isDone() || queued) {_				deploymentFuture = allocationFuture.thenRun(ThrowingRunnable.unchecked(this::deploy))__			} else {_				deploymentFuture = FutureUtils.completedExceptionally(_					new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			deploymentFuture.whenComplete(_				(Void ignored, Throwable failure) -> {_					if (failure != null) {_						final Throwable stripCompletionException = ExceptionUtils.stripCompletionException(failure)__						final Throwable schedulingFailureCause___						if (stripCompletionException instanceof TimeoutException) {_							schedulingFailureCause = new NoResourceAvailableException(_								"Could not allocate enough slots within timeout of " + allocationTimeout + " to run the job. " +_									"Please make sure that the cluster has enough resources.")__						} else {_							schedulingFailureCause = stripCompletionException__						}_						markFailed(schedulingFailureCause)__					}_				})___			return deploymentFuture__		} catch (IllegalExecutionStateException e) {_			return FutureUtils.completedExceptionally(e)__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,set,with,all,previous,allocation,ids,in,the,job,graph,can,be,empty,if,the,allocation,ids,are,not,required,for,scheduling,return,future,which,is,completed,once,the,execution,has,been,deployed;public,completable,future,void,schedule,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,assert,running,in,job,master,main,thread,final,execution,graph,execution,graph,vertex,get,execution,graph,final,time,allocation,timeout,execution,graph,get,allocation,timeout,try,final,completable,future,execution,allocation,future,allocate,and,assign,slot,for,execution,slot,provider,queued,location,preference,constraint,all,previous,execution,graph,allocation,ids,allocation,timeout,final,completable,future,void,deployment,future,if,allocation,future,is,done,queued,deployment,future,allocation,future,then,run,throwing,runnable,unchecked,this,deploy,else,deployment,future,future,utils,completed,exceptionally,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,deployment,future,when,complete,void,ignored,throwable,failure,if,failure,null,final,throwable,strip,completion,exception,exception,utils,strip,completion,exception,failure,final,throwable,scheduling,failure,cause,if,strip,completion,exception,instanceof,timeout,exception,scheduling,failure,cause,new,no,resource,available,exception,could,not,allocate,enough,slots,within,timeout,of,allocation,timeout,to,run,the,job,please,make,sure,that,the,cluster,has,enough,resources,else,scheduling,failure,cause,strip,completion,exception,mark,failed,scheduling,failure,cause,return,deployment,future,catch,illegal,execution,state,exception,e,return,future,utils,completed,exceptionally,e
Execution -> public CompletableFuture<Void> scheduleForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds);1550683188;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it._@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph._Can be empty if the allocation ids are not required for scheduling._@return Future which is completed once the Execution has been deployed;public CompletableFuture<Void> scheduleForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds) {__		assertRunningInJobMasterMainThread()__		final ExecutionGraph executionGraph = vertex.getExecutionGraph()__		final Time allocationTimeout = executionGraph.getAllocationTimeout()__		try {_			final CompletableFuture<Execution> allocationFuture = allocateAndAssignSlotForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint,_				allPreviousExecutionGraphAllocationIds,_				allocationTimeout)___			final CompletableFuture<Void> deploymentFuture___			if (allocationFuture.isDone() || queued) {_				deploymentFuture = allocationFuture.thenRun(ThrowingRunnable.unchecked(this::deploy))__			} else {_				deploymentFuture = FutureUtils.completedExceptionally(_					new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			deploymentFuture.whenComplete(_				(Void ignored, Throwable failure) -> {_					if (failure != null) {_						final Throwable stripCompletionException = ExceptionUtils.stripCompletionException(failure)__						final Throwable schedulingFailureCause___						if (stripCompletionException instanceof TimeoutException) {_							schedulingFailureCause = new NoResourceAvailableException(_								"Could not allocate enough slots within timeout of " + allocationTimeout + " to run the job. " +_									"Please make sure that the cluster has enough resources.")__						} else {_							schedulingFailureCause = stripCompletionException__						}_						markFailed(schedulingFailureCause)__					}_				})___			return deploymentFuture__		} catch (IllegalExecutionStateException e) {_			return FutureUtils.completedExceptionally(e)__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,set,with,all,previous,allocation,ids,in,the,job,graph,can,be,empty,if,the,allocation,ids,are,not,required,for,scheduling,return,future,which,is,completed,once,the,execution,has,been,deployed;public,completable,future,void,schedule,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,assert,running,in,job,master,main,thread,final,execution,graph,execution,graph,vertex,get,execution,graph,final,time,allocation,timeout,execution,graph,get,allocation,timeout,try,final,completable,future,execution,allocation,future,allocate,and,assign,slot,for,execution,slot,provider,queued,location,preference,constraint,all,previous,execution,graph,allocation,ids,allocation,timeout,final,completable,future,void,deployment,future,if,allocation,future,is,done,queued,deployment,future,allocation,future,then,run,throwing,runnable,unchecked,this,deploy,else,deployment,future,future,utils,completed,exceptionally,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,deployment,future,when,complete,void,ignored,throwable,failure,if,failure,null,final,throwable,strip,completion,exception,exception,utils,strip,completion,exception,failure,final,throwable,scheduling,failure,cause,if,strip,completion,exception,instanceof,timeout,exception,scheduling,failure,cause,new,no,resource,available,exception,could,not,allocate,enough,slots,within,timeout,of,allocation,timeout,to,run,the,job,please,make,sure,that,the,cluster,has,enough,resources,else,scheduling,failure,cause,strip,completion,exception,mark,failed,scheduling,failure,cause,return,deployment,future,catch,illegal,execution,state,exception,e,return,future,utils,completed,exceptionally,e
Execution -> public CompletableFuture<Void> scheduleForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds);1550855836;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it._@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph._Can be empty if the allocation ids are not required for scheduling._@return Future which is completed once the Execution has been deployed;public CompletableFuture<Void> scheduleForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds) {__		assertRunningInJobMasterMainThread()__		final ExecutionGraph executionGraph = vertex.getExecutionGraph()__		final Time allocationTimeout = executionGraph.getAllocationTimeout()__		try {_			final CompletableFuture<Execution> allocationFuture = allocateAndAssignSlotForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint,_				allPreviousExecutionGraphAllocationIds,_				allocationTimeout)___			final CompletableFuture<Void> deploymentFuture___			if (allocationFuture.isDone() || queued) {_				deploymentFuture = allocationFuture.thenRun(ThrowingRunnable.unchecked(this::deploy))__			} else {_				deploymentFuture = FutureUtils.completedExceptionally(_					new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			deploymentFuture.whenComplete(_				(Void ignored, Throwable failure) -> {_					if (failure != null) {_						final Throwable stripCompletionException = ExceptionUtils.stripCompletionException(failure)__						final Throwable schedulingFailureCause___						if (stripCompletionException instanceof TimeoutException) {_							schedulingFailureCause = new NoResourceAvailableException(_								"Could not allocate enough slots within timeout of " + allocationTimeout + " to run the job. " +_									"Please make sure that the cluster has enough resources.")__						} else {_							schedulingFailureCause = stripCompletionException__						}_						markFailed(schedulingFailureCause)__					}_				})___			return deploymentFuture__		} catch (IllegalExecutionStateException e) {_			return FutureUtils.completedExceptionally(e)__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,set,with,all,previous,allocation,ids,in,the,job,graph,can,be,empty,if,the,allocation,ids,are,not,required,for,scheduling,return,future,which,is,completed,once,the,execution,has,been,deployed;public,completable,future,void,schedule,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,assert,running,in,job,master,main,thread,final,execution,graph,execution,graph,vertex,get,execution,graph,final,time,allocation,timeout,execution,graph,get,allocation,timeout,try,final,completable,future,execution,allocation,future,allocate,and,assign,slot,for,execution,slot,provider,queued,location,preference,constraint,all,previous,execution,graph,allocation,ids,allocation,timeout,final,completable,future,void,deployment,future,if,allocation,future,is,done,queued,deployment,future,allocation,future,then,run,throwing,runnable,unchecked,this,deploy,else,deployment,future,future,utils,completed,exceptionally,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,deployment,future,when,complete,void,ignored,throwable,failure,if,failure,null,final,throwable,strip,completion,exception,exception,utils,strip,completion,exception,failure,final,throwable,scheduling,failure,cause,if,strip,completion,exception,instanceof,timeout,exception,scheduling,failure,cause,new,no,resource,available,exception,could,not,allocate,enough,slots,within,timeout,of,allocation,timeout,to,run,the,job,please,make,sure,that,the,cluster,has,enough,resources,else,scheduling,failure,cause,strip,completion,exception,mark,failed,scheduling,failure,cause,return,deployment,future,catch,illegal,execution,state,exception,e,return,future,utils,completed,exceptionally,e
Execution -> @VisibleForTesting 	boolean tryAssignResource(final LogicalSlot logicalSlot);1513201052;Tries to assign the given slot to the execution. The assignment works only if the_Execution is in state SCHEDULED. Returns true, if the resource could be assigned.__@param logicalSlot to assign to this execution_@return true if the slot could be assigned to the execution, otherwise false;@VisibleForTesting_	boolean tryAssignResource(final LogicalSlot logicalSlot) {_		checkNotNull(logicalSlot)___		_		_		if (state == SCHEDULED || state == CREATED) {_			if (ASSIGNED_SLOT_UPDATER.compareAndSet(this, null, logicalSlot)) {_				_				if (state == SCHEDULED || state == CREATED) {_					checkState(!taskManagerLocationFuture.isDone(), "The TaskManagerLocationFuture should not be set if we haven't assigned a resource yet.")__					taskManagerLocationFuture.complete(logicalSlot.getTaskManagerLocation())___					return true__				} else {_					_					ASSIGNED_SLOT_UPDATER.set(this, null)__					return false__				}_			} else {_				_				return false__			}_		} else {_			_			return false__		}_	};tries,to,assign,the,given,slot,to,the,execution,the,assignment,works,only,if,the,execution,is,in,state,scheduled,returns,true,if,the,resource,could,be,assigned,param,logical,slot,to,assign,to,this,execution,return,true,if,the,slot,could,be,assigned,to,the,execution,otherwise,false;visible,for,testing,boolean,try,assign,resource,final,logical,slot,logical,slot,check,not,null,logical,slot,if,state,scheduled,state,created,if,compare,and,set,this,null,logical,slot,if,state,scheduled,state,created,check,state,task,manager,location,future,is,done,the,task,manager,location,future,should,not,be,set,if,we,haven,t,assigned,a,resource,yet,task,manager,location,future,complete,logical,slot,get,task,manager,location,return,true,else,set,this,null,return,false,else,return,false,else,return,false
Execution -> @VisibleForTesting 	boolean tryAssignResource(final LogicalSlot logicalSlot);1513201070;Tries to assign the given slot to the execution. The assignment works only if the_Execution is in state SCHEDULED. Returns true, if the resource could be assigned.__@param logicalSlot to assign to this execution_@return true if the slot could be assigned to the execution, otherwise false;@VisibleForTesting_	boolean tryAssignResource(final LogicalSlot logicalSlot) {_		checkNotNull(logicalSlot)___		_		_		if (state == SCHEDULED || state == CREATED) {_			if (ASSIGNED_SLOT_UPDATER.compareAndSet(this, null, logicalSlot)) {_				_				if (state == SCHEDULED || state == CREATED) {_					checkState(!taskManagerLocationFuture.isDone(), "The TaskManagerLocationFuture should not be set if we haven't assigned a resource yet.")__					taskManagerLocationFuture.complete(logicalSlot.getTaskManagerLocation())___					return true__				} else {_					_					ASSIGNED_SLOT_UPDATER.set(this, null)__					return false__				}_			} else {_				_				return false__			}_		} else {_			_			return false__		}_	};tries,to,assign,the,given,slot,to,the,execution,the,assignment,works,only,if,the,execution,is,in,state,scheduled,returns,true,if,the,resource,could,be,assigned,param,logical,slot,to,assign,to,this,execution,return,true,if,the,slot,could,be,assigned,to,the,execution,otherwise,false;visible,for,testing,boolean,try,assign,resource,final,logical,slot,logical,slot,check,not,null,logical,slot,if,state,scheduled,state,created,if,compare,and,set,this,null,logical,slot,if,state,scheduled,state,created,check,state,task,manager,location,future,is,done,the,task,manager,location,future,should,not,be,set,if,we,haven,t,assigned,a,resource,yet,task,manager,location,future,complete,logical,slot,get,task,manager,location,return,true,else,set,this,null,return,false,else,return,false,else,return,false
Execution -> @VisibleForTesting 	boolean tryAssignResource(final LogicalSlot logicalSlot);1513261599;Tries to assign the given slot to the execution. The assignment works only if the_Execution is in state SCHEDULED. Returns true, if the resource could be assigned.__@param logicalSlot to assign to this execution_@return true if the slot could be assigned to the execution, otherwise false;@VisibleForTesting_	boolean tryAssignResource(final LogicalSlot logicalSlot) {_		checkNotNull(logicalSlot)___		_		_		if (state == SCHEDULED || state == CREATED) {_			if (ASSIGNED_SLOT_UPDATER.compareAndSet(this, null, logicalSlot)) {_				_				if (state == SCHEDULED || state == CREATED) {_					checkState(!taskManagerLocationFuture.isDone(), "The TaskManagerLocationFuture should not be set if we haven't assigned a resource yet.")__					taskManagerLocationFuture.complete(logicalSlot.getTaskManagerLocation())___					return true__				} else {_					_					ASSIGNED_SLOT_UPDATER.set(this, null)__					return false__				}_			} else {_				_				return false__			}_		} else {_			_			return false__		}_	};tries,to,assign,the,given,slot,to,the,execution,the,assignment,works,only,if,the,execution,is,in,state,scheduled,returns,true,if,the,resource,could,be,assigned,param,logical,slot,to,assign,to,this,execution,return,true,if,the,slot,could,be,assigned,to,the,execution,otherwise,false;visible,for,testing,boolean,try,assign,resource,final,logical,slot,logical,slot,check,not,null,logical,slot,if,state,scheduled,state,created,if,compare,and,set,this,null,logical,slot,if,state,scheduled,state,created,check,state,task,manager,location,future,is,done,the,task,manager,location,future,should,not,be,set,if,we,haven,t,assigned,a,resource,yet,task,manager,location,future,complete,logical,slot,get,task,manager,location,return,true,else,set,this,null,return,false,else,return,false,else,return,false
Execution -> @VisibleForTesting 	boolean tryAssignResource(final LogicalSlot logicalSlot);1515177485;Tries to assign the given slot to the execution. The assignment works only if the_Execution is in state SCHEDULED. Returns true, if the resource could be assigned.__@param logicalSlot to assign to this execution_@return true if the slot could be assigned to the execution, otherwise false;@VisibleForTesting_	boolean tryAssignResource(final LogicalSlot logicalSlot) {_		checkNotNull(logicalSlot)___		_		_		if (state == SCHEDULED || state == CREATED) {_			if (ASSIGNED_SLOT_UPDATER.compareAndSet(this, null, logicalSlot)) {_				_				if (state == SCHEDULED || state == CREATED) {_					checkState(!taskManagerLocationFuture.isDone(), "The TaskManagerLocationFuture should not be set if we haven't assigned a resource yet.")__					taskManagerLocationFuture.complete(logicalSlot.getTaskManagerLocation())___					return true__				} else {_					_					ASSIGNED_SLOT_UPDATER.set(this, null)__					return false__				}_			} else {_				_				return false__			}_		} else {_			_			return false__		}_	};tries,to,assign,the,given,slot,to,the,execution,the,assignment,works,only,if,the,execution,is,in,state,scheduled,returns,true,if,the,resource,could,be,assigned,param,logical,slot,to,assign,to,this,execution,return,true,if,the,slot,could,be,assigned,to,the,execution,otherwise,false;visible,for,testing,boolean,try,assign,resource,final,logical,slot,logical,slot,check,not,null,logical,slot,if,state,scheduled,state,created,if,compare,and,set,this,null,logical,slot,if,state,scheduled,state,created,check,state,task,manager,location,future,is,done,the,task,manager,location,future,should,not,be,set,if,we,haven,t,assigned,a,resource,yet,task,manager,location,future,complete,logical,slot,get,task,manager,location,return,true,else,set,this,null,return,false,else,return,false,else,return,false
Execution -> @VisibleForTesting 	boolean tryAssignResource(final LogicalSlot logicalSlot);1516626377;Tries to assign the given slot to the execution. The assignment works only if the_Execution is in state SCHEDULED. Returns true, if the resource could be assigned.__@param logicalSlot to assign to this execution_@return true if the slot could be assigned to the execution, otherwise false;@VisibleForTesting_	boolean tryAssignResource(final LogicalSlot logicalSlot) {_		checkNotNull(logicalSlot)___		_		_		if (state == SCHEDULED || state == CREATED) {_			if (ASSIGNED_SLOT_UPDATER.compareAndSet(this, null, logicalSlot)) {_				_				if (state == SCHEDULED || state == CREATED) {_					checkState(!taskManagerLocationFuture.isDone(), "The TaskManagerLocationFuture should not be set if we haven't assigned a resource yet.")__					taskManagerLocationFuture.complete(logicalSlot.getTaskManagerLocation())___					return true__				} else {_					_					ASSIGNED_SLOT_UPDATER.set(this, null)__					return false__				}_			} else {_				_				return false__			}_		} else {_			_			return false__		}_	};tries,to,assign,the,given,slot,to,the,execution,the,assignment,works,only,if,the,execution,is,in,state,scheduled,returns,true,if,the,resource,could,be,assigned,param,logical,slot,to,assign,to,this,execution,return,true,if,the,slot,could,be,assigned,to,the,execution,otherwise,false;visible,for,testing,boolean,try,assign,resource,final,logical,slot,logical,slot,check,not,null,logical,slot,if,state,scheduled,state,created,if,compare,and,set,this,null,logical,slot,if,state,scheduled,state,created,check,state,task,manager,location,future,is,done,the,task,manager,location,future,should,not,be,set,if,we,haven,t,assigned,a,resource,yet,task,manager,location,future,complete,logical,slot,get,task,manager,location,return,true,else,set,this,null,return,false,else,return,false,else,return,false
Execution -> @VisibleForTesting 	boolean tryAssignResource(final LogicalSlot logicalSlot);1516626397;Tries to assign the given slot to the execution. The assignment works only if the_Execution is in state SCHEDULED. Returns true, if the resource could be assigned.__@param logicalSlot to assign to this execution_@return true if the slot could be assigned to the execution, otherwise false;@VisibleForTesting_	boolean tryAssignResource(final LogicalSlot logicalSlot) {_		checkNotNull(logicalSlot)___		_		_		if (state == SCHEDULED || state == CREATED) {_			if (ASSIGNED_SLOT_UPDATER.compareAndSet(this, null, logicalSlot)) {_				_				if (state == SCHEDULED || state == CREATED) {_					checkState(!taskManagerLocationFuture.isDone(), "The TaskManagerLocationFuture should not be set if we haven't assigned a resource yet.")__					taskManagerLocationFuture.complete(logicalSlot.getTaskManagerLocation())___					return true__				} else {_					_					ASSIGNED_SLOT_UPDATER.set(this, null)__					return false__				}_			} else {_				_				return false__			}_		} else {_			_			return false__		}_	};tries,to,assign,the,given,slot,to,the,execution,the,assignment,works,only,if,the,execution,is,in,state,scheduled,returns,true,if,the,resource,could,be,assigned,param,logical,slot,to,assign,to,this,execution,return,true,if,the,slot,could,be,assigned,to,the,execution,otherwise,false;visible,for,testing,boolean,try,assign,resource,final,logical,slot,logical,slot,check,not,null,logical,slot,if,state,scheduled,state,created,if,compare,and,set,this,null,logical,slot,if,state,scheduled,state,created,check,state,task,manager,location,future,is,done,the,task,manager,location,future,should,not,be,set,if,we,haven,t,assigned,a,resource,yet,task,manager,location,future,complete,logical,slot,get,task,manager,location,return,true,else,set,this,null,return,false,else,return,false,else,return,false
Execution -> @VisibleForTesting 	boolean tryAssignResource(final LogicalSlot logicalSlot);1518680774;Tries to assign the given slot to the execution. The assignment works only if the_Execution is in state SCHEDULED. Returns true, if the resource could be assigned.__@param logicalSlot to assign to this execution_@return true if the slot could be assigned to the execution, otherwise false;@VisibleForTesting_	boolean tryAssignResource(final LogicalSlot logicalSlot) {_		checkNotNull(logicalSlot)___		_		_		if (state == SCHEDULED || state == CREATED) {_			if (ASSIGNED_SLOT_UPDATER.compareAndSet(this, null, logicalSlot)) {_				_				if (state == SCHEDULED || state == CREATED) {_					checkState(!taskManagerLocationFuture.isDone(), "The TaskManagerLocationFuture should not be set if we haven't assigned a resource yet.")__					taskManagerLocationFuture.complete(logicalSlot.getTaskManagerLocation())___					return true__				} else {_					_					ASSIGNED_SLOT_UPDATER.set(this, null)__					return false__				}_			} else {_				_				return false__			}_		} else {_			_			return false__		}_	};tries,to,assign,the,given,slot,to,the,execution,the,assignment,works,only,if,the,execution,is,in,state,scheduled,returns,true,if,the,resource,could,be,assigned,param,logical,slot,to,assign,to,this,execution,return,true,if,the,slot,could,be,assigned,to,the,execution,otherwise,false;visible,for,testing,boolean,try,assign,resource,final,logical,slot,logical,slot,check,not,null,logical,slot,if,state,scheduled,state,created,if,compare,and,set,this,null,logical,slot,if,state,scheduled,state,created,check,state,task,manager,location,future,is,done,the,task,manager,location,future,should,not,be,set,if,we,haven,t,assigned,a,resource,yet,task,manager,location,future,complete,logical,slot,get,task,manager,location,return,true,else,set,this,null,return,false,else,return,false,else,return,false
Execution -> @VisibleForTesting 	boolean tryAssignResource(final LogicalSlot logicalSlot);1518712478;Tries to assign the given slot to the execution. The assignment works only if the_Execution is in state SCHEDULED. Returns true, if the resource could be assigned.__@param logicalSlot to assign to this execution_@return true if the slot could be assigned to the execution, otherwise false;@VisibleForTesting_	boolean tryAssignResource(final LogicalSlot logicalSlot) {_		checkNotNull(logicalSlot)___		_		_		if (state == SCHEDULED || state == CREATED) {_			if (ASSIGNED_SLOT_UPDATER.compareAndSet(this, null, logicalSlot)) {_				_				if (state == SCHEDULED || state == CREATED) {_					checkState(!taskManagerLocationFuture.isDone(), "The TaskManagerLocationFuture should not be set if we haven't assigned a resource yet.")__					taskManagerLocationFuture.complete(logicalSlot.getTaskManagerLocation())___					return true__				} else {_					_					ASSIGNED_SLOT_UPDATER.set(this, null)__					return false__				}_			} else {_				_				return false__			}_		} else {_			_			return false__		}_	};tries,to,assign,the,given,slot,to,the,execution,the,assignment,works,only,if,the,execution,is,in,state,scheduled,returns,true,if,the,resource,could,be,assigned,param,logical,slot,to,assign,to,this,execution,return,true,if,the,slot,could,be,assigned,to,the,execution,otherwise,false;visible,for,testing,boolean,try,assign,resource,final,logical,slot,logical,slot,check,not,null,logical,slot,if,state,scheduled,state,created,if,compare,and,set,this,null,logical,slot,if,state,scheduled,state,created,check,state,task,manager,location,future,is,done,the,task,manager,location,future,should,not,be,set,if,we,haven,t,assigned,a,resource,yet,task,manager,location,future,complete,logical,slot,get,task,manager,location,return,true,else,set,this,null,return,false,else,return,false,else,return,false
Execution -> @VisibleForTesting 	boolean tryAssignResource(final LogicalSlot logicalSlot);1519316529;Tries to assign the given slot to the execution. The assignment works only if the_Execution is in state SCHEDULED. Returns true, if the resource could be assigned.__@param logicalSlot to assign to this execution_@return true if the slot could be assigned to the execution, otherwise false;@VisibleForTesting_	boolean tryAssignResource(final LogicalSlot logicalSlot) {_		checkNotNull(logicalSlot)___		_		_		if (state == SCHEDULED || state == CREATED) {_			if (ASSIGNED_SLOT_UPDATER.compareAndSet(this, null, logicalSlot)) {_				_				if (state == SCHEDULED || state == CREATED) {_					checkState(!taskManagerLocationFuture.isDone(), "The TaskManagerLocationFuture should not be set if we haven't assigned a resource yet.")__					taskManagerLocationFuture.complete(logicalSlot.getTaskManagerLocation())___					return true__				} else {_					_					ASSIGNED_SLOT_UPDATER.set(this, null)__					return false__				}_			} else {_				_				return false__			}_		} else {_			_			return false__		}_	};tries,to,assign,the,given,slot,to,the,execution,the,assignment,works,only,if,the,execution,is,in,state,scheduled,returns,true,if,the,resource,could,be,assigned,param,logical,slot,to,assign,to,this,execution,return,true,if,the,slot,could,be,assigned,to,the,execution,otherwise,false;visible,for,testing,boolean,try,assign,resource,final,logical,slot,logical,slot,check,not,null,logical,slot,if,state,scheduled,state,created,if,compare,and,set,this,null,logical,slot,if,state,scheduled,state,created,check,state,task,manager,location,future,is,done,the,task,manager,location,future,should,not,be,set,if,we,haven,t,assigned,a,resource,yet,task,manager,location,future,complete,logical,slot,get,task,manager,location,return,true,else,set,this,null,return,false,else,return,false,else,return,false
Execution -> @VisibleForTesting 	boolean tryAssignResource(final LogicalSlot logicalSlot);1519481114;Tries to assign the given slot to the execution. The assignment works only if the_Execution is in state SCHEDULED. Returns true, if the resource could be assigned.__@param logicalSlot to assign to this execution_@return true if the slot could be assigned to the execution, otherwise false;@VisibleForTesting_	boolean tryAssignResource(final LogicalSlot logicalSlot) {_		checkNotNull(logicalSlot)___		_		_		if (state == SCHEDULED || state == CREATED) {_			if (ASSIGNED_SLOT_UPDATER.compareAndSet(this, null, logicalSlot)) {_				_				if (state == SCHEDULED || state == CREATED) {_					checkState(!taskManagerLocationFuture.isDone(), "The TaskManagerLocationFuture should not be set if we haven't assigned a resource yet.")__					taskManagerLocationFuture.complete(logicalSlot.getTaskManagerLocation())___					return true__				} else {_					_					ASSIGNED_SLOT_UPDATER.set(this, null)__					return false__				}_			} else {_				_				return false__			}_		} else {_			_			return false__		}_	};tries,to,assign,the,given,slot,to,the,execution,the,assignment,works,only,if,the,execution,is,in,state,scheduled,returns,true,if,the,resource,could,be,assigned,param,logical,slot,to,assign,to,this,execution,return,true,if,the,slot,could,be,assigned,to,the,execution,otherwise,false;visible,for,testing,boolean,try,assign,resource,final,logical,slot,logical,slot,check,not,null,logical,slot,if,state,scheduled,state,created,if,compare,and,set,this,null,logical,slot,if,state,scheduled,state,created,check,state,task,manager,location,future,is,done,the,task,manager,location,future,should,not,be,set,if,we,haven,t,assigned,a,resource,yet,task,manager,location,future,complete,logical,slot,get,task,manager,location,return,true,else,set,this,null,return,false,else,return,false,else,return,false
Execution -> @VisibleForTesting 	boolean tryAssignResource(final LogicalSlot logicalSlot);1519568061;Tries to assign the given slot to the execution. The assignment works only if the_Execution is in state SCHEDULED. Returns true, if the resource could be assigned.__@param logicalSlot to assign to this execution_@return true if the slot could be assigned to the execution, otherwise false;@VisibleForTesting_	boolean tryAssignResource(final LogicalSlot logicalSlot) {_		checkNotNull(logicalSlot)___		_		_		if (state == SCHEDULED || state == CREATED) {_			if (ASSIGNED_SLOT_UPDATER.compareAndSet(this, null, logicalSlot)) {_				_				if (state == SCHEDULED || state == CREATED) {_					checkState(!taskManagerLocationFuture.isDone(), "The TaskManagerLocationFuture should not be set if we haven't assigned a resource yet.")__					taskManagerLocationFuture.complete(logicalSlot.getTaskManagerLocation())___					return true__				} else {_					_					ASSIGNED_SLOT_UPDATER.set(this, null)__					return false__				}_			} else {_				_				return false__			}_		} else {_			_			return false__		}_	};tries,to,assign,the,given,slot,to,the,execution,the,assignment,works,only,if,the,execution,is,in,state,scheduled,returns,true,if,the,resource,could,be,assigned,param,logical,slot,to,assign,to,this,execution,return,true,if,the,slot,could,be,assigned,to,the,execution,otherwise,false;visible,for,testing,boolean,try,assign,resource,final,logical,slot,logical,slot,check,not,null,logical,slot,if,state,scheduled,state,created,if,compare,and,set,this,null,logical,slot,if,state,scheduled,state,created,check,state,task,manager,location,future,is,done,the,task,manager,location,future,should,not,be,set,if,we,haven,t,assigned,a,resource,yet,task,manager,location,future,complete,logical,slot,get,task,manager,location,return,true,else,set,this,null,return,false,else,return,false,else,return,false
Execution -> @VisibleForTesting 	boolean tryAssignResource(final LogicalSlot logicalSlot);1519655521;Tries to assign the given slot to the execution. The assignment works only if the_Execution is in state SCHEDULED. Returns true, if the resource could be assigned.__@param logicalSlot to assign to this execution_@return true if the slot could be assigned to the execution, otherwise false;@VisibleForTesting_	boolean tryAssignResource(final LogicalSlot logicalSlot) {_		checkNotNull(logicalSlot)___		_		_		if (state == SCHEDULED || state == CREATED) {_			if (ASSIGNED_SLOT_UPDATER.compareAndSet(this, null, logicalSlot)) {_				_				if (state == SCHEDULED || state == CREATED) {_					checkState(!taskManagerLocationFuture.isDone(), "The TaskManagerLocationFuture should not be set if we haven't assigned a resource yet.")__					taskManagerLocationFuture.complete(logicalSlot.getTaskManagerLocation())__					assignedAllocationID = logicalSlot.getAllocationId()__					return true__				} else {_					_					ASSIGNED_SLOT_UPDATER.set(this, null)__					return false__				}_			} else {_				_				return false__			}_		} else {_			_			return false__		}_	};tries,to,assign,the,given,slot,to,the,execution,the,assignment,works,only,if,the,execution,is,in,state,scheduled,returns,true,if,the,resource,could,be,assigned,param,logical,slot,to,assign,to,this,execution,return,true,if,the,slot,could,be,assigned,to,the,execution,otherwise,false;visible,for,testing,boolean,try,assign,resource,final,logical,slot,logical,slot,check,not,null,logical,slot,if,state,scheduled,state,created,if,compare,and,set,this,null,logical,slot,if,state,scheduled,state,created,check,state,task,manager,location,future,is,done,the,task,manager,location,future,should,not,be,set,if,we,haven,t,assigned,a,resource,yet,task,manager,location,future,complete,logical,slot,get,task,manager,location,assigned,allocation,id,logical,slot,get,allocation,id,return,true,else,set,this,null,return,false,else,return,false,else,return,false
Execution -> @VisibleForTesting 	boolean tryAssignResource(final LogicalSlot logicalSlot);1522049586;Tries to assign the given slot to the execution. The assignment works only if the_Execution is in state SCHEDULED. Returns true, if the resource could be assigned.__@param logicalSlot to assign to this execution_@return true if the slot could be assigned to the execution, otherwise false;@VisibleForTesting_	boolean tryAssignResource(final LogicalSlot logicalSlot) {_		checkNotNull(logicalSlot)___		_		_		if (state == SCHEDULED || state == CREATED) {_			if (ASSIGNED_SLOT_UPDATER.compareAndSet(this, null, logicalSlot)) {_				_				if (state == SCHEDULED || state == CREATED) {_					checkState(!taskManagerLocationFuture.isDone(), "The TaskManagerLocationFuture should not be set if we haven't assigned a resource yet.")__					taskManagerLocationFuture.complete(logicalSlot.getTaskManagerLocation())__					assignedAllocationID = logicalSlot.getAllocationId()__					return true__				} else {_					_					ASSIGNED_SLOT_UPDATER.set(this, null)__					return false__				}_			} else {_				_				return false__			}_		} else {_			_			return false__		}_	};tries,to,assign,the,given,slot,to,the,execution,the,assignment,works,only,if,the,execution,is,in,state,scheduled,returns,true,if,the,resource,could,be,assigned,param,logical,slot,to,assign,to,this,execution,return,true,if,the,slot,could,be,assigned,to,the,execution,otherwise,false;visible,for,testing,boolean,try,assign,resource,final,logical,slot,logical,slot,check,not,null,logical,slot,if,state,scheduled,state,created,if,compare,and,set,this,null,logical,slot,if,state,scheduled,state,created,check,state,task,manager,location,future,is,done,the,task,manager,location,future,should,not,be,set,if,we,haven,t,assigned,a,resource,yet,task,manager,location,future,complete,logical,slot,get,task,manager,location,assigned,allocation,id,logical,slot,get,allocation,id,return,true,else,set,this,null,return,false,else,return,false,else,return,false
Execution -> @VisibleForTesting 	boolean tryAssignResource(final LogicalSlot logicalSlot);1522249273;Tries to assign the given slot to the execution. The assignment works only if the_Execution is in state SCHEDULED. Returns true, if the resource could be assigned.__@param logicalSlot to assign to this execution_@return true if the slot could be assigned to the execution, otherwise false;@VisibleForTesting_	boolean tryAssignResource(final LogicalSlot logicalSlot) {_		checkNotNull(logicalSlot)___		_		_		if (state == SCHEDULED || state == CREATED) {_			if (ASSIGNED_SLOT_UPDATER.compareAndSet(this, null, logicalSlot) && logicalSlot.tryAssignPayload(this)) {_				_				if (state == SCHEDULED || state == CREATED) {_					checkState(!taskManagerLocationFuture.isDone(), "The TaskManagerLocationFuture should not be set if we haven't assigned a resource yet.")__					taskManagerLocationFuture.complete(logicalSlot.getTaskManagerLocation())__					assignedAllocationID = logicalSlot.getAllocationId()__					return true__				} else {_					_					ASSIGNED_SLOT_UPDATER.set(this, null)__					return false__				}_			} else {_				_				return false__			}_		} else {_			_			return false__		}_	};tries,to,assign,the,given,slot,to,the,execution,the,assignment,works,only,if,the,execution,is,in,state,scheduled,returns,true,if,the,resource,could,be,assigned,param,logical,slot,to,assign,to,this,execution,return,true,if,the,slot,could,be,assigned,to,the,execution,otherwise,false;visible,for,testing,boolean,try,assign,resource,final,logical,slot,logical,slot,check,not,null,logical,slot,if,state,scheduled,state,created,if,compare,and,set,this,null,logical,slot,logical,slot,try,assign,payload,this,if,state,scheduled,state,created,check,state,task,manager,location,future,is,done,the,task,manager,location,future,should,not,be,set,if,we,haven,t,assigned,a,resource,yet,task,manager,location,future,complete,logical,slot,get,task,manager,location,assigned,allocation,id,logical,slot,get,allocation,id,return,true,else,set,this,null,return,false,else,return,false,else,return,false
Execution -> @VisibleForTesting 	boolean tryAssignResource(final LogicalSlot logicalSlot);1530712207;Tries to assign the given slot to the execution. The assignment works only if the_Execution is in state SCHEDULED. Returns true, if the resource could be assigned.__@param logicalSlot to assign to this execution_@return true if the slot could be assigned to the execution, otherwise false;@VisibleForTesting_	boolean tryAssignResource(final LogicalSlot logicalSlot) {_		checkNotNull(logicalSlot)___		_		_		if (state == SCHEDULED || state == CREATED) {_			if (ASSIGNED_SLOT_UPDATER.compareAndSet(this, null, logicalSlot) && logicalSlot.tryAssignPayload(this)) {_				_				if (state == SCHEDULED || state == CREATED) {_					checkState(!taskManagerLocationFuture.isDone(), "The TaskManagerLocationFuture should not be set if we haven't assigned a resource yet.")__					taskManagerLocationFuture.complete(logicalSlot.getTaskManagerLocation())__					assignedAllocationID = logicalSlot.getAllocationId()__					return true__				} else {_					_					ASSIGNED_SLOT_UPDATER.set(this, null)__					return false__				}_			} else {_				_				return false__			}_		} else {_			_			return false__		}_	};tries,to,assign,the,given,slot,to,the,execution,the,assignment,works,only,if,the,execution,is,in,state,scheduled,returns,true,if,the,resource,could,be,assigned,param,logical,slot,to,assign,to,this,execution,return,true,if,the,slot,could,be,assigned,to,the,execution,otherwise,false;visible,for,testing,boolean,try,assign,resource,final,logical,slot,logical,slot,check,not,null,logical,slot,if,state,scheduled,state,created,if,compare,and,set,this,null,logical,slot,logical,slot,try,assign,payload,this,if,state,scheduled,state,created,check,state,task,manager,location,future,is,done,the,task,manager,location,future,should,not,be,set,if,we,haven,t,assigned,a,resource,yet,task,manager,location,future,complete,logical,slot,get,task,manager,location,assigned,allocation,id,logical,slot,get,allocation,id,return,true,else,set,this,null,return,false,else,return,false,else,return,false
Execution -> @VisibleForTesting 	boolean tryAssignResource(final LogicalSlot logicalSlot);1532383539;Tries to assign the given slot to the execution. The assignment works only if the_Execution is in state SCHEDULED. Returns true, if the resource could be assigned.__@param logicalSlot to assign to this execution_@return true if the slot could be assigned to the execution, otherwise false;@VisibleForTesting_	boolean tryAssignResource(final LogicalSlot logicalSlot) {_		checkNotNull(logicalSlot)___		_		_		if (state == SCHEDULED || state == CREATED) {_			if (ASSIGNED_SLOT_UPDATER.compareAndSet(this, null, logicalSlot)) {_				if (logicalSlot.tryAssignPayload(this)) {_					_					if ((state == SCHEDULED || state == CREATED) && !taskManagerLocationFuture.isDone()) {_						taskManagerLocationFuture.complete(logicalSlot.getTaskManagerLocation())__						assignedAllocationID = logicalSlot.getAllocationId()__						return true__					} else {_						_						ASSIGNED_SLOT_UPDATER.set(this, null)__						return false__					}_				} else {_					ASSIGNED_SLOT_UPDATER.set(this, null)__					return false__				}_			} else {_				_				return false__			}_		} else {_			_			return false__		}_	};tries,to,assign,the,given,slot,to,the,execution,the,assignment,works,only,if,the,execution,is,in,state,scheduled,returns,true,if,the,resource,could,be,assigned,param,logical,slot,to,assign,to,this,execution,return,true,if,the,slot,could,be,assigned,to,the,execution,otherwise,false;visible,for,testing,boolean,try,assign,resource,final,logical,slot,logical,slot,check,not,null,logical,slot,if,state,scheduled,state,created,if,compare,and,set,this,null,logical,slot,if,logical,slot,try,assign,payload,this,if,state,scheduled,state,created,task,manager,location,future,is,done,task,manager,location,future,complete,logical,slot,get,task,manager,location,assigned,allocation,id,logical,slot,get,allocation,id,return,true,else,set,this,null,return,false,else,set,this,null,return,false,else,return,false,else,return,false
Execution -> @VisibleForTesting 	boolean tryAssignResource(final LogicalSlot logicalSlot);1532383539;Tries to assign the given slot to the execution. The assignment works only if the_Execution is in state SCHEDULED. Returns true, if the resource could be assigned.__@param logicalSlot to assign to this execution_@return true if the slot could be assigned to the execution, otherwise false;@VisibleForTesting_	boolean tryAssignResource(final LogicalSlot logicalSlot) {_		checkNotNull(logicalSlot)___		_		_		if (state == SCHEDULED || state == CREATED) {_			if (ASSIGNED_SLOT_UPDATER.compareAndSet(this, null, logicalSlot)) {_				if (logicalSlot.tryAssignPayload(this)) {_					_					if ((state == SCHEDULED || state == CREATED) && !taskManagerLocationFuture.isDone()) {_						taskManagerLocationFuture.complete(logicalSlot.getTaskManagerLocation())__						assignedAllocationID = logicalSlot.getAllocationId()__						return true__					} else {_						_						ASSIGNED_SLOT_UPDATER.set(this, null)__						return false__					}_				} else {_					ASSIGNED_SLOT_UPDATER.set(this, null)__					return false__				}_			} else {_				_				return false__			}_		} else {_			_			return false__		}_	};tries,to,assign,the,given,slot,to,the,execution,the,assignment,works,only,if,the,execution,is,in,state,scheduled,returns,true,if,the,resource,could,be,assigned,param,logical,slot,to,assign,to,this,execution,return,true,if,the,slot,could,be,assigned,to,the,execution,otherwise,false;visible,for,testing,boolean,try,assign,resource,final,logical,slot,logical,slot,check,not,null,logical,slot,if,state,scheduled,state,created,if,compare,and,set,this,null,logical,slot,if,logical,slot,try,assign,payload,this,if,state,scheduled,state,created,task,manager,location,future,is,done,task,manager,location,future,complete,logical,slot,get,task,manager,location,assigned,allocation,id,logical,slot,get,allocation,id,return,true,else,set,this,null,return,false,else,set,this,null,return,false,else,return,false,else,return,false
Execution -> @VisibleForTesting 	boolean tryAssignResource(final LogicalSlot logicalSlot);1532383539;Tries to assign the given slot to the execution. The assignment works only if the_Execution is in state SCHEDULED. Returns true, if the resource could be assigned.__@param logicalSlot to assign to this execution_@return true if the slot could be assigned to the execution, otherwise false;@VisibleForTesting_	boolean tryAssignResource(final LogicalSlot logicalSlot) {_		checkNotNull(logicalSlot)___		_		_		if (state == SCHEDULED || state == CREATED) {_			if (ASSIGNED_SLOT_UPDATER.compareAndSet(this, null, logicalSlot)) {_				if (logicalSlot.tryAssignPayload(this)) {_					_					if ((state == SCHEDULED || state == CREATED) && !taskManagerLocationFuture.isDone()) {_						taskManagerLocationFuture.complete(logicalSlot.getTaskManagerLocation())__						assignedAllocationID = logicalSlot.getAllocationId()__						return true__					} else {_						_						ASSIGNED_SLOT_UPDATER.set(this, null)__						return false__					}_				} else {_					ASSIGNED_SLOT_UPDATER.set(this, null)__					return false__				}_			} else {_				_				return false__			}_		} else {_			_			return false__		}_	};tries,to,assign,the,given,slot,to,the,execution,the,assignment,works,only,if,the,execution,is,in,state,scheduled,returns,true,if,the,resource,could,be,assigned,param,logical,slot,to,assign,to,this,execution,return,true,if,the,slot,could,be,assigned,to,the,execution,otherwise,false;visible,for,testing,boolean,try,assign,resource,final,logical,slot,logical,slot,check,not,null,logical,slot,if,state,scheduled,state,created,if,compare,and,set,this,null,logical,slot,if,logical,slot,try,assign,payload,this,if,state,scheduled,state,created,task,manager,location,future,is,done,task,manager,location,future,complete,logical,slot,get,task,manager,location,assigned,allocation,id,logical,slot,get,allocation,id,return,true,else,set,this,null,return,false,else,set,this,null,return,false,else,return,false,else,return,false
Execution -> @VisibleForTesting 	boolean tryAssignResource(final LogicalSlot logicalSlot);1540920690;Tries to assign the given slot to the execution. The assignment works only if the_Execution is in state SCHEDULED. Returns true, if the resource could be assigned.__@param logicalSlot to assign to this execution_@return true if the slot could be assigned to the execution, otherwise false;@VisibleForTesting_	boolean tryAssignResource(final LogicalSlot logicalSlot) {_		checkNotNull(logicalSlot)___		_		_		if (state == SCHEDULED || state == CREATED) {_			if (ASSIGNED_SLOT_UPDATER.compareAndSet(this, null, logicalSlot)) {_				if (logicalSlot.tryAssignPayload(this)) {_					_					if ((state == SCHEDULED || state == CREATED) && !taskManagerLocationFuture.isDone()) {_						taskManagerLocationFuture.complete(logicalSlot.getTaskManagerLocation())__						assignedAllocationID = logicalSlot.getAllocationId()__						return true__					} else {_						_						ASSIGNED_SLOT_UPDATER.set(this, null)__						return false__					}_				} else {_					ASSIGNED_SLOT_UPDATER.set(this, null)__					return false__				}_			} else {_				_				return false__			}_		} else {_			_			return false__		}_	};tries,to,assign,the,given,slot,to,the,execution,the,assignment,works,only,if,the,execution,is,in,state,scheduled,returns,true,if,the,resource,could,be,assigned,param,logical,slot,to,assign,to,this,execution,return,true,if,the,slot,could,be,assigned,to,the,execution,otherwise,false;visible,for,testing,boolean,try,assign,resource,final,logical,slot,logical,slot,check,not,null,logical,slot,if,state,scheduled,state,created,if,compare,and,set,this,null,logical,slot,if,logical,slot,try,assign,payload,this,if,state,scheduled,state,created,task,manager,location,future,is,done,task,manager,location,future,complete,logical,slot,get,task,manager,location,assigned,allocation,id,logical,slot,get,allocation,id,return,true,else,set,this,null,return,false,else,set,this,null,return,false,else,return,false,else,return,false
Execution -> @VisibleForTesting 	boolean tryAssignResource(final LogicalSlot logicalSlot);1542356428;Tries to assign the given slot to the execution. The assignment works only if the_Execution is in state SCHEDULED. Returns true, if the resource could be assigned.__@param logicalSlot to assign to this execution_@return true if the slot could be assigned to the execution, otherwise false;@VisibleForTesting_	boolean tryAssignResource(final LogicalSlot logicalSlot) {_		checkNotNull(logicalSlot)___		_		_		if (state == SCHEDULED || state == CREATED) {_			if (ASSIGNED_SLOT_UPDATER.compareAndSet(this, null, logicalSlot)) {_				if (logicalSlot.tryAssignPayload(this)) {_					_					if ((state == SCHEDULED || state == CREATED) && !taskManagerLocationFuture.isDone()) {_						taskManagerLocationFuture.complete(logicalSlot.getTaskManagerLocation())__						assignedAllocationID = logicalSlot.getAllocationId()__						return true__					} else {_						_						ASSIGNED_SLOT_UPDATER.set(this, null)__						return false__					}_				} else {_					ASSIGNED_SLOT_UPDATER.set(this, null)__					return false__				}_			} else {_				_				return false__			}_		} else {_			_			return false__		}_	};tries,to,assign,the,given,slot,to,the,execution,the,assignment,works,only,if,the,execution,is,in,state,scheduled,returns,true,if,the,resource,could,be,assigned,param,logical,slot,to,assign,to,this,execution,return,true,if,the,slot,could,be,assigned,to,the,execution,otherwise,false;visible,for,testing,boolean,try,assign,resource,final,logical,slot,logical,slot,check,not,null,logical,slot,if,state,scheduled,state,created,if,compare,and,set,this,null,logical,slot,if,logical,slot,try,assign,payload,this,if,state,scheduled,state,created,task,manager,location,future,is,done,task,manager,location,future,complete,logical,slot,get,task,manager,location,assigned,allocation,id,logical,slot,get,allocation,id,return,true,else,set,this,null,return,false,else,set,this,null,return,false,else,return,false,else,return,false
Execution -> @VisibleForTesting 	boolean tryAssignResource(final LogicalSlot logicalSlot);1546870832;Tries to assign the given slot to the execution. The assignment works only if the_Execution is in state SCHEDULED. Returns true, if the resource could be assigned.__@param logicalSlot to assign to this execution_@return true if the slot could be assigned to the execution, otherwise false;@VisibleForTesting_	boolean tryAssignResource(final LogicalSlot logicalSlot) {_		checkNotNull(logicalSlot)___		_		_		if (state == SCHEDULED || state == CREATED) {_			if (ASSIGNED_SLOT_UPDATER.compareAndSet(this, null, logicalSlot)) {_				if (logicalSlot.tryAssignPayload(this)) {_					_					if ((state == SCHEDULED || state == CREATED) && !taskManagerLocationFuture.isDone()) {_						taskManagerLocationFuture.complete(logicalSlot.getTaskManagerLocation())__						assignedAllocationID = logicalSlot.getAllocationId()__						return true__					} else {_						_						ASSIGNED_SLOT_UPDATER.set(this, null)__						return false__					}_				} else {_					ASSIGNED_SLOT_UPDATER.set(this, null)__					return false__				}_			} else {_				_				return false__			}_		} else {_			_			return false__		}_	};tries,to,assign,the,given,slot,to,the,execution,the,assignment,works,only,if,the,execution,is,in,state,scheduled,returns,true,if,the,resource,could,be,assigned,param,logical,slot,to,assign,to,this,execution,return,true,if,the,slot,could,be,assigned,to,the,execution,otherwise,false;visible,for,testing,boolean,try,assign,resource,final,logical,slot,logical,slot,check,not,null,logical,slot,if,state,scheduled,state,created,if,compare,and,set,this,null,logical,slot,if,logical,slot,try,assign,payload,this,if,state,scheduled,state,created,task,manager,location,future,is,done,task,manager,location,future,complete,logical,slot,get,task,manager,location,assigned,allocation,id,logical,slot,get,allocation,id,return,true,else,set,this,null,return,false,else,set,this,null,return,false,else,return,false,else,return,false
Execution -> @VisibleForTesting 	boolean tryAssignResource(final LogicalSlot logicalSlot);1547644408;Tries to assign the given slot to the execution. The assignment works only if the_Execution is in state SCHEDULED. Returns true, if the resource could be assigned.__@param logicalSlot to assign to this execution_@return true if the slot could be assigned to the execution, otherwise false;@VisibleForTesting_	boolean tryAssignResource(final LogicalSlot logicalSlot) {_		checkNotNull(logicalSlot)___		_		_		if (state == SCHEDULED || state == CREATED) {_			if (ASSIGNED_SLOT_UPDATER.compareAndSet(this, null, logicalSlot)) {_				if (logicalSlot.tryAssignPayload(this)) {_					_					if ((state == SCHEDULED || state == CREATED) && !taskManagerLocationFuture.isDone()) {_						taskManagerLocationFuture.complete(logicalSlot.getTaskManagerLocation())__						assignedAllocationID = logicalSlot.getAllocationId()__						return true__					} else {_						_						ASSIGNED_SLOT_UPDATER.set(this, null)__						return false__					}_				} else {_					ASSIGNED_SLOT_UPDATER.set(this, null)__					return false__				}_			} else {_				_				return false__			}_		} else {_			_			return false__		}_	};tries,to,assign,the,given,slot,to,the,execution,the,assignment,works,only,if,the,execution,is,in,state,scheduled,returns,true,if,the,resource,could,be,assigned,param,logical,slot,to,assign,to,this,execution,return,true,if,the,slot,could,be,assigned,to,the,execution,otherwise,false;visible,for,testing,boolean,try,assign,resource,final,logical,slot,logical,slot,check,not,null,logical,slot,if,state,scheduled,state,created,if,compare,and,set,this,null,logical,slot,if,logical,slot,try,assign,payload,this,if,state,scheduled,state,created,task,manager,location,future,is,done,task,manager,location,future,complete,logical,slot,get,task,manager,location,assigned,allocation,id,logical,slot,get,allocation,id,return,true,else,set,this,null,return,false,else,set,this,null,return,false,else,return,false,else,return,false
Execution -> @VisibleForTesting 	boolean tryAssignResource(final LogicalSlot logicalSlot);1549365080;Tries to assign the given slot to the execution. The assignment works only if the_Execution is in state SCHEDULED. Returns true, if the resource could be assigned.__@param logicalSlot to assign to this execution_@return true if the slot could be assigned to the execution, otherwise false;@VisibleForTesting_	boolean tryAssignResource(final LogicalSlot logicalSlot) {__		assertRunningInJobMasterMainThread()___		checkNotNull(logicalSlot)___		_		_		if (state == SCHEDULED || state == CREATED) {_			if (ASSIGNED_SLOT_UPDATER.compareAndSet(this, null, logicalSlot)) {_				if (logicalSlot.tryAssignPayload(this)) {_					_					if ((state == SCHEDULED || state == CREATED) && !taskManagerLocationFuture.isDone()) {_						taskManagerLocationFuture.complete(logicalSlot.getTaskManagerLocation())__						assignedAllocationID = logicalSlot.getAllocationId()__						return true__					} else {_						_						ASSIGNED_SLOT_UPDATER.set(this, null)__						return false__					}_				} else {_					ASSIGNED_SLOT_UPDATER.set(this, null)__					return false__				}_			} else {_				_				return false__			}_		} else {_			_			return false__		}_	};tries,to,assign,the,given,slot,to,the,execution,the,assignment,works,only,if,the,execution,is,in,state,scheduled,returns,true,if,the,resource,could,be,assigned,param,logical,slot,to,assign,to,this,execution,return,true,if,the,slot,could,be,assigned,to,the,execution,otherwise,false;visible,for,testing,boolean,try,assign,resource,final,logical,slot,logical,slot,assert,running,in,job,master,main,thread,check,not,null,logical,slot,if,state,scheduled,state,created,if,compare,and,set,this,null,logical,slot,if,logical,slot,try,assign,payload,this,if,state,scheduled,state,created,task,manager,location,future,is,done,task,manager,location,future,complete,logical,slot,get,task,manager,location,assigned,allocation,id,logical,slot,get,allocation,id,return,true,else,set,this,null,return,false,else,set,this,null,return,false,else,return,false,else,return,false
Execution -> @VisibleForTesting 	boolean tryAssignResource(final LogicalSlot logicalSlot);1550220073;Tries to assign the given slot to the execution. The assignment works only if the_Execution is in state SCHEDULED. Returns true, if the resource could be assigned.__@param logicalSlot to assign to this execution_@return true if the slot could be assigned to the execution, otherwise false;@VisibleForTesting_	boolean tryAssignResource(final LogicalSlot logicalSlot) {__		assertRunningInJobMasterMainThread()___		checkNotNull(logicalSlot)___		_		_		if (state == SCHEDULED || state == CREATED) {_			if (ASSIGNED_SLOT_UPDATER.compareAndSet(this, null, logicalSlot)) {_				if (logicalSlot.tryAssignPayload(this)) {_					_					if ((state == SCHEDULED || state == CREATED) && !taskManagerLocationFuture.isDone()) {_						taskManagerLocationFuture.complete(logicalSlot.getTaskManagerLocation())__						assignedAllocationID = logicalSlot.getAllocationId()__						return true__					} else {_						_						ASSIGNED_SLOT_UPDATER.set(this, null)__						return false__					}_				} else {_					ASSIGNED_SLOT_UPDATER.set(this, null)__					return false__				}_			} else {_				_				return false__			}_		} else {_			_			return false__		}_	};tries,to,assign,the,given,slot,to,the,execution,the,assignment,works,only,if,the,execution,is,in,state,scheduled,returns,true,if,the,resource,could,be,assigned,param,logical,slot,to,assign,to,this,execution,return,true,if,the,slot,could,be,assigned,to,the,execution,otherwise,false;visible,for,testing,boolean,try,assign,resource,final,logical,slot,logical,slot,assert,running,in,job,master,main,thread,check,not,null,logical,slot,if,state,scheduled,state,created,if,compare,and,set,this,null,logical,slot,if,logical,slot,try,assign,payload,this,if,state,scheduled,state,created,task,manager,location,future,is,done,task,manager,location,future,complete,logical,slot,get,task,manager,location,assigned,allocation,id,logical,slot,get,allocation,id,return,true,else,set,this,null,return,false,else,set,this,null,return,false,else,return,false,else,return,false
Execution -> @VisibleForTesting 	boolean tryAssignResource(final LogicalSlot logicalSlot);1550654143;Tries to assign the given slot to the execution. The assignment works only if the_Execution is in state SCHEDULED. Returns true, if the resource could be assigned.__@param logicalSlot to assign to this execution_@return true if the slot could be assigned to the execution, otherwise false;@VisibleForTesting_	boolean tryAssignResource(final LogicalSlot logicalSlot) {__		assertRunningInJobMasterMainThread()___		checkNotNull(logicalSlot)___		_		_		if (state == SCHEDULED || state == CREATED) {_			if (ASSIGNED_SLOT_UPDATER.compareAndSet(this, null, logicalSlot)) {_				if (logicalSlot.tryAssignPayload(this)) {_					_					if ((state == SCHEDULED || state == CREATED) && !taskManagerLocationFuture.isDone()) {_						taskManagerLocationFuture.complete(logicalSlot.getTaskManagerLocation())__						assignedAllocationID = logicalSlot.getAllocationId()__						return true__					} else {_						_						ASSIGNED_SLOT_UPDATER.set(this, null)__						return false__					}_				} else {_					ASSIGNED_SLOT_UPDATER.set(this, null)__					return false__				}_			} else {_				_				return false__			}_		} else {_			_			return false__		}_	};tries,to,assign,the,given,slot,to,the,execution,the,assignment,works,only,if,the,execution,is,in,state,scheduled,returns,true,if,the,resource,could,be,assigned,param,logical,slot,to,assign,to,this,execution,return,true,if,the,slot,could,be,assigned,to,the,execution,otherwise,false;visible,for,testing,boolean,try,assign,resource,final,logical,slot,logical,slot,assert,running,in,job,master,main,thread,check,not,null,logical,slot,if,state,scheduled,state,created,if,compare,and,set,this,null,logical,slot,if,logical,slot,try,assign,payload,this,if,state,scheduled,state,created,task,manager,location,future,is,done,task,manager,location,future,complete,logical,slot,get,task,manager,location,assigned,allocation,id,logical,slot,get,allocation,id,return,true,else,set,this,null,return,false,else,set,this,null,return,false,else,return,false,else,return,false
Execution -> @VisibleForTesting 	boolean tryAssignResource(final LogicalSlot logicalSlot);1550683188;Tries to assign the given slot to the execution. The assignment works only if the_Execution is in state SCHEDULED. Returns true, if the resource could be assigned.__@param logicalSlot to assign to this execution_@return true if the slot could be assigned to the execution, otherwise false;@VisibleForTesting_	boolean tryAssignResource(final LogicalSlot logicalSlot) {__		assertRunningInJobMasterMainThread()___		checkNotNull(logicalSlot)___		_		_		if (state == SCHEDULED || state == CREATED) {_			if (ASSIGNED_SLOT_UPDATER.compareAndSet(this, null, logicalSlot)) {_				if (logicalSlot.tryAssignPayload(this)) {_					_					if ((state == SCHEDULED || state == CREATED) && !taskManagerLocationFuture.isDone()) {_						taskManagerLocationFuture.complete(logicalSlot.getTaskManagerLocation())__						assignedAllocationID = logicalSlot.getAllocationId()__						return true__					} else {_						_						ASSIGNED_SLOT_UPDATER.set(this, null)__						return false__					}_				} else {_					ASSIGNED_SLOT_UPDATER.set(this, null)__					return false__				}_			} else {_				_				return false__			}_		} else {_			_			return false__		}_	};tries,to,assign,the,given,slot,to,the,execution,the,assignment,works,only,if,the,execution,is,in,state,scheduled,returns,true,if,the,resource,could,be,assigned,param,logical,slot,to,assign,to,this,execution,return,true,if,the,slot,could,be,assigned,to,the,execution,otherwise,false;visible,for,testing,boolean,try,assign,resource,final,logical,slot,logical,slot,assert,running,in,job,master,main,thread,check,not,null,logical,slot,if,state,scheduled,state,created,if,compare,and,set,this,null,logical,slot,if,logical,slot,try,assign,payload,this,if,state,scheduled,state,created,task,manager,location,future,is,done,task,manager,location,future,complete,logical,slot,get,task,manager,location,assigned,allocation,id,logical,slot,get,allocation,id,return,true,else,set,this,null,return,false,else,set,this,null,return,false,else,return,false,else,return,false
Execution -> @VisibleForTesting 	boolean tryAssignResource(final LogicalSlot logicalSlot);1550855836;Tries to assign the given slot to the execution. The assignment works only if the_Execution is in state SCHEDULED. Returns true, if the resource could be assigned.__@param logicalSlot to assign to this execution_@return true if the slot could be assigned to the execution, otherwise false;@VisibleForTesting_	boolean tryAssignResource(final LogicalSlot logicalSlot) {__		assertRunningInJobMasterMainThread()___		checkNotNull(logicalSlot)___		_		_		if (state == SCHEDULED || state == CREATED) {_			if (ASSIGNED_SLOT_UPDATER.compareAndSet(this, null, logicalSlot)) {_				if (logicalSlot.tryAssignPayload(this)) {_					_					if ((state == SCHEDULED || state == CREATED) && !taskManagerLocationFuture.isDone()) {_						taskManagerLocationFuture.complete(logicalSlot.getTaskManagerLocation())__						assignedAllocationID = logicalSlot.getAllocationId()__						return true__					} else {_						_						ASSIGNED_SLOT_UPDATER.set(this, null)__						return false__					}_				} else {_					ASSIGNED_SLOT_UPDATER.set(this, null)__					return false__				}_			} else {_				_				return false__			}_		} else {_			_			return false__		}_	};tries,to,assign,the,given,slot,to,the,execution,the,assignment,works,only,if,the,execution,is,in,state,scheduled,returns,true,if,the,resource,could,be,assigned,param,logical,slot,to,assign,to,this,execution,return,true,if,the,slot,could,be,assigned,to,the,execution,otherwise,false;visible,for,testing,boolean,try,assign,resource,final,logical,slot,logical,slot,assert,running,in,job,master,main,thread,check,not,null,logical,slot,if,state,scheduled,state,created,if,compare,and,set,this,null,logical,slot,if,logical,slot,try,assign,payload,this,if,state,scheduled,state,created,task,manager,location,future,is,done,task,manager,location,future,complete,logical,slot,get,task,manager,location,assigned,allocation,id,logical,slot,get,allocation,id,return,true,else,set,this,null,return,false,else,set,this,null,return,false,else,return,false,else,return,false
Execution -> public CompletableFuture<Void> scheduleForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint);1519316529;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it._@param locationPreferenceConstraint constraint for the location preferences_@return Future which is completed once the Execution has been deployed;public CompletableFuture<Void> scheduleForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) {_		final Time allocationTimeout = vertex.getExecutionGraph().getAllocationTimeout()__		try {_			final CompletableFuture<Execution> allocationFuture = allocateAndAssignSlotForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint,_				allocationTimeout)___			_			_			_			final CompletableFuture<Void> deploymentFuture = allocationFuture.handle(_				(Execution ignored, Throwable throwable) -> {_					if (throwable != null) {_						markFailed(ExceptionUtils.stripCompletionException(throwable))__					} else {_						try {_							deploy()__						} catch (Throwable t) {_							markFailed(ExceptionUtils.stripCompletionException(t))__						}_					}_					return null__				}_			)___			_			if (!queued && !deploymentFuture.isDone()) {_				allocationFuture.completeExceptionally(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return deploymentFuture__		} catch (IllegalExecutionStateException e) {_			return FutureUtils.completedExceptionally(e)__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,param,location,preference,constraint,constraint,for,the,location,preferences,return,future,which,is,completed,once,the,execution,has,been,deployed;public,completable,future,void,schedule,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,final,time,allocation,timeout,vertex,get,execution,graph,get,allocation,timeout,try,final,completable,future,execution,allocation,future,allocate,and,assign,slot,for,execution,slot,provider,queued,location,preference,constraint,allocation,timeout,final,completable,future,void,deployment,future,allocation,future,handle,execution,ignored,throwable,throwable,if,throwable,null,mark,failed,exception,utils,strip,completion,exception,throwable,else,try,deploy,catch,throwable,t,mark,failed,exception,utils,strip,completion,exception,t,return,null,if,queued,deployment,future,is,done,allocation,future,complete,exceptionally,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,deployment,future,catch,illegal,execution,state,exception,e,return,future,utils,completed,exceptionally,e
Execution -> public CompletableFuture<Void> scheduleForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint);1519481114;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it._@param locationPreferenceConstraint constraint for the location preferences_@return Future which is completed once the Execution has been deployed;public CompletableFuture<Void> scheduleForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) {_		final Time allocationTimeout = vertex.getExecutionGraph().getAllocationTimeout()__		try {_			final CompletableFuture<Execution> allocationFuture = allocateAndAssignSlotForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint,_				allocationTimeout)___			_			_			_			final CompletableFuture<Void> deploymentFuture = allocationFuture.handle(_				(Execution ignored, Throwable throwable) -> {_					if (throwable != null) {_						markFailed(ExceptionUtils.stripCompletionException(throwable))__					} else {_						try {_							deploy()__						} catch (Throwable t) {_							markFailed(ExceptionUtils.stripCompletionException(t))__						}_					}_					return null__				}_			)___			_			if (!queued && !deploymentFuture.isDone()) {_				allocationFuture.completeExceptionally(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return deploymentFuture__		} catch (IllegalExecutionStateException e) {_			return FutureUtils.completedExceptionally(e)__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,param,location,preference,constraint,constraint,for,the,location,preferences,return,future,which,is,completed,once,the,execution,has,been,deployed;public,completable,future,void,schedule,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,final,time,allocation,timeout,vertex,get,execution,graph,get,allocation,timeout,try,final,completable,future,execution,allocation,future,allocate,and,assign,slot,for,execution,slot,provider,queued,location,preference,constraint,allocation,timeout,final,completable,future,void,deployment,future,allocation,future,handle,execution,ignored,throwable,throwable,if,throwable,null,mark,failed,exception,utils,strip,completion,exception,throwable,else,try,deploy,catch,throwable,t,mark,failed,exception,utils,strip,completion,exception,t,return,null,if,queued,deployment,future,is,done,allocation,future,complete,exceptionally,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,deployment,future,catch,illegal,execution,state,exception,e,return,future,utils,completed,exceptionally,e
Execution -> public CompletableFuture<Void> scheduleForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint);1519568061;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it._@param locationPreferenceConstraint constraint for the location preferences_@return Future which is completed once the Execution has been deployed;public CompletableFuture<Void> scheduleForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) {_		final Time allocationTimeout = vertex.getExecutionGraph().getAllocationTimeout()__		try {_			final CompletableFuture<Execution> allocationFuture = allocateAndAssignSlotForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint,_				allocationTimeout)___			_			_			_			final CompletableFuture<Void> deploymentFuture = allocationFuture.handle(_				(Execution ignored, Throwable throwable) -> {_					if (throwable != null) {_						markFailed(ExceptionUtils.stripCompletionException(throwable))__					} else {_						try {_							deploy()__						} catch (Throwable t) {_							markFailed(ExceptionUtils.stripCompletionException(t))__						}_					}_					return null__				}_			)___			_			if (!queued && !deploymentFuture.isDone()) {_				allocationFuture.completeExceptionally(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return deploymentFuture__		} catch (IllegalExecutionStateException e) {_			return FutureUtils.completedExceptionally(e)__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,param,location,preference,constraint,constraint,for,the,location,preferences,return,future,which,is,completed,once,the,execution,has,been,deployed;public,completable,future,void,schedule,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,final,time,allocation,timeout,vertex,get,execution,graph,get,allocation,timeout,try,final,completable,future,execution,allocation,future,allocate,and,assign,slot,for,execution,slot,provider,queued,location,preference,constraint,allocation,timeout,final,completable,future,void,deployment,future,allocation,future,handle,execution,ignored,throwable,throwable,if,throwable,null,mark,failed,exception,utils,strip,completion,exception,throwable,else,try,deploy,catch,throwable,t,mark,failed,exception,utils,strip,completion,exception,t,return,null,if,queued,deployment,future,is,done,allocation,future,complete,exceptionally,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,deployment,future,catch,illegal,execution,state,exception,e,return,future,utils,completed,exceptionally,e
Execution -> public CompletableFuture<Void> scheduleForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint);1519655521;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it._@param locationPreferenceConstraint constraint for the location preferences_@return Future which is completed once the Execution has been deployed;public CompletableFuture<Void> scheduleForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) {_		final Time allocationTimeout = vertex.getExecutionGraph().getAllocationTimeout()__		try {_			final CompletableFuture<Execution> allocationFuture = allocateAndAssignSlotForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint,_				allocationTimeout)___			_			_			_			final CompletableFuture<Void> deploymentFuture = allocationFuture.handle(_				(Execution ignored, Throwable throwable) -> {_					if (throwable != null) {_						markFailed(ExceptionUtils.stripCompletionException(throwable))__					} else {_						try {_							deploy()__						} catch (Throwable t) {_							markFailed(ExceptionUtils.stripCompletionException(t))__						}_					}_					return null__				}_			)___			_			if (!queued && !deploymentFuture.isDone()) {_				allocationFuture.completeExceptionally(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return deploymentFuture__		} catch (IllegalExecutionStateException e) {_			return FutureUtils.completedExceptionally(e)__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,param,location,preference,constraint,constraint,for,the,location,preferences,return,future,which,is,completed,once,the,execution,has,been,deployed;public,completable,future,void,schedule,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,final,time,allocation,timeout,vertex,get,execution,graph,get,allocation,timeout,try,final,completable,future,execution,allocation,future,allocate,and,assign,slot,for,execution,slot,provider,queued,location,preference,constraint,allocation,timeout,final,completable,future,void,deployment,future,allocation,future,handle,execution,ignored,throwable,throwable,if,throwable,null,mark,failed,exception,utils,strip,completion,exception,throwable,else,try,deploy,catch,throwable,t,mark,failed,exception,utils,strip,completion,exception,t,return,null,if,queued,deployment,future,is,done,allocation,future,complete,exceptionally,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,deployment,future,catch,illegal,execution,state,exception,e,return,future,utils,completed,exceptionally,e
Execution -> public CompletableFuture<Void> scheduleForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint);1522049586;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it._@param locationPreferenceConstraint constraint for the location preferences_@return Future which is completed once the Execution has been deployed;public CompletableFuture<Void> scheduleForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) {_		final Time allocationTimeout = vertex.getExecutionGraph().getAllocationTimeout()__		try {_			final CompletableFuture<Execution> allocationFuture = allocateAndAssignSlotForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint,_				allocationTimeout)___			_			_			_			final CompletableFuture<Void> deploymentFuture = allocationFuture.handle(_				(Execution ignored, Throwable throwable) -> {_					if (throwable != null) {_						markFailed(ExceptionUtils.stripCompletionException(throwable))__					} else {_						try {_							deploy()__						} catch (Throwable t) {_							markFailed(ExceptionUtils.stripCompletionException(t))__						}_					}_					return null__				}_			)___			_			if (!queued && !deploymentFuture.isDone()) {_				allocationFuture.completeExceptionally(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return deploymentFuture__		} catch (IllegalExecutionStateException e) {_			return FutureUtils.completedExceptionally(e)__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,param,location,preference,constraint,constraint,for,the,location,preferences,return,future,which,is,completed,once,the,execution,has,been,deployed;public,completable,future,void,schedule,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,final,time,allocation,timeout,vertex,get,execution,graph,get,allocation,timeout,try,final,completable,future,execution,allocation,future,allocate,and,assign,slot,for,execution,slot,provider,queued,location,preference,constraint,allocation,timeout,final,completable,future,void,deployment,future,allocation,future,handle,execution,ignored,throwable,throwable,if,throwable,null,mark,failed,exception,utils,strip,completion,exception,throwable,else,try,deploy,catch,throwable,t,mark,failed,exception,utils,strip,completion,exception,t,return,null,if,queued,deployment,future,is,done,allocation,future,complete,exceptionally,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,deployment,future,catch,illegal,execution,state,exception,e,return,future,utils,completed,exceptionally,e
Execution -> public CompletableFuture<Void> scheduleForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint);1522249273;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it._@param locationPreferenceConstraint constraint for the location preferences_@return Future which is completed once the Execution has been deployed;public CompletableFuture<Void> scheduleForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) {_		final Time allocationTimeout = vertex.getExecutionGraph().getAllocationTimeout()__		try {_			final CompletableFuture<Execution> allocationFuture = allocateAndAssignSlotForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint,_				allocationTimeout)___			_			_			_			final CompletableFuture<Void> deploymentFuture = allocationFuture.handle(_				(Execution ignored, Throwable throwable) -> {_					if (throwable != null) {_						markFailed(ExceptionUtils.stripCompletionException(throwable))__					} else {_						try {_							deploy()__						} catch (Throwable t) {_							markFailed(ExceptionUtils.stripCompletionException(t))__						}_					}_					return null__				}_			)___			_			if (!queued && !deploymentFuture.isDone()) {_				allocationFuture.completeExceptionally(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return deploymentFuture__		} catch (IllegalExecutionStateException e) {_			return FutureUtils.completedExceptionally(e)__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,param,location,preference,constraint,constraint,for,the,location,preferences,return,future,which,is,completed,once,the,execution,has,been,deployed;public,completable,future,void,schedule,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,final,time,allocation,timeout,vertex,get,execution,graph,get,allocation,timeout,try,final,completable,future,execution,allocation,future,allocate,and,assign,slot,for,execution,slot,provider,queued,location,preference,constraint,allocation,timeout,final,completable,future,void,deployment,future,allocation,future,handle,execution,ignored,throwable,throwable,if,throwable,null,mark,failed,exception,utils,strip,completion,exception,throwable,else,try,deploy,catch,throwable,t,mark,failed,exception,utils,strip,completion,exception,t,return,null,if,queued,deployment,future,is,done,allocation,future,complete,exceptionally,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,deployment,future,catch,illegal,execution,state,exception,e,return,future,utils,completed,exceptionally,e
Execution -> public CompletableFuture<Void> scheduleForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint);1530712207;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it._@param locationPreferenceConstraint constraint for the location preferences_@return Future which is completed once the Execution has been deployed;public CompletableFuture<Void> scheduleForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) {_		final Time allocationTimeout = vertex.getExecutionGraph().getAllocationTimeout()__		try {_			final CompletableFuture<Execution> allocationFuture = allocateAndAssignSlotForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint,_				allocationTimeout)___			_			_			_			final CompletableFuture<Void> deploymentFuture = allocationFuture.handle(_				(Execution ignored, Throwable throwable) -> {_					if (throwable != null) {_						markFailed(ExceptionUtils.stripCompletionException(throwable))__					} else {_						try {_							deploy()__						} catch (Throwable t) {_							markFailed(ExceptionUtils.stripCompletionException(t))__						}_					}_					return null__				}_			)___			_			if (!queued && !deploymentFuture.isDone()) {_				allocationFuture.completeExceptionally(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return deploymentFuture__		} catch (IllegalExecutionStateException e) {_			return FutureUtils.completedExceptionally(e)__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,param,location,preference,constraint,constraint,for,the,location,preferences,return,future,which,is,completed,once,the,execution,has,been,deployed;public,completable,future,void,schedule,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,final,time,allocation,timeout,vertex,get,execution,graph,get,allocation,timeout,try,final,completable,future,execution,allocation,future,allocate,and,assign,slot,for,execution,slot,provider,queued,location,preference,constraint,allocation,timeout,final,completable,future,void,deployment,future,allocation,future,handle,execution,ignored,throwable,throwable,if,throwable,null,mark,failed,exception,utils,strip,completion,exception,throwable,else,try,deploy,catch,throwable,t,mark,failed,exception,utils,strip,completion,exception,t,return,null,if,queued,deployment,future,is,done,allocation,future,complete,exceptionally,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,deployment,future,catch,illegal,execution,state,exception,e,return,future,utils,completed,exceptionally,e
Execution -> public CompletableFuture<Void> scheduleForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint);1532383539;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it._@param locationPreferenceConstraint constraint for the location preferences_@return Future which is completed once the Execution has been deployed;public CompletableFuture<Void> scheduleForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) {_		final Time allocationTimeout = vertex.getExecutionGraph().getAllocationTimeout()__		try {_			final CompletableFuture<Execution> allocationFuture = allocateAndAssignSlotForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint,_				allocationTimeout)___			_			_			_			final CompletableFuture<Void> deploymentFuture = allocationFuture.handle(_				(Execution ignored, Throwable throwable) -> {_					if (throwable != null) {_						markFailed(ExceptionUtils.stripCompletionException(throwable))__					} else {_						try {_							deploy()__						} catch (Throwable t) {_							markFailed(ExceptionUtils.stripCompletionException(t))__						}_					}_					return null__				}_			)___			_			if (!queued && !deploymentFuture.isDone()) {_				allocationFuture.completeExceptionally(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return deploymentFuture__		} catch (IllegalExecutionStateException e) {_			return FutureUtils.completedExceptionally(e)__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,param,location,preference,constraint,constraint,for,the,location,preferences,return,future,which,is,completed,once,the,execution,has,been,deployed;public,completable,future,void,schedule,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,final,time,allocation,timeout,vertex,get,execution,graph,get,allocation,timeout,try,final,completable,future,execution,allocation,future,allocate,and,assign,slot,for,execution,slot,provider,queued,location,preference,constraint,allocation,timeout,final,completable,future,void,deployment,future,allocation,future,handle,execution,ignored,throwable,throwable,if,throwable,null,mark,failed,exception,utils,strip,completion,exception,throwable,else,try,deploy,catch,throwable,t,mark,failed,exception,utils,strip,completion,exception,t,return,null,if,queued,deployment,future,is,done,allocation,future,complete,exceptionally,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,deployment,future,catch,illegal,execution,state,exception,e,return,future,utils,completed,exceptionally,e
Execution -> public CompletableFuture<Void> scheduleForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint);1532383539;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it._@param locationPreferenceConstraint constraint for the location preferences_@return Future which is completed once the Execution has been deployed;public CompletableFuture<Void> scheduleForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) {_		final Time allocationTimeout = vertex.getExecutionGraph().getAllocationTimeout()__		try {_			final CompletableFuture<Execution> allocationFuture = allocateAndAssignSlotForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint,_				allocationTimeout)___			_			_			_			final CompletableFuture<Void> deploymentFuture = allocationFuture.handle(_				(Execution ignored, Throwable throwable) -> {_					if (throwable != null) {_						markFailed(ExceptionUtils.stripCompletionException(throwable))__					} else {_						try {_							deploy()__						} catch (Throwable t) {_							markFailed(ExceptionUtils.stripCompletionException(t))__						}_					}_					return null__				}_			)___			_			if (!queued && !deploymentFuture.isDone()) {_				allocationFuture.completeExceptionally(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return deploymentFuture__		} catch (IllegalExecutionStateException e) {_			return FutureUtils.completedExceptionally(e)__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,param,location,preference,constraint,constraint,for,the,location,preferences,return,future,which,is,completed,once,the,execution,has,been,deployed;public,completable,future,void,schedule,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,final,time,allocation,timeout,vertex,get,execution,graph,get,allocation,timeout,try,final,completable,future,execution,allocation,future,allocate,and,assign,slot,for,execution,slot,provider,queued,location,preference,constraint,allocation,timeout,final,completable,future,void,deployment,future,allocation,future,handle,execution,ignored,throwable,throwable,if,throwable,null,mark,failed,exception,utils,strip,completion,exception,throwable,else,try,deploy,catch,throwable,t,mark,failed,exception,utils,strip,completion,exception,t,return,null,if,queued,deployment,future,is,done,allocation,future,complete,exceptionally,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,deployment,future,catch,illegal,execution,state,exception,e,return,future,utils,completed,exceptionally,e
Execution -> public CompletableFuture<Void> scheduleForExecution( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint);1532383539;NOTE: This method only throws exceptions if it is in an illegal state to be scheduled, or if the tasks needs_to be scheduled immediately and no resource is available. If the task is accepted by the schedule, any_error sets the vertex state to failed and triggers the recovery logic.__@param slotProvider The slot provider to use to allocate slot for this execution attempt._@param queued Flag to indicate whether the scheduler may queue this task if it cannot_immediately deploy it._@param locationPreferenceConstraint constraint for the location preferences_@return Future which is completed once the Execution has been deployed;public CompletableFuture<Void> scheduleForExecution(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) {_		final Time allocationTimeout = vertex.getExecutionGraph().getAllocationTimeout()__		try {_			final CompletableFuture<Execution> allocationFuture = allocateAndAssignSlotForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint,_				allocationTimeout)___			_			_			_			final CompletableFuture<Void> deploymentFuture = allocationFuture.thenAccept(_				(FutureConsumerWithException<Execution, Exception>) value -> deploy())___			deploymentFuture.whenComplete(_				(Void ignored, Throwable failure) -> {_					if (failure != null) {_						markFailed(ExceptionUtils.stripCompletionException(failure))__					}_				})___			_			if (!queued && !deploymentFuture.isDone()) {_				deploymentFuture.completeExceptionally(new IllegalArgumentException("The slot allocation future has not been completed yet."))__			}__			return deploymentFuture__		} catch (IllegalExecutionStateException e) {_			return FutureUtils.completedExceptionally(e)__		}_	};note,this,method,only,throws,exceptions,if,it,is,in,an,illegal,state,to,be,scheduled,or,if,the,tasks,needs,to,be,scheduled,immediately,and,no,resource,is,available,if,the,task,is,accepted,by,the,schedule,any,error,sets,the,vertex,state,to,failed,and,triggers,the,recovery,logic,param,slot,provider,the,slot,provider,to,use,to,allocate,slot,for,this,execution,attempt,param,queued,flag,to,indicate,whether,the,scheduler,may,queue,this,task,if,it,cannot,immediately,deploy,it,param,location,preference,constraint,constraint,for,the,location,preferences,return,future,which,is,completed,once,the,execution,has,been,deployed;public,completable,future,void,schedule,for,execution,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,final,time,allocation,timeout,vertex,get,execution,graph,get,allocation,timeout,try,final,completable,future,execution,allocation,future,allocate,and,assign,slot,for,execution,slot,provider,queued,location,preference,constraint,allocation,timeout,final,completable,future,void,deployment,future,allocation,future,then,accept,future,consumer,with,exception,execution,exception,value,deploy,deployment,future,when,complete,void,ignored,throwable,failure,if,failure,null,mark,failed,exception,utils,strip,completion,exception,failure,if,queued,deployment,future,is,done,deployment,future,complete,exceptionally,new,illegal,argument,exception,the,slot,allocation,future,has,not,been,completed,yet,return,deployment,future,catch,illegal,execution,state,exception,e,return,future,utils,completed,exceptionally,e
Execution -> private void releaseAssignedResource(@Nullable Throwable cause);1513261599;Releases the assigned resource and completes the release future_once the assigned resource has been successfully released__@param cause for the resource release, null if none;private void releaseAssignedResource(@Nullable Throwable cause) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			slot.releaseSlot(cause).whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (throwable != null) {_						releaseFuture.completeExceptionally(throwable)__					} else {_						releaseFuture.complete(null)__					}_				})__		} else {_			_			releaseFuture.complete(null)__		}_	};releases,the,assigned,resource,and,completes,the,release,future,once,the,assigned,resource,has,been,successfully,released,param,cause,for,the,resource,release,null,if,none;private,void,release,assigned,resource,nullable,throwable,cause,final,logical,slot,slot,assigned,resource,if,slot,null,slot,release,slot,cause,when,complete,object,ignored,throwable,throwable,if,throwable,null,release,future,complete,exceptionally,throwable,else,release,future,complete,null,else,release,future,complete,null
Execution -> private void releaseAssignedResource(@Nullable Throwable cause);1515177485;Releases the assigned resource and completes the release future_once the assigned resource has been successfully released__@param cause for the resource release, null if none;private void releaseAssignedResource(@Nullable Throwable cause) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			slot.releaseSlot(cause).whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (throwable != null) {_						releaseFuture.completeExceptionally(throwable)__					} else {_						releaseFuture.complete(null)__					}_				})__		} else {_			_			releaseFuture.complete(null)__		}_	};releases,the,assigned,resource,and,completes,the,release,future,once,the,assigned,resource,has,been,successfully,released,param,cause,for,the,resource,release,null,if,none;private,void,release,assigned,resource,nullable,throwable,cause,final,logical,slot,slot,assigned,resource,if,slot,null,slot,release,slot,cause,when,complete,object,ignored,throwable,throwable,if,throwable,null,release,future,complete,exceptionally,throwable,else,release,future,complete,null,else,release,future,complete,null
Execution -> private void releaseAssignedResource(@Nullable Throwable cause);1516626377;Releases the assigned resource and completes the release future_once the assigned resource has been successfully released__@param cause for the resource release, null if none;private void releaseAssignedResource(@Nullable Throwable cause) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			slot.releaseSlot(cause).whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (throwable != null) {_						releaseFuture.completeExceptionally(throwable)__					} else {_						releaseFuture.complete(null)__					}_				})__		} else {_			_			releaseFuture.complete(null)__		}_	};releases,the,assigned,resource,and,completes,the,release,future,once,the,assigned,resource,has,been,successfully,released,param,cause,for,the,resource,release,null,if,none;private,void,release,assigned,resource,nullable,throwable,cause,final,logical,slot,slot,assigned,resource,if,slot,null,slot,release,slot,cause,when,complete,object,ignored,throwable,throwable,if,throwable,null,release,future,complete,exceptionally,throwable,else,release,future,complete,null,else,release,future,complete,null
Execution -> private void releaseAssignedResource(@Nullable Throwable cause);1516626397;Releases the assigned resource and completes the release future_once the assigned resource has been successfully released__@param cause for the resource release, null if none;private void releaseAssignedResource(@Nullable Throwable cause) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			slot.releaseSlot(cause).whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (throwable != null) {_						releaseFuture.completeExceptionally(throwable)__					} else {_						releaseFuture.complete(null)__					}_				})__		} else {_			_			releaseFuture.complete(null)__		}_	};releases,the,assigned,resource,and,completes,the,release,future,once,the,assigned,resource,has,been,successfully,released,param,cause,for,the,resource,release,null,if,none;private,void,release,assigned,resource,nullable,throwable,cause,final,logical,slot,slot,assigned,resource,if,slot,null,slot,release,slot,cause,when,complete,object,ignored,throwable,throwable,if,throwable,null,release,future,complete,exceptionally,throwable,else,release,future,complete,null,else,release,future,complete,null
Execution -> private void releaseAssignedResource(@Nullable Throwable cause);1518680774;Releases the assigned resource and completes the release future_once the assigned resource has been successfully released__@param cause for the resource release, null if none;private void releaseAssignedResource(@Nullable Throwable cause) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			slot.releaseSlot(cause).whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (throwable != null) {_						releaseFuture.completeExceptionally(throwable)__					} else {_						releaseFuture.complete(null)__					}_				})__		} else {_			_			releaseFuture.complete(null)__		}_	};releases,the,assigned,resource,and,completes,the,release,future,once,the,assigned,resource,has,been,successfully,released,param,cause,for,the,resource,release,null,if,none;private,void,release,assigned,resource,nullable,throwable,cause,final,logical,slot,slot,assigned,resource,if,slot,null,slot,release,slot,cause,when,complete,object,ignored,throwable,throwable,if,throwable,null,release,future,complete,exceptionally,throwable,else,release,future,complete,null,else,release,future,complete,null
Execution -> private void releaseAssignedResource(@Nullable Throwable cause);1518712478;Releases the assigned resource and completes the release future_once the assigned resource has been successfully released__@param cause for the resource release, null if none;private void releaseAssignedResource(@Nullable Throwable cause) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			slot.releaseSlot(cause).whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (throwable != null) {_						releaseFuture.completeExceptionally(throwable)__					} else {_						releaseFuture.complete(null)__					}_				})__		} else {_			_			releaseFuture.complete(null)__		}_	};releases,the,assigned,resource,and,completes,the,release,future,once,the,assigned,resource,has,been,successfully,released,param,cause,for,the,resource,release,null,if,none;private,void,release,assigned,resource,nullable,throwable,cause,final,logical,slot,slot,assigned,resource,if,slot,null,slot,release,slot,cause,when,complete,object,ignored,throwable,throwable,if,throwable,null,release,future,complete,exceptionally,throwable,else,release,future,complete,null,else,release,future,complete,null
Execution -> private void releaseAssignedResource(@Nullable Throwable cause);1519316529;Releases the assigned resource and completes the release future_once the assigned resource has been successfully released__@param cause for the resource release, null if none;private void releaseAssignedResource(@Nullable Throwable cause) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			slot.releaseSlot(cause).whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (throwable != null) {_						releaseFuture.completeExceptionally(throwable)__					} else {_						releaseFuture.complete(null)__					}_				})__		} else {_			_			releaseFuture.complete(null)__		}_	};releases,the,assigned,resource,and,completes,the,release,future,once,the,assigned,resource,has,been,successfully,released,param,cause,for,the,resource,release,null,if,none;private,void,release,assigned,resource,nullable,throwable,cause,final,logical,slot,slot,assigned,resource,if,slot,null,slot,release,slot,cause,when,complete,object,ignored,throwable,throwable,if,throwable,null,release,future,complete,exceptionally,throwable,else,release,future,complete,null,else,release,future,complete,null
Execution -> private void releaseAssignedResource(@Nullable Throwable cause);1519481114;Releases the assigned resource and completes the release future_once the assigned resource has been successfully released__@param cause for the resource release, null if none;private void releaseAssignedResource(@Nullable Throwable cause) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			slot.releaseSlot(cause).whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (throwable != null) {_						releaseFuture.completeExceptionally(throwable)__					} else {_						releaseFuture.complete(null)__					}_				})__		} else {_			_			releaseFuture.complete(null)__		}_	};releases,the,assigned,resource,and,completes,the,release,future,once,the,assigned,resource,has,been,successfully,released,param,cause,for,the,resource,release,null,if,none;private,void,release,assigned,resource,nullable,throwable,cause,final,logical,slot,slot,assigned,resource,if,slot,null,slot,release,slot,cause,when,complete,object,ignored,throwable,throwable,if,throwable,null,release,future,complete,exceptionally,throwable,else,release,future,complete,null,else,release,future,complete,null
Execution -> private void releaseAssignedResource(@Nullable Throwable cause);1519568061;Releases the assigned resource and completes the release future_once the assigned resource has been successfully released__@param cause for the resource release, null if none;private void releaseAssignedResource(@Nullable Throwable cause) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			slot.releaseSlot(cause).whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (throwable != null) {_						releaseFuture.completeExceptionally(throwable)__					} else {_						releaseFuture.complete(null)__					}_				})__		} else {_			_			releaseFuture.complete(null)__		}_	};releases,the,assigned,resource,and,completes,the,release,future,once,the,assigned,resource,has,been,successfully,released,param,cause,for,the,resource,release,null,if,none;private,void,release,assigned,resource,nullable,throwable,cause,final,logical,slot,slot,assigned,resource,if,slot,null,slot,release,slot,cause,when,complete,object,ignored,throwable,throwable,if,throwable,null,release,future,complete,exceptionally,throwable,else,release,future,complete,null,else,release,future,complete,null
Execution -> private void releaseAssignedResource(@Nullable Throwable cause);1519655521;Releases the assigned resource and completes the release future_once the assigned resource has been successfully released__@param cause for the resource release, null if none;private void releaseAssignedResource(@Nullable Throwable cause) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			slot.releaseSlot(cause).whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (throwable != null) {_						releaseFuture.completeExceptionally(throwable)__					} else {_						releaseFuture.complete(null)__					}_				})__		} else {_			_			releaseFuture.complete(null)__		}_	};releases,the,assigned,resource,and,completes,the,release,future,once,the,assigned,resource,has,been,successfully,released,param,cause,for,the,resource,release,null,if,none;private,void,release,assigned,resource,nullable,throwable,cause,final,logical,slot,slot,assigned,resource,if,slot,null,slot,release,slot,cause,when,complete,object,ignored,throwable,throwable,if,throwable,null,release,future,complete,exceptionally,throwable,else,release,future,complete,null,else,release,future,complete,null
Execution -> private void releaseAssignedResource(@Nullable Throwable cause);1522049586;Releases the assigned resource and completes the release future_once the assigned resource has been successfully released__@param cause for the resource release, null if none;private void releaseAssignedResource(@Nullable Throwable cause) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			slot.releaseSlot(cause).whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (throwable != null) {_						releaseFuture.completeExceptionally(throwable)__					} else {_						releaseFuture.complete(null)__					}_				})__		} else {_			_			releaseFuture.complete(null)__		}_	};releases,the,assigned,resource,and,completes,the,release,future,once,the,assigned,resource,has,been,successfully,released,param,cause,for,the,resource,release,null,if,none;private,void,release,assigned,resource,nullable,throwable,cause,final,logical,slot,slot,assigned,resource,if,slot,null,slot,release,slot,cause,when,complete,object,ignored,throwable,throwable,if,throwable,null,release,future,complete,exceptionally,throwable,else,release,future,complete,null,else,release,future,complete,null
Execution -> private void releaseAssignedResource(@Nullable Throwable cause);1522249273;Releases the assigned resource and completes the release future_once the assigned resource has been successfully released__@param cause for the resource release, null if none;private void releaseAssignedResource(@Nullable Throwable cause) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			slot.releaseSlot(cause).whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (throwable != null) {_						releaseFuture.completeExceptionally(throwable)__					} else {_						releaseFuture.complete(null)__					}_				})__		} else {_			_			releaseFuture.complete(null)__		}_	};releases,the,assigned,resource,and,completes,the,release,future,once,the,assigned,resource,has,been,successfully,released,param,cause,for,the,resource,release,null,if,none;private,void,release,assigned,resource,nullable,throwable,cause,final,logical,slot,slot,assigned,resource,if,slot,null,slot,release,slot,cause,when,complete,object,ignored,throwable,throwable,if,throwable,null,release,future,complete,exceptionally,throwable,else,release,future,complete,null,else,release,future,complete,null
Execution -> private void releaseAssignedResource(@Nullable Throwable cause);1530712207;Releases the assigned resource and completes the release future_once the assigned resource has been successfully released__@param cause for the resource release, null if none;private void releaseAssignedResource(@Nullable Throwable cause) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			slot.releaseSlot(cause).whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (throwable != null) {_						releaseFuture.completeExceptionally(throwable)__					} else {_						releaseFuture.complete(null)__					}_				})__		} else {_			_			releaseFuture.complete(null)__		}_	};releases,the,assigned,resource,and,completes,the,release,future,once,the,assigned,resource,has,been,successfully,released,param,cause,for,the,resource,release,null,if,none;private,void,release,assigned,resource,nullable,throwable,cause,final,logical,slot,slot,assigned,resource,if,slot,null,slot,release,slot,cause,when,complete,object,ignored,throwable,throwable,if,throwable,null,release,future,complete,exceptionally,throwable,else,release,future,complete,null,else,release,future,complete,null
Execution -> private void releaseAssignedResource(@Nullable Throwable cause);1532383539;Releases the assigned resource and completes the release future_once the assigned resource has been successfully released__@param cause for the resource release, null if none;private void releaseAssignedResource(@Nullable Throwable cause) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			slot.releaseSlot(cause).whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (throwable != null) {_						releaseFuture.completeExceptionally(throwable)__					} else {_						releaseFuture.complete(null)__					}_				})__		} else {_			_			releaseFuture.complete(null)__		}_	};releases,the,assigned,resource,and,completes,the,release,future,once,the,assigned,resource,has,been,successfully,released,param,cause,for,the,resource,release,null,if,none;private,void,release,assigned,resource,nullable,throwable,cause,final,logical,slot,slot,assigned,resource,if,slot,null,slot,release,slot,cause,when,complete,object,ignored,throwable,throwable,if,throwable,null,release,future,complete,exceptionally,throwable,else,release,future,complete,null,else,release,future,complete,null
Execution -> private void releaseAssignedResource(@Nullable Throwable cause);1532383539;Releases the assigned resource and completes the release future_once the assigned resource has been successfully released.__@param cause for the resource release, null if none;private void releaseAssignedResource(@Nullable Throwable cause) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			slot.releaseSlot(cause).whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (throwable != null) {_						releaseFuture.completeExceptionally(throwable)__					} else {_						releaseFuture.complete(null)__					}_				})__		} else {_			_			releaseFuture.complete(null)__		}_	};releases,the,assigned,resource,and,completes,the,release,future,once,the,assigned,resource,has,been,successfully,released,param,cause,for,the,resource,release,null,if,none;private,void,release,assigned,resource,nullable,throwable,cause,final,logical,slot,slot,assigned,resource,if,slot,null,slot,release,slot,cause,when,complete,object,ignored,throwable,throwable,if,throwable,null,release,future,complete,exceptionally,throwable,else,release,future,complete,null,else,release,future,complete,null
Execution -> private void releaseAssignedResource(@Nullable Throwable cause);1532383539;Releases the assigned resource and completes the release future_once the assigned resource has been successfully released.__@param cause for the resource release, null if none;private void releaseAssignedResource(@Nullable Throwable cause) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			slot.releaseSlot(cause).whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (throwable != null) {_						releaseFuture.completeExceptionally(throwable)__					} else {_						releaseFuture.complete(null)__					}_				})__		} else {_			_			releaseFuture.complete(null)__		}_	};releases,the,assigned,resource,and,completes,the,release,future,once,the,assigned,resource,has,been,successfully,released,param,cause,for,the,resource,release,null,if,none;private,void,release,assigned,resource,nullable,throwable,cause,final,logical,slot,slot,assigned,resource,if,slot,null,slot,release,slot,cause,when,complete,object,ignored,throwable,throwable,if,throwable,null,release,future,complete,exceptionally,throwable,else,release,future,complete,null,else,release,future,complete,null
Execution -> private void releaseAssignedResource(@Nullable Throwable cause);1540920690;Releases the assigned resource and completes the release future_once the assigned resource has been successfully released.__@param cause for the resource release, null if none;private void releaseAssignedResource(@Nullable Throwable cause) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			slot.releaseSlot(cause).whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (throwable != null) {_						releaseFuture.completeExceptionally(throwable)__					} else {_						releaseFuture.complete(null)__					}_				})__		} else {_			_			releaseFuture.complete(null)__		}_	};releases,the,assigned,resource,and,completes,the,release,future,once,the,assigned,resource,has,been,successfully,released,param,cause,for,the,resource,release,null,if,none;private,void,release,assigned,resource,nullable,throwable,cause,final,logical,slot,slot,assigned,resource,if,slot,null,slot,release,slot,cause,when,complete,object,ignored,throwable,throwable,if,throwable,null,release,future,complete,exceptionally,throwable,else,release,future,complete,null,else,release,future,complete,null
Execution -> private void releaseAssignedResource(@Nullable Throwable cause);1542356428;Releases the assigned resource and completes the release future_once the assigned resource has been successfully released.__@param cause for the resource release, null if none;private void releaseAssignedResource(@Nullable Throwable cause) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			slot.releaseSlot(cause).whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (throwable != null) {_						releaseFuture.completeExceptionally(throwable)__					} else {_						releaseFuture.complete(null)__					}_				})__		} else {_			_			releaseFuture.complete(null)__		}_	};releases,the,assigned,resource,and,completes,the,release,future,once,the,assigned,resource,has,been,successfully,released,param,cause,for,the,resource,release,null,if,none;private,void,release,assigned,resource,nullable,throwable,cause,final,logical,slot,slot,assigned,resource,if,slot,null,slot,release,slot,cause,when,complete,object,ignored,throwable,throwable,if,throwable,null,release,future,complete,exceptionally,throwable,else,release,future,complete,null,else,release,future,complete,null
Execution -> private void releaseAssignedResource(@Nullable Throwable cause);1546870832;Releases the assigned resource and completes the release future_once the assigned resource has been successfully released.__@param cause for the resource release, null if none;private void releaseAssignedResource(@Nullable Throwable cause) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			slot.releaseSlot(cause).whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (throwable != null) {_						releaseFuture.completeExceptionally(throwable)__					} else {_						releaseFuture.complete(null)__					}_				})__		} else {_			_			releaseFuture.complete(null)__		}_	};releases,the,assigned,resource,and,completes,the,release,future,once,the,assigned,resource,has,been,successfully,released,param,cause,for,the,resource,release,null,if,none;private,void,release,assigned,resource,nullable,throwable,cause,final,logical,slot,slot,assigned,resource,if,slot,null,slot,release,slot,cause,when,complete,object,ignored,throwable,throwable,if,throwable,null,release,future,complete,exceptionally,throwable,else,release,future,complete,null,else,release,future,complete,null
Execution -> private void releaseAssignedResource(@Nullable Throwable cause);1547644408;Releases the assigned resource and completes the release future_once the assigned resource has been successfully released.__@param cause for the resource release, null if none;private void releaseAssignedResource(@Nullable Throwable cause) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			slot.releaseSlot(cause).whenComplete(_				(Object ignored, Throwable throwable) -> {_					if (throwable != null) {_						releaseFuture.completeExceptionally(throwable)__					} else {_						releaseFuture.complete(null)__					}_				})__		} else {_			_			releaseFuture.complete(null)__		}_	};releases,the,assigned,resource,and,completes,the,release,future,once,the,assigned,resource,has,been,successfully,released,param,cause,for,the,resource,release,null,if,none;private,void,release,assigned,resource,nullable,throwable,cause,final,logical,slot,slot,assigned,resource,if,slot,null,slot,release,slot,cause,when,complete,object,ignored,throwable,throwable,if,throwable,null,release,future,complete,exceptionally,throwable,else,release,future,complete,null,else,release,future,complete,null
Execution -> private void releaseAssignedResource(@Nullable Throwable cause);1549365080;Releases the assigned resource and completes the release future_once the assigned resource has been successfully released.__@param cause for the resource release, null if none;private void releaseAssignedResource(@Nullable Throwable cause) {__		assertRunningInJobMasterMainThread()___		final LogicalSlot slot = assignedResource___		if (slot != null) {_			ComponentMainThreadExecutor jobMasterMainThreadExecutor =_				getVertex().getExecutionGraph().getJobMasterMainThreadExecutor()___			FutureUtils.whenCompleteAsyncIfNotDone(_				slot.releaseSlot(cause),_				jobMasterMainThreadExecutor,_				(Object ignored, Throwable throwable) -> {_					if (throwable != null) {_						releaseFuture.completeExceptionally(throwable)__					} else {_						releaseFuture.complete(null)__					}_				})__		} else {_			_			releaseFuture.complete(null)__		}_	};releases,the,assigned,resource,and,completes,the,release,future,once,the,assigned,resource,has,been,successfully,released,param,cause,for,the,resource,release,null,if,none;private,void,release,assigned,resource,nullable,throwable,cause,assert,running,in,job,master,main,thread,final,logical,slot,slot,assigned,resource,if,slot,null,component,main,thread,executor,job,master,main,thread,executor,get,vertex,get,execution,graph,get,job,master,main,thread,executor,future,utils,when,complete,async,if,not,done,slot,release,slot,cause,job,master,main,thread,executor,object,ignored,throwable,throwable,if,throwable,null,release,future,complete,exceptionally,throwable,else,release,future,complete,null,else,release,future,complete,null
Execution -> private void releaseAssignedResource(@Nullable Throwable cause);1550220073;Releases the assigned resource and completes the release future_once the assigned resource has been successfully released.__@param cause for the resource release, null if none;private void releaseAssignedResource(@Nullable Throwable cause) {__		assertRunningInJobMasterMainThread()___		final LogicalSlot slot = assignedResource___		if (slot != null) {_			ComponentMainThreadExecutor jobMasterMainThreadExecutor =_				getVertex().getExecutionGraph().getJobMasterMainThreadExecutor()___			FutureUtils.whenCompleteAsyncIfNotDone(_				slot.releaseSlot(cause),_				jobMasterMainThreadExecutor,_				(Object ignored, Throwable throwable) -> {_					if (throwable != null) {_						releaseFuture.completeExceptionally(throwable)__					} else {_						releaseFuture.complete(null)__					}_				})__		} else {_			_			releaseFuture.complete(null)__		}_	};releases,the,assigned,resource,and,completes,the,release,future,once,the,assigned,resource,has,been,successfully,released,param,cause,for,the,resource,release,null,if,none;private,void,release,assigned,resource,nullable,throwable,cause,assert,running,in,job,master,main,thread,final,logical,slot,slot,assigned,resource,if,slot,null,component,main,thread,executor,job,master,main,thread,executor,get,vertex,get,execution,graph,get,job,master,main,thread,executor,future,utils,when,complete,async,if,not,done,slot,release,slot,cause,job,master,main,thread,executor,object,ignored,throwable,throwable,if,throwable,null,release,future,complete,exceptionally,throwable,else,release,future,complete,null,else,release,future,complete,null
Execution -> private void releaseAssignedResource(@Nullable Throwable cause);1550654143;Releases the assigned resource and completes the release future_once the assigned resource has been successfully released.__@param cause for the resource release, null if none;private void releaseAssignedResource(@Nullable Throwable cause) {__		assertRunningInJobMasterMainThread()___		final LogicalSlot slot = assignedResource___		if (slot != null) {_			ComponentMainThreadExecutor jobMasterMainThreadExecutor =_				getVertex().getExecutionGraph().getJobMasterMainThreadExecutor()___			slot.releaseSlot(cause)_				.whenComplete((Object ignored, Throwable throwable) -> {_					jobMasterMainThreadExecutor.assertRunningInMainThread()__					if (throwable != null) {_						releaseFuture.completeExceptionally(throwable)__					} else {_						releaseFuture.complete(null)__					}_				})__		} else {_			_			releaseFuture.complete(null)__		}_	};releases,the,assigned,resource,and,completes,the,release,future,once,the,assigned,resource,has,been,successfully,released,param,cause,for,the,resource,release,null,if,none;private,void,release,assigned,resource,nullable,throwable,cause,assert,running,in,job,master,main,thread,final,logical,slot,slot,assigned,resource,if,slot,null,component,main,thread,executor,job,master,main,thread,executor,get,vertex,get,execution,graph,get,job,master,main,thread,executor,slot,release,slot,cause,when,complete,object,ignored,throwable,throwable,job,master,main,thread,executor,assert,running,in,main,thread,if,throwable,null,release,future,complete,exceptionally,throwable,else,release,future,complete,null,else,release,future,complete,null
Execution -> private void releaseAssignedResource(@Nullable Throwable cause);1550683188;Releases the assigned resource and completes the release future_once the assigned resource has been successfully released.__@param cause for the resource release, null if none;private void releaseAssignedResource(@Nullable Throwable cause) {__		assertRunningInJobMasterMainThread()___		final LogicalSlot slot = assignedResource___		if (slot != null) {_			ComponentMainThreadExecutor jobMasterMainThreadExecutor =_				getVertex().getExecutionGraph().getJobMasterMainThreadExecutor()___			slot.releaseSlot(cause)_				.whenComplete((Object ignored, Throwable throwable) -> {_					jobMasterMainThreadExecutor.assertRunningInMainThread()__					if (throwable != null) {_						releaseFuture.completeExceptionally(throwable)__					} else {_						releaseFuture.complete(null)__					}_				})__		} else {_			_			releaseFuture.complete(null)__		}_	};releases,the,assigned,resource,and,completes,the,release,future,once,the,assigned,resource,has,been,successfully,released,param,cause,for,the,resource,release,null,if,none;private,void,release,assigned,resource,nullable,throwable,cause,assert,running,in,job,master,main,thread,final,logical,slot,slot,assigned,resource,if,slot,null,component,main,thread,executor,job,master,main,thread,executor,get,vertex,get,execution,graph,get,job,master,main,thread,executor,slot,release,slot,cause,when,complete,object,ignored,throwable,throwable,job,master,main,thread,executor,assert,running,in,main,thread,if,throwable,null,release,future,complete,exceptionally,throwable,else,release,future,complete,null,else,release,future,complete,null
Execution -> private void releaseAssignedResource(@Nullable Throwable cause);1550855836;Releases the assigned resource and completes the release future_once the assigned resource has been successfully released.__@param cause for the resource release, null if none;private void releaseAssignedResource(@Nullable Throwable cause) {__		assertRunningInJobMasterMainThread()___		final LogicalSlot slot = assignedResource___		if (slot != null) {_			ComponentMainThreadExecutor jobMasterMainThreadExecutor =_				getVertex().getExecutionGraph().getJobMasterMainThreadExecutor()___			slot.releaseSlot(cause)_				.whenComplete((Object ignored, Throwable throwable) -> {_					jobMasterMainThreadExecutor.assertRunningInMainThread()__					if (throwable != null) {_						releaseFuture.completeExceptionally(throwable)__					} else {_						releaseFuture.complete(null)__					}_				})__		} else {_			_			releaseFuture.complete(null)__		}_	};releases,the,assigned,resource,and,completes,the,release,future,once,the,assigned,resource,has,been,successfully,released,param,cause,for,the,resource,release,null,if,none;private,void,release,assigned,resource,nullable,throwable,cause,assert,running,in,job,master,main,thread,final,logical,slot,slot,assigned,resource,if,slot,null,component,main,thread,executor,job,master,main,thread,executor,get,vertex,get,execution,graph,get,job,master,main,thread,executor,slot,release,slot,cause,when,complete,object,ignored,throwable,throwable,job,master,main,thread,executor,assert,running,in,main,thread,if,throwable,null,release,future,complete,exceptionally,throwable,else,release,future,complete,null,else,release,future,complete,null
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1477923124;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1477989375;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1478800024;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1481290933;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1482522865;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1486114103;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1486114103;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1486740510;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1487548884;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1487871589;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1488878443;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1490800309;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1490819573;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1493831843;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1493831843;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1501622876;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1501665499;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1501760738;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1502801814;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1509125300;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1509631297;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1509638684;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1509638685;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1513201052;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1513201070;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1513261599;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1515177485;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1516626377;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1516626397;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1518680774;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1518712478;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1519316529;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1519481114;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1519568061;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1519655521;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1522049586;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1522249273;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1530712207;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1532383539;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1532383539;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1532383539;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1540920690;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1542356428;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1546870832;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1547644408;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1549365080;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1550220073;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1550654143;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1550683188;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators);1550855836;Update accumulators (discarded when the Execution has already been terminated)._@param userAccumulators the user accumulators;public void setAccumulators(Map<String, Accumulator<?, ?>> userAccumulators) {_		synchronized (accumulatorLock) {_			if (!state.isTerminal()) {_				this.userAccumulators = userAccumulators__			}_		}_	};update,accumulators,discarded,when,the,execution,has,already,been,terminated,param,user,accumulators,the,user,accumulators;public,void,set,accumulators,map,string,accumulator,user,accumulators,synchronized,accumulator,lock,if,state,is,terminal,this,user,accumulators,user,accumulators
Execution -> public void setInitialState(TaskStateSnapshot checkpointStateHandles);1502801814;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param checkpointStateHandles all checkpointed operator state;public void setInitialState(TaskStateSnapshot checkpointStateHandles) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskState = checkpointStateHandles__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,checkpoint,state,handles,all,checkpointed,operator,state;public,void,set,initial,state,task,state,snapshot,checkpoint,state,handles,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,state,checkpoint,state,handles
Execution -> public void setInitialState(TaskStateSnapshot checkpointStateHandles);1509125300;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param checkpointStateHandles all checkpointed operator state;public void setInitialState(TaskStateSnapshot checkpointStateHandles) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskState = checkpointStateHandles__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,checkpoint,state,handles,all,checkpointed,operator,state;public,void,set,initial,state,task,state,snapshot,checkpoint,state,handles,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,state,checkpoint,state,handles
Execution -> public void setInitialState(TaskStateSnapshot checkpointStateHandles);1509631297;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param checkpointStateHandles all checkpointed operator state;public void setInitialState(TaskStateSnapshot checkpointStateHandles) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskState = checkpointStateHandles__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,checkpoint,state,handles,all,checkpointed,operator,state;public,void,set,initial,state,task,state,snapshot,checkpoint,state,handles,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,state,checkpoint,state,handles
Execution -> public void setInitialState(TaskStateSnapshot checkpointStateHandles);1509638684;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param checkpointStateHandles all checkpointed operator state;public void setInitialState(TaskStateSnapshot checkpointStateHandles) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskState = checkpointStateHandles__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,checkpoint,state,handles,all,checkpointed,operator,state;public,void,set,initial,state,task,state,snapshot,checkpoint,state,handles,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,state,checkpoint,state,handles
Execution -> public void setInitialState(TaskStateSnapshot checkpointStateHandles);1509638685;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param checkpointStateHandles all checkpointed operator state;public void setInitialState(TaskStateSnapshot checkpointStateHandles) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskState = checkpointStateHandles__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,checkpoint,state,handles,all,checkpointed,operator,state;public,void,set,initial,state,task,state,snapshot,checkpoint,state,handles,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,state,checkpoint,state,handles
Execution -> public void setInitialState(TaskStateSnapshot checkpointStateHandles);1513201052;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param checkpointStateHandles all checkpointed operator state;public void setInitialState(TaskStateSnapshot checkpointStateHandles) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskState = checkpointStateHandles__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,checkpoint,state,handles,all,checkpointed,operator,state;public,void,set,initial,state,task,state,snapshot,checkpoint,state,handles,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,state,checkpoint,state,handles
Execution -> public void setInitialState(TaskStateSnapshot checkpointStateHandles);1513201070;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param checkpointStateHandles all checkpointed operator state;public void setInitialState(TaskStateSnapshot checkpointStateHandles) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskState = checkpointStateHandles__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,checkpoint,state,handles,all,checkpointed,operator,state;public,void,set,initial,state,task,state,snapshot,checkpoint,state,handles,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,state,checkpoint,state,handles
Execution -> public void setInitialState(TaskStateSnapshot checkpointStateHandles);1513261599;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param checkpointStateHandles all checkpointed operator state;public void setInitialState(TaskStateSnapshot checkpointStateHandles) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskState = checkpointStateHandles__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,checkpoint,state,handles,all,checkpointed,operator,state;public,void,set,initial,state,task,state,snapshot,checkpoint,state,handles,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,state,checkpoint,state,handles
Execution -> public void setInitialState(TaskStateSnapshot checkpointStateHandles);1515177485;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param checkpointStateHandles all checkpointed operator state;public void setInitialState(TaskStateSnapshot checkpointStateHandles) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskState = checkpointStateHandles__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,checkpoint,state,handles,all,checkpointed,operator,state;public,void,set,initial,state,task,state,snapshot,checkpoint,state,handles,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,state,checkpoint,state,handles
Execution -> public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStackTraceDepth, 			Time timeout);1515177485;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStackTraceDepth,_			Time timeout) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStackTraceDepth,_				timeout)__		} else {_			return FutureUtils.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,stack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,completable,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,stack,trace,depth,time,timeout,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,stack,trace,depth,timeout,else,return,future,utils,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStackTraceDepth, 			Time timeout);1516626377;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStackTraceDepth,_			Time timeout) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStackTraceDepth,_				timeout)__		} else {_			return FutureUtils.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,stack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,completable,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,stack,trace,depth,time,timeout,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,stack,trace,depth,timeout,else,return,future,utils,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStackTraceDepth, 			Time timeout);1516626397;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStackTraceDepth,_			Time timeout) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStackTraceDepth,_				timeout)__		} else {_			return FutureUtils.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,stack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,completable,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,stack,trace,depth,time,timeout,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,stack,trace,depth,timeout,else,return,future,utils,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStackTraceDepth, 			Time timeout);1518680774;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStackTraceDepth,_			Time timeout) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStackTraceDepth,_				timeout)__		} else {_			return FutureUtils.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,stack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,completable,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,stack,trace,depth,time,timeout,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,stack,trace,depth,timeout,else,return,future,utils,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStackTraceDepth, 			Time timeout);1518712478;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStackTraceDepth,_			Time timeout) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStackTraceDepth,_				timeout)__		} else {_			return FutureUtils.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,stack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,completable,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,stack,trace,depth,time,timeout,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,stack,trace,depth,timeout,else,return,future,utils,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStackTraceDepth, 			Time timeout);1519316529;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStackTraceDepth,_			Time timeout) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStackTraceDepth,_				timeout)__		} else {_			return FutureUtils.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,stack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,completable,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,stack,trace,depth,time,timeout,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,stack,trace,depth,timeout,else,return,future,utils,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStackTraceDepth, 			Time timeout);1519481114;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStackTraceDepth,_			Time timeout) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStackTraceDepth,_				timeout)__		} else {_			return FutureUtils.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,stack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,completable,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,stack,trace,depth,time,timeout,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,stack,trace,depth,timeout,else,return,future,utils,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStackTraceDepth, 			Time timeout);1519568061;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStackTraceDepth,_			Time timeout) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStackTraceDepth,_				timeout)__		} else {_			return FutureUtils.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,stack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,completable,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,stack,trace,depth,time,timeout,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,stack,trace,depth,timeout,else,return,future,utils,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStackTraceDepth, 			Time timeout);1519655521;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStackTraceDepth,_			Time timeout) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStackTraceDepth,_				timeout)__		} else {_			return FutureUtils.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,stack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,completable,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,stack,trace,depth,time,timeout,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,stack,trace,depth,timeout,else,return,future,utils,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStackTraceDepth, 			Time timeout);1522049586;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStackTraceDepth,_			Time timeout) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStackTraceDepth,_				timeout)__		} else {_			return FutureUtils.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,stack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,completable,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,stack,trace,depth,time,timeout,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,stack,trace,depth,timeout,else,return,future,utils,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStackTraceDepth, 			Time timeout);1522249273;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStackTraceDepth,_			Time timeout) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStackTraceDepth,_				timeout)__		} else {_			return FutureUtils.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,stack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,completable,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,stack,trace,depth,time,timeout,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,stack,trace,depth,timeout,else,return,future,utils,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStackTraceDepth, 			Time timeout);1530712207;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStackTraceDepth,_			Time timeout) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStackTraceDepth,_				timeout)__		} else {_			return FutureUtils.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,stack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,completable,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,stack,trace,depth,time,timeout,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,stack,trace,depth,timeout,else,return,future,utils,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStackTraceDepth, 			Time timeout);1532383539;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStackTraceDepth,_			Time timeout) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStackTraceDepth,_				timeout)__		} else {_			return FutureUtils.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,stack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,completable,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,stack,trace,depth,time,timeout,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,stack,trace,depth,timeout,else,return,future,utils,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStackTraceDepth, 			Time timeout);1532383539;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStackTraceDepth,_			Time timeout) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStackTraceDepth,_				timeout)__		} else {_			return FutureUtils.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,stack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,completable,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,stack,trace,depth,time,timeout,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,stack,trace,depth,timeout,else,return,future,utils,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStackTraceDepth, 			Time timeout);1532383539;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStackTraceDepth,_			Time timeout) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStackTraceDepth,_				timeout)__		} else {_			return FutureUtils.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,stack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,completable,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,stack,trace,depth,time,timeout,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,stack,trace,depth,timeout,else,return,future,utils,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStackTraceDepth, 			Time timeout);1540920690;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStackTraceDepth,_			Time timeout) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStackTraceDepth,_				timeout)__		} else {_			return FutureUtils.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,stack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,completable,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,stack,trace,depth,time,timeout,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,stack,trace,depth,timeout,else,return,future,utils,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStackTraceDepth, 			Time timeout);1542356428;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStackTraceDepth,_			Time timeout) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStackTraceDepth,_				timeout)__		} else {_			return FutureUtils.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,stack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,completable,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,stack,trace,depth,time,timeout,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,stack,trace,depth,timeout,else,return,future,utils,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStackTraceDepth, 			Time timeout);1546870832;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStackTraceDepth,_			Time timeout) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStackTraceDepth,_				timeout)__		} else {_			return FutureUtils.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,stack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,completable,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,stack,trace,depth,time,timeout,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,stack,trace,depth,timeout,else,return,future,utils,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStackTraceDepth, 			Time timeout);1547644408;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStackTraceDepth,_			Time timeout) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStackTraceDepth,_				timeout)__		} else {_			return FutureUtils.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,stack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,completable,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,stack,trace,depth,time,timeout,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,stack,trace,depth,timeout,else,return,future,utils,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStackTraceDepth, 			Time timeout);1549365080;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStackTraceDepth,_			Time timeout) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStackTraceDepth,_				timeout)__		} else {_			return FutureUtils.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,stack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,completable,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,stack,trace,depth,time,timeout,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,stack,trace,depth,timeout,else,return,future,utils,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStackTraceDepth, 			Time timeout);1550220073;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStackTraceDepth,_			Time timeout) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStackTraceDepth,_				timeout)__		} else {_			return FutureUtils.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,stack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,completable,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,stack,trace,depth,time,timeout,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,stack,trace,depth,timeout,else,return,future,utils,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStackTraceDepth, 			Time timeout);1550654143;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStackTraceDepth,_			Time timeout) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStackTraceDepth,_				timeout)__		} else {_			return FutureUtils.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,stack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,completable,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,stack,trace,depth,time,timeout,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,stack,trace,depth,timeout,else,return,future,utils,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStackTraceDepth, 			Time timeout);1550683188;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStackTraceDepth,_			Time timeout) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStackTraceDepth,_				timeout)__		} else {_			return FutureUtils.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,stack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,completable,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,stack,trace,depth,time,timeout,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,stack,trace,depth,timeout,else,return,future,utils,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStackTraceDepth, 			Time timeout);1550855836;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStackTraceDepth,_			Time timeout) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStackTraceDepth,_				timeout)__		} else {_			return FutureUtils.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,stack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,completable,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,stack,trace,depth,time,timeout,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,stack,trace,depth,timeout,else,return,future,utils,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1477989375;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			Future<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, timeout)___			updatePartitionsResultFuture.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_						" failed due to:", failure))__					return null__				}_			}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,timeout,update,partitions,result,future,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,return,null,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1478800024;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			Future<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, timeout)___			updatePartitionsResultFuture.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_						" failed due to:", failure))__					return null__				}_			}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,timeout,update,partitions,result,future,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,return,null,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1481290933;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			Future<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, timeout)___			updatePartitionsResultFuture.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_						" failed due to:", failure))__					return null__				}_			}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,timeout,update,partitions,result,future,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,return,null,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1482522865;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			Future<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, timeout)___			updatePartitionsResultFuture.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_						" failed due to:", failure))__					return null__				}_			}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,timeout,update,partitions,result,future,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,return,null,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1486114103;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			Future<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, timeout)___			updatePartitionsResultFuture.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_						" failed due to:", failure))__					return null__				}_			}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,timeout,update,partitions,result,future,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,return,null,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1486114103;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			Future<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, timeout)___			updatePartitionsResultFuture.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_						" failed due to:", failure))__					return null__				}_			}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,timeout,update,partitions,result,future,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,return,null,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1486740510;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			Future<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, timeout)___			updatePartitionsResultFuture.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_						" failed due to:", failure))__					return null__				}_			}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,timeout,update,partitions,result,future,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,return,null,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1487548884;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			Future<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, timeout)___			updatePartitionsResultFuture.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_						" failed due to:", failure))__					return null__				}_			}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,timeout,update,partitions,result,future,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,return,null,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1487871589;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			Future<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, timeout)___			updatePartitionsResultFuture.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_						" failed due to:", failure))__					return null__				}_			}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,timeout,update,partitions,result,future,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,return,null,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1488878443;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			Future<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, timeout)___			updatePartitionsResultFuture.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_						" failed due to:", failure))__					return null__				}_			}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,timeout,update,partitions,result,future,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,return,null,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1490800309;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			Future<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, timeout)___			updatePartitionsResultFuture.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_						" failed due to:", failure))__					return null__				}_			}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,timeout,update,partitions,result,future,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,return,null,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1490819573;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			Future<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, timeout)___			updatePartitionsResultFuture.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_						" failed due to:", failure))__					return null__				}_			}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,timeout,update,partitions,result,future,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,return,null,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1493831843;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			Future<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, timeout)___			updatePartitionsResultFuture.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_						" failed due to:", failure))__					return null__				}_			}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,timeout,update,partitions,result,future,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,return,null,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1493831843;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			Future<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, timeout)___			updatePartitionsResultFuture.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_						" failed due to:", failure))__					return null__				}_			}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,timeout,update,partitions,result,future,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,return,null,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1501622876;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			CompletableFuture<Acknowledge> updatePartitionsResultFuture = FutureUtils.toJava(_				taskManagerGateway.updatePartitions(attemptId, partitionInfos, timeout))___			updatePartitionsResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__					}_				}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,completable,future,acknowledge,update,partitions,result,future,future,utils,to,java,task,manager,gateway,update,partitions,attempt,id,partition,infos,timeout,update,partitions,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1501665499;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			CompletableFuture<Acknowledge> updatePartitionsResultFuture = FutureUtils.toJava(_				taskManagerGateway.updatePartitions(attemptId, partitionInfos, timeout))___			updatePartitionsResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__					}_				}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,completable,future,acknowledge,update,partitions,result,future,future,utils,to,java,task,manager,gateway,update,partitions,attempt,id,partition,infos,timeout,update,partitions,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1501760738;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			CompletableFuture<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, timeout)___			updatePartitionsResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__					}_				}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,completable,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,timeout,update,partitions,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1502801814;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			CompletableFuture<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, timeout)___			updatePartitionsResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__					}_				}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,completable,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,timeout,update,partitions,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1509125300;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			CompletableFuture<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, timeout)___			updatePartitionsResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__					}_				}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,completable,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,timeout,update,partitions,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1509631297;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			CompletableFuture<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, timeout)___			updatePartitionsResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__					}_				}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,completable,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,timeout,update,partitions,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1509638684;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final SimpleSlot slot = assignedResource.get()___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			CompletableFuture<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, timeout)___			updatePartitionsResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__					}_				}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,simple,slot,slot,assigned,resource,get,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,completable,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,timeout,update,partitions,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1509638685;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			CompletableFuture<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, timeout)___			updatePartitionsResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__					}_				}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,completable,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,timeout,update,partitions,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1513201052;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			CompletableFuture<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, timeout)___			updatePartitionsResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__					}_				}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,completable,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,timeout,update,partitions,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1513201070;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			CompletableFuture<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, timeout)___			updatePartitionsResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__					}_				}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,completable,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,timeout,update,partitions,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1513261599;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			CompletableFuture<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, timeout)___			updatePartitionsResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__					}_				}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,completable,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,timeout,update,partitions,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1515177485;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			CompletableFuture<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, timeout)___			updatePartitionsResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__					}_				}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,completable,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,timeout,update,partitions,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1516626377;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			CompletableFuture<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, timeout)___			updatePartitionsResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__					}_				}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,completable,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,timeout,update,partitions,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1516626397;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			CompletableFuture<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, timeout)___			updatePartitionsResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__					}_				}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,completable,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,timeout,update,partitions,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1518680774;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			CompletableFuture<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, rpcTimeout)___			updatePartitionsResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__					}_				}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,completable,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,rpc,timeout,update,partitions,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1518712478;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			CompletableFuture<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, rpcTimeout)___			updatePartitionsResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__					}_				}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,completable,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,rpc,timeout,update,partitions,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1519316529;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			CompletableFuture<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, rpcTimeout)___			updatePartitionsResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__					}_				}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,completable,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,rpc,timeout,update,partitions,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1519481114;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			CompletableFuture<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, rpcTimeout)___			updatePartitionsResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__					}_				}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,completable,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,rpc,timeout,update,partitions,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1519568061;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			CompletableFuture<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, rpcTimeout)___			updatePartitionsResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__					}_				}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,completable,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,rpc,timeout,update,partitions,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1519655521;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			CompletableFuture<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, rpcTimeout)___			updatePartitionsResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__					}_				}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,completable,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,rpc,timeout,update,partitions,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1522049586;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			CompletableFuture<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, rpcTimeout)___			updatePartitionsResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__					}_				}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,completable,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,rpc,timeout,update,partitions,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1522249273;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			CompletableFuture<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, rpcTimeout)___			updatePartitionsResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__					}_				}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,completable,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,rpc,timeout,update,partitions,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1530712207;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			CompletableFuture<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, rpcTimeout)___			updatePartitionsResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__					}_				}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,completable,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,rpc,timeout,update,partitions,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1532383539;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			CompletableFuture<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, rpcTimeout)___			updatePartitionsResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__					}_				}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,completable,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,rpc,timeout,update,partitions,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1532383539;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			CompletableFuture<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, rpcTimeout)___			updatePartitionsResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__					}_				}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,completable,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,rpc,timeout,update,partitions,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1532383539;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			CompletableFuture<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, rpcTimeout)___			updatePartitionsResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__					}_				}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,completable,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,rpc,timeout,update,partitions,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1540920690;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			CompletableFuture<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, rpcTimeout)___			updatePartitionsResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__					}_				}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,completable,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,rpc,timeout,update,partitions,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1542356428;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			CompletableFuture<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, rpcTimeout)___			updatePartitionsResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__					}_				}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,completable,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,rpc,timeout,update,partitions,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1546870832;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			CompletableFuture<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, rpcTimeout)___			updatePartitionsResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__					}_				}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,completable,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,rpc,timeout,update,partitions,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1547644408;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			CompletableFuture<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, rpcTimeout)___			updatePartitionsResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__					}_				}, executor)__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,completable,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,rpc,timeout,update,partitions,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1549365080;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			CompletableFuture<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, rpcTimeout)___			updatePartitionsResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						failSync(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__					}_				}, getVertex().getExecutionGraph().getJobMasterMainThreadExecutor())__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,completable,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,rpc,timeout,update,partitions,result,future,when,complete,async,ack,failure,if,failure,null,fail,sync,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,get,vertex,get,execution,graph,get,job,master,main,thread,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1550220073;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			CompletableFuture<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, rpcTimeout)___			updatePartitionsResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__					}_				}, getVertex().getExecutionGraph().getJobMasterMainThreadExecutor())__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,completable,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,rpc,timeout,update,partitions,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,get,vertex,get,execution,graph,get,job,master,main,thread,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1550654143;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			CompletableFuture<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, rpcTimeout)___			updatePartitionsResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__					}_				}, getVertex().getExecutionGraph().getJobMasterMainThreadExecutor())__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,completable,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,rpc,timeout,update,partitions,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,get,vertex,get,execution,graph,get,job,master,main,thread,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1550683188;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			CompletableFuture<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, rpcTimeout)___			updatePartitionsResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__					}_				}, getVertex().getExecutionGraph().getJobMasterMainThreadExecutor())__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,completable,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,rpc,timeout,update,partitions,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,get,vertex,get,execution,graph,get,job,master,main,thread,executor
Execution -> private void sendUpdatePartitionInfoRpcCall( 			final Iterable<PartitionInfo> partitionInfos);1550855836;Update the partition infos on the assigned resource.__@param partitionInfos for the remote task;private void sendUpdatePartitionInfoRpcCall(_			final Iterable<PartitionInfo> partitionInfos) {__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()__			final TaskManagerLocation taskManagerLocation = slot.getTaskManagerLocation()___			CompletableFuture<Acknowledge> updatePartitionsResultFuture = taskManagerGateway.updatePartitions(attemptId, partitionInfos, rpcTimeout)___			updatePartitionsResultFuture.whenCompleteAsync(_				(ack, failure) -> {_					_					if (failure != null) {_						fail(new IllegalStateException("Update task on TaskManager " + taskManagerLocation +_							" failed due to:", failure))__					}_				}, getVertex().getExecutionGraph().getJobMasterMainThreadExecutor())__		}_	};update,the,partition,infos,on,the,assigned,resource,param,partition,infos,for,the,remote,task;private,void,send,update,partition,info,rpc,call,final,iterable,partition,info,partition,infos,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,final,task,manager,location,task,manager,location,slot,get,task,manager,location,completable,future,acknowledge,update,partitions,result,future,task,manager,gateway,update,partitions,attempt,id,partition,infos,rpc,timeout,update,partitions,result,future,when,complete,async,ack,failure,if,failure,null,fail,new,illegal,state,exception,update,task,on,task,manager,task,manager,location,failed,due,to,failure,get,vertex,get,execution,graph,get,job,master,main,thread,executor
Execution -> public void stop();1455549373;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {_			final ActorGateway gateway = slot.getInstance().getActorGateway()___			Future<Object> stopResult = gateway.retry(_				new StopTask(attemptId),_				NUM_STOP_CALL_TRIES,_				timeout,_				executionContext)___			stopResult.onComplete(new OnComplete<Object>() {_				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be stopped.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.info("Stopping task was not successful. Description: {}",_									result.description())__						}_					}_				}_			}, executionContext)__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,instance,get,actor,gateway,future,object,stop,result,gateway,retry,new,stop,task,attempt,id,timeout,execution,context,stop,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,stopped,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,info,stopping,task,was,not,successful,description,result,description,execution,context
Execution -> public void stop();1456772768;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {_			final ActorGateway gateway = slot.getInstance().getActorGateway()___			Future<Object> stopResult = gateway.retry(_				new StopTask(attemptId),_				NUM_STOP_CALL_TRIES,_				timeout,_				executionContext)___			stopResult.onComplete(new OnComplete<Object>() {_				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be stopped.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.info("Stopping task was not successful. Description: {}",_									result.description())__						}_					}_				}_			}, executionContext)__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,instance,get,actor,gateway,future,object,stop,result,gateway,retry,new,stop,task,attempt,id,timeout,execution,context,stop,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,stopped,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,info,stopping,task,was,not,successful,description,result,description,execution,context
Execution -> public void stop();1461666173;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {_			final ActorGateway gateway = slot.getInstance().getActorGateway()___			Future<Object> stopResult = gateway.retry(_				new StopTask(attemptId),_				NUM_STOP_CALL_TRIES,_				timeout,_				executionContext)___			stopResult.onComplete(new OnComplete<Object>() {_				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be stopped.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.info("Stopping task was not successful. Description: {}",_									result.description())__						}_					}_				}_			}, executionContext)__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,instance,get,actor,gateway,future,object,stop,result,gateway,retry,new,stop,task,attempt,id,timeout,execution,context,stop,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,stopped,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,info,stopping,task,was,not,successful,description,result,description,execution,context
Execution -> public void stop();1464612094;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {_			final ActorGateway gateway = slot.getInstance().getActorGateway()___			Future<Object> stopResult = gateway.retry(_				new StopTask(attemptId),_				NUM_STOP_CALL_TRIES,_				timeout,_				executionContext)___			stopResult.onComplete(new OnComplete<Object>() {_				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be stopped.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.info("Stopping task was not successful. Description: {}",_									result.description())__						}_					}_				}_			}, executionContext)__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,instance,get,actor,gateway,future,object,stop,result,gateway,retry,new,stop,task,attempt,id,timeout,execution,context,stop,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,stopped,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,info,stopping,task,was,not,successful,description,result,description,execution,context
Execution -> public void stop();1465991918;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {_			final ActorGateway gateway = slot.getInstance().getActorGateway()___			Future<Object> stopResult = gateway.retry(_				new StopTask(attemptId),_				NUM_STOP_CALL_TRIES,_				timeout,_				executionContext)___			stopResult.onComplete(new OnComplete<Object>() {_				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be stopped.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.info("Stopping task was not successful. Description: {}",_									result.description())__						}_					}_				}_			}, executionContext)__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,instance,get,actor,gateway,future,object,stop,result,gateway,retry,new,stop,task,attempt,id,timeout,execution,context,stop,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,stopped,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,info,stopping,task,was,not,successful,description,result,description,execution,context
Execution -> public void stop();1468523508;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {_			final ActorGateway gateway = slot.getInstance().getActorGateway()___			Future<Object> stopResult = gateway.retry(_				new StopTask(attemptId),_				NUM_STOP_CALL_TRIES,_				timeout,_				executionContext)___			stopResult.onComplete(new OnComplete<Object>() {_				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be stopped.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.info("Stopping task was not successful. Description: {}",_									result.description())__						}_					}_				}_			}, executionContext)__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,instance,get,actor,gateway,future,object,stop,result,gateway,retry,new,stop,task,attempt,id,timeout,execution,context,stop,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,stopped,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,info,stopping,task,was,not,successful,description,result,description,execution,context
Execution -> public void stop();1470070623;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {_			final ActorGateway gateway = slot.getInstance().getActorGateway()___			Future<Object> stopResult = gateway.retry(_				new StopTask(attemptId),_				NUM_STOP_CALL_TRIES,_				timeout,_				executionContext)___			stopResult.onComplete(new OnComplete<Object>() {_				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be stopped.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.info("Stopping task was not successful. Description: {}",_									result.description())__						}_					}_				}_			}, executionContext)__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,instance,get,actor,gateway,future,object,stop,result,gateway,retry,new,stop,task,attempt,id,timeout,execution,context,stop,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,stopped,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,info,stopping,task,was,not,successful,description,result,description,execution,context
Execution -> public void stop();1470419821;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {_			final ActorGateway gateway = slot.getInstance().getActorGateway()___			Future<Object> stopResult = gateway.retry(_				new StopTask(attemptId),_				NUM_STOP_CALL_TRIES,_				timeout,_				executionContext)___			stopResult.onComplete(new OnComplete<Object>() {_				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be stopped.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.info("Stopping task was not successful. Description: {}",_									result.description())__						}_					}_				}_			}, executionContext)__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,instance,get,actor,gateway,future,object,stop,result,gateway,retry,new,stop,task,attempt,id,timeout,execution,context,stop,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,stopped,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,info,stopping,task,was,not,successful,description,result,description,execution,context
Execution -> public void stop();1472663401;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {_			final ActorGateway gateway = slot.getInstance().getActorGateway()___			Future<Object> stopResult = gateway.retry(_				new StopTask(attemptId),_				NUM_STOP_CALL_TRIES,_				timeout,_				executionContext)___			stopResult.onComplete(new OnComplete<Object>() {_				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be stopped.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.info("Stopping task was not successful. Description: {}",_									result.description())__						}_					}_				}_			}, executionContext)__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,instance,get,actor,gateway,future,object,stop,result,gateway,retry,new,stop,task,attempt,id,timeout,execution,context,stop,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,stopped,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,info,stopping,task,was,not,successful,description,result,description,execution,context
Execution -> public void stop();1472663402;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {_			final ActorGateway gateway = slot.getInstance().getActorGateway()___			Future<Object> stopResult = gateway.retry(_				new StopTask(attemptId),_				NUM_STOP_CALL_TRIES,_				timeout,_				executionContext)___			stopResult.onComplete(new OnComplete<Object>() {_				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be stopped.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.info("Stopping task was not successful. Description: {}",_									result.description())__						}_					}_				}_			}, executionContext)__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,instance,get,actor,gateway,future,object,stop,result,gateway,retry,new,stop,task,attempt,id,timeout,execution,context,stop,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,stopped,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,info,stopping,task,was,not,successful,description,result,description,execution,context
Execution -> public void stop();1472830377;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {_			final ActorGateway gateway = slot.getInstance().getActorGateway()___			Future<Object> stopResult = gateway.retry(_				new StopTask(attemptId),_				NUM_STOP_CALL_TRIES,_				timeout,_				executionContext)___			stopResult.onComplete(new OnComplete<Object>() {_				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be stopped.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.info("Stopping task was not successful. Description: {}",_									result.description())__						}_					}_				}_			}, executionContext)__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,instance,get,actor,gateway,future,object,stop,result,gateway,retry,new,stop,task,attempt,id,timeout,execution,context,stop,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,stopped,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,info,stopping,task,was,not,successful,description,result,description,execution,context
Execution -> public void stop();1472830377;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {_			final ActorGateway gateway = slot.getTaskManagerActorGateway()___			Future<Object> stopResult = gateway.retry(_				new StopTask(attemptId),_				NUM_STOP_CALL_TRIES,_				timeout,_				executionContext)___			stopResult.onComplete(new OnComplete<Object>() {_				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be stopped.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.info("Stopping task was not successful. Description: {}",_									result.description())__						}_					}_				}_			}, executionContext)__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,task,manager,actor,gateway,future,object,stop,result,gateway,retry,new,stop,task,attempt,id,timeout,execution,context,stop,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,stopped,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,info,stopping,task,was,not,successful,description,result,description,execution,context
Execution -> public void stop();1473023399;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {_			final ActorGateway gateway = slot.getTaskManagerActorGateway()___			Future<Object> stopResult = gateway.retry(_				new StopTask(attemptId),_				NUM_STOP_CALL_TRIES,_				timeout,_				executionContext)___			stopResult.onComplete(new OnComplete<Object>() {_				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be stopped.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.info("Stopping task was not successful. Description: {}",_									result.description())__						}_					}_				}_			}, executionContext)__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,task,manager,actor,gateway,future,object,stop,result,gateway,retry,new,stop,task,attempt,id,timeout,execution,context,stop,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,stopped,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,info,stopping,task,was,not,successful,description,result,description,execution,context
Execution -> public void stop();1474994376;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {_			final ActorGateway gateway = slot.getTaskManagerActorGateway()___			scala.concurrent.Future<Object> stopResult = gateway.retry(_				new StopTask(attemptId),_				NUM_STOP_CALL_TRIES,_				timeout,_				executionContext)___			stopResult.onComplete(new OnComplete<Object>() {_				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be stopped.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.info("Stopping task was not successful. Description: {}",_									result.description())__						}_					}_				}_			}, executionContext)__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,task,manager,actor,gateway,scala,concurrent,future,object,stop,result,gateway,retry,new,stop,task,attempt,id,timeout,execution,context,stop,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,stopped,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,info,stopping,task,was,not,successful,description,result,description,execution,context
Execution -> public void stop();1474994376;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {_			final ActorGateway gateway = slot.getTaskManagerActorGateway()___			scala.concurrent.Future<Object> stopResult = gateway.retry(_				new StopTask(attemptId),_				NUM_STOP_CALL_TRIES,_				timeout,_				executionContext)___			stopResult.onComplete(new OnComplete<Object>() {_				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be stopped.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.info("Stopping task was not successful. Description: {}",_									result.description())__						}_					}_				}_			}, executionContext)__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,task,manager,actor,gateway,scala,concurrent,future,object,stop,result,gateway,retry,new,stop,task,attempt,id,timeout,execution,context,stop,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,stopped,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,info,stopping,task,was,not,successful,description,result,description,execution,context
Execution -> public void stop();1475231926;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {_			final ActorGateway gateway = slot.getTaskManagerActorGateway()___			scala.concurrent.Future<Object> stopResult = gateway.retry(_				new StopTask(attemptId),_				NUM_STOP_CALL_TRIES,_				timeout,_				executionContext)___			stopResult.onComplete(new OnComplete<Object>() {_				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be stopped.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.info("Stopping task was not successful. Description: {}",_									result.description())__						}_					}_				}_			}, executionContext)__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,task,manager,actor,gateway,scala,concurrent,future,object,stop,result,gateway,retry,new,stop,task,attempt,id,timeout,execution,context,stop,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,stopped,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,info,stopping,task,was,not,successful,description,result,description,execution,context
Execution -> public void stop();1476446128;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {_			final ActorGateway gateway = slot.getTaskManagerActorGateway()___			scala.concurrent.Future<Object> stopResult = gateway.retry(_				new StopTask(attemptId),_				NUM_STOP_CALL_TRIES,_				timeout,_				executionContext)___			stopResult.onComplete(new OnComplete<Object>() {_				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be stopped.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.info("Stopping task was not successful. Description: {}",_									result.description())__						}_					}_				}_			}, executionContext)__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,task,manager,actor,gateway,scala,concurrent,future,object,stop,result,gateway,retry,new,stop,task,attempt,id,timeout,execution,context,stop,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,stopped,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,info,stopping,task,was,not,successful,description,result,description,execution,context
Execution -> public void stop();1476972861;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {_			final ActorGateway gateway = slot.getTaskManagerActorGateway()___			scala.concurrent.Future<Object> stopResult = gateway.retry(_				new StopTask(attemptId),_				NUM_STOP_CALL_TRIES,_				timeout,_				executionContext)___			stopResult.onComplete(new OnComplete<Object>() {_				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be stopped.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.info("Stopping task was not successful. Description: {}",_									result.description())__						}_					}_				}_			}, executionContext)__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,task,manager,actor,gateway,scala,concurrent,future,object,stop,result,gateway,retry,new,stop,task,attempt,id,timeout,execution,context,stop,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,stopped,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,info,stopping,task,was,not,successful,description,result,description,execution,context
Execution -> public void stop();1477923124;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = this.assignedResource___		if (slot != null) {_			final ActorGateway gateway = slot.getTaskManagerActorGateway()___			scala.concurrent.Future<Object> stopResult = gateway.retry(_				new StopTask(attemptId),_				NUM_STOP_CALL_TRIES,_				timeout,_				executionContext)___			stopResult.onComplete(new OnComplete<Object>() {_				@Override_				public void onComplete(Throwable failure, Object success) throws Throwable {_					if (failure != null) {_						fail(new Exception("Task could not be stopped.", failure))__					} else {_						TaskOperationResult result = (TaskOperationResult) success__						if (!result.success()) {_							LOG.info("Stopping task was not successful. Description: {}",_									result.description())__						}_					}_				}_			}, executionContext)__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,this,assigned,resource,if,slot,null,final,actor,gateway,gateway,slot,get,task,manager,actor,gateway,scala,concurrent,future,object,stop,result,gateway,retry,new,stop,task,attempt,id,timeout,execution,context,stop,result,on,complete,new,on,complete,object,override,public,void,on,complete,throwable,failure,object,success,throws,throwable,if,failure,null,fail,new,exception,task,could,not,be,stopped,failure,else,task,operation,result,result,task,operation,result,success,if,result,success,log,info,stopping,task,was,not,successful,description,result,description,execution,context
Execution -> public void stop();1477989375;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			Future<Acknowledge> stopResultFuture = FutureUtils.retry(_				new Callable<Future<Acknowledge>>() {__					@Override_					public Future<Acknowledge> call() throws Exception {_						return taskManagerGateway.stopTask(attemptId, timeout)__					}_				},_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					LOG.info("Stopping task was not successful.", failure)__					return null__				}_			})__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,future,acknowledge,stop,result,future,future,utils,retry,new,callable,future,acknowledge,override,public,future,acknowledge,call,throws,exception,return,task,manager,gateway,stop,task,attempt,id,timeout,executor,stop,result,future,exceptionally,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1478800024;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			Future<Acknowledge> stopResultFuture = FutureUtils.retry(_				new Callable<Future<Acknowledge>>() {__					@Override_					public Future<Acknowledge> call() throws Exception {_						return taskManagerGateway.stopTask(attemptId, timeout)__					}_				},_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					LOG.info("Stopping task was not successful.", failure)__					return null__				}_			})__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,future,acknowledge,stop,result,future,future,utils,retry,new,callable,future,acknowledge,override,public,future,acknowledge,call,throws,exception,return,task,manager,gateway,stop,task,attempt,id,timeout,executor,stop,result,future,exceptionally,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1481290933;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			Future<Acknowledge> stopResultFuture = FutureUtils.retry(_				new Callable<Future<Acknowledge>>() {__					@Override_					public Future<Acknowledge> call() throws Exception {_						return taskManagerGateway.stopTask(attemptId, timeout)__					}_				},_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					LOG.info("Stopping task was not successful.", failure)__					return null__				}_			})__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,future,acknowledge,stop,result,future,future,utils,retry,new,callable,future,acknowledge,override,public,future,acknowledge,call,throws,exception,return,task,manager,gateway,stop,task,attempt,id,timeout,executor,stop,result,future,exceptionally,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1482522865;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			Future<Acknowledge> stopResultFuture = FutureUtils.retry(_				new Callable<Future<Acknowledge>>() {__					@Override_					public Future<Acknowledge> call() throws Exception {_						return taskManagerGateway.stopTask(attemptId, timeout)__					}_				},_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					LOG.info("Stopping task was not successful.", failure)__					return null__				}_			})__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,future,acknowledge,stop,result,future,future,utils,retry,new,callable,future,acknowledge,override,public,future,acknowledge,call,throws,exception,return,task,manager,gateway,stop,task,attempt,id,timeout,executor,stop,result,future,exceptionally,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1486114103;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			Future<Acknowledge> stopResultFuture = FutureUtils.retry(_				new Callable<Future<Acknowledge>>() {__					@Override_					public Future<Acknowledge> call() throws Exception {_						return taskManagerGateway.stopTask(attemptId, timeout)__					}_				},_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					LOG.info("Stopping task was not successful.", failure)__					return null__				}_			})__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,future,acknowledge,stop,result,future,future,utils,retry,new,callable,future,acknowledge,override,public,future,acknowledge,call,throws,exception,return,task,manager,gateway,stop,task,attempt,id,timeout,executor,stop,result,future,exceptionally,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1486114103;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			Future<Acknowledge> stopResultFuture = FutureUtils.retry(_				new Callable<Future<Acknowledge>>() {__					@Override_					public Future<Acknowledge> call() throws Exception {_						return taskManagerGateway.stopTask(attemptId, timeout)__					}_				},_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					LOG.info("Stopping task was not successful.", failure)__					return null__				}_			})__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,future,acknowledge,stop,result,future,future,utils,retry,new,callable,future,acknowledge,override,public,future,acknowledge,call,throws,exception,return,task,manager,gateway,stop,task,attempt,id,timeout,executor,stop,result,future,exceptionally,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1486740510;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			Future<Acknowledge> stopResultFuture = FutureUtils.retry(_				new Callable<Future<Acknowledge>>() {__					@Override_					public Future<Acknowledge> call() throws Exception {_						return taskManagerGateway.stopTask(attemptId, timeout)__					}_				},_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					LOG.info("Stopping task was not successful.", failure)__					return null__				}_			})__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,future,acknowledge,stop,result,future,future,utils,retry,new,callable,future,acknowledge,override,public,future,acknowledge,call,throws,exception,return,task,manager,gateway,stop,task,attempt,id,timeout,executor,stop,result,future,exceptionally,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1487548884;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			Future<Acknowledge> stopResultFuture = FutureUtils.retry(_				new Callable<Future<Acknowledge>>() {__					@Override_					public Future<Acknowledge> call() throws Exception {_						return taskManagerGateway.stopTask(attemptId, timeout)__					}_				},_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					LOG.info("Stopping task was not successful.", failure)__					return null__				}_			})__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,future,acknowledge,stop,result,future,future,utils,retry,new,callable,future,acknowledge,override,public,future,acknowledge,call,throws,exception,return,task,manager,gateway,stop,task,attempt,id,timeout,executor,stop,result,future,exceptionally,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1487871589;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			Future<Acknowledge> stopResultFuture = FutureUtils.retry(_				new Callable<Future<Acknowledge>>() {__					@Override_					public Future<Acknowledge> call() throws Exception {_						return taskManagerGateway.stopTask(attemptId, timeout)__					}_				},_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					LOG.info("Stopping task was not successful.", failure)__					return null__				}_			})__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,future,acknowledge,stop,result,future,future,utils,retry,new,callable,future,acknowledge,override,public,future,acknowledge,call,throws,exception,return,task,manager,gateway,stop,task,attempt,id,timeout,executor,stop,result,future,exceptionally,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1488878443;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			Future<Acknowledge> stopResultFuture = FutureUtils.retry(_				new Callable<Future<Acknowledge>>() {__					@Override_					public Future<Acknowledge> call() throws Exception {_						return taskManagerGateway.stopTask(attemptId, timeout)__					}_				},_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					LOG.info("Stopping task was not successful.", failure)__					return null__				}_			})__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,future,acknowledge,stop,result,future,future,utils,retry,new,callable,future,acknowledge,override,public,future,acknowledge,call,throws,exception,return,task,manager,gateway,stop,task,attempt,id,timeout,executor,stop,result,future,exceptionally,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1490800309;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			Future<Acknowledge> stopResultFuture = FutureUtils.retry(_				new Callable<Future<Acknowledge>>() {__					@Override_					public Future<Acknowledge> call() throws Exception {_						return taskManagerGateway.stopTask(attemptId, timeout)__					}_				},_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					LOG.info("Stopping task was not successful.", failure)__					return null__				}_			})__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,future,acknowledge,stop,result,future,future,utils,retry,new,callable,future,acknowledge,override,public,future,acknowledge,call,throws,exception,return,task,manager,gateway,stop,task,attempt,id,timeout,executor,stop,result,future,exceptionally,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1490819573;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			Future<Acknowledge> stopResultFuture = FutureUtils.retry(_				new Callable<Future<Acknowledge>>() {__					@Override_					public Future<Acknowledge> call() throws Exception {_						return taskManagerGateway.stopTask(attemptId, timeout)__					}_				},_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					LOG.info("Stopping task was not successful.", failure)__					return null__				}_			})__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,future,acknowledge,stop,result,future,future,utils,retry,new,callable,future,acknowledge,override,public,future,acknowledge,call,throws,exception,return,task,manager,gateway,stop,task,attempt,id,timeout,executor,stop,result,future,exceptionally,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1493831843;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			Future<Acknowledge> stopResultFuture = FutureUtils.retry(_				new Callable<Future<Acknowledge>>() {__					@Override_					public Future<Acknowledge> call() throws Exception {_						return taskManagerGateway.stopTask(attemptId, timeout)__					}_				},_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					LOG.info("Stopping task was not successful.", failure)__					return null__				}_			})__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,future,acknowledge,stop,result,future,future,utils,retry,new,callable,future,acknowledge,override,public,future,acknowledge,call,throws,exception,return,task,manager,gateway,stop,task,attempt,id,timeout,executor,stop,result,future,exceptionally,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1493831843;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			Future<Acknowledge> stopResultFuture = FutureUtils.retry(_				new Callable<Future<Acknowledge>>() {__					@Override_					public Future<Acknowledge> call() throws Exception {_						return taskManagerGateway.stopTask(attemptId, timeout)__					}_				},_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(new ApplyFunction<Throwable, Void>() {_				@Override_				public Void apply(Throwable failure) {_					LOG.info("Stopping task was not successful.", failure)__					return null__				}_			})__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,future,acknowledge,stop,result,future,future,utils,retry,new,callable,future,acknowledge,override,public,future,acknowledge,call,throws,exception,return,task,manager,gateway,stop,task,attempt,id,timeout,executor,stop,result,future,exceptionally,new,apply,function,throwable,void,override,public,void,apply,throwable,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1501622876;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> stopResultFuture = FutureUtils.retry(_				() -> FutureUtils.toJava(taskManagerGateway.stopTask(attemptId, timeout)),_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(_				failure -> {_					LOG.info("Stopping task was not successful.", failure)__					return null__				})__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,stop,result,future,future,utils,retry,future,utils,to,java,task,manager,gateway,stop,task,attempt,id,timeout,executor,stop,result,future,exceptionally,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1501665499;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> stopResultFuture = FutureUtils.retry(_				() -> FutureUtils.toJava(taskManagerGateway.stopTask(attemptId, timeout)),_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(_				failure -> {_					LOG.info("Stopping task was not successful.", failure)__					return null__				})__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,stop,result,future,future,utils,retry,future,utils,to,java,task,manager,gateway,stop,task,attempt,id,timeout,executor,stop,result,future,exceptionally,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1501760738;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> stopResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.stopTask(attemptId, timeout),_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(_				failure -> {_					LOG.info("Stopping task was not successful.", failure)__					return null__				})__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,stop,result,future,future,utils,retry,task,manager,gateway,stop,task,attempt,id,timeout,executor,stop,result,future,exceptionally,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1502801814;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> stopResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.stopTask(attemptId, timeout),_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(_				failure -> {_					LOG.info("Stopping task was not successful.", failure)__					return null__				})__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,stop,result,future,future,utils,retry,task,manager,gateway,stop,task,attempt,id,timeout,executor,stop,result,future,exceptionally,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1509125300;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> stopResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.stopTask(attemptId, timeout),_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(_				failure -> {_					LOG.info("Stopping task was not successful.", failure)__					return null__				})__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,stop,result,future,future,utils,retry,task,manager,gateway,stop,task,attempt,id,timeout,executor,stop,result,future,exceptionally,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1509631297;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> stopResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.stopTask(attemptId, timeout),_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(_				failure -> {_					LOG.info("Stopping task was not successful.", failure)__					return null__				})__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,stop,result,future,future,utils,retry,task,manager,gateway,stop,task,attempt,id,timeout,executor,stop,result,future,exceptionally,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1509638684;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = assignedResource.get()___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> stopResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.stopTask(attemptId, timeout),_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(_				failure -> {_					LOG.info("Stopping task was not successful.", failure)__					return null__				})__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,assigned,resource,get,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,stop,result,future,future,utils,retry,task,manager,gateway,stop,task,attempt,id,timeout,executor,stop,result,future,exceptionally,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1509638685;Sends stop RPC call.;public void stop() {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> stopResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.stopTask(attemptId, timeout),_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(_				failure -> {_					LOG.info("Stopping task was not successful.", failure)__					return null__				})__		}_	};sends,stop,rpc,call;public,void,stop,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,stop,result,future,future,utils,retry,task,manager,gateway,stop,task,attempt,id,timeout,executor,stop,result,future,exceptionally,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1513201052;Sends stop RPC call.;public void stop() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> stopResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.stopTask(attemptId, timeout),_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(_				failure -> {_					LOG.info("Stopping task was not successful.", failure)__					return null__				})__		}_	};sends,stop,rpc,call;public,void,stop,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,stop,result,future,future,utils,retry,task,manager,gateway,stop,task,attempt,id,timeout,executor,stop,result,future,exceptionally,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1513201070;Sends stop RPC call.;public void stop() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> stopResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.stopTask(attemptId, timeout),_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(_				failure -> {_					LOG.info("Stopping task was not successful.", failure)__					return null__				})__		}_	};sends,stop,rpc,call;public,void,stop,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,stop,result,future,future,utils,retry,task,manager,gateway,stop,task,attempt,id,timeout,executor,stop,result,future,exceptionally,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1513261599;Sends stop RPC call.;public void stop() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> stopResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.stopTask(attemptId, timeout),_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(_				failure -> {_					LOG.info("Stopping task was not successful.", failure)__					return null__				})__		}_	};sends,stop,rpc,call;public,void,stop,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,stop,result,future,future,utils,retry,task,manager,gateway,stop,task,attempt,id,timeout,executor,stop,result,future,exceptionally,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1515177485;Sends stop RPC call.;public void stop() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> stopResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.stopTask(attemptId, timeout),_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(_				failure -> {_					LOG.info("Stopping task was not successful.", failure)__					return null__				})__		}_	};sends,stop,rpc,call;public,void,stop,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,stop,result,future,future,utils,retry,task,manager,gateway,stop,task,attempt,id,timeout,executor,stop,result,future,exceptionally,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1516626377;Sends stop RPC call.;public void stop() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> stopResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.stopTask(attemptId, timeout),_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(_				failure -> {_					LOG.info("Stopping task was not successful.", failure)__					return null__				})__		}_	};sends,stop,rpc,call;public,void,stop,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,stop,result,future,future,utils,retry,task,manager,gateway,stop,task,attempt,id,timeout,executor,stop,result,future,exceptionally,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1516626397;Sends stop RPC call.;public void stop() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> stopResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.stopTask(attemptId, timeout),_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(_				failure -> {_					LOG.info("Stopping task was not successful.", failure)__					return null__				})__		}_	};sends,stop,rpc,call;public,void,stop,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,stop,result,future,future,utils,retry,task,manager,gateway,stop,task,attempt,id,timeout,executor,stop,result,future,exceptionally,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1518680774;Sends stop RPC call.;public void stop() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> stopResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.stopTask(attemptId, rpcTimeout),_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(_				failure -> {_					LOG.info("Stopping task was not successful.", failure)__					return null__				})__		}_	};sends,stop,rpc,call;public,void,stop,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,stop,result,future,future,utils,retry,task,manager,gateway,stop,task,attempt,id,rpc,timeout,executor,stop,result,future,exceptionally,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1518712478;Sends stop RPC call.;public void stop() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> stopResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.stopTask(attemptId, rpcTimeout),_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(_				failure -> {_					LOG.info("Stopping task was not successful.", failure)__					return null__				})__		}_	};sends,stop,rpc,call;public,void,stop,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,stop,result,future,future,utils,retry,task,manager,gateway,stop,task,attempt,id,rpc,timeout,executor,stop,result,future,exceptionally,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1519316529;Sends stop RPC call.;public void stop() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> stopResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.stopTask(attemptId, rpcTimeout),_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(_				failure -> {_					LOG.info("Stopping task was not successful.", failure)__					return null__				})__		}_	};sends,stop,rpc,call;public,void,stop,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,stop,result,future,future,utils,retry,task,manager,gateway,stop,task,attempt,id,rpc,timeout,executor,stop,result,future,exceptionally,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1519481114;Sends stop RPC call.;public void stop() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> stopResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.stopTask(attemptId, rpcTimeout),_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(_				failure -> {_					LOG.info("Stopping task was not successful.", failure)__					return null__				})__		}_	};sends,stop,rpc,call;public,void,stop,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,stop,result,future,future,utils,retry,task,manager,gateway,stop,task,attempt,id,rpc,timeout,executor,stop,result,future,exceptionally,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1519568061;Sends stop RPC call.;public void stop() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> stopResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.stopTask(attemptId, rpcTimeout),_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(_				failure -> {_					LOG.info("Stopping task was not successful.", failure)__					return null__				})__		}_	};sends,stop,rpc,call;public,void,stop,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,stop,result,future,future,utils,retry,task,manager,gateway,stop,task,attempt,id,rpc,timeout,executor,stop,result,future,exceptionally,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1519655521;Sends stop RPC call.;public void stop() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> stopResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.stopTask(attemptId, rpcTimeout),_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(_				failure -> {_					LOG.info("Stopping task was not successful.", failure)__					return null__				})__		}_	};sends,stop,rpc,call;public,void,stop,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,stop,result,future,future,utils,retry,task,manager,gateway,stop,task,attempt,id,rpc,timeout,executor,stop,result,future,exceptionally,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1522049586;Sends stop RPC call.;public void stop() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> stopResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.stopTask(attemptId, rpcTimeout),_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(_				failure -> {_					LOG.info("Stopping task was not successful.", failure)__					return null__				})__		}_	};sends,stop,rpc,call;public,void,stop,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,stop,result,future,future,utils,retry,task,manager,gateway,stop,task,attempt,id,rpc,timeout,executor,stop,result,future,exceptionally,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1522249273;Sends stop RPC call.;public void stop() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> stopResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.stopTask(attemptId, rpcTimeout),_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(_				failure -> {_					LOG.info("Stopping task was not successful.", failure)__					return null__				})__		}_	};sends,stop,rpc,call;public,void,stop,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,stop,result,future,future,utils,retry,task,manager,gateway,stop,task,attempt,id,rpc,timeout,executor,stop,result,future,exceptionally,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1530712207;Sends stop RPC call.;public void stop() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> stopResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.stopTask(attemptId, rpcTimeout),_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(_				failure -> {_					LOG.info("Stopping task was not successful.", failure)__					return null__				})__		}_	};sends,stop,rpc,call;public,void,stop,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,stop,result,future,future,utils,retry,task,manager,gateway,stop,task,attempt,id,rpc,timeout,executor,stop,result,future,exceptionally,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1532383539;Sends stop RPC call.;public void stop() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> stopResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.stopTask(attemptId, rpcTimeout),_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(_				failure -> {_					LOG.info("Stopping task was not successful.", failure)__					return null__				})__		}_	};sends,stop,rpc,call;public,void,stop,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,stop,result,future,future,utils,retry,task,manager,gateway,stop,task,attempt,id,rpc,timeout,executor,stop,result,future,exceptionally,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1532383539;Sends stop RPC call.;public void stop() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> stopResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.stopTask(attemptId, rpcTimeout),_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(_				failure -> {_					LOG.info("Stopping task was not successful.", failure)__					return null__				})__		}_	};sends,stop,rpc,call;public,void,stop,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,stop,result,future,future,utils,retry,task,manager,gateway,stop,task,attempt,id,rpc,timeout,executor,stop,result,future,exceptionally,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1532383539;Sends stop RPC call.;public void stop() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> stopResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.stopTask(attemptId, rpcTimeout),_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(_				failure -> {_					LOG.info("Stopping task was not successful.", failure)__					return null__				})__		}_	};sends,stop,rpc,call;public,void,stop,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,stop,result,future,future,utils,retry,task,manager,gateway,stop,task,attempt,id,rpc,timeout,executor,stop,result,future,exceptionally,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1540920690;Sends stop RPC call.;public void stop() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> stopResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.stopTask(attemptId, rpcTimeout),_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(_				failure -> {_					LOG.info("Stopping task was not successful.", failure)__					return null__				})__		}_	};sends,stop,rpc,call;public,void,stop,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,stop,result,future,future,utils,retry,task,manager,gateway,stop,task,attempt,id,rpc,timeout,executor,stop,result,future,exceptionally,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1542356428;Sends stop RPC call.;public void stop() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> stopResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.stopTask(attemptId, rpcTimeout),_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(_				failure -> {_					LOG.info("Stopping task was not successful.", failure)__					return null__				})__		}_	};sends,stop,rpc,call;public,void,stop,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,stop,result,future,future,utils,retry,task,manager,gateway,stop,task,attempt,id,rpc,timeout,executor,stop,result,future,exceptionally,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1546870832;Sends stop RPC call.;public void stop() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> stopResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.stopTask(attemptId, rpcTimeout),_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(_				failure -> {_					LOG.info("Stopping task was not successful.", failure)__					return null__				})__		}_	};sends,stop,rpc,call;public,void,stop,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,stop,result,future,future,utils,retry,task,manager,gateway,stop,task,attempt,id,rpc,timeout,executor,stop,result,future,exceptionally,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1547644408;Sends stop RPC call.;public void stop() {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> stopResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.stopTask(attemptId, rpcTimeout),_				NUM_STOP_CALL_TRIES,_				executor)___			stopResultFuture.exceptionally(_				failure -> {_					LOG.info("Stopping task was not successful.", failure)__					return null__				})__		}_	};sends,stop,rpc,call;public,void,stop,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,stop,result,future,future,utils,retry,task,manager,gateway,stop,task,attempt,id,rpc,timeout,executor,stop,result,future,exceptionally,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1549365080;Sends stop RPC call.;public void stop() {_		assertRunningInJobMasterMainThread()__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> stopResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.stopTask(attemptId, rpcTimeout),_				NUM_STOP_CALL_TRIES,_				vertex.getExecutionGraph().getJobMasterMainThreadExecutor())___			stopResultFuture.exceptionally(_				failure -> {_					LOG.info("Stopping task was not successful.", failure)__					return null__				})__		}_	};sends,stop,rpc,call;public,void,stop,assert,running,in,job,master,main,thread,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,stop,result,future,future,utils,retry,task,manager,gateway,stop,task,attempt,id,rpc,timeout,vertex,get,execution,graph,get,job,master,main,thread,executor,stop,result,future,exceptionally,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1550220073;Sends stop RPC call.;public void stop() {_		assertRunningInJobMasterMainThread()__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> stopResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.stopTask(attemptId, rpcTimeout),_				NUM_STOP_CALL_TRIES,_				vertex.getExecutionGraph().getJobMasterMainThreadExecutor())___			stopResultFuture.exceptionally(_				failure -> {_					LOG.info("Stopping task was not successful.", failure)__					return null__				})__		}_	};sends,stop,rpc,call;public,void,stop,assert,running,in,job,master,main,thread,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,stop,result,future,future,utils,retry,task,manager,gateway,stop,task,attempt,id,rpc,timeout,vertex,get,execution,graph,get,job,master,main,thread,executor,stop,result,future,exceptionally,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1550654143;Sends stop RPC call.;public void stop() {_		assertRunningInJobMasterMainThread()__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> stopResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.stopTask(attemptId, rpcTimeout),_				NUM_STOP_CALL_TRIES,_				vertex.getExecutionGraph().getJobMasterMainThreadExecutor())___			stopResultFuture.exceptionally(_				failure -> {_					LOG.info("Stopping task was not successful.", failure)__					return null__				})__		}_	};sends,stop,rpc,call;public,void,stop,assert,running,in,job,master,main,thread,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,stop,result,future,future,utils,retry,task,manager,gateway,stop,task,attempt,id,rpc,timeout,vertex,get,execution,graph,get,job,master,main,thread,executor,stop,result,future,exceptionally,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1550683188;Sends stop RPC call.;public void stop() {_		assertRunningInJobMasterMainThread()__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> stopResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.stopTask(attemptId, rpcTimeout),_				NUM_STOP_CALL_TRIES,_				vertex.getExecutionGraph().getJobMasterMainThreadExecutor())___			stopResultFuture.exceptionally(_				failure -> {_					LOG.info("Stopping task was not successful.", failure)__					return null__				})__		}_	};sends,stop,rpc,call;public,void,stop,assert,running,in,job,master,main,thread,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,stop,result,future,future,utils,retry,task,manager,gateway,stop,task,attempt,id,rpc,timeout,vertex,get,execution,graph,get,job,master,main,thread,executor,stop,result,future,exceptionally,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void stop();1550855836;Sends stop RPC call.;public void stop() {_		assertRunningInJobMasterMainThread()__		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			CompletableFuture<Acknowledge> stopResultFuture = FutureUtils.retry(_				() -> taskManagerGateway.stopTask(attemptId, rpcTimeout),_				NUM_STOP_CALL_TRIES,_				vertex.getExecutionGraph().getJobMasterMainThreadExecutor())___			stopResultFuture.exceptionally(_				failure -> {_					LOG.info("Stopping task was not successful.", failure)__					return null__				})__		}_	};sends,stop,rpc,call;public,void,stop,assert,running,in,job,master,main,thread,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,completable,future,acknowledge,stop,result,future,future,utils,retry,task,manager,gateway,stop,task,attempt,id,rpc,timeout,vertex,get,execution,graph,get,job,master,main,thread,executor,stop,result,future,exceptionally,failure,log,info,stopping,task,was,not,successful,failure,return,null
Execution -> public void setInitialState(TaskStateHandles checkpointStateHandles);1476972861;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param checkpointStateHandles all checkpointed operator state;public void setInitialState(TaskStateHandles checkpointStateHandles) {__		if (state != ExecutionState.CREATED) {_			throw new IllegalArgumentException("Can only assign operator state when execution attempt is in CREATED")__		}__		this.taskStateHandles = checkpointStateHandles__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,checkpoint,state,handles,all,checkpointed,operator,state;public,void,set,initial,state,task,state,handles,checkpoint,state,handles,if,state,execution,state,created,throw,new,illegal,argument,exception,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,state,handles,checkpoint,state,handles
Execution -> public void setInitialState(TaskStateHandles checkpointStateHandles);1477923124;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param checkpointStateHandles all checkpointed operator state;public void setInitialState(TaskStateHandles checkpointStateHandles) {__		if (state != ExecutionState.CREATED) {_			throw new IllegalArgumentException("Can only assign operator state when execution attempt is in CREATED")__		}__		this.taskStateHandles = checkpointStateHandles__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,checkpoint,state,handles,all,checkpointed,operator,state;public,void,set,initial,state,task,state,handles,checkpoint,state,handles,if,state,execution,state,created,throw,new,illegal,argument,exception,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,state,handles,checkpoint,state,handles
Execution -> public void setInitialState(TaskStateHandles checkpointStateHandles);1477989375;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param checkpointStateHandles all checkpointed operator state;public void setInitialState(TaskStateHandles checkpointStateHandles) {__		if (state != ExecutionState.CREATED) {_			throw new IllegalArgumentException("Can only assign operator state when execution attempt is in CREATED")__		}__		this.taskStateHandles = checkpointStateHandles__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,checkpoint,state,handles,all,checkpointed,operator,state;public,void,set,initial,state,task,state,handles,checkpoint,state,handles,if,state,execution,state,created,throw,new,illegal,argument,exception,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,state,handles,checkpoint,state,handles
Execution -> public void setInitialState(TaskStateHandles checkpointStateHandles);1478800024;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param checkpointStateHandles all checkpointed operator state;public void setInitialState(TaskStateHandles checkpointStateHandles) {__		if (state != ExecutionState.CREATED) {_			throw new IllegalArgumentException("Can only assign operator state when execution attempt is in CREATED")__		}__		this.taskStateHandles = checkpointStateHandles__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,checkpoint,state,handles,all,checkpointed,operator,state;public,void,set,initial,state,task,state,handles,checkpoint,state,handles,if,state,execution,state,created,throw,new,illegal,argument,exception,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,state,handles,checkpoint,state,handles
Execution -> public void setInitialState(TaskStateHandles checkpointStateHandles);1481290933;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param checkpointStateHandles all checkpointed operator state;public void setInitialState(TaskStateHandles checkpointStateHandles) {__		if (state != ExecutionState.CREATED) {_			throw new IllegalArgumentException("Can only assign operator state when execution attempt is in CREATED")__		}__		this.taskStateHandles = checkpointStateHandles__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,checkpoint,state,handles,all,checkpointed,operator,state;public,void,set,initial,state,task,state,handles,checkpoint,state,handles,if,state,execution,state,created,throw,new,illegal,argument,exception,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,state,handles,checkpoint,state,handles
Execution -> public void setInitialState(TaskStateHandles checkpointStateHandles);1482522865;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param checkpointStateHandles all checkpointed operator state;public void setInitialState(TaskStateHandles checkpointStateHandles) {__		if (state != ExecutionState.CREATED) {_			throw new IllegalArgumentException("Can only assign operator state when execution attempt is in CREATED")__		}__		this.taskStateHandles = checkpointStateHandles__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,checkpoint,state,handles,all,checkpointed,operator,state;public,void,set,initial,state,task,state,handles,checkpoint,state,handles,if,state,execution,state,created,throw,new,illegal,argument,exception,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,state,handles,checkpoint,state,handles
Execution -> public void setInitialState(TaskStateHandles checkpointStateHandles);1486114103;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param checkpointStateHandles all checkpointed operator state;public void setInitialState(TaskStateHandles checkpointStateHandles) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskStateHandles = checkpointStateHandles__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,checkpoint,state,handles,all,checkpointed,operator,state;public,void,set,initial,state,task,state,handles,checkpoint,state,handles,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,state,handles,checkpoint,state,handles
Execution -> public void setInitialState(TaskStateHandles checkpointStateHandles);1486114103;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param checkpointStateHandles all checkpointed operator state;public void setInitialState(TaskStateHandles checkpointStateHandles) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskState = checkpointStateHandles__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,checkpoint,state,handles,all,checkpointed,operator,state;public,void,set,initial,state,task,state,handles,checkpoint,state,handles,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,state,checkpoint,state,handles
Execution -> public void setInitialState(TaskStateHandles checkpointStateHandles);1486740510;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param checkpointStateHandles all checkpointed operator state;public void setInitialState(TaskStateHandles checkpointStateHandles) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskState = checkpointStateHandles__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,checkpoint,state,handles,all,checkpointed,operator,state;public,void,set,initial,state,task,state,handles,checkpoint,state,handles,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,state,checkpoint,state,handles
Execution -> public void setInitialState(TaskStateHandles checkpointStateHandles);1487548884;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param checkpointStateHandles all checkpointed operator state;public void setInitialState(TaskStateHandles checkpointStateHandles) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskState = checkpointStateHandles__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,checkpoint,state,handles,all,checkpointed,operator,state;public,void,set,initial,state,task,state,handles,checkpoint,state,handles,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,state,checkpoint,state,handles
Execution -> public void setInitialState(TaskStateHandles checkpointStateHandles);1487871589;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param checkpointStateHandles all checkpointed operator state;public void setInitialState(TaskStateHandles checkpointStateHandles) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskState = checkpointStateHandles__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,checkpoint,state,handles,all,checkpointed,operator,state;public,void,set,initial,state,task,state,handles,checkpoint,state,handles,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,state,checkpoint,state,handles
Execution -> public void setInitialState(TaskStateHandles checkpointStateHandles);1488878443;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param checkpointStateHandles all checkpointed operator state;public void setInitialState(TaskStateHandles checkpointStateHandles) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskState = checkpointStateHandles__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,checkpoint,state,handles,all,checkpointed,operator,state;public,void,set,initial,state,task,state,handles,checkpoint,state,handles,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,state,checkpoint,state,handles
Execution -> public void setInitialState(TaskStateHandles checkpointStateHandles);1490800309;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param checkpointStateHandles all checkpointed operator state;public void setInitialState(TaskStateHandles checkpointStateHandles) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskState = checkpointStateHandles__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,checkpoint,state,handles,all,checkpointed,operator,state;public,void,set,initial,state,task,state,handles,checkpoint,state,handles,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,state,checkpoint,state,handles
Execution -> public void setInitialState(TaskStateHandles checkpointStateHandles);1490819573;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param checkpointStateHandles all checkpointed operator state;public void setInitialState(TaskStateHandles checkpointStateHandles) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskState = checkpointStateHandles__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,checkpoint,state,handles,all,checkpointed,operator,state;public,void,set,initial,state,task,state,handles,checkpoint,state,handles,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,state,checkpoint,state,handles
Execution -> public void setInitialState(TaskStateHandles checkpointStateHandles);1493831843;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param checkpointStateHandles all checkpointed operator state;public void setInitialState(TaskStateHandles checkpointStateHandles) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskState = checkpointStateHandles__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,checkpoint,state,handles,all,checkpointed,operator,state;public,void,set,initial,state,task,state,handles,checkpoint,state,handles,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,state,checkpoint,state,handles
Execution -> public void setInitialState(TaskStateHandles checkpointStateHandles);1493831843;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param checkpointStateHandles all checkpointed operator state;public void setInitialState(TaskStateHandles checkpointStateHandles) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskState = checkpointStateHandles__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,checkpoint,state,handles,all,checkpointed,operator,state;public,void,set,initial,state,task,state,handles,checkpoint,state,handles,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,state,checkpoint,state,handles
Execution -> public void setInitialState(TaskStateHandles checkpointStateHandles);1501622876;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param checkpointStateHandles all checkpointed operator state;public void setInitialState(TaskStateHandles checkpointStateHandles) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskState = checkpointStateHandles__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,checkpoint,state,handles,all,checkpointed,operator,state;public,void,set,initial,state,task,state,handles,checkpoint,state,handles,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,state,checkpoint,state,handles
Execution -> public void setInitialState(TaskStateHandles checkpointStateHandles);1501665499;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param checkpointStateHandles all checkpointed operator state;public void setInitialState(TaskStateHandles checkpointStateHandles) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskState = checkpointStateHandles__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,checkpoint,state,handles,all,checkpointed,operator,state;public,void,set,initial,state,task,state,handles,checkpoint,state,handles,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,state,checkpoint,state,handles
Execution -> public void setInitialState(TaskStateHandles checkpointStateHandles);1501760738;Sets the initial state for the execution. The serialized state is then shipped via the_{@link TaskDeploymentDescriptor} to the TaskManagers.__@param checkpointStateHandles all checkpointed operator state;public void setInitialState(TaskStateHandles checkpointStateHandles) {_		checkState(state == CREATED, "Can only assign operator state when execution attempt is in CREATED")__		this.taskState = checkpointStateHandles__	};sets,the,initial,state,for,the,execution,the,serialized,state,is,then,shipped,via,the,link,task,deployment,descriptor,to,the,task,managers,param,checkpoint,state,handles,all,checkpointed,operator,state;public,void,set,initial,state,task,state,handles,checkpoint,state,handles,check,state,state,created,can,only,assign,operator,state,when,execution,attempt,is,in,created,this,task,state,checkpoint,state,handles
Execution -> @Override 	public CompletableFuture<ExecutionState> getTerminalStateFuture();1513201070;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached.__@return A future which is completed once the execution reaches a terminal state;@Override_	public CompletableFuture<ExecutionState> getTerminalStateFuture() {_		return terminalStateFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,return,a,future,which,is,completed,once,the,execution,reaches,a,terminal,state;override,public,completable,future,execution,state,get,terminal,state,future,return,terminal,state,future
Execution -> @Override 	public CompletableFuture<ExecutionState> getTerminalStateFuture();1513261599;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached.__@return A future which is completed once the execution reaches a terminal state;@Override_	public CompletableFuture<ExecutionState> getTerminalStateFuture() {_		return terminalStateFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,return,a,future,which,is,completed,once,the,execution,reaches,a,terminal,state;override,public,completable,future,execution,state,get,terminal,state,future,return,terminal,state,future
Execution -> @Override 	public CompletableFuture<ExecutionState> getTerminalStateFuture();1515177485;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached.__@return A future which is completed once the execution reaches a terminal state;@Override_	public CompletableFuture<ExecutionState> getTerminalStateFuture() {_		return terminalStateFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,return,a,future,which,is,completed,once,the,execution,reaches,a,terminal,state;override,public,completable,future,execution,state,get,terminal,state,future,return,terminal,state,future
Execution -> @Override 	public CompletableFuture<ExecutionState> getTerminalStateFuture();1516626377;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached.__@return A future which is completed once the execution reaches a terminal state;@Override_	public CompletableFuture<ExecutionState> getTerminalStateFuture() {_		return terminalStateFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,return,a,future,which,is,completed,once,the,execution,reaches,a,terminal,state;override,public,completable,future,execution,state,get,terminal,state,future,return,terminal,state,future
Execution -> @Override 	public CompletableFuture<ExecutionState> getTerminalStateFuture();1516626397;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached.__@return A future which is completed once the execution reaches a terminal state;@Override_	public CompletableFuture<ExecutionState> getTerminalStateFuture() {_		return terminalStateFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,return,a,future,which,is,completed,once,the,execution,reaches,a,terminal,state;override,public,completable,future,execution,state,get,terminal,state,future,return,terminal,state,future
Execution -> @Override 	public CompletableFuture<ExecutionState> getTerminalStateFuture();1518680774;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached.__@return A future which is completed once the execution reaches a terminal state;@Override_	public CompletableFuture<ExecutionState> getTerminalStateFuture() {_		return terminalStateFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,return,a,future,which,is,completed,once,the,execution,reaches,a,terminal,state;override,public,completable,future,execution,state,get,terminal,state,future,return,terminal,state,future
Execution -> @Override 	public CompletableFuture<ExecutionState> getTerminalStateFuture();1518712478;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached.__@return A future which is completed once the execution reaches a terminal state;@Override_	public CompletableFuture<ExecutionState> getTerminalStateFuture() {_		return terminalStateFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,return,a,future,which,is,completed,once,the,execution,reaches,a,terminal,state;override,public,completable,future,execution,state,get,terminal,state,future,return,terminal,state,future
Execution -> @Override 	public CompletableFuture<ExecutionState> getTerminalStateFuture();1519316529;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached.__@return A future which is completed once the execution reaches a terminal state;@Override_	public CompletableFuture<ExecutionState> getTerminalStateFuture() {_		return terminalStateFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,return,a,future,which,is,completed,once,the,execution,reaches,a,terminal,state;override,public,completable,future,execution,state,get,terminal,state,future,return,terminal,state,future
Execution -> @Override 	public CompletableFuture<ExecutionState> getTerminalStateFuture();1519481114;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached.__@return A future which is completed once the execution reaches a terminal state;@Override_	public CompletableFuture<ExecutionState> getTerminalStateFuture() {_		return terminalStateFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,return,a,future,which,is,completed,once,the,execution,reaches,a,terminal,state;override,public,completable,future,execution,state,get,terminal,state,future,return,terminal,state,future
Execution -> @Override 	public CompletableFuture<ExecutionState> getTerminalStateFuture();1519568061;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached.__@return A future which is completed once the execution reaches a terminal state;@Override_	public CompletableFuture<ExecutionState> getTerminalStateFuture() {_		return terminalStateFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,return,a,future,which,is,completed,once,the,execution,reaches,a,terminal,state;override,public,completable,future,execution,state,get,terminal,state,future,return,terminal,state,future
Execution -> @Override 	public CompletableFuture<ExecutionState> getTerminalStateFuture();1519655521;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached.__@return A future which is completed once the execution reaches a terminal state;@Override_	public CompletableFuture<ExecutionState> getTerminalStateFuture() {_		return terminalStateFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,return,a,future,which,is,completed,once,the,execution,reaches,a,terminal,state;override,public,completable,future,execution,state,get,terminal,state,future,return,terminal,state,future
Execution -> @Override 	public CompletableFuture<ExecutionState> getTerminalStateFuture();1522049586;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached.__@return A future which is completed once the execution reaches a terminal state;@Override_	public CompletableFuture<ExecutionState> getTerminalStateFuture() {_		return terminalStateFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,return,a,future,which,is,completed,once,the,execution,reaches,a,terminal,state;override,public,completable,future,execution,state,get,terminal,state,future,return,terminal,state,future
Execution -> @Override 	public CompletableFuture<ExecutionState> getTerminalStateFuture();1522249273;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached.__@return A future which is completed once the execution reaches a terminal state;@Override_	public CompletableFuture<ExecutionState> getTerminalStateFuture() {_		return terminalStateFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,return,a,future,which,is,completed,once,the,execution,reaches,a,terminal,state;override,public,completable,future,execution,state,get,terminal,state,future,return,terminal,state,future
Execution -> @Override 	public CompletableFuture<ExecutionState> getTerminalStateFuture();1530712207;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached.__@return A future which is completed once the execution reaches a terminal state;@Override_	public CompletableFuture<ExecutionState> getTerminalStateFuture() {_		return terminalStateFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,return,a,future,which,is,completed,once,the,execution,reaches,a,terminal,state;override,public,completable,future,execution,state,get,terminal,state,future,return,terminal,state,future
Execution -> @Override 	public CompletableFuture<ExecutionState> getTerminalStateFuture();1532383539;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached.__@return A future which is completed once the execution reaches a terminal state;@Override_	public CompletableFuture<ExecutionState> getTerminalStateFuture() {_		return terminalStateFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,return,a,future,which,is,completed,once,the,execution,reaches,a,terminal,state;override,public,completable,future,execution,state,get,terminal,state,future,return,terminal,state,future
Execution -> @Override 	public CompletableFuture<ExecutionState> getTerminalStateFuture();1532383539;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached.__@return A future which is completed once the execution reaches a terminal state;@Override_	public CompletableFuture<ExecutionState> getTerminalStateFuture() {_		return terminalStateFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,return,a,future,which,is,completed,once,the,execution,reaches,a,terminal,state;override,public,completable,future,execution,state,get,terminal,state,future,return,terminal,state,future
Execution -> @Override 	public CompletableFuture<ExecutionState> getTerminalStateFuture();1532383539;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached.__@return A future which is completed once the execution reaches a terminal state;@Override_	public CompletableFuture<ExecutionState> getTerminalStateFuture() {_		return terminalStateFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,return,a,future,which,is,completed,once,the,execution,reaches,a,terminal,state;override,public,completable,future,execution,state,get,terminal,state,future,return,terminal,state,future
Execution -> @Override 	public CompletableFuture<ExecutionState> getTerminalStateFuture();1540920690;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached.__@return A future which is completed once the execution reaches a terminal state;@Override_	public CompletableFuture<ExecutionState> getTerminalStateFuture() {_		return terminalStateFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,return,a,future,which,is,completed,once,the,execution,reaches,a,terminal,state;override,public,completable,future,execution,state,get,terminal,state,future,return,terminal,state,future
Execution -> @Override 	public CompletableFuture<ExecutionState> getTerminalStateFuture();1542356428;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached.__@return A future which is completed once the execution reaches a terminal state;@Override_	public CompletableFuture<ExecutionState> getTerminalStateFuture() {_		return terminalStateFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,return,a,future,which,is,completed,once,the,execution,reaches,a,terminal,state;override,public,completable,future,execution,state,get,terminal,state,future,return,terminal,state,future
Execution -> @Override 	public CompletableFuture<ExecutionState> getTerminalStateFuture();1546870832;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached.__@return A future which is completed once the execution reaches a terminal state;@Override_	public CompletableFuture<ExecutionState> getTerminalStateFuture() {_		return terminalStateFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,return,a,future,which,is,completed,once,the,execution,reaches,a,terminal,state;override,public,completable,future,execution,state,get,terminal,state,future,return,terminal,state,future
Execution -> @Override 	public CompletableFuture<ExecutionState> getTerminalStateFuture();1547644408;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached.__@return A future which is completed once the execution reaches a terminal state;@Override_	public CompletableFuture<ExecutionState> getTerminalStateFuture() {_		return terminalStateFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,return,a,future,which,is,completed,once,the,execution,reaches,a,terminal,state;override,public,completable,future,execution,state,get,terminal,state,future,return,terminal,state,future
Execution -> @Override 	public CompletableFuture<ExecutionState> getTerminalStateFuture();1549365080;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached._This future is always completed from the job master's main thread.__@return A future which is completed once the execution reaches a terminal state;@Override_	public CompletableFuture<ExecutionState> getTerminalStateFuture() {_		return terminalStateFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,this,future,is,always,completed,from,the,job,master,s,main,thread,return,a,future,which,is,completed,once,the,execution,reaches,a,terminal,state;override,public,completable,future,execution,state,get,terminal,state,future,return,terminal,state,future
Execution -> @Override 	public CompletableFuture<ExecutionState> getTerminalStateFuture();1550220073;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached._This future is always completed from the job master's main thread.__@return A future which is completed once the execution reaches a terminal state;@Override_	public CompletableFuture<ExecutionState> getTerminalStateFuture() {_		return terminalStateFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,this,future,is,always,completed,from,the,job,master,s,main,thread,return,a,future,which,is,completed,once,the,execution,reaches,a,terminal,state;override,public,completable,future,execution,state,get,terminal,state,future,return,terminal,state,future
Execution -> @Override 	public CompletableFuture<ExecutionState> getTerminalStateFuture();1550654143;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached._This future is always completed from the job master's main thread.__@return A future which is completed once the execution reaches a terminal state;@Override_	public CompletableFuture<ExecutionState> getTerminalStateFuture() {_		return terminalStateFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,this,future,is,always,completed,from,the,job,master,s,main,thread,return,a,future,which,is,completed,once,the,execution,reaches,a,terminal,state;override,public,completable,future,execution,state,get,terminal,state,future,return,terminal,state,future
Execution -> @Override 	public CompletableFuture<ExecutionState> getTerminalStateFuture();1550683188;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached._This future is always completed from the job master's main thread.__@return A future which is completed once the execution reaches a terminal state;@Override_	public CompletableFuture<ExecutionState> getTerminalStateFuture() {_		return terminalStateFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,this,future,is,always,completed,from,the,job,master,s,main,thread,return,a,future,which,is,completed,once,the,execution,reaches,a,terminal,state;override,public,completable,future,execution,state,get,terminal,state,future,return,terminal,state,future
Execution -> @Override 	public CompletableFuture<ExecutionState> getTerminalStateFuture();1550855836;Gets a future that completes once the task execution reaches a terminal state._The future will be completed with specific state that the execution reached._This future is always completed from the job master's main thread.__@return A future which is completed once the execution reaches a terminal state;@Override_	public CompletableFuture<ExecutionState> getTerminalStateFuture() {_		return terminalStateFuture__	};gets,a,future,that,completes,once,the,task,execution,reaches,a,terminal,state,the,future,will,be,completed,with,specific,state,that,the,execution,reached,this,future,is,always,completed,from,the,job,master,s,main,thread,return,a,future,which,is,completed,once,the,execution,reaches,a,terminal,state;override,public,completable,future,execution,state,get,terminal,state,future,return,terminal,state,future
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp);1477989375;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp);1478800024;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp);1481290933;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp);1482522865;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp);1486114103;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp);1486114103;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp);1486740510;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void triggerCheckpoint(long checkpointId, long timestamp);1487548884;Trigger a new checkpoint on the task of this execution.__@param checkpointId of th checkpoint to trigger_@param timestamp of the checkpoint to trigger;public void triggerCheckpoint(long checkpointId, long timestamp) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};trigger,a,new,checkpoint,on,the,task,of,this,execution,param,checkpoint,id,of,th,checkpoint,to,trigger,param,timestamp,of,the,checkpoint,to,trigger;public,void,trigger,checkpoint,long,checkpoint,id,long,timestamp,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,trigger,checkpoint,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public Future<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStrackTraceDepth, 			Time timeout);1477989375;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStrackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public Future<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStrackTraceDepth,_			Time timeout) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStrackTraceDepth,_				timeout)__		} else {_			return FlinkCompletableFuture.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,strack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,strack,trace,depth,time,timeout,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,strack,trace,depth,timeout,else,return,flink,completable,future,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public Future<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStrackTraceDepth, 			Time timeout);1478800024;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStrackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public Future<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStrackTraceDepth,_			Time timeout) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStrackTraceDepth,_				timeout)__		} else {_			return FlinkCompletableFuture.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,strack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,strack,trace,depth,time,timeout,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,strack,trace,depth,timeout,else,return,flink,completable,future,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public Future<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStrackTraceDepth, 			Time timeout);1481290933;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStrackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public Future<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStrackTraceDepth,_			Time timeout) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStrackTraceDepth,_				timeout)__		} else {_			return FlinkCompletableFuture.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,strack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,strack,trace,depth,time,timeout,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,strack,trace,depth,timeout,else,return,flink,completable,future,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public Future<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStrackTraceDepth, 			Time timeout);1482522865;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStrackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public Future<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStrackTraceDepth,_			Time timeout) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStrackTraceDepth,_				timeout)__		} else {_			return FlinkCompletableFuture.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,strack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,strack,trace,depth,time,timeout,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,strack,trace,depth,timeout,else,return,flink,completable,future,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public Future<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStrackTraceDepth, 			Time timeout);1486114103;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStrackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public Future<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStrackTraceDepth,_			Time timeout) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStrackTraceDepth,_				timeout)__		} else {_			return FlinkCompletableFuture.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,strack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,strack,trace,depth,time,timeout,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,strack,trace,depth,timeout,else,return,flink,completable,future,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public Future<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStrackTraceDepth, 			Time timeout);1486114103;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStrackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public Future<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStrackTraceDepth,_			Time timeout) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStrackTraceDepth,_				timeout)__		} else {_			return FlinkCompletableFuture.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,strack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,strack,trace,depth,time,timeout,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,strack,trace,depth,timeout,else,return,flink,completable,future,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public Future<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStrackTraceDepth, 			Time timeout);1486740510;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStrackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public Future<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStrackTraceDepth,_			Time timeout) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStrackTraceDepth,_				timeout)__		} else {_			return FlinkCompletableFuture.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,strack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,strack,trace,depth,time,timeout,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,strack,trace,depth,timeout,else,return,flink,completable,future,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public Future<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStrackTraceDepth, 			Time timeout);1487548884;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStrackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public Future<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStrackTraceDepth,_			Time timeout) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStrackTraceDepth,_				timeout)__		} else {_			return FlinkCompletableFuture.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,strack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,strack,trace,depth,time,timeout,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,strack,trace,depth,timeout,else,return,flink,completable,future,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public Future<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStrackTraceDepth, 			Time timeout);1487871589;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStrackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public Future<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStrackTraceDepth,_			Time timeout) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStrackTraceDepth,_				timeout)__		} else {_			return FlinkCompletableFuture.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,strack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,strack,trace,depth,time,timeout,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,strack,trace,depth,timeout,else,return,flink,completable,future,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public Future<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStrackTraceDepth, 			Time timeout);1488878443;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStrackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public Future<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStrackTraceDepth,_			Time timeout) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStrackTraceDepth,_				timeout)__		} else {_			return FlinkCompletableFuture.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,strack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,strack,trace,depth,time,timeout,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,strack,trace,depth,timeout,else,return,flink,completable,future,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public Future<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStrackTraceDepth, 			Time timeout);1490800309;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStrackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public Future<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStrackTraceDepth,_			Time timeout) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStrackTraceDepth,_				timeout)__		} else {_			return FlinkCompletableFuture.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,strack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,strack,trace,depth,time,timeout,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,strack,trace,depth,timeout,else,return,flink,completable,future,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public Future<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStrackTraceDepth, 			Time timeout);1490819573;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStrackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public Future<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStrackTraceDepth,_			Time timeout) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStrackTraceDepth,_				timeout)__		} else {_			return FlinkCompletableFuture.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,strack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,strack,trace,depth,time,timeout,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,strack,trace,depth,timeout,else,return,flink,completable,future,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public Future<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStrackTraceDepth, 			Time timeout);1493831843;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStrackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public Future<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStrackTraceDepth,_			Time timeout) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStrackTraceDepth,_				timeout)__		} else {_			return FlinkCompletableFuture.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,strack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,strack,trace,depth,time,timeout,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,strack,trace,depth,timeout,else,return,flink,completable,future,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public Future<StackTraceSampleResponse> requestStackTraceSample( 			int sampleId, 			int numSamples, 			Time delayBetweenSamples, 			int maxStrackTraceDepth, 			Time timeout);1493831843;Request a stack trace sample from the task of this execution.__@param sampleId of the stack trace sample_@param numSamples the sample should contain_@param delayBetweenSamples to wait_@param maxStrackTraceDepth of the samples_@param timeout until the request times out_@return Future stack trace sample response;public Future<StackTraceSampleResponse> requestStackTraceSample(_			int sampleId,_			int numSamples,_			Time delayBetweenSamples,_			int maxStrackTraceDepth,_			Time timeout) {__		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			return taskManagerGateway.requestStackTraceSample(_				attemptId,_				sampleId,_				numSamples,_				delayBetweenSamples,_				maxStrackTraceDepth,_				timeout)__		} else {_			return FlinkCompletableFuture.completedExceptionally(new Exception("The execution has no slot assigned."))__		}_	};request,a,stack,trace,sample,from,the,task,of,this,execution,param,sample,id,of,the,stack,trace,sample,param,num,samples,the,sample,should,contain,param,delay,between,samples,to,wait,param,max,strack,trace,depth,of,the,samples,param,timeout,until,the,request,times,out,return,future,stack,trace,sample,response;public,future,stack,trace,sample,response,request,stack,trace,sample,int,sample,id,int,num,samples,time,delay,between,samples,int,max,strack,trace,depth,time,timeout,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,return,task,manager,gateway,request,stack,trace,sample,attempt,id,sample,id,num,samples,delay,between,samples,max,strack,trace,depth,timeout,else,return,flink,completable,future,completed,exceptionally,new,exception,the,execution,has,no,slot,assigned
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1477989375;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1478800024;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1481290933;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1482522865;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1486114103;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1486114103;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1486740510;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1487548884;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1487871589;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1488878443;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1490800309;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1490819573;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1493831843;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1493831843;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1501622876;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1501665499;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1501760738;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1502801814;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1509125300;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1509631297;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1509638684;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final SimpleSlot slot = assignedResource.get()___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,simple,slot,slot,assigned,resource,get,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1509638685;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final SimpleSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,simple,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1513201052;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1513201070;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1513261599;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1515177485;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1516626377;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1516626397;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1518680774;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1518712478;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1519316529;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1519481114;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1519568061;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1519655521;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1522049586;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1522249273;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1530712207;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1532383539;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1532383539;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1532383539;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1540920690;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1542356428;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1546870832;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1547644408;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1549365080;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1550220073;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1550654143;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1550683188;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
Execution -> public void notifyCheckpointComplete(long checkpointId, long timestamp);1550855836;Notify the task of this execution about a completed checkpoint.__@param checkpointId of the completed checkpoint_@param timestamp of the completed checkpoint;public void notifyCheckpointComplete(long checkpointId, long timestamp) {_		final LogicalSlot slot = assignedResource___		if (slot != null) {_			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway()___			taskManagerGateway.notifyCheckpointComplete(attemptId, getVertex().getJobId(), checkpointId, timestamp)__		} else {_			LOG.debug("The execution has no slot assigned. This indicates that the execution is " +_				"no longer running.")__		}_	};notify,the,task,of,this,execution,about,a,completed,checkpoint,param,checkpoint,id,of,the,completed,checkpoint,param,timestamp,of,the,completed,checkpoint;public,void,notify,checkpoint,complete,long,checkpoint,id,long,timestamp,final,logical,slot,slot,assigned,resource,if,slot,null,final,task,manager,gateway,task,manager,gateway,slot,get,task,manager,gateway,task,manager,gateway,notify,checkpoint,complete,attempt,id,get,vertex,get,job,id,checkpoint,id,timestamp,else,log,debug,the,execution,has,no,slot,assigned,this,indicates,that,the,execution,is,no,longer,running
