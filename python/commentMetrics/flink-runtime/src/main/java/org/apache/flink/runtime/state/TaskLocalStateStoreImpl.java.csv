# id;timestamp;commentText;codeText;commentWords;codeWords
TaskLocalStateStoreImpl -> private void deleteDirectory(File directory) throws IOException;1519568061;Helper method to delete a directory.;private void deleteDirectory(File directory) throws IOException {_		Path path = new Path(directory.toURI())__		FileSystem fileSystem = path.getFileSystem()__		if (fileSystem.exists(path)) {_			fileSystem.delete(path, true)__		}_	};helper,method,to,delete,a,directory;private,void,delete,directory,file,directory,throws,ioexception,path,path,new,path,directory,to,uri,file,system,file,system,path,get,file,system,if,file,system,exists,path,file,system,delete,path,true
TaskLocalStateStoreImpl -> private void deleteDirectory(File directory) throws IOException;1519741691;Helper method to delete a directory.;private void deleteDirectory(File directory) throws IOException {_		Path path = new Path(directory.toURI())__		FileSystem fileSystem = path.getFileSystem()__		if (fileSystem.exists(path)) {_			fileSystem.delete(path, true)__		}_	};helper,method,to,delete,a,directory;private,void,delete,directory,file,directory,throws,ioexception,path,path,new,path,directory,to,uri,file,system,file,system,path,get,file,system,if,file,system,exists,path,file,system,delete,path,true
TaskLocalStateStoreImpl -> private void deleteDirectory(File directory) throws IOException;1519821266;Helper method to delete a directory.;private void deleteDirectory(File directory) throws IOException {_		Path path = new Path(directory.toURI())__		FileSystem fileSystem = path.getFileSystem()__		if (fileSystem.exists(path)) {_			fileSystem.delete(path, true)__		}_	};helper,method,to,delete,a,directory;private,void,delete,directory,file,directory,throws,ioexception,path,path,new,path,directory,to,uri,file,system,file,system,path,get,file,system,if,file,system,exists,path,file,system,delete,path,true
TaskLocalStateStoreImpl -> private void deleteDirectory(File directory) throws IOException;1526544183;Helper method to delete a directory.;private void deleteDirectory(File directory) throws IOException {_		Path path = new Path(directory.toURI())__		FileSystem fileSystem = path.getFileSystem()__		if (fileSystem.exists(path)) {_			fileSystem.delete(path, true)__		}_	};helper,method,to,delete,a,directory;private,void,delete,directory,file,directory,throws,ioexception,path,path,new,path,directory,to,uri,file,system,file,system,path,get,file,system,if,file,system,exists,path,file,system,delete,path,true
TaskLocalStateStoreImpl -> private void deleteDirectory(File directory) throws IOException;1526544184;Helper method to delete a directory.;private void deleteDirectory(File directory) throws IOException {_		Path path = new Path(directory.toURI())__		FileSystem fileSystem = path.getFileSystem()__		if (fileSystem.exists(path)) {_			fileSystem.delete(path, true)__		}_	};helper,method,to,delete,a,directory;private,void,delete,directory,file,directory,throws,ioexception,path,path,new,path,directory,to,uri,file,system,file,system,path,get,file,system,if,file,system,exists,path,file,system,delete,path,true
TaskLocalStateStoreImpl -> private void deleteDirectory(File directory) throws IOException;1551195367;Helper method to delete a directory.;private void deleteDirectory(File directory) throws IOException {_		Path path = new Path(directory.toURI())__		FileSystem fileSystem = path.getFileSystem()__		if (fileSystem.exists(path)) {_			fileSystem.delete(path, true)__		}_	};helper,method,to,delete,a,directory;private,void,delete,directory,file,directory,throws,ioexception,path,path,new,path,directory,to,uri,file,system,file,system,path,get,file,system,if,file,system,exists,path,file,system,delete,path,true
TaskLocalStateStoreImpl -> @Override 	public CompletableFuture<Void> dispose();1526544183;Disposes the state of all local snapshots managed by this object.;@Override_	public CompletableFuture<Void> dispose() {__		Collection<Map.Entry<Long, TaskStateSnapshot>> statesCopy___		synchronized (lock) {_			disposed = true__			statesCopy = new ArrayList<>(storedTaskStateByCheckpointID.entrySet())__			storedTaskStateByCheckpointID.clear()__		}__		return CompletableFuture.runAsync(_			() -> {_				_				syncDiscardLocalStateForCollection(statesCopy)___				_				LocalRecoveryDirectoryProvider directoryProvider = localRecoveryConfig.getLocalStateDirectoryProvider()__				for (int i = 0_ i < directoryProvider.allocationBaseDirsCount()_ ++i) {_					File subtaskBaseDirectory = directoryProvider.selectSubtaskBaseDirectory(i)__					try {_						deleteDirectory(subtaskBaseDirectory)__					} catch (IOException e) {_						LOG.warn("Exception when deleting local recovery subtask base directory {} in subtask ({} - {} - {})",_							subtaskBaseDirectory, jobID, jobVertexID, subtaskIndex, e)__					}_				}_			},_			discardExecutor)__	};disposes,the,state,of,all,local,snapshots,managed,by,this,object;override,public,completable,future,void,dispose,collection,map,entry,long,task,state,snapshot,states,copy,synchronized,lock,disposed,true,states,copy,new,array,list,stored,task,state,by,checkpoint,id,entry,set,stored,task,state,by,checkpoint,id,clear,return,completable,future,run,async,sync,discard,local,state,for,collection,states,copy,local,recovery,directory,provider,directory,provider,local,recovery,config,get,local,state,directory,provider,for,int,i,0,i,directory,provider,allocation,base,dirs,count,i,file,subtask,base,directory,directory,provider,select,subtask,base,directory,i,try,delete,directory,subtask,base,directory,catch,ioexception,e,log,warn,exception,when,deleting,local,recovery,subtask,base,directory,in,subtask,subtask,base,directory,job,id,job,vertex,id,subtask,index,e,discard,executor
TaskLocalStateStoreImpl -> @Override 	public CompletableFuture<Void> dispose();1526544184;Disposes the state of all local snapshots managed by this object.;@Override_	public CompletableFuture<Void> dispose() {__		Collection<Map.Entry<Long, TaskStateSnapshot>> statesCopy___		synchronized (lock) {_			disposed = true__			statesCopy = new ArrayList<>(storedTaskStateByCheckpointID.entrySet())__			storedTaskStateByCheckpointID.clear()__		}__		return CompletableFuture.runAsync(_			() -> {_				_				syncDiscardLocalStateForCollection(statesCopy)___				_				LocalRecoveryDirectoryProvider directoryProvider = localRecoveryConfig.getLocalStateDirectoryProvider()__				for (int i = 0_ i < directoryProvider.allocationBaseDirsCount()_ ++i) {_					File subtaskBaseDirectory = directoryProvider.selectSubtaskBaseDirectory(i)__					try {_						deleteDirectory(subtaskBaseDirectory)__					} catch (IOException e) {_						LOG.warn("Exception when deleting local recovery subtask base directory {} in subtask ({} - {} - {})",_							subtaskBaseDirectory, jobID, jobVertexID, subtaskIndex, e)__					}_				}_			},_			discardExecutor)__	};disposes,the,state,of,all,local,snapshots,managed,by,this,object;override,public,completable,future,void,dispose,collection,map,entry,long,task,state,snapshot,states,copy,synchronized,lock,disposed,true,states,copy,new,array,list,stored,task,state,by,checkpoint,id,entry,set,stored,task,state,by,checkpoint,id,clear,return,completable,future,run,async,sync,discard,local,state,for,collection,states,copy,local,recovery,directory,provider,directory,provider,local,recovery,config,get,local,state,directory,provider,for,int,i,0,i,directory,provider,allocation,base,dirs,count,i,file,subtask,base,directory,directory,provider,select,subtask,base,directory,i,try,delete,directory,subtask,base,directory,catch,ioexception,e,log,warn,exception,when,deleting,local,recovery,subtask,base,directory,in,subtask,subtask,base,directory,job,id,job,vertex,id,subtask,index,e,discard,executor
TaskLocalStateStoreImpl -> @Override 	public CompletableFuture<Void> dispose();1551195367;Disposes the state of all local snapshots managed by this object.;@Override_	public CompletableFuture<Void> dispose() {__		Collection<Map.Entry<Long, TaskStateSnapshot>> statesCopy___		synchronized (lock) {_			disposed = true__			statesCopy = new ArrayList<>(storedTaskStateByCheckpointID.entrySet())__			storedTaskStateByCheckpointID.clear()__		}__		return CompletableFuture.runAsync(_			() -> {_				_				syncDiscardLocalStateForCollection(statesCopy)___				_				LocalRecoveryDirectoryProvider directoryProvider = localRecoveryConfig.getLocalStateDirectoryProvider()__				for (int i = 0_ i < directoryProvider.allocationBaseDirsCount()_ ++i) {_					File subtaskBaseDirectory = directoryProvider.selectSubtaskBaseDirectory(i)__					try {_						deleteDirectory(subtaskBaseDirectory)__					} catch (IOException e) {_						LOG.warn("Exception when deleting local recovery subtask base directory {} in subtask ({} - {} - {})",_							subtaskBaseDirectory, jobID, jobVertexID, subtaskIndex, e)__					}_				}_			},_			discardExecutor)__	};disposes,the,state,of,all,local,snapshots,managed,by,this,object;override,public,completable,future,void,dispose,collection,map,entry,long,task,state,snapshot,states,copy,synchronized,lock,disposed,true,states,copy,new,array,list,stored,task,state,by,checkpoint,id,entry,set,stored,task,state,by,checkpoint,id,clear,return,completable,future,run,async,sync,discard,local,state,for,collection,states,copy,local,recovery,directory,provider,directory,provider,local,recovery,config,get,local,state,directory,provider,for,int,i,0,i,directory,provider,allocation,base,dirs,count,i,file,subtask,base,directory,directory,provider,select,subtask,base,directory,i,try,delete,directory,subtask,base,directory,catch,ioexception,e,log,warn,exception,when,deleting,local,recovery,subtask,base,directory,in,subtask,subtask,base,directory,job,id,job,vertex,id,subtask,index,e,discard,executor
TaskLocalStateStoreImpl -> private void pruneCheckpoints(LongPredicate pruningChecker, boolean breakOnceCheckerFalse);1519821266;Pruning the useless checkpoints, it should be called only when holding the {@link #lock}.;private void pruneCheckpoints(LongPredicate pruningChecker, boolean breakOnceCheckerFalse) {__		final List<Map.Entry<Long, TaskStateSnapshot>> toRemove = new ArrayList<>()___		synchronized (lock) {__			Iterator<Map.Entry<Long, TaskStateSnapshot>> entryIterator =_				storedTaskStateByCheckpointID.entrySet().iterator()___			while (entryIterator.hasNext()) {__				Map.Entry<Long, TaskStateSnapshot> snapshotEntry = entryIterator.next()__				long entryCheckpointId = snapshotEntry.getKey()___				if (pruningChecker.test(entryCheckpointId)) {_					toRemove.add(snapshotEntry)__					entryIterator.remove()__				} else if (breakOnceCheckerFalse) {_					break__				}_			}_		}__		asyncDiscardLocalStateForCollection(toRemove)__	};pruning,the,useless,checkpoints,it,should,be,called,only,when,holding,the,link,lock;private,void,prune,checkpoints,long,predicate,pruning,checker,boolean,break,once,checker,false,final,list,map,entry,long,task,state,snapshot,to,remove,new,array,list,synchronized,lock,iterator,map,entry,long,task,state,snapshot,entry,iterator,stored,task,state,by,checkpoint,id,entry,set,iterator,while,entry,iterator,has,next,map,entry,long,task,state,snapshot,snapshot,entry,entry,iterator,next,long,entry,checkpoint,id,snapshot,entry,get,key,if,pruning,checker,test,entry,checkpoint,id,to,remove,add,snapshot,entry,entry,iterator,remove,else,if,break,once,checker,false,break,async,discard,local,state,for,collection,to,remove
TaskLocalStateStoreImpl -> private void pruneCheckpoints(LongPredicate pruningChecker, boolean breakOnceCheckerFalse);1526544183;Pruning the useless checkpoints, it should be called only when holding the {@link #lock}.;private void pruneCheckpoints(LongPredicate pruningChecker, boolean breakOnceCheckerFalse) {__		final List<Map.Entry<Long, TaskStateSnapshot>> toRemove = new ArrayList<>()___		synchronized (lock) {__			Iterator<Map.Entry<Long, TaskStateSnapshot>> entryIterator =_				storedTaskStateByCheckpointID.entrySet().iterator()___			while (entryIterator.hasNext()) {__				Map.Entry<Long, TaskStateSnapshot> snapshotEntry = entryIterator.next()__				long entryCheckpointId = snapshotEntry.getKey()___				if (pruningChecker.test(entryCheckpointId)) {_					toRemove.add(snapshotEntry)__					entryIterator.remove()__				} else if (breakOnceCheckerFalse) {_					break__				}_			}_		}__		asyncDiscardLocalStateForCollection(toRemove)__	};pruning,the,useless,checkpoints,it,should,be,called,only,when,holding,the,link,lock;private,void,prune,checkpoints,long,predicate,pruning,checker,boolean,break,once,checker,false,final,list,map,entry,long,task,state,snapshot,to,remove,new,array,list,synchronized,lock,iterator,map,entry,long,task,state,snapshot,entry,iterator,stored,task,state,by,checkpoint,id,entry,set,iterator,while,entry,iterator,has,next,map,entry,long,task,state,snapshot,snapshot,entry,entry,iterator,next,long,entry,checkpoint,id,snapshot,entry,get,key,if,pruning,checker,test,entry,checkpoint,id,to,remove,add,snapshot,entry,entry,iterator,remove,else,if,break,once,checker,false,break,async,discard,local,state,for,collection,to,remove
TaskLocalStateStoreImpl -> private void pruneCheckpoints(LongPredicate pruningChecker, boolean breakOnceCheckerFalse);1526544184;Pruning the useless checkpoints, it should be called only when holding the {@link #lock}.;private void pruneCheckpoints(LongPredicate pruningChecker, boolean breakOnceCheckerFalse) {__		final List<Map.Entry<Long, TaskStateSnapshot>> toRemove = new ArrayList<>()___		synchronized (lock) {__			Iterator<Map.Entry<Long, TaskStateSnapshot>> entryIterator =_				storedTaskStateByCheckpointID.entrySet().iterator()___			while (entryIterator.hasNext()) {__				Map.Entry<Long, TaskStateSnapshot> snapshotEntry = entryIterator.next()__				long entryCheckpointId = snapshotEntry.getKey()___				if (pruningChecker.test(entryCheckpointId)) {_					toRemove.add(snapshotEntry)__					entryIterator.remove()__				} else if (breakOnceCheckerFalse) {_					break__				}_			}_		}__		asyncDiscardLocalStateForCollection(toRemove)__	};pruning,the,useless,checkpoints,it,should,be,called,only,when,holding,the,link,lock;private,void,prune,checkpoints,long,predicate,pruning,checker,boolean,break,once,checker,false,final,list,map,entry,long,task,state,snapshot,to,remove,new,array,list,synchronized,lock,iterator,map,entry,long,task,state,snapshot,entry,iterator,stored,task,state,by,checkpoint,id,entry,set,iterator,while,entry,iterator,has,next,map,entry,long,task,state,snapshot,snapshot,entry,entry,iterator,next,long,entry,checkpoint,id,snapshot,entry,get,key,if,pruning,checker,test,entry,checkpoint,id,to,remove,add,snapshot,entry,entry,iterator,remove,else,if,break,once,checker,false,break,async,discard,local,state,for,collection,to,remove
TaskLocalStateStoreImpl -> private void pruneCheckpoints(LongPredicate pruningChecker, boolean breakOnceCheckerFalse);1551195367;Pruning the useless checkpoints, it should be called only when holding the {@link #lock}.;private void pruneCheckpoints(LongPredicate pruningChecker, boolean breakOnceCheckerFalse) {__		final List<Map.Entry<Long, TaskStateSnapshot>> toRemove = new ArrayList<>()___		synchronized (lock) {__			Iterator<Map.Entry<Long, TaskStateSnapshot>> entryIterator =_				storedTaskStateByCheckpointID.entrySet().iterator()___			while (entryIterator.hasNext()) {__				Map.Entry<Long, TaskStateSnapshot> snapshotEntry = entryIterator.next()__				long entryCheckpointId = snapshotEntry.getKey()___				if (pruningChecker.test(entryCheckpointId)) {_					toRemove.add(snapshotEntry)__					entryIterator.remove()__				} else if (breakOnceCheckerFalse) {_					break__				}_			}_		}__		asyncDiscardLocalStateForCollection(toRemove)__	};pruning,the,useless,checkpoints,it,should,be,called,only,when,holding,the,link,lock;private,void,prune,checkpoints,long,predicate,pruning,checker,boolean,break,once,checker,false,final,list,map,entry,long,task,state,snapshot,to,remove,new,array,list,synchronized,lock,iterator,map,entry,long,task,state,snapshot,entry,iterator,stored,task,state,by,checkpoint,id,entry,set,iterator,while,entry,iterator,has,next,map,entry,long,task,state,snapshot,snapshot,entry,entry,iterator,next,long,entry,checkpoint,id,snapshot,entry,get,key,if,pruning,checker,test,entry,checkpoint,id,to,remove,add,snapshot,entry,entry,iterator,remove,else,if,break,once,checker,false,break,async,discard,local,state,for,collection,to,remove
TaskLocalStateStoreImpl -> private void discardLocalStateForCheckpoint(long checkpointID, TaskStateSnapshot o);1519568061;Helper method that discards state objects with an executor and reports exceptions to the log.;private void discardLocalStateForCheckpoint(long checkpointID, TaskStateSnapshot o) {__		try {_			if (LOG.isTraceEnabled()) {_				LOG.trace("Discarding local task state snapshot of checkpoint {} for {}/{}/{}.",_					checkpointID, jobID, jobVertexID, subtaskIndex)__			} else {_				LOG.debug("Discarding local task state snapshot {} of checkpoint {} for {}/{}/{}.",_					o, checkpointID, jobID, jobVertexID, subtaskIndex)__			}_			o.discardState()__		} catch (Exception discardEx) {_			LOG.warn("Exception while discarding local task state snapshot of checkpoint " + checkpointID + ".", discardEx)__		}__		LocalRecoveryDirectoryProvider directoryProvider = localRecoveryConfig.getLocalStateDirectoryProvider()__		File checkpointDir = directoryProvider.subtaskSpecificCheckpointDirectory(checkpointID)__		LOG.debug("Deleting local state directory {} of checkpoint {} for {}/{}/{}/{}.",_			checkpointDir, checkpointID, jobID, jobVertexID, subtaskIndex)__		try {_			deleteDirectory(checkpointDir)__		} catch (IOException ex) {_			LOG.warn("Exception while deleting local state directory of checkpoint " + checkpointID + ".", ex)__		}_	};helper,method,that,discards,state,objects,with,an,executor,and,reports,exceptions,to,the,log;private,void,discard,local,state,for,checkpoint,long,checkpoint,id,task,state,snapshot,o,try,if,log,is,trace,enabled,log,trace,discarding,local,task,state,snapshot,of,checkpoint,for,checkpoint,id,job,id,job,vertex,id,subtask,index,else,log,debug,discarding,local,task,state,snapshot,of,checkpoint,for,o,checkpoint,id,job,id,job,vertex,id,subtask,index,o,discard,state,catch,exception,discard,ex,log,warn,exception,while,discarding,local,task,state,snapshot,of,checkpoint,checkpoint,id,discard,ex,local,recovery,directory,provider,directory,provider,local,recovery,config,get,local,state,directory,provider,file,checkpoint,dir,directory,provider,subtask,specific,checkpoint,directory,checkpoint,id,log,debug,deleting,local,state,directory,of,checkpoint,for,checkpoint,dir,checkpoint,id,job,id,job,vertex,id,subtask,index,try,delete,directory,checkpoint,dir,catch,ioexception,ex,log,warn,exception,while,deleting,local,state,directory,of,checkpoint,checkpoint,id,ex
TaskLocalStateStoreImpl -> private void discardLocalStateForCheckpoint(long checkpointID, TaskStateSnapshot o);1519741691;Helper method that discards state objects with an executor and reports exceptions to the log.;private void discardLocalStateForCheckpoint(long checkpointID, TaskStateSnapshot o) {__		if (LOG.isTraceEnabled()) {_			LOG.trace("Discarding local task state snapshot of checkpoint {} for subtask ({} - {} - {}).",_				checkpointID, jobID, jobVertexID, subtaskIndex)__		} else {_			LOG.debug("Discarding local task state snapshot {} of checkpoint {} for subtask ({} - {} - {}).",_				o, checkpointID, jobID, jobVertexID, subtaskIndex)__		}__		try {_			o.discardState()__		} catch (Exception discardEx) {_			LOG.warn("Exception while discarding local task state snapshot of checkpoint {} in subtask ({} - {} - {}).",_				checkpointID, jobID, jobVertexID, subtaskIndex, discardEx)__		}__		LocalRecoveryDirectoryProvider directoryProvider = localRecoveryConfig.getLocalStateDirectoryProvider()__		File checkpointDir = directoryProvider.subtaskSpecificCheckpointDirectory(checkpointID)___		LOG.debug("Deleting local state directory {} of checkpoint {} for subtask ({} - {} - {}).",_			checkpointDir, checkpointID, jobID, jobVertexID, subtaskIndex)___		try {_			deleteDirectory(checkpointDir)__		} catch (IOException ex) {_			LOG.warn("Exception while deleting local state directory of checkpoint {} in subtask ({} - {} - {}).",_				checkpointID, jobID, jobVertexID, subtaskIndex, ex)__		}_	};helper,method,that,discards,state,objects,with,an,executor,and,reports,exceptions,to,the,log;private,void,discard,local,state,for,checkpoint,long,checkpoint,id,task,state,snapshot,o,if,log,is,trace,enabled,log,trace,discarding,local,task,state,snapshot,of,checkpoint,for,subtask,checkpoint,id,job,id,job,vertex,id,subtask,index,else,log,debug,discarding,local,task,state,snapshot,of,checkpoint,for,subtask,o,checkpoint,id,job,id,job,vertex,id,subtask,index,try,o,discard,state,catch,exception,discard,ex,log,warn,exception,while,discarding,local,task,state,snapshot,of,checkpoint,in,subtask,checkpoint,id,job,id,job,vertex,id,subtask,index,discard,ex,local,recovery,directory,provider,directory,provider,local,recovery,config,get,local,state,directory,provider,file,checkpoint,dir,directory,provider,subtask,specific,checkpoint,directory,checkpoint,id,log,debug,deleting,local,state,directory,of,checkpoint,for,subtask,checkpoint,dir,checkpoint,id,job,id,job,vertex,id,subtask,index,try,delete,directory,checkpoint,dir,catch,ioexception,ex,log,warn,exception,while,deleting,local,state,directory,of,checkpoint,in,subtask,checkpoint,id,job,id,job,vertex,id,subtask,index,ex
TaskLocalStateStoreImpl -> private void discardLocalStateForCheckpoint(long checkpointID, TaskStateSnapshot o);1519821266;Helper method that discards state objects with an executor and reports exceptions to the log.;private void discardLocalStateForCheckpoint(long checkpointID, TaskStateSnapshot o) {__		if (LOG.isTraceEnabled()) {_			LOG.trace("Discarding local task state snapshot of checkpoint {} for subtask ({} - {} - {}).",_				checkpointID, jobID, jobVertexID, subtaskIndex)__		} else {_			LOG.debug("Discarding local task state snapshot {} of checkpoint {} for subtask ({} - {} - {}).",_				o, checkpointID, jobID, jobVertexID, subtaskIndex)__		}__		try {_			o.discardState()__		} catch (Exception discardEx) {_			LOG.warn("Exception while discarding local task state snapshot of checkpoint {} in subtask ({} - {} - {}).",_				checkpointID, jobID, jobVertexID, subtaskIndex, discardEx)__		}__		LocalRecoveryDirectoryProvider directoryProvider = localRecoveryConfig.getLocalStateDirectoryProvider()__		File checkpointDir = directoryProvider.subtaskSpecificCheckpointDirectory(checkpointID)___		LOG.debug("Deleting local state directory {} of checkpoint {} for subtask ({} - {} - {}).",_			checkpointDir, checkpointID, jobID, jobVertexID, subtaskIndex)___		try {_			deleteDirectory(checkpointDir)__		} catch (IOException ex) {_			LOG.warn("Exception while deleting local state directory of checkpoint {} in subtask ({} - {} - {}).",_				checkpointID, jobID, jobVertexID, subtaskIndex, ex)__		}_	};helper,method,that,discards,state,objects,with,an,executor,and,reports,exceptions,to,the,log;private,void,discard,local,state,for,checkpoint,long,checkpoint,id,task,state,snapshot,o,if,log,is,trace,enabled,log,trace,discarding,local,task,state,snapshot,of,checkpoint,for,subtask,checkpoint,id,job,id,job,vertex,id,subtask,index,else,log,debug,discarding,local,task,state,snapshot,of,checkpoint,for,subtask,o,checkpoint,id,job,id,job,vertex,id,subtask,index,try,o,discard,state,catch,exception,discard,ex,log,warn,exception,while,discarding,local,task,state,snapshot,of,checkpoint,in,subtask,checkpoint,id,job,id,job,vertex,id,subtask,index,discard,ex,local,recovery,directory,provider,directory,provider,local,recovery,config,get,local,state,directory,provider,file,checkpoint,dir,directory,provider,subtask,specific,checkpoint,directory,checkpoint,id,log,debug,deleting,local,state,directory,of,checkpoint,for,subtask,checkpoint,dir,checkpoint,id,job,id,job,vertex,id,subtask,index,try,delete,directory,checkpoint,dir,catch,ioexception,ex,log,warn,exception,while,deleting,local,state,directory,of,checkpoint,in,subtask,checkpoint,id,job,id,job,vertex,id,subtask,index,ex
TaskLocalStateStoreImpl -> private void discardLocalStateForCheckpoint(long checkpointID, TaskStateSnapshot o);1526544183;Helper method that discards state objects with an executor and reports exceptions to the log.;private void discardLocalStateForCheckpoint(long checkpointID, TaskStateSnapshot o) {__		if (LOG.isTraceEnabled()) {_			LOG.trace("Discarding local task state snapshot of checkpoint {} for subtask ({} - {} - {}).",_				checkpointID, jobID, jobVertexID, subtaskIndex)__		} else {_			LOG.debug("Discarding local task state snapshot {} of checkpoint {} for subtask ({} - {} - {}).",_				o, checkpointID, jobID, jobVertexID, subtaskIndex)__		}__		try {_			o.discardState()__		} catch (Exception discardEx) {_			LOG.warn("Exception while discarding local task state snapshot of checkpoint {} in subtask ({} - {} - {}).",_				checkpointID, jobID, jobVertexID, subtaskIndex, discardEx)__		}__		LocalRecoveryDirectoryProvider directoryProvider = localRecoveryConfig.getLocalStateDirectoryProvider()__		File checkpointDir = directoryProvider.subtaskSpecificCheckpointDirectory(checkpointID)___		LOG.debug("Deleting local state directory {} of checkpoint {} for subtask ({} - {} - {}).",_			checkpointDir, checkpointID, jobID, jobVertexID, subtaskIndex)___		try {_			deleteDirectory(checkpointDir)__		} catch (IOException ex) {_			LOG.warn("Exception while deleting local state directory of checkpoint {} in subtask ({} - {} - {}).",_				checkpointID, jobID, jobVertexID, subtaskIndex, ex)__		}_	};helper,method,that,discards,state,objects,with,an,executor,and,reports,exceptions,to,the,log;private,void,discard,local,state,for,checkpoint,long,checkpoint,id,task,state,snapshot,o,if,log,is,trace,enabled,log,trace,discarding,local,task,state,snapshot,of,checkpoint,for,subtask,checkpoint,id,job,id,job,vertex,id,subtask,index,else,log,debug,discarding,local,task,state,snapshot,of,checkpoint,for,subtask,o,checkpoint,id,job,id,job,vertex,id,subtask,index,try,o,discard,state,catch,exception,discard,ex,log,warn,exception,while,discarding,local,task,state,snapshot,of,checkpoint,in,subtask,checkpoint,id,job,id,job,vertex,id,subtask,index,discard,ex,local,recovery,directory,provider,directory,provider,local,recovery,config,get,local,state,directory,provider,file,checkpoint,dir,directory,provider,subtask,specific,checkpoint,directory,checkpoint,id,log,debug,deleting,local,state,directory,of,checkpoint,for,subtask,checkpoint,dir,checkpoint,id,job,id,job,vertex,id,subtask,index,try,delete,directory,checkpoint,dir,catch,ioexception,ex,log,warn,exception,while,deleting,local,state,directory,of,checkpoint,in,subtask,checkpoint,id,job,id,job,vertex,id,subtask,index,ex
TaskLocalStateStoreImpl -> private void discardLocalStateForCheckpoint(long checkpointID, TaskStateSnapshot o);1526544184;Helper method that discards state objects with an executor and reports exceptions to the log.;private void discardLocalStateForCheckpoint(long checkpointID, TaskStateSnapshot o) {__		if (LOG.isTraceEnabled()) {_			LOG.trace("Discarding local task state snapshot of checkpoint {} for subtask ({} - {} - {}).",_				checkpointID, jobID, jobVertexID, subtaskIndex)__		} else {_			LOG.debug("Discarding local task state snapshot {} of checkpoint {} for subtask ({} - {} - {}).",_				o, checkpointID, jobID, jobVertexID, subtaskIndex)__		}__		try {_			o.discardState()__		} catch (Exception discardEx) {_			LOG.warn("Exception while discarding local task state snapshot of checkpoint {} in subtask ({} - {} - {}).",_				checkpointID, jobID, jobVertexID, subtaskIndex, discardEx)__		}__		LocalRecoveryDirectoryProvider directoryProvider = localRecoveryConfig.getLocalStateDirectoryProvider()__		File checkpointDir = directoryProvider.subtaskSpecificCheckpointDirectory(checkpointID)___		LOG.debug("Deleting local state directory {} of checkpoint {} for subtask ({} - {} - {}).",_			checkpointDir, checkpointID, jobID, jobVertexID, subtaskIndex)___		try {_			deleteDirectory(checkpointDir)__		} catch (IOException ex) {_			LOG.warn("Exception while deleting local state directory of checkpoint {} in subtask ({} - {} - {}).",_				checkpointID, jobID, jobVertexID, subtaskIndex, ex)__		}_	};helper,method,that,discards,state,objects,with,an,executor,and,reports,exceptions,to,the,log;private,void,discard,local,state,for,checkpoint,long,checkpoint,id,task,state,snapshot,o,if,log,is,trace,enabled,log,trace,discarding,local,task,state,snapshot,of,checkpoint,for,subtask,checkpoint,id,job,id,job,vertex,id,subtask,index,else,log,debug,discarding,local,task,state,snapshot,of,checkpoint,for,subtask,o,checkpoint,id,job,id,job,vertex,id,subtask,index,try,o,discard,state,catch,exception,discard,ex,log,warn,exception,while,discarding,local,task,state,snapshot,of,checkpoint,in,subtask,checkpoint,id,job,id,job,vertex,id,subtask,index,discard,ex,local,recovery,directory,provider,directory,provider,local,recovery,config,get,local,state,directory,provider,file,checkpoint,dir,directory,provider,subtask,specific,checkpoint,directory,checkpoint,id,log,debug,deleting,local,state,directory,of,checkpoint,for,subtask,checkpoint,dir,checkpoint,id,job,id,job,vertex,id,subtask,index,try,delete,directory,checkpoint,dir,catch,ioexception,ex,log,warn,exception,while,deleting,local,state,directory,of,checkpoint,in,subtask,checkpoint,id,job,id,job,vertex,id,subtask,index,ex
TaskLocalStateStoreImpl -> private void discardLocalStateForCheckpoint(long checkpointID, TaskStateSnapshot o);1551195367;Helper method that discards state objects with an executor and reports exceptions to the log.;private void discardLocalStateForCheckpoint(long checkpointID, TaskStateSnapshot o) {__		if (LOG.isTraceEnabled()) {_			LOG.trace("Discarding local task state snapshot of checkpoint {} for subtask ({} - {} - {}).",_				checkpointID, jobID, jobVertexID, subtaskIndex)__		} else {_			LOG.debug("Discarding local task state snapshot {} of checkpoint {} for subtask ({} - {} - {}).",_				o, checkpointID, jobID, jobVertexID, subtaskIndex)__		}__		try {_			o.discardState()__		} catch (Exception discardEx) {_			LOG.warn("Exception while discarding local task state snapshot of checkpoint {} in subtask ({} - {} - {}).",_				checkpointID, jobID, jobVertexID, subtaskIndex, discardEx)__		}__		LocalRecoveryDirectoryProvider directoryProvider = localRecoveryConfig.getLocalStateDirectoryProvider()__		File checkpointDir = directoryProvider.subtaskSpecificCheckpointDirectory(checkpointID)___		LOG.debug("Deleting local state directory {} of checkpoint {} for subtask ({} - {} - {}).",_			checkpointDir, checkpointID, jobID, jobVertexID, subtaskIndex)___		try {_			deleteDirectory(checkpointDir)__		} catch (IOException ex) {_			LOG.warn("Exception while deleting local state directory of checkpoint {} in subtask ({} - {} - {}).",_				checkpointID, jobID, jobVertexID, subtaskIndex, ex)__		}_	};helper,method,that,discards,state,objects,with,an,executor,and,reports,exceptions,to,the,log;private,void,discard,local,state,for,checkpoint,long,checkpoint,id,task,state,snapshot,o,if,log,is,trace,enabled,log,trace,discarding,local,task,state,snapshot,of,checkpoint,for,subtask,checkpoint,id,job,id,job,vertex,id,subtask,index,else,log,debug,discarding,local,task,state,snapshot,of,checkpoint,for,subtask,o,checkpoint,id,job,id,job,vertex,id,subtask,index,try,o,discard,state,catch,exception,discard,ex,log,warn,exception,while,discarding,local,task,state,snapshot,of,checkpoint,in,subtask,checkpoint,id,job,id,job,vertex,id,subtask,index,discard,ex,local,recovery,directory,provider,directory,provider,local,recovery,config,get,local,state,directory,provider,file,checkpoint,dir,directory,provider,subtask,specific,checkpoint,directory,checkpoint,id,log,debug,deleting,local,state,directory,of,checkpoint,for,subtask,checkpoint,dir,checkpoint,id,job,id,job,vertex,id,subtask,index,try,delete,directory,checkpoint,dir,catch,ioexception,ex,log,warn,exception,while,deleting,local,state,directory,of,checkpoint,in,subtask,checkpoint,id,job,id,job,vertex,id,subtask,index,ex
TaskLocalStateStoreImpl -> public CompletableFuture<Void> dispose();1519568061;Disposes the state of all local snapshots managed by this object.;public CompletableFuture<Void> dispose() {__		Collection<Map.Entry<Long, TaskStateSnapshot>> statesCopy___		synchronized (lock) {_			disposed = true__			statesCopy = new ArrayList<>(storedTaskStateByCheckpointID.entrySet())__			storedTaskStateByCheckpointID.clear()__		}__		return CompletableFuture.runAsync(_			() -> {_				_				syncDiscardLocalStateForCollection(statesCopy)___				_				LocalRecoveryDirectoryProvider directoryProvider = localRecoveryConfig.getLocalStateDirectoryProvider()__				for (int i = 0_ i < directoryProvider.allocationBaseDirsCount()_ ++i) {_					File subtaskBaseDirectory = directoryProvider.selectSubtaskBaseDirectory(i)__					try {_						deleteDirectory(subtaskBaseDirectory)__					} catch (IOException e) {_						LOG.warn("Exception when deleting local recovery subtask base dir: " + subtaskBaseDirectory, e)__					}_				}_			},_			discardExecutor)__	};disposes,the,state,of,all,local,snapshots,managed,by,this,object;public,completable,future,void,dispose,collection,map,entry,long,task,state,snapshot,states,copy,synchronized,lock,disposed,true,states,copy,new,array,list,stored,task,state,by,checkpoint,id,entry,set,stored,task,state,by,checkpoint,id,clear,return,completable,future,run,async,sync,discard,local,state,for,collection,states,copy,local,recovery,directory,provider,directory,provider,local,recovery,config,get,local,state,directory,provider,for,int,i,0,i,directory,provider,allocation,base,dirs,count,i,file,subtask,base,directory,directory,provider,select,subtask,base,directory,i,try,delete,directory,subtask,base,directory,catch,ioexception,e,log,warn,exception,when,deleting,local,recovery,subtask,base,dir,subtask,base,directory,e,discard,executor
TaskLocalStateStoreImpl -> public CompletableFuture<Void> dispose();1519741691;Disposes the state of all local snapshots managed by this object.;public CompletableFuture<Void> dispose() {__		Collection<Map.Entry<Long, TaskStateSnapshot>> statesCopy___		synchronized (lock) {_			disposed = true__			statesCopy = new ArrayList<>(storedTaskStateByCheckpointID.entrySet())__			storedTaskStateByCheckpointID.clear()__		}__		return CompletableFuture.runAsync(_			() -> {_				_				syncDiscardLocalStateForCollection(statesCopy)___				_				LocalRecoveryDirectoryProvider directoryProvider = localRecoveryConfig.getLocalStateDirectoryProvider()__				for (int i = 0_ i < directoryProvider.allocationBaseDirsCount()_ ++i) {_					File subtaskBaseDirectory = directoryProvider.selectSubtaskBaseDirectory(i)__					try {_						deleteDirectory(subtaskBaseDirectory)__					} catch (IOException e) {_						LOG.warn("Exception when deleting local recovery subtask base directory {} in subtask ({} - {} - {})",_							subtaskBaseDirectory, jobID, jobVertexID, subtaskIndex, e)__					}_				}_			},_			discardExecutor)__	};disposes,the,state,of,all,local,snapshots,managed,by,this,object;public,completable,future,void,dispose,collection,map,entry,long,task,state,snapshot,states,copy,synchronized,lock,disposed,true,states,copy,new,array,list,stored,task,state,by,checkpoint,id,entry,set,stored,task,state,by,checkpoint,id,clear,return,completable,future,run,async,sync,discard,local,state,for,collection,states,copy,local,recovery,directory,provider,directory,provider,local,recovery,config,get,local,state,directory,provider,for,int,i,0,i,directory,provider,allocation,base,dirs,count,i,file,subtask,base,directory,directory,provider,select,subtask,base,directory,i,try,delete,directory,subtask,base,directory,catch,ioexception,e,log,warn,exception,when,deleting,local,recovery,subtask,base,directory,in,subtask,subtask,base,directory,job,id,job,vertex,id,subtask,index,e,discard,executor
TaskLocalStateStoreImpl -> public CompletableFuture<Void> dispose();1519821266;Disposes the state of all local snapshots managed by this object.;public CompletableFuture<Void> dispose() {__		Collection<Map.Entry<Long, TaskStateSnapshot>> statesCopy___		synchronized (lock) {_			disposed = true__			statesCopy = new ArrayList<>(storedTaskStateByCheckpointID.entrySet())__			storedTaskStateByCheckpointID.clear()__		}__		return CompletableFuture.runAsync(_			() -> {_				_				syncDiscardLocalStateForCollection(statesCopy)___				_				LocalRecoveryDirectoryProvider directoryProvider = localRecoveryConfig.getLocalStateDirectoryProvider()__				for (int i = 0_ i < directoryProvider.allocationBaseDirsCount()_ ++i) {_					File subtaskBaseDirectory = directoryProvider.selectSubtaskBaseDirectory(i)__					try {_						deleteDirectory(subtaskBaseDirectory)__					} catch (IOException e) {_						LOG.warn("Exception when deleting local recovery subtask base directory {} in subtask ({} - {} - {})",_							subtaskBaseDirectory, jobID, jobVertexID, subtaskIndex, e)__					}_				}_			},_			discardExecutor)__	};disposes,the,state,of,all,local,snapshots,managed,by,this,object;public,completable,future,void,dispose,collection,map,entry,long,task,state,snapshot,states,copy,synchronized,lock,disposed,true,states,copy,new,array,list,stored,task,state,by,checkpoint,id,entry,set,stored,task,state,by,checkpoint,id,clear,return,completable,future,run,async,sync,discard,local,state,for,collection,states,copy,local,recovery,directory,provider,directory,provider,local,recovery,config,get,local,state,directory,provider,for,int,i,0,i,directory,provider,allocation,base,dirs,count,i,file,subtask,base,directory,directory,provider,select,subtask,base,directory,i,try,delete,directory,subtask,base,directory,catch,ioexception,e,log,warn,exception,when,deleting,local,recovery,subtask,base,directory,in,subtask,subtask,base,directory,job,id,job,vertex,id,subtask,index,e,discard,executor
