# id;timestamp;commentText;codeText;commentWords;codeWords
MiniCluster -> public MiniCluster(MiniClusterConfiguration config);1482522863;@param config The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration config) {_		this.config = checkNotNull(config, "config may not be null")__	};param,config,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,config,this,config,check,not,null,config,config,may,not,be,null
MiniCluster -> public MiniCluster(MiniClusterConfiguration config);1482522863;@param config The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration config) {_		this.config = checkNotNull(config, "config may not be null")__	};param,config,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,config,this,config,check,not,null,config,config,may,not,be,null
MiniCluster -> public MiniCluster(MiniClusterConfiguration config);1482522864;@param config The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration config) {_		this.config = checkNotNull(config, "config may not be null")__	};param,config,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,config,this,config,check,not,null,config,config,may,not,be,null
MiniCluster -> public MiniCluster(MiniClusterConfiguration config);1482522864;Creates a new Flink mini cluster based on the given configuration.__@param config The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration config) {_		this.config = checkNotNull(config, "config may not be null")__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,config,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,config,this,config,check,not,null,config,config,may,not,be,null
MiniCluster -> public MiniCluster(MiniClusterConfiguration config);1482522864;Creates a new Flink mini cluster based on the given configuration.__@param config The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration config) {_		this.config = checkNotNull(config, "config may not be null")__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,config,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,config,this,config,check,not,null,config,config,may,not,be,null
MiniCluster -> public MiniCluster(MiniClusterConfiguration config);1482522864;Creates a new Flink mini cluster based on the given configuration.__@param config The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration config) {_		this.config = checkNotNull(config, "config may not be null")__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,config,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,config,this,config,check,not,null,config,config,may,not,be,null
MiniCluster -> public MiniCluster(MiniClusterConfiguration config);1482522866;Creates a new Flink mini cluster based on the given configuration.__@param config The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration config) {_		this.config = checkNotNull(config, "config may not be null")__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,config,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,config,this,config,check,not,null,config,config,may,not,be,null
MiniCluster -> public MiniCluster(MiniClusterConfiguration config);1482522866;Creates a new Flink mini cluster based on the given configuration.__@param config The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration config) {_		this.config = checkNotNull(config, "config may not be null")__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,config,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,config,this,config,check,not,null,config,config,may,not,be,null
MiniCluster -> public MiniCluster(MiniClusterConfiguration config);1482522866;Creates a new Flink mini cluster based on the given configuration.__@param config The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration config) {_		this.config = checkNotNull(config, "config may not be null")__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,config,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,config,this,config,check,not,null,config,config,may,not,be,null
MiniCluster -> public MiniCluster(MiniClusterConfiguration config);1482522867;Creates a new Flink mini cluster based on the given configuration.__@param config The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration config) {_		this.config = checkNotNull(config, "config may not be null")__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,config,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,config,this,config,check,not,null,config,config,may,not,be,null
MiniCluster -> public MiniCluster(MiniClusterConfiguration config);1489766405;Creates a new Flink mini cluster based on the given configuration.__@param config The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration config) {_		this.config = checkNotNull(config, "config may not be null")__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,config,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,config,this,config,check,not,null,config,config,may,not,be,null
MiniCluster -> public MiniCluster(MiniClusterConfiguration config);1490273924;Creates a new Flink mini cluster based on the given configuration.__@param config The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration config) {_		this.config = checkNotNull(config, "config may not be null")__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,config,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,config,this,config,check,not,null,config,config,may,not,be,null
MiniCluster -> public MiniCluster(MiniClusterConfiguration config);1490273924;Creates a new Flink mini cluster based on the given configuration.__@param config The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration config) {_		this.config = checkNotNull(config, "config may not be null")__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,config,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,config,this,config,check,not,null,config,config,may,not,be,null
MiniCluster -> public MiniCluster(MiniClusterConfiguration config);1493146240;Creates a new Flink mini cluster based on the given configuration.__@param config The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration config) {_		this.config = checkNotNull(config, "config may not be null")__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,config,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,config,this,config,check,not,null,config,config,may,not,be,null
MiniCluster -> public MiniCluster(MiniClusterConfiguration config);1493975155;Creates a new Flink mini cluster based on the given configuration.__@param config The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration config) {_		this.config = checkNotNull(config, "config may not be null")__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,config,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,config,this,config,check,not,null,config,config,may,not,be,null
MiniCluster -> public MiniCluster(MiniClusterConfiguration config);1499254138;Creates a new Flink mini cluster based on the given configuration.__@param config The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration config) {_		this.config = checkNotNull(config, "config may not be null")__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,config,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,config,this,config,check,not,null,config,config,may,not,be,null
MiniCluster -> public MiniCluster(MiniClusterConfiguration config);1499789965;Creates a new Flink mini cluster based on the given configuration.__@param config The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration config) {_		this.config = checkNotNull(config, "config may not be null")__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,config,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,config,this,config,check,not,null,config,config,may,not,be,null
MiniCluster -> public MiniCluster(MiniClusterConfiguration config);1501437265;Creates a new Flink mini cluster based on the given configuration.__@param config The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration config) {_		this.config = checkNotNull(config, "config may not be null")__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,config,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,config,this,config,check,not,null,config,config,may,not,be,null
MiniCluster -> public MiniCluster(MiniClusterConfiguration config);1501660818;Creates a new Flink mini cluster based on the given configuration.__@param config The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration config) {_		this.config = checkNotNull(config, "config may not be null")__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,config,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,config,this,config,check,not,null,config,config,may,not,be,null
MiniCluster -> public MiniCluster(MiniClusterConfiguration config);1504477043;Creates a new Flink mini cluster based on the given configuration.__@param config The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration config) {_		this.config = checkNotNull(config, "config may not be null")__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,config,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,config,this,config,check,not,null,config,config,may,not,be,null
MiniCluster -> public MiniCluster(MiniClusterConfiguration config);1504525441;Creates a new Flink mini cluster based on the given configuration.__@param config The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration config) {_		this.config = checkNotNull(config, "config may not be null")__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,config,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,config,this,config,check,not,null,config,config,may,not,be,null
MiniCluster -> public MiniCluster(MiniClusterConfiguration config);1504607872;Creates a new Flink mini cluster based on the given configuration.__@param config The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration config) {_		this.config = checkNotNull(config, "config may not be null")__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,config,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,config,this,config,check,not,null,config,config,may,not,be,null
MiniCluster -> public MiniCluster(MiniClusterConfiguration config);1507212387;Creates a new Flink mini cluster based on the given configuration.__@param config The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration config) {_		this.config = checkNotNull(config, "config may not be null")__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,config,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,config,this,config,check,not,null,config,config,may,not,be,null
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1519249745;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1519406526;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1519406527;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1519406529;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1519510773;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1519512293;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1519977151;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1519977152;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1519977152;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1519977155;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1520032992;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1521379500;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1521385093;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1521385094;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1521537266;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1521537266;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1521537266;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1521804758;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1522132482;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1522681180;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1522759723;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1522825170;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1525420604;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		uploadUserArtifacts(job)___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,upload,user,artifacts,job,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1525452496;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		uploadUserArtifacts(job)___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,upload,user,artifacts,job,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1526334048;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		uploadUserArtifacts(job)___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,upload,user,artifacts,job,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1526336566;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		uploadUserArtifacts(job)___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,upload,user,artifacts,job,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1529682304;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		uploadUserArtifacts(job)___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,upload,user,artifacts,job,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1530181266;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1530644925;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1533555608;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1538042094;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1539169204;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1539176686;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1539176687;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1539176687;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1539582211;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1539787538;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1545326469;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1547675340;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1547675341;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1548249770;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1548326020;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1548846699;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1548866156;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1548966387;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1549360057;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1549360057;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1549360057;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1549360057;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1549360057;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1549360058;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1550005040;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1550069788;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1550228244;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1550483152;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException;1550823915;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		try {_			submissionFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e))__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,try,submission,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,exception,utils,strip,execution,exception,e
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException;1482522863;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException {_		checkNotNull(job, "job is null")___		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			jobDispatcher.runDetached(job)__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,check,not,null,job,job,is,null,synchronized,lock,check,state,running,mini,cluster,is,not,running,job,dispatcher,run,detached,job
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException;1482522863;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException {_		checkNotNull(job, "job is null")___		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			jobDispatcher.runDetached(job)__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,check,not,null,job,job,is,null,synchronized,lock,check,state,running,mini,cluster,is,not,running,job,dispatcher,run,detached,job
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException;1482522864;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException {_		checkNotNull(job, "job is null")___		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			jobDispatcher.runDetached(job)__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,check,not,null,job,job,is,null,synchronized,lock,check,state,running,mini,cluster,is,not,running,job,dispatcher,run,detached,job
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException;1482522864;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException {_		checkNotNull(job, "job is null")___		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			jobDispatcher.runDetached(job)__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,check,not,null,job,job,is,null,synchronized,lock,check,state,running,mini,cluster,is,not,running,job,dispatcher,run,detached,job
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException;1482522864;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException {_		checkNotNull(job, "job is null")___		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			jobDispatcher.runDetached(job)__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,check,not,null,job,job,is,null,synchronized,lock,check,state,running,mini,cluster,is,not,running,job,dispatcher,run,detached,job
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException;1482522864;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException {_		checkNotNull(job, "job is null")___		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			jobDispatcher.runDetached(job)__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,check,not,null,job,job,is,null,synchronized,lock,check,state,running,mini,cluster,is,not,running,job,dispatcher,run,detached,job
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException;1482522866;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException {_		checkNotNull(job, "job is null")___		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			jobDispatcher.runDetached(job)__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,check,not,null,job,job,is,null,synchronized,lock,check,state,running,mini,cluster,is,not,running,job,dispatcher,run,detached,job
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException;1482522866;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException {_		checkNotNull(job, "job is null")___		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			jobDispatcher.runDetached(job)__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,check,not,null,job,job,is,null,synchronized,lock,check,state,running,mini,cluster,is,not,running,job,dispatcher,run,detached,job
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException;1482522866;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException {_		checkNotNull(job, "job is null")___		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			jobDispatcher.runDetached(job)__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,check,not,null,job,job,is,null,synchronized,lock,check,state,running,mini,cluster,is,not,running,job,dispatcher,run,detached,job
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException;1482522867;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException {_		checkNotNull(job, "job is null")___		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			jobDispatcher.runDetached(job)__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,check,not,null,job,job,is,null,synchronized,lock,check,state,running,mini,cluster,is,not,running,job,dispatcher,run,detached,job
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException;1489766405;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException {_		checkNotNull(job, "job is null")___		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			jobDispatcher.runDetached(job)__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,check,not,null,job,job,is,null,synchronized,lock,check,state,running,mini,cluster,is,not,running,job,dispatcher,run,detached,job
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException;1490273924;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException {_		checkNotNull(job, "job is null")___		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			jobDispatcher.runDetached(job)__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,check,not,null,job,job,is,null,synchronized,lock,check,state,running,mini,cluster,is,not,running,job,dispatcher,run,detached,job
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException;1490273924;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException {_		checkNotNull(job, "job is null")___		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			jobDispatcher.runDetached(job)__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,check,not,null,job,job,is,null,synchronized,lock,check,state,running,mini,cluster,is,not,running,job,dispatcher,run,detached,job
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException;1493146240;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException {_		checkNotNull(job, "job is null")___		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			jobDispatcher.runDetached(job)__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,check,not,null,job,job,is,null,synchronized,lock,check,state,running,mini,cluster,is,not,running,job,dispatcher,run,detached,job
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException;1493975155;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException {_		checkNotNull(job, "job is null")___		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			jobDispatcher.runDetached(job)__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,check,not,null,job,job,is,null,synchronized,lock,check,state,running,mini,cluster,is,not,running,job,dispatcher,run,detached,job
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException;1499254138;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException {_		checkNotNull(job, "job is null")___		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			jobDispatcher.runDetached(job)__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,check,not,null,job,job,is,null,synchronized,lock,check,state,running,mini,cluster,is,not,running,job,dispatcher,run,detached,job
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException;1499789965;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException {_		checkNotNull(job, "job is null")___		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			jobDispatcher.runDetached(job)__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,check,not,null,job,job,is,null,synchronized,lock,check,state,running,mini,cluster,is,not,running,job,dispatcher,run,detached,job
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException;1501437265;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException {_		checkNotNull(job, "job is null")___		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			jobDispatcher.runDetached(job)__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,check,not,null,job,job,is,null,synchronized,lock,check,state,running,mini,cluster,is,not,running,job,dispatcher,run,detached,job
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException;1501660818;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException {_		checkNotNull(job, "job is null")___		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			jobDispatcher.runDetached(job)__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,check,not,null,job,job,is,null,synchronized,lock,check,state,running,mini,cluster,is,not,running,job,dispatcher,run,detached,job
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException;1504477043;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException {_		checkNotNull(job, "job is null")___		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			jobDispatcher.runDetached(job)__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,check,not,null,job,job,is,null,synchronized,lock,check,state,running,mini,cluster,is,not,running,job,dispatcher,run,detached,job
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException;1504525441;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException {_		checkNotNull(job, "job is null")___		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			jobDispatcher.runDetached(job)__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,check,not,null,job,job,is,null,synchronized,lock,check,state,running,mini,cluster,is,not,running,job,dispatcher,run,detached,job
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException;1504607872;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException {_		checkNotNull(job, "job is null")___		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			jobDispatcher.runDetached(job)__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,check,not,null,job,job,is,null,synchronized,lock,check,state,running,mini,cluster,is,not,running,job,dispatcher,run,detached,job
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException;1507212387;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException {_		checkNotNull(job, "job is null")___		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			jobDispatcher.runDetached(job)__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,check,not,null,job,job,is,null,synchronized,lock,check,state,running,mini,cluster,is,not,running,job,dispatcher,run,detached,job
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException;1509006142;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException {_		checkNotNull(job, "job is null")___		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			jobDispatcher.runDetached(job)__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,check,not,null,job,job,is,null,synchronized,lock,check,state,running,mini,cluster,is,not,running,job,dispatcher,run,detached,job
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException;1509547920;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException {_		checkNotNull(job, "job is null")___		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			jobDispatcher.runDetached(job)__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,check,not,null,job,job,is,null,synchronized,lock,check,state,running,mini,cluster,is,not,running,job,dispatcher,run,detached,job
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException;1509547921;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException {_		checkNotNull(job, "job is null")___		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			jobDispatcher.runDetached(job)__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,check,not,null,job,job,is,null,synchronized,lock,check,state,running,mini,cluster,is,not,running,job,dispatcher,run,detached,job
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException;1515583830;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException {_		checkNotNull(job, "job is null")___		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			jobDispatcher.runDetached(job)__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,check,not,null,job,job,is,null,synchronized,lock,check,state,running,mini,cluster,is,not,running,job,dispatcher,run,detached,job
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException;1515600854;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException {_		checkNotNull(job, "job is null")___		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			jobDispatcher.runDetached(job)__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,check,not,null,job,job,is,null,synchronized,lock,check,state,running,mini,cluster,is,not,running,job,dispatcher,run,detached,job
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException;1517915730;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException {_		checkNotNull(job, "job is null")___		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			jobDispatcher.runDetached(job)__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,check,not,null,job,job,is,null,synchronized,lock,check,state,running,mini,cluster,is,not,running,job,dispatcher,run,detached,job
MiniCluster -> public void runDetached(JobGraph job) throws JobExecutionException;1519121818;This method executes a job in detached mode. The method returns immediately after the job_has been added to the__@param job  The Flink job to execute__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public void runDetached(JobGraph job) throws JobExecutionException {_		checkNotNull(job, "job is null")___		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			jobDispatcher.runDetached(job)__		}_	};this,method,executes,a,job,in,detached,mode,the,method,returns,immediately,after,the,job,has,been,added,to,the,param,job,the,flink,job,to,execute,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,void,run,detached,job,graph,job,throws,job,execution,exception,check,not,null,job,job,is,null,synchronized,lock,check,state,running,mini,cluster,is,not,running,job,dispatcher,run,detached,job
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config, boolean singleRpcService);1482522863;Creates a mini cluster based on the given configuration, starting one or more_RPC services, depending on the given flag.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config, boolean singleRpcService) {_		this(createConfig(config, singleRpcService))__	};creates,a,mini,cluster,based,on,the,given,configuration,starting,one,or,more,rpc,services,depending,on,the,given,flag,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,boolean,single,rpc,service,this,create,config,config,single,rpc,service
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config, boolean singleRpcService);1482522863;Creates a mini cluster based on the given configuration, starting one or more_RPC services, depending on the given flag.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config, boolean singleRpcService) {_		this(createConfig(config, singleRpcService))__	};creates,a,mini,cluster,based,on,the,given,configuration,starting,one,or,more,rpc,services,depending,on,the,given,flag,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,boolean,single,rpc,service,this,create,config,config,single,rpc,service
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config, boolean singleRpcService);1482522864;Creates a mini cluster based on the given configuration, starting one or more_RPC services, depending on the given flag.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config, boolean singleRpcService) {_		this(createConfig(config, singleRpcService))__	};creates,a,mini,cluster,based,on,the,given,configuration,starting,one,or,more,rpc,services,depending,on,the,given,flag,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,boolean,single,rpc,service,this,create,config,config,single,rpc,service
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config, boolean singleRpcService);1482522864;Creates a mini cluster based on the given configuration, starting one or more_RPC services, depending on the given flag.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config, boolean singleRpcService) {_		this(createConfig(config, singleRpcService))__	};creates,a,mini,cluster,based,on,the,given,configuration,starting,one,or,more,rpc,services,depending,on,the,given,flag,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,boolean,single,rpc,service,this,create,config,config,single,rpc,service
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config, boolean singleRpcService);1482522864;Creates a mini cluster based on the given configuration, starting one or more_RPC services, depending on the given flag.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config, boolean singleRpcService) {_		this(createConfig(config, singleRpcService))__	};creates,a,mini,cluster,based,on,the,given,configuration,starting,one,or,more,rpc,services,depending,on,the,given,flag,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,boolean,single,rpc,service,this,create,config,config,single,rpc,service
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config, boolean singleRpcService);1482522864;Creates a mini cluster based on the given configuration, starting one or more_RPC services, depending on the given flag.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config, boolean singleRpcService) {_		this(createConfig(config, singleRpcService))__	};creates,a,mini,cluster,based,on,the,given,configuration,starting,one,or,more,rpc,services,depending,on,the,given,flag,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,boolean,single,rpc,service,this,create,config,config,single,rpc,service
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config, boolean singleRpcService);1482522866;Creates a mini cluster based on the given configuration, starting one or more_RPC services, depending on the given flag.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config, boolean singleRpcService) {_		this(createConfig(config, singleRpcService))__	};creates,a,mini,cluster,based,on,the,given,configuration,starting,one,or,more,rpc,services,depending,on,the,given,flag,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,boolean,single,rpc,service,this,create,config,config,single,rpc,service
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config, boolean singleRpcService);1482522866;Creates a mini cluster based on the given configuration, starting one or more_RPC services, depending on the given flag.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config, boolean singleRpcService) {_		this(createConfig(config, singleRpcService))__	};creates,a,mini,cluster,based,on,the,given,configuration,starting,one,or,more,rpc,services,depending,on,the,given,flag,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,boolean,single,rpc,service,this,create,config,config,single,rpc,service
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config, boolean singleRpcService);1482522866;Creates a mini cluster based on the given configuration, starting one or more_RPC services, depending on the given flag.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config, boolean singleRpcService) {_		this(createConfig(config, singleRpcService))__	};creates,a,mini,cluster,based,on,the,given,configuration,starting,one,or,more,rpc,services,depending,on,the,given,flag,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,boolean,single,rpc,service,this,create,config,config,single,rpc,service
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config, boolean singleRpcService);1482522867;Creates a mini cluster based on the given configuration, starting one or more_RPC services, depending on the given flag.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config, boolean singleRpcService) {_		this(createConfig(config, singleRpcService))__	};creates,a,mini,cluster,based,on,the,given,configuration,starting,one,or,more,rpc,services,depending,on,the,given,flag,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,boolean,single,rpc,service,this,create,config,config,single,rpc,service
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config, boolean singleRpcService);1489766405;Creates a mini cluster based on the given configuration, starting one or more_RPC services, depending on the given flag.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config, boolean singleRpcService) {_		this(createConfig(config, singleRpcService))__	};creates,a,mini,cluster,based,on,the,given,configuration,starting,one,or,more,rpc,services,depending,on,the,given,flag,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,boolean,single,rpc,service,this,create,config,config,single,rpc,service
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config, boolean singleRpcService);1490273924;Creates a mini cluster based on the given configuration, starting one or more_RPC services, depending on the given flag.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config, boolean singleRpcService) {_		this(createConfig(config, singleRpcService))__	};creates,a,mini,cluster,based,on,the,given,configuration,starting,one,or,more,rpc,services,depending,on,the,given,flag,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,boolean,single,rpc,service,this,create,config,config,single,rpc,service
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config, boolean singleRpcService);1490273924;Creates a mini cluster based on the given configuration, starting one or more_RPC services, depending on the given flag.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config, boolean singleRpcService) {_		this(createConfig(config, singleRpcService))__	};creates,a,mini,cluster,based,on,the,given,configuration,starting,one,or,more,rpc,services,depending,on,the,given,flag,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,boolean,single,rpc,service,this,create,config,config,single,rpc,service
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config, boolean singleRpcService);1493146240;Creates a mini cluster based on the given configuration, starting one or more_RPC services, depending on the given flag.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config, boolean singleRpcService) {_		this(createConfig(config, singleRpcService))__	};creates,a,mini,cluster,based,on,the,given,configuration,starting,one,or,more,rpc,services,depending,on,the,given,flag,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,boolean,single,rpc,service,this,create,config,config,single,rpc,service
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config, boolean singleRpcService);1493975155;Creates a mini cluster based on the given configuration, starting one or more_RPC services, depending on the given flag.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config, boolean singleRpcService) {_		this(createConfig(config, singleRpcService))__	};creates,a,mini,cluster,based,on,the,given,configuration,starting,one,or,more,rpc,services,depending,on,the,given,flag,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,boolean,single,rpc,service,this,create,config,config,single,rpc,service
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config, boolean singleRpcService);1499254138;Creates a mini cluster based on the given configuration, starting one or more_RPC services, depending on the given flag.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config, boolean singleRpcService) {_		this(createConfig(config, singleRpcService))__	};creates,a,mini,cluster,based,on,the,given,configuration,starting,one,or,more,rpc,services,depending,on,the,given,flag,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,boolean,single,rpc,service,this,create,config,config,single,rpc,service
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config, boolean singleRpcService);1499789965;Creates a mini cluster based on the given configuration, starting one or more_RPC services, depending on the given flag.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config, boolean singleRpcService) {_		this(createConfig(config, singleRpcService))__	};creates,a,mini,cluster,based,on,the,given,configuration,starting,one,or,more,rpc,services,depending,on,the,given,flag,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,boolean,single,rpc,service,this,create,config,config,single,rpc,service
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config, boolean singleRpcService);1501437265;Creates a mini cluster based on the given configuration, starting one or more_RPC services, depending on the given flag.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config, boolean singleRpcService) {_		this(createConfig(config, singleRpcService))__	};creates,a,mini,cluster,based,on,the,given,configuration,starting,one,or,more,rpc,services,depending,on,the,given,flag,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,boolean,single,rpc,service,this,create,config,config,single,rpc,service
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config, boolean singleRpcService);1501660818;Creates a mini cluster based on the given configuration, starting one or more_RPC services, depending on the given flag.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config, boolean singleRpcService) {_		this(createConfig(config, singleRpcService))__	};creates,a,mini,cluster,based,on,the,given,configuration,starting,one,or,more,rpc,services,depending,on,the,given,flag,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,boolean,single,rpc,service,this,create,config,config,single,rpc,service
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config, boolean singleRpcService);1504477043;Creates a mini cluster based on the given configuration, starting one or more_RPC services, depending on the given flag.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config, boolean singleRpcService) {_		this(createConfig(config, singleRpcService))___		running = false__	};creates,a,mini,cluster,based,on,the,given,configuration,starting,one,or,more,rpc,services,depending,on,the,given,flag,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,boolean,single,rpc,service,this,create,config,config,single,rpc,service,running,false
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config, boolean singleRpcService);1504525441;Creates a mini cluster based on the given configuration, starting one or more_RPC services, depending on the given flag.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config, boolean singleRpcService) {_		this(createConfig(config, singleRpcService))___		running = false__	};creates,a,mini,cluster,based,on,the,given,configuration,starting,one,or,more,rpc,services,depending,on,the,given,flag,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,boolean,single,rpc,service,this,create,config,config,single,rpc,service,running,false
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config, boolean singleRpcService);1504607872;Creates a mini cluster based on the given configuration, starting one or more_RPC services, depending on the given flag.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config, boolean singleRpcService) {_		this(createConfig(config, singleRpcService))___		running = false__	};creates,a,mini,cluster,based,on,the,given,configuration,starting,one,or,more,rpc,services,depending,on,the,given,flag,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,boolean,single,rpc,service,this,create,config,config,single,rpc,service,running,false
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config, boolean singleRpcService);1507212387;Creates a mini cluster based on the given configuration, starting one or more_RPC services, depending on the given flag.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config, boolean singleRpcService) {_		this(createConfig(config, singleRpcService))___		running = false__	};creates,a,mini,cluster,based,on,the,given,configuration,starting,one,or,more,rpc,services,depending,on,the,given,flag,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,boolean,single,rpc,service,this,create,config,config,single,rpc,service,running,false
MiniCluster -> public MiniCluster();1482522863;Creates a new mini cluster with the default configuration:_<ul>_<li>One JobManager</li>_<li>One TaskManager</li>_<li>One task slot in the TaskManager</li>_<li>All components share the same RPC subsystem (minimizes communication overhead)</li>_</ul>;public MiniCluster() {_		this(new MiniClusterConfiguration())__	};creates,a,new,mini,cluster,with,the,default,configuration,ul,li,one,job,manager,li,li,one,task,manager,li,li,one,task,slot,in,the,task,manager,li,li,all,components,share,the,same,rpc,subsystem,minimizes,communication,overhead,li,ul;public,mini,cluster,this,new,mini,cluster,configuration
MiniCluster -> public MiniCluster();1482522863;Creates a new mini cluster with the default configuration:_<ul>_<li>One JobManager</li>_<li>One TaskManager</li>_<li>One task slot in the TaskManager</li>_<li>All components share the same RPC subsystem (minimizes communication overhead)</li>_</ul>;public MiniCluster() {_		this(new MiniClusterConfiguration())__	};creates,a,new,mini,cluster,with,the,default,configuration,ul,li,one,job,manager,li,li,one,task,manager,li,li,one,task,slot,in,the,task,manager,li,li,all,components,share,the,same,rpc,subsystem,minimizes,communication,overhead,li,ul;public,mini,cluster,this,new,mini,cluster,configuration
MiniCluster -> public MiniCluster();1482522864;Creates a new mini cluster with the default configuration:_<ul>_<li>One JobManager</li>_<li>One TaskManager</li>_<li>One task slot in the TaskManager</li>_<li>All components share the same RPC subsystem (minimizes communication overhead)</li>_</ul>;public MiniCluster() {_		this(new MiniClusterConfiguration())__	};creates,a,new,mini,cluster,with,the,default,configuration,ul,li,one,job,manager,li,li,one,task,manager,li,li,one,task,slot,in,the,task,manager,li,li,all,components,share,the,same,rpc,subsystem,minimizes,communication,overhead,li,ul;public,mini,cluster,this,new,mini,cluster,configuration
MiniCluster -> public MiniCluster();1482522864;Creates a new mini cluster with the default configuration:_<ul>_<li>One JobManager</li>_<li>One TaskManager</li>_<li>One task slot in the TaskManager</li>_<li>All components share the same RPC subsystem (minimizes communication overhead)</li>_</ul>;public MiniCluster() {_		this(new MiniClusterConfiguration())__	};creates,a,new,mini,cluster,with,the,default,configuration,ul,li,one,job,manager,li,li,one,task,manager,li,li,one,task,slot,in,the,task,manager,li,li,all,components,share,the,same,rpc,subsystem,minimizes,communication,overhead,li,ul;public,mini,cluster,this,new,mini,cluster,configuration
MiniCluster -> public MiniCluster();1482522864;Creates a new mini cluster with the default configuration:_<ul>_<li>One JobManager</li>_<li>One TaskManager</li>_<li>One task slot in the TaskManager</li>_<li>All components share the same RPC subsystem (minimizes communication overhead)</li>_</ul>;public MiniCluster() {_		this(new MiniClusterConfiguration())__	};creates,a,new,mini,cluster,with,the,default,configuration,ul,li,one,job,manager,li,li,one,task,manager,li,li,one,task,slot,in,the,task,manager,li,li,all,components,share,the,same,rpc,subsystem,minimizes,communication,overhead,li,ul;public,mini,cluster,this,new,mini,cluster,configuration
MiniCluster -> public MiniCluster();1482522864;Creates a new mini cluster with the default configuration:_<ul>_<li>One JobManager</li>_<li>One TaskManager</li>_<li>One task slot in the TaskManager</li>_<li>All components share the same RPC subsystem (minimizes communication overhead)</li>_</ul>;public MiniCluster() {_		this(new MiniClusterConfiguration())__	};creates,a,new,mini,cluster,with,the,default,configuration,ul,li,one,job,manager,li,li,one,task,manager,li,li,one,task,slot,in,the,task,manager,li,li,all,components,share,the,same,rpc,subsystem,minimizes,communication,overhead,li,ul;public,mini,cluster,this,new,mini,cluster,configuration
MiniCluster -> public MiniCluster();1482522866;Creates a new mini cluster with the default configuration:_<ul>_<li>One JobManager</li>_<li>One TaskManager</li>_<li>One task slot in the TaskManager</li>_<li>All components share the same RPC subsystem (minimizes communication overhead)</li>_</ul>;public MiniCluster() {_		this(new MiniClusterConfiguration())__	};creates,a,new,mini,cluster,with,the,default,configuration,ul,li,one,job,manager,li,li,one,task,manager,li,li,one,task,slot,in,the,task,manager,li,li,all,components,share,the,same,rpc,subsystem,minimizes,communication,overhead,li,ul;public,mini,cluster,this,new,mini,cluster,configuration
MiniCluster -> public MiniCluster();1482522866;Creates a new mini cluster with the default configuration:_<ul>_<li>One JobManager</li>_<li>One TaskManager</li>_<li>One task slot in the TaskManager</li>_<li>All components share the same RPC subsystem (minimizes communication overhead)</li>_</ul>;public MiniCluster() {_		this(new MiniClusterConfiguration())__	};creates,a,new,mini,cluster,with,the,default,configuration,ul,li,one,job,manager,li,li,one,task,manager,li,li,one,task,slot,in,the,task,manager,li,li,all,components,share,the,same,rpc,subsystem,minimizes,communication,overhead,li,ul;public,mini,cluster,this,new,mini,cluster,configuration
MiniCluster -> public MiniCluster();1482522866;Creates a new mini cluster with the default configuration:_<ul>_<li>One JobManager</li>_<li>One TaskManager</li>_<li>One task slot in the TaskManager</li>_<li>All components share the same RPC subsystem (minimizes communication overhead)</li>_</ul>;public MiniCluster() {_		this(new MiniClusterConfiguration())__	};creates,a,new,mini,cluster,with,the,default,configuration,ul,li,one,job,manager,li,li,one,task,manager,li,li,one,task,slot,in,the,task,manager,li,li,all,components,share,the,same,rpc,subsystem,minimizes,communication,overhead,li,ul;public,mini,cluster,this,new,mini,cluster,configuration
MiniCluster -> public MiniCluster();1482522867;Creates a new mini cluster with the default configuration:_<ul>_<li>One JobManager</li>_<li>One TaskManager</li>_<li>One task slot in the TaskManager</li>_<li>All components share the same RPC subsystem (minimizes communication overhead)</li>_</ul>;public MiniCluster() {_		this(new MiniClusterConfiguration())__	};creates,a,new,mini,cluster,with,the,default,configuration,ul,li,one,job,manager,li,li,one,task,manager,li,li,one,task,slot,in,the,task,manager,li,li,all,components,share,the,same,rpc,subsystem,minimizes,communication,overhead,li,ul;public,mini,cluster,this,new,mini,cluster,configuration
MiniCluster -> public MiniCluster();1489766405;Creates a new mini cluster with the default configuration:_<ul>_<li>One JobManager</li>_<li>One TaskManager</li>_<li>One task slot in the TaskManager</li>_<li>All components share the same RPC subsystem (minimizes communication overhead)</li>_</ul>;public MiniCluster() {_		this(new MiniClusterConfiguration())__	};creates,a,new,mini,cluster,with,the,default,configuration,ul,li,one,job,manager,li,li,one,task,manager,li,li,one,task,slot,in,the,task,manager,li,li,all,components,share,the,same,rpc,subsystem,minimizes,communication,overhead,li,ul;public,mini,cluster,this,new,mini,cluster,configuration
MiniCluster -> public MiniCluster();1490273924;Creates a new mini cluster with the default configuration:_<ul>_<li>One JobManager</li>_<li>One TaskManager</li>_<li>One task slot in the TaskManager</li>_<li>All components share the same RPC subsystem (minimizes communication overhead)</li>_</ul>;public MiniCluster() {_		this(new MiniClusterConfiguration())__	};creates,a,new,mini,cluster,with,the,default,configuration,ul,li,one,job,manager,li,li,one,task,manager,li,li,one,task,slot,in,the,task,manager,li,li,all,components,share,the,same,rpc,subsystem,minimizes,communication,overhead,li,ul;public,mini,cluster,this,new,mini,cluster,configuration
MiniCluster -> public MiniCluster();1490273924;Creates a new mini cluster with the default configuration:_<ul>_<li>One JobManager</li>_<li>One TaskManager</li>_<li>One task slot in the TaskManager</li>_<li>All components share the same RPC subsystem (minimizes communication overhead)</li>_</ul>;public MiniCluster() {_		this(new MiniClusterConfiguration())__	};creates,a,new,mini,cluster,with,the,default,configuration,ul,li,one,job,manager,li,li,one,task,manager,li,li,one,task,slot,in,the,task,manager,li,li,all,components,share,the,same,rpc,subsystem,minimizes,communication,overhead,li,ul;public,mini,cluster,this,new,mini,cluster,configuration
MiniCluster -> public MiniCluster();1493146240;Creates a new mini cluster with the default configuration:_<ul>_<li>One JobManager</li>_<li>One TaskManager</li>_<li>One task slot in the TaskManager</li>_<li>All components share the same RPC subsystem (minimizes communication overhead)</li>_</ul>;public MiniCluster() {_		this(new MiniClusterConfiguration())__	};creates,a,new,mini,cluster,with,the,default,configuration,ul,li,one,job,manager,li,li,one,task,manager,li,li,one,task,slot,in,the,task,manager,li,li,all,components,share,the,same,rpc,subsystem,minimizes,communication,overhead,li,ul;public,mini,cluster,this,new,mini,cluster,configuration
MiniCluster -> public MiniCluster();1493975155;Creates a new mini cluster with the default configuration:_<ul>_<li>One JobManager</li>_<li>One TaskManager</li>_<li>One task slot in the TaskManager</li>_<li>All components share the same RPC subsystem (minimizes communication overhead)</li>_</ul>;public MiniCluster() {_		this(new MiniClusterConfiguration())__	};creates,a,new,mini,cluster,with,the,default,configuration,ul,li,one,job,manager,li,li,one,task,manager,li,li,one,task,slot,in,the,task,manager,li,li,all,components,share,the,same,rpc,subsystem,minimizes,communication,overhead,li,ul;public,mini,cluster,this,new,mini,cluster,configuration
MiniCluster -> public MiniCluster();1499254138;Creates a new mini cluster with the default configuration:_<ul>_<li>One JobManager</li>_<li>One TaskManager</li>_<li>One task slot in the TaskManager</li>_<li>All components share the same RPC subsystem (minimizes communication overhead)</li>_</ul>;public MiniCluster() {_		this(new MiniClusterConfiguration())__	};creates,a,new,mini,cluster,with,the,default,configuration,ul,li,one,job,manager,li,li,one,task,manager,li,li,one,task,slot,in,the,task,manager,li,li,all,components,share,the,same,rpc,subsystem,minimizes,communication,overhead,li,ul;public,mini,cluster,this,new,mini,cluster,configuration
MiniCluster -> public MiniCluster();1499789965;Creates a new mini cluster with the default configuration:_<ul>_<li>One JobManager</li>_<li>One TaskManager</li>_<li>One task slot in the TaskManager</li>_<li>All components share the same RPC subsystem (minimizes communication overhead)</li>_</ul>;public MiniCluster() {_		this(new MiniClusterConfiguration())__	};creates,a,new,mini,cluster,with,the,default,configuration,ul,li,one,job,manager,li,li,one,task,manager,li,li,one,task,slot,in,the,task,manager,li,li,all,components,share,the,same,rpc,subsystem,minimizes,communication,overhead,li,ul;public,mini,cluster,this,new,mini,cluster,configuration
MiniCluster -> public MiniCluster();1501437265;Creates a new mini cluster with the default configuration:_<ul>_<li>One JobManager</li>_<li>One TaskManager</li>_<li>One task slot in the TaskManager</li>_<li>All components share the same RPC subsystem (minimizes communication overhead)</li>_</ul>;public MiniCluster() {_		this(new MiniClusterConfiguration())__	};creates,a,new,mini,cluster,with,the,default,configuration,ul,li,one,job,manager,li,li,one,task,manager,li,li,one,task,slot,in,the,task,manager,li,li,all,components,share,the,same,rpc,subsystem,minimizes,communication,overhead,li,ul;public,mini,cluster,this,new,mini,cluster,configuration
MiniCluster -> public MiniCluster();1501660818;Creates a new mini cluster with the default configuration:_<ul>_<li>One JobManager</li>_<li>One TaskManager</li>_<li>One task slot in the TaskManager</li>_<li>All components share the same RPC subsystem (minimizes communication overhead)</li>_</ul>;public MiniCluster() {_		this(new MiniClusterConfiguration())__	};creates,a,new,mini,cluster,with,the,default,configuration,ul,li,one,job,manager,li,li,one,task,manager,li,li,one,task,slot,in,the,task,manager,li,li,all,components,share,the,same,rpc,subsystem,minimizes,communication,overhead,li,ul;public,mini,cluster,this,new,mini,cluster,configuration
MiniCluster -> public MiniCluster();1504477043;Creates a new mini cluster with the default configuration:_<ul>_<li>One JobManager</li>_<li>One TaskManager</li>_<li>One task slot in the TaskManager</li>_<li>All components share the same RPC subsystem (minimizes communication overhead)</li>_</ul>;public MiniCluster() {_		this(new MiniClusterConfiguration())__	};creates,a,new,mini,cluster,with,the,default,configuration,ul,li,one,job,manager,li,li,one,task,manager,li,li,one,task,slot,in,the,task,manager,li,li,all,components,share,the,same,rpc,subsystem,minimizes,communication,overhead,li,ul;public,mini,cluster,this,new,mini,cluster,configuration
MiniCluster -> public MiniCluster();1504525441;Creates a new mini cluster with the default configuration:_<ul>_<li>One JobManager</li>_<li>One TaskManager</li>_<li>One task slot in the TaskManager</li>_<li>All components share the same RPC subsystem (minimizes communication overhead)</li>_</ul>;public MiniCluster() {_		this(new MiniClusterConfiguration())__	};creates,a,new,mini,cluster,with,the,default,configuration,ul,li,one,job,manager,li,li,one,task,manager,li,li,one,task,slot,in,the,task,manager,li,li,all,components,share,the,same,rpc,subsystem,minimizes,communication,overhead,li,ul;public,mini,cluster,this,new,mini,cluster,configuration
MiniCluster -> public MiniCluster();1504607872;Creates a new mini cluster with the default configuration:_<ul>_<li>One JobManager</li>_<li>One TaskManager</li>_<li>One task slot in the TaskManager</li>_<li>All components share the same RPC subsystem (minimizes communication overhead)</li>_</ul>;public MiniCluster() {_		this(new MiniClusterConfiguration())__	};creates,a,new,mini,cluster,with,the,default,configuration,ul,li,one,job,manager,li,li,one,task,manager,li,li,one,task,slot,in,the,task,manager,li,li,all,components,share,the,same,rpc,subsystem,minimizes,communication,overhead,li,ul;public,mini,cluster,this,new,mini,cluster,configuration
MiniCluster -> public MiniCluster();1507212387;Creates a new mini cluster with the default configuration:_<ul>_<li>One JobManager</li>_<li>One TaskManager</li>_<li>One task slot in the TaskManager</li>_<li>All components share the same RPC subsystem (minimizes communication overhead)</li>_</ul>;public MiniCluster() {_		this(new MiniClusterConfiguration())__	};creates,a,new,mini,cluster,with,the,default,configuration,ul,li,one,job,manager,li,li,one,task,manager,li,li,one,task,slot,in,the,task,manager,li,li,all,components,share,the,same,rpc,subsystem,minimizes,communication,overhead,li,ul;public,mini,cluster,this,new,mini,cluster,configuration
MiniCluster -> TerminatingFatalErrorHandlerFactory -> @GuardedBy("lock") 		private TerminatingFatalErrorHandler create(int index);1550069788;Create a new {@link TerminatingFatalErrorHandler} for the {@link TaskExecutor} with_the given index.__@param index into the {@link #taskManagers} collection to identify the correct {@link TaskExecutor}._@return {@link TerminatingFatalErrorHandler} for the given index;@GuardedBy("lock")_		private TerminatingFatalErrorHandler create(int index) {_			return new TerminatingFatalErrorHandler(index)__		};create,a,new,link,terminating,fatal,error,handler,for,the,link,task,executor,with,the,given,index,param,index,into,the,link,task,managers,collection,to,identify,the,correct,link,task,executor,return,link,terminating,fatal,error,handler,for,the,given,index;guarded,by,lock,private,terminating,fatal,error,handler,create,int,index,return,new,terminating,fatal,error,handler,index
MiniCluster -> TerminatingFatalErrorHandlerFactory -> @GuardedBy("lock") 		private TerminatingFatalErrorHandler create(int index);1550228244;Create a new {@link TerminatingFatalErrorHandler} for the {@link TaskExecutor} with_the given index.__@param index into the {@link #taskManagers} collection to identify the correct {@link TaskExecutor}._@return {@link TerminatingFatalErrorHandler} for the given index;@GuardedBy("lock")_		private TerminatingFatalErrorHandler create(int index) {_			return new TerminatingFatalErrorHandler(index)__		};create,a,new,link,terminating,fatal,error,handler,for,the,link,task,executor,with,the,given,index,param,index,into,the,link,task,managers,collection,to,identify,the,correct,link,task,executor,return,link,terminating,fatal,error,handler,for,the,given,index;guarded,by,lock,private,terminating,fatal,error,handler,create,int,index,return,new,terminating,fatal,error,handler,index
MiniCluster -> TerminatingFatalErrorHandlerFactory -> @GuardedBy("lock") 		private TerminatingFatalErrorHandler create(int index);1550483152;Create a new {@link TerminatingFatalErrorHandler} for the {@link TaskExecutor} with_the given index.__@param index into the {@link #taskManagers} collection to identify the correct {@link TaskExecutor}._@return {@link TerminatingFatalErrorHandler} for the given index;@GuardedBy("lock")_		private TerminatingFatalErrorHandler create(int index) {_			return new TerminatingFatalErrorHandler(index)__		};create,a,new,link,terminating,fatal,error,handler,for,the,link,task,executor,with,the,given,index,param,index,into,the,link,task,managers,collection,to,identify,the,correct,link,task,executor,return,link,terminating,fatal,error,handler,for,the,given,index;guarded,by,lock,private,terminating,fatal,error,handler,create,int,index,return,new,terminating,fatal,error,handler,index
MiniCluster -> TerminatingFatalErrorHandlerFactory -> @GuardedBy("lock") 		private TerminatingFatalErrorHandler create(int index);1550823915;Create a new {@link TerminatingFatalErrorHandler} for the {@link TaskExecutor} with_the given index.__@param index into the {@link #taskManagers} collection to identify the correct {@link TaskExecutor}._@return {@link TerminatingFatalErrorHandler} for the given index;@GuardedBy("lock")_		private TerminatingFatalErrorHandler create(int index) {_			return new TerminatingFatalErrorHandler(index)__		};create,a,new,link,terminating,fatal,error,handler,for,the,link,task,executor,with,the,given,index,param,index,into,the,link,task,managers,collection,to,identify,the,correct,link,task,executor,return,link,terminating,fatal,error,handler,for,the,given,index;guarded,by,lock,private,terminating,fatal,error,handler,create,int,index,return,new,terminating,fatal,error,handler,index
MiniCluster -> protected MetricRegistry createMetricRegistry(Configuration config);1482522863;Factory method to create the metric registry for the mini cluster__@param config The configuration of the mini cluster;protected MetricRegistry createMetricRegistry(Configuration config) {_		return new MetricRegistry(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,create,metric,registry,configuration,config,return,new,metric,registry,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistry createMetricRegistry(Configuration config);1482522863;Factory method to create the metric registry for the mini cluster__@param config The configuration of the mini cluster;protected MetricRegistry createMetricRegistry(Configuration config) {_		return new MetricRegistry(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,create,metric,registry,configuration,config,return,new,metric,registry,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistry createMetricRegistry(Configuration config);1482522864;Factory method to create the metric registry for the mini cluster__@param config The configuration of the mini cluster;protected MetricRegistry createMetricRegistry(Configuration config) {_		return new MetricRegistry(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,create,metric,registry,configuration,config,return,new,metric,registry,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistry createMetricRegistry(Configuration config);1482522864;Factory method to create the metric registry for the mini cluster__@param config The configuration of the mini cluster;protected MetricRegistry createMetricRegistry(Configuration config) {_		return new MetricRegistry(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,create,metric,registry,configuration,config,return,new,metric,registry,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistry createMetricRegistry(Configuration config);1482522864;Factory method to create the metric registry for the mini cluster__@param config The configuration of the mini cluster;protected MetricRegistry createMetricRegistry(Configuration config) {_		return new MetricRegistry(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,create,metric,registry,configuration,config,return,new,metric,registry,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistry createMetricRegistry(Configuration config);1482522864;Factory method to create the metric registry for the mini cluster__@param config The configuration of the mini cluster;protected MetricRegistry createMetricRegistry(Configuration config) {_		return new MetricRegistry(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,create,metric,registry,configuration,config,return,new,metric,registry,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistry createMetricRegistry(Configuration config);1482522866;Factory method to create the metric registry for the mini cluster__@param config The configuration of the mini cluster;protected MetricRegistry createMetricRegistry(Configuration config) {_		return new MetricRegistry(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,create,metric,registry,configuration,config,return,new,metric,registry,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistry createMetricRegistry(Configuration config);1482522866;Factory method to create the metric registry for the mini cluster__@param config The configuration of the mini cluster;protected MetricRegistry createMetricRegistry(Configuration config) {_		return new MetricRegistry(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,create,metric,registry,configuration,config,return,new,metric,registry,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistry createMetricRegistry(Configuration config);1482522866;Factory method to create the metric registry for the mini cluster__@param config The configuration of the mini cluster;protected MetricRegistry createMetricRegistry(Configuration config) {_		return new MetricRegistry(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,create,metric,registry,configuration,config,return,new,metric,registry,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistry createMetricRegistry(Configuration config);1482522867;Factory method to create the metric registry for the mini cluster__@param config The configuration of the mini cluster;protected MetricRegistry createMetricRegistry(Configuration config) {_		return new MetricRegistry(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,create,metric,registry,configuration,config,return,new,metric,registry,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistry createMetricRegistry(Configuration config);1489766405;Factory method to create the metric registry for the mini cluster__@param config The configuration of the mini cluster;protected MetricRegistry createMetricRegistry(Configuration config) {_		return new MetricRegistry(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,create,metric,registry,configuration,config,return,new,metric,registry,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistry createMetricRegistry(Configuration config);1490273924;Factory method to create the metric registry for the mini cluster__@param config The configuration of the mini cluster;protected MetricRegistry createMetricRegistry(Configuration config) {_		return new MetricRegistry(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,create,metric,registry,configuration,config,return,new,metric,registry,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistry createMetricRegistry(Configuration config);1490273924;Factory method to create the metric registry for the mini cluster__@param config The configuration of the mini cluster;protected MetricRegistry createMetricRegistry(Configuration config) {_		return new MetricRegistry(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,create,metric,registry,configuration,config,return,new,metric,registry,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistry createMetricRegistry(Configuration config);1493146240;Factory method to create the metric registry for the mini cluster__@param config The configuration of the mini cluster;protected MetricRegistry createMetricRegistry(Configuration config) {_		return new MetricRegistry(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,create,metric,registry,configuration,config,return,new,metric,registry,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistry createMetricRegistry(Configuration config);1493975155;Factory method to create the metric registry for the mini cluster__@param config The configuration of the mini cluster;protected MetricRegistry createMetricRegistry(Configuration config) {_		return new MetricRegistry(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,create,metric,registry,configuration,config,return,new,metric,registry,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistry createMetricRegistry(Configuration config);1499254138;Factory method to create the metric registry for the mini cluster__@param config The configuration of the mini cluster;protected MetricRegistry createMetricRegistry(Configuration config) {_		return new MetricRegistry(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,create,metric,registry,configuration,config,return,new,metric,registry,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistry createMetricRegistry(Configuration config);1499789965;Factory method to create the metric registry for the mini cluster__@param config The configuration of the mini cluster;protected MetricRegistry createMetricRegistry(Configuration config) {_		return new MetricRegistry(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,create,metric,registry,configuration,config,return,new,metric,registry,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistry createMetricRegistry(Configuration config);1501437265;Factory method to create the metric registry for the mini cluster__@param config The configuration of the mini cluster;protected MetricRegistry createMetricRegistry(Configuration config) {_		return new MetricRegistry(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,create,metric,registry,configuration,config,return,new,metric,registry,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistry createMetricRegistry(Configuration config);1501660818;Factory method to create the metric registry for the mini cluster__@param config The configuration of the mini cluster;protected MetricRegistry createMetricRegistry(Configuration config) {_		return new MetricRegistry(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,create,metric,registry,configuration,config,return,new,metric,registry,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistry createMetricRegistry(Configuration config);1504477043;Factory method to create the metric registry for the mini cluster__@param config The configuration of the mini cluster;protected MetricRegistry createMetricRegistry(Configuration config) {_		return new MetricRegistry(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,create,metric,registry,configuration,config,return,new,metric,registry,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistry createMetricRegistry(Configuration config);1504525441;Factory method to create the metric registry for the mini cluster__@param config The configuration of the mini cluster;protected MetricRegistry createMetricRegistry(Configuration config) {_		return new MetricRegistry(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,create,metric,registry,configuration,config,return,new,metric,registry,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistry createMetricRegistry(Configuration config);1504607872;Factory method to create the metric registry for the mini cluster__@param config The configuration of the mini cluster;protected MetricRegistry createMetricRegistry(Configuration config) {_		return new MetricRegistry(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,create,metric,registry,configuration,config,return,new,metric,registry,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistry createMetricRegistry(Configuration config);1507212387;Factory method to create the metric registry for the mini cluster__@param config The configuration of the mini cluster;protected MetricRegistry createMetricRegistry(Configuration config) {_		return new MetricRegistry(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,create,metric,registry,configuration,config,return,new,metric,registry,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistry createMetricRegistry(Configuration config);1509006142;Factory method to create the metric registry for the mini cluster__@param config The configuration of the mini cluster;protected MetricRegistry createMetricRegistry(Configuration config) {_		return new MetricRegistry(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,create,metric,registry,configuration,config,return,new,metric,registry,metric,registry,configuration,from,configuration,config
MiniCluster -> public boolean isRunning();1482522863;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1482522863;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1482522864;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1482522864;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1482522864;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1482522864;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1482522866;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1482522866;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1482522866;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1482522867;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1489766405;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1490273924;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1490273924;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1493146240;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1493975155;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1499254138;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1499789965;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1501437265;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1501660818;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1504477043;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1504525441;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1504607872;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1507212387;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1509006142;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1509547920;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1509547921;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1515583830;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1515600854;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1517915730;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1519121818;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1519249745;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1519406526;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1519406527;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1519406529;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1519510773;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1519512293;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1519977151;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1519977152;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1519977152;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1519977155;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1520032992;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1521379500;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1521385093;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1521385094;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1521537266;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1521537266;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1521537266;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1521804758;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1522132482;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1522681180;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1522759723;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1522825170;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1525420604;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1525452496;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1526334048;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1526336566;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1529682304;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1530181266;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1530644925;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1533555608;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1538042094;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1539169204;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1539176686;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1539176687;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1539176687;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1539582211;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1539787538;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1545326469;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1547675340;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1547675341;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1548249770;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1548326020;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1548846699;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1548866156;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1548966387;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1549360057;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1549360057;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1549360057;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1549360057;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1549360057;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1549360058;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1550005040;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1550069788;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1550228244;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1550483152;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> public boolean isRunning();1550823915;Checks if the mini cluster was started and is running.;public boolean isRunning() {_		return running__	};checks,if,the,mini,cluster,was,started,and,is,running;public,boolean,is,running,return,running
MiniCluster -> protected RpcService createRpcService( 			AkkaRpcServiceConfiguration akkaRpcServiceConfig, 			boolean remoteEnabled, 			String bindAddress);1548326020;Factory method to instantiate the RPC service.__@param akkaRpcServiceConfig_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			AkkaRpcServiceConfiguration akkaRpcServiceConfig,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(akkaRpcServiceConfig.getConfiguration(), bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(akkaRpcServiceConfig.getConfiguration())__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, akkaRpcServiceConfig)__	};factory,method,to,instantiate,the,rpc,service,param,akka,rpc,service,config,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,akka,rpc,service,configuration,akka,rpc,service,config,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,akka,rpc,service,config,get,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,akka,rpc,service,config,get,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,akka,rpc,service,config
MiniCluster -> protected RpcService createRpcService( 			AkkaRpcServiceConfiguration akkaRpcServiceConfig, 			boolean remoteEnabled, 			String bindAddress);1548846699;Factory method to instantiate the RPC service.__@param akkaRpcServiceConfig_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			AkkaRpcServiceConfiguration akkaRpcServiceConfig,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(akkaRpcServiceConfig.getConfiguration(), bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(akkaRpcServiceConfig.getConfiguration())__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, akkaRpcServiceConfig)__	};factory,method,to,instantiate,the,rpc,service,param,akka,rpc,service,config,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,akka,rpc,service,configuration,akka,rpc,service,config,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,akka,rpc,service,config,get,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,akka,rpc,service,config,get,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,akka,rpc,service,config
MiniCluster -> protected RpcService createRpcService( 			AkkaRpcServiceConfiguration akkaRpcServiceConfig, 			boolean remoteEnabled, 			String bindAddress);1548866156;Factory method to instantiate the RPC service.__@param akkaRpcServiceConfig_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			AkkaRpcServiceConfiguration akkaRpcServiceConfig,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(akkaRpcServiceConfig.getConfiguration(), bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(akkaRpcServiceConfig.getConfiguration())__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, akkaRpcServiceConfig)__	};factory,method,to,instantiate,the,rpc,service,param,akka,rpc,service,config,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,akka,rpc,service,configuration,akka,rpc,service,config,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,akka,rpc,service,config,get,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,akka,rpc,service,config,get,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,akka,rpc,service,config
MiniCluster -> protected RpcService createRpcService( 			AkkaRpcServiceConfiguration akkaRpcServiceConfig, 			boolean remoteEnabled, 			String bindAddress);1548966387;Factory method to instantiate the RPC service.__@param akkaRpcServiceConfig_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			AkkaRpcServiceConfiguration akkaRpcServiceConfig,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(akkaRpcServiceConfig.getConfiguration(), bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(akkaRpcServiceConfig.getConfiguration())__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, akkaRpcServiceConfig)__	};factory,method,to,instantiate,the,rpc,service,param,akka,rpc,service,config,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,akka,rpc,service,configuration,akka,rpc,service,config,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,akka,rpc,service,config,get,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,akka,rpc,service,config,get,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,akka,rpc,service,config
MiniCluster -> protected RpcService createRpcService( 			AkkaRpcServiceConfiguration akkaRpcServiceConfig, 			boolean remoteEnabled, 			String bindAddress);1549360057;Factory method to instantiate the RPC service.__@param akkaRpcServiceConfig_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			AkkaRpcServiceConfiguration akkaRpcServiceConfig,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(akkaRpcServiceConfig.getConfiguration(), bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(akkaRpcServiceConfig.getConfiguration())__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, akkaRpcServiceConfig)__	};factory,method,to,instantiate,the,rpc,service,param,akka,rpc,service,config,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,akka,rpc,service,configuration,akka,rpc,service,config,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,akka,rpc,service,config,get,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,akka,rpc,service,config,get,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,akka,rpc,service,config
MiniCluster -> protected RpcService createRpcService( 			AkkaRpcServiceConfiguration akkaRpcServiceConfig, 			boolean remoteEnabled, 			String bindAddress);1549360057;Factory method to instantiate the RPC service.__@param akkaRpcServiceConfig_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			AkkaRpcServiceConfiguration akkaRpcServiceConfig,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(akkaRpcServiceConfig.getConfiguration(), bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(akkaRpcServiceConfig.getConfiguration())__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, akkaRpcServiceConfig)__	};factory,method,to,instantiate,the,rpc,service,param,akka,rpc,service,config,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,akka,rpc,service,configuration,akka,rpc,service,config,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,akka,rpc,service,config,get,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,akka,rpc,service,config,get,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,akka,rpc,service,config
MiniCluster -> protected RpcService createRpcService( 			AkkaRpcServiceConfiguration akkaRpcServiceConfig, 			boolean remoteEnabled, 			String bindAddress);1549360057;Factory method to instantiate the RPC service.__@param akkaRpcServiceConfig_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			AkkaRpcServiceConfiguration akkaRpcServiceConfig,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(akkaRpcServiceConfig.getConfiguration(), bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(akkaRpcServiceConfig.getConfiguration())__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, akkaRpcServiceConfig)__	};factory,method,to,instantiate,the,rpc,service,param,akka,rpc,service,config,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,akka,rpc,service,configuration,akka,rpc,service,config,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,akka,rpc,service,config,get,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,akka,rpc,service,config,get,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,akka,rpc,service,config
MiniCluster -> protected RpcService createRpcService( 			AkkaRpcServiceConfiguration akkaRpcServiceConfig, 			boolean remoteEnabled, 			String bindAddress);1549360057;Factory method to instantiate the RPC service.__@param akkaRpcServiceConfig_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			AkkaRpcServiceConfiguration akkaRpcServiceConfig,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(akkaRpcServiceConfig.getConfiguration(), bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(akkaRpcServiceConfig.getConfiguration())__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, akkaRpcServiceConfig)__	};factory,method,to,instantiate,the,rpc,service,param,akka,rpc,service,config,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,akka,rpc,service,configuration,akka,rpc,service,config,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,akka,rpc,service,config,get,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,akka,rpc,service,config,get,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,akka,rpc,service,config
MiniCluster -> protected RpcService createRpcService( 			AkkaRpcServiceConfiguration akkaRpcServiceConfig, 			boolean remoteEnabled, 			String bindAddress);1549360057;Factory method to instantiate the RPC service.__@param akkaRpcServiceConfig_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			AkkaRpcServiceConfiguration akkaRpcServiceConfig,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(akkaRpcServiceConfig.getConfiguration(), bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(akkaRpcServiceConfig.getConfiguration())__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, akkaRpcServiceConfig)__	};factory,method,to,instantiate,the,rpc,service,param,akka,rpc,service,config,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,akka,rpc,service,configuration,akka,rpc,service,config,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,akka,rpc,service,config,get,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,akka,rpc,service,config,get,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,akka,rpc,service,config
MiniCluster -> protected RpcService createRpcService( 			AkkaRpcServiceConfiguration akkaRpcServiceConfig, 			boolean remoteEnabled, 			String bindAddress);1549360058;Factory method to instantiate the RPC service.__@param akkaRpcServiceConfig_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			AkkaRpcServiceConfiguration akkaRpcServiceConfig,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(akkaRpcServiceConfig.getConfiguration(), bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(akkaRpcServiceConfig.getConfiguration())__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, akkaRpcServiceConfig)__	};factory,method,to,instantiate,the,rpc,service,param,akka,rpc,service,config,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,akka,rpc,service,configuration,akka,rpc,service,config,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,akka,rpc,service,config,get,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,akka,rpc,service,config,get,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,akka,rpc,service,config
MiniCluster -> protected RpcService createRpcService( 			AkkaRpcServiceConfiguration akkaRpcServiceConfig, 			boolean remoteEnabled, 			String bindAddress);1550005040;Factory method to instantiate the RPC service.__@param akkaRpcServiceConfig_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			AkkaRpcServiceConfiguration akkaRpcServiceConfig,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(akkaRpcServiceConfig.getConfiguration(), bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(akkaRpcServiceConfig.getConfiguration())__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, akkaRpcServiceConfig)__	};factory,method,to,instantiate,the,rpc,service,param,akka,rpc,service,config,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,akka,rpc,service,configuration,akka,rpc,service,config,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,akka,rpc,service,config,get,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,akka,rpc,service,config,get,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,akka,rpc,service,config
MiniCluster -> protected RpcService createRpcService( 			AkkaRpcServiceConfiguration akkaRpcServiceConfig, 			boolean remoteEnabled, 			String bindAddress);1550069788;Factory method to instantiate the RPC service.__@param akkaRpcServiceConfig_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			AkkaRpcServiceConfiguration akkaRpcServiceConfig,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(akkaRpcServiceConfig.getConfiguration(), bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(akkaRpcServiceConfig.getConfiguration())__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, akkaRpcServiceConfig)__	};factory,method,to,instantiate,the,rpc,service,param,akka,rpc,service,config,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,akka,rpc,service,configuration,akka,rpc,service,config,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,akka,rpc,service,config,get,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,akka,rpc,service,config,get,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,akka,rpc,service,config
MiniCluster -> protected RpcService createRpcService( 			AkkaRpcServiceConfiguration akkaRpcServiceConfig, 			boolean remoteEnabled, 			String bindAddress);1550228244;Factory method to instantiate the RPC service.__@param akkaRpcServiceConfig_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			AkkaRpcServiceConfiguration akkaRpcServiceConfig,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(akkaRpcServiceConfig.getConfiguration(), bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(akkaRpcServiceConfig.getConfiguration())__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, akkaRpcServiceConfig)__	};factory,method,to,instantiate,the,rpc,service,param,akka,rpc,service,config,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,akka,rpc,service,configuration,akka,rpc,service,config,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,akka,rpc,service,config,get,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,akka,rpc,service,config,get,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,akka,rpc,service,config
MiniCluster -> protected RpcService createRpcService( 			AkkaRpcServiceConfiguration akkaRpcServiceConfig, 			boolean remoteEnabled, 			String bindAddress);1550483152;Factory method to instantiate the RPC service.__@param akkaRpcServiceConfig_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			AkkaRpcServiceConfiguration akkaRpcServiceConfig,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(akkaRpcServiceConfig.getConfiguration(), bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(akkaRpcServiceConfig.getConfiguration())__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, akkaRpcServiceConfig)__	};factory,method,to,instantiate,the,rpc,service,param,akka,rpc,service,config,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,akka,rpc,service,configuration,akka,rpc,service,config,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,akka,rpc,service,config,get,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,akka,rpc,service,config,get,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,akka,rpc,service,config
MiniCluster -> protected RpcService createRpcService( 			AkkaRpcServiceConfiguration akkaRpcServiceConfig, 			boolean remoteEnabled, 			String bindAddress);1550823915;Factory method to instantiate the RPC service.__@param akkaRpcServiceConfig_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			AkkaRpcServiceConfiguration akkaRpcServiceConfig,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(akkaRpcServiceConfig.getConfiguration(), bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(akkaRpcServiceConfig.getConfiguration())__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, akkaRpcServiceConfig)__	};factory,method,to,instantiate,the,rpc,service,param,akka,rpc,service,config,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,akka,rpc,service,configuration,akka,rpc,service,config,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,akka,rpc,service,config,get,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,akka,rpc,service,config,get,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,akka,rpc,service,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1509547920;Factory method to create the metric registry for the mini cluster__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1509547921;Factory method to create the metric registry for the mini cluster__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1515583830;Factory method to create the metric registry for the mini cluster__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1515600854;Factory method to create the metric registry for the mini cluster__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1517915730;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1519121818;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1519249745;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1519406526;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1519406527;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1519406529;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1519510773;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1519512293;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1519977151;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1519977152;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1519977152;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1519977155;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1520032992;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1521379500;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1521385093;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1521385094;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1521537266;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1521537266;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1521537266;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1521804758;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1522132482;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1522681180;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1522759723;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1522825170;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1525420604;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1525452496;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1526334048;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1526336566;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1529682304;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1530181266;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1530644925;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1533555608;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1538042094;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1539169204;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1539176686;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1539176687;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1539176687;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1539582211;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1539787538;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1545326469;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1547675340;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1547675341;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1548249770;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1548326020;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1548846699;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1548866156;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1548966387;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1549360057;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1549360057;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1549360057;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1549360057;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1549360057;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1549360058;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1550005040;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1550069788;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1550228244;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1550483152;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> protected MetricRegistryImpl createMetricRegistry(Configuration config);1550823915;Factory method to create the metric registry for the mini cluster.__@param config The configuration of the mini cluster;protected MetricRegistryImpl createMetricRegistry(Configuration config) {_		return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config))__	};factory,method,to,create,the,metric,registry,for,the,mini,cluster,param,config,the,configuration,of,the,mini,cluster;protected,metric,registry,impl,create,metric,registry,configuration,config,return,new,metric,registry,impl,metric,registry,configuration,from,configuration,config
MiniCluster -> public void start() throws Exception;1482522863;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			final Configuration configuration = new UnmodifiableConfiguration(config.getConfiguration())__			final Time rpcTimeout = config.getRpcTimeout()__			final int numJobManagers = config.getNumJobManagers()__			final int numTaskManagers = config.getNumTaskManagers()__			final boolean singleRpc = config.getUseSingleRpcSystem()___			try {_				metricRegistry = createMetricRegistry(configuration)___				RpcService[] jobManagerRpcServices = new RpcService[numJobManagers]__				RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				if (singleRpc) {_					_					commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___					_					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}_				}_				else {_					_					final String jobManagerBindAddress = config.getJobManagerBindAddress()__					final String taskManagerBindAddress = config.getTaskManagerBindAddress()___					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, jobManagerBindAddress)__					}__					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcServices = jobManagerRpcServices__					this.taskManagerRpcServices = taskManagerRpcServices__				}__				_				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(configuration)___				_				jobDispatcher = new MiniClusterJobDispatcher(_						configuration, haServices, metricRegistry, numJobManagers, jobManagerRpcServices)__			}_			catch (Exception e) {_				_				try {_					shutdownInternally()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,final,configuration,configuration,new,unmodifiable,configuration,config,get,configuration,final,time,rpc,timeout,config,get,rpc,timeout,final,int,num,job,managers,config,get,num,job,managers,final,int,num,task,managers,config,get,num,task,managers,final,boolean,single,rpc,config,get,use,single,rpc,system,try,metric,registry,create,metric,registry,configuration,rpc,service,job,manager,rpc,services,new,rpc,service,num,job,managers,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,if,single,rpc,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,else,final,string,job,manager,bind,address,config,get,job,manager,bind,address,final,string,task,manager,bind,address,config,get,task,manager,bind,address,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,services,job,manager,rpc,services,this,task,manager,rpc,services,task,manager,rpc,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,job,dispatcher,new,mini,cluster,job,dispatcher,configuration,ha,services,metric,registry,num,job,managers,job,manager,rpc,services,catch,exception,e,try,shutdown,internally,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true
MiniCluster -> public void start() throws Exception;1482522863;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			final Configuration configuration = new UnmodifiableConfiguration(config.getConfiguration())__			final Time rpcTimeout = config.getRpcTimeout()__			final int numJobManagers = config.getNumJobManagers()__			final int numTaskManagers = config.getNumTaskManagers()__			final boolean singleRpc = config.getUseSingleRpcSystem()___			try {_				metricRegistry = createMetricRegistry(configuration)___				RpcService[] jobManagerRpcServices = new RpcService[numJobManagers]__				RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				if (singleRpc) {_					_					commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___					_					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}_				}_				else {_					_					final String jobManagerBindAddress = config.getJobManagerBindAddress()__					final String taskManagerBindAddress = config.getTaskManagerBindAddress()___					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, jobManagerBindAddress)__					}__					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcServices = jobManagerRpcServices__					this.taskManagerRpcServices = taskManagerRpcServices__				}__				_				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(configuration)___				_				jobDispatcher = new MiniClusterJobDispatcher(_						configuration, haServices, metricRegistry, numJobManagers, jobManagerRpcServices)__			}_			catch (Exception e) {_				_				try {_					shutdownInternally()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,final,configuration,configuration,new,unmodifiable,configuration,config,get,configuration,final,time,rpc,timeout,config,get,rpc,timeout,final,int,num,job,managers,config,get,num,job,managers,final,int,num,task,managers,config,get,num,task,managers,final,boolean,single,rpc,config,get,use,single,rpc,system,try,metric,registry,create,metric,registry,configuration,rpc,service,job,manager,rpc,services,new,rpc,service,num,job,managers,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,if,single,rpc,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,else,final,string,job,manager,bind,address,config,get,job,manager,bind,address,final,string,task,manager,bind,address,config,get,task,manager,bind,address,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,services,job,manager,rpc,services,this,task,manager,rpc,services,task,manager,rpc,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,job,dispatcher,new,mini,cluster,job,dispatcher,configuration,ha,services,metric,registry,num,job,managers,job,manager,rpc,services,catch,exception,e,try,shutdown,internally,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true
MiniCluster -> public void start() throws Exception;1482522864;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			final Configuration configuration = new UnmodifiableConfiguration(config.getConfiguration())__			final Time rpcTimeout = config.getRpcTimeout()__			final int numJobManagers = config.getNumJobManagers()__			final int numTaskManagers = config.getNumTaskManagers()__			final int numResourceManagers = config.getNumResourceManagers()__			final boolean singleRpc = config.getUseSingleRpcSystem()___			try {_				metricRegistry = createMetricRegistry(configuration)___				RpcService[] jobManagerRpcServices = new RpcService[numJobManagers]__				RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]__				RpcService[] resourceManagerRpcServices = new RpcService[numResourceManagers]___				_				if (singleRpc) {_					_					commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___					_					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = commonRpcService__					}__					this.resourceManagerRpcServices = null__					this.jobManagerRpcServices = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = config.getJobManagerBindAddress()__					final String taskManagerBindAddress = config.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = config.getResourceManagerBindAddress()___					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, jobManagerBindAddress)__					}__					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, resourceManagerBindAddress)__					}__					this.jobManagerRpcServices = jobManagerRpcServices__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcServices = resourceManagerRpcServices__				}__				_				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(configuration)___				_				taskManagerRunners = startTaskManagers(_						configuration, haServices, metricRegistry, numTaskManagers, taskManagerRpcServices)___				_				jobDispatcher = new MiniClusterJobDispatcher(_						configuration, haServices, metricRegistry, numJobManagers, jobManagerRpcServices)__			}_			catch (Exception e) {_				_				try {_					shutdownInternally()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,final,configuration,configuration,new,unmodifiable,configuration,config,get,configuration,final,time,rpc,timeout,config,get,rpc,timeout,final,int,num,job,managers,config,get,num,job,managers,final,int,num,task,managers,config,get,num,task,managers,final,int,num,resource,managers,config,get,num,resource,managers,final,boolean,single,rpc,config,get,use,single,rpc,system,try,metric,registry,create,metric,registry,configuration,rpc,service,job,manager,rpc,services,new,rpc,service,num,job,managers,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,rpc,service,resource,manager,rpc,services,new,rpc,service,num,resource,managers,if,single,rpc,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,common,rpc,service,this,resource,manager,rpc,services,null,this,job,manager,rpc,services,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,config,get,job,manager,bind,address,final,string,task,manager,bind,address,config,get,task,manager,bind,address,final,string,resource,manager,bind,address,config,get,resource,manager,bind,address,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,this,job,manager,rpc,services,job,manager,rpc,services,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,services,resource,manager,rpc,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,task,manager,runners,start,task,managers,configuration,ha,services,metric,registry,num,task,managers,task,manager,rpc,services,job,dispatcher,new,mini,cluster,job,dispatcher,configuration,ha,services,metric,registry,num,job,managers,job,manager,rpc,services,catch,exception,e,try,shutdown,internally,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true
MiniCluster -> public void start() throws Exception;1482522864;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", config)___			final Configuration configuration = new UnmodifiableConfiguration(config.getConfiguration())__			final Time rpcTimeout = config.getRpcTimeout()__			final int numJobManagers = config.getNumJobManagers()__			final int numTaskManagers = config.getNumTaskManagers()__			final int numResourceManagers = config.getNumResourceManagers()__			final boolean singleRpc = config.getUseSingleRpcSystem()___			try {_				metricRegistry = createMetricRegistry(configuration)___				RpcService[] jobManagerRpcServices = new RpcService[numJobManagers]__				RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]__				RpcService[] resourceManagerRpcServices = new RpcService[numResourceManagers]___				_				if (singleRpc) {_					_					commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___					_					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = commonRpcService__					}__					this.resourceManagerRpcServices = null__					this.jobManagerRpcServices = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = config.getJobManagerBindAddress()__					final String taskManagerBindAddress = config.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = config.getResourceManagerBindAddress()___					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, jobManagerBindAddress)__					}__					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, resourceManagerBindAddress)__					}__					this.jobManagerRpcServices = jobManagerRpcServices__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcServices = resourceManagerRpcServices__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(configuration)___				_				LOG.info("Starting {} ResourceManger(s)", numResourceManagers)__				resourceManagers = startResourceManagers(_						configuration, haServices, metricRegistry, numResourceManagers, resourceManagerRpcServices)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagerRunners = startTaskManagers(_						configuration, haServices, metricRegistry, numTaskManagers, taskManagerRpcServices)___				_				LOG.info("Starting job dispatcher for {} JobManger(s)", numJobManagers)__				jobDispatcher = new MiniClusterJobDispatcher(_						configuration, haServices, metricRegistry, numJobManagers, jobManagerRpcServices)__			}_			catch (Exception e) {_				_				try {_					shutdownInternally()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,config,final,configuration,configuration,new,unmodifiable,configuration,config,get,configuration,final,time,rpc,timeout,config,get,rpc,timeout,final,int,num,job,managers,config,get,num,job,managers,final,int,num,task,managers,config,get,num,task,managers,final,int,num,resource,managers,config,get,num,resource,managers,final,boolean,single,rpc,config,get,use,single,rpc,system,try,metric,registry,create,metric,registry,configuration,rpc,service,job,manager,rpc,services,new,rpc,service,num,job,managers,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,rpc,service,resource,manager,rpc,services,new,rpc,service,num,resource,managers,if,single,rpc,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,common,rpc,service,this,resource,manager,rpc,services,null,this,job,manager,rpc,services,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,config,get,job,manager,bind,address,final,string,task,manager,bind,address,config,get,task,manager,bind,address,final,string,resource,manager,bind,address,config,get,resource,manager,bind,address,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,this,job,manager,rpc,services,job,manager,rpc,services,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,services,resource,manager,rpc,services,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,log,info,starting,resource,manger,s,num,resource,managers,resource,managers,start,resource,managers,configuration,ha,services,metric,registry,num,resource,managers,resource,manager,rpc,services,log,info,starting,task,manger,s,num,task,managers,task,manager,runners,start,task,managers,configuration,ha,services,metric,registry,num,task,managers,task,manager,rpc,services,log,info,starting,job,dispatcher,for,job,manger,s,num,job,managers,job,dispatcher,new,mini,cluster,job,dispatcher,configuration,ha,services,metric,registry,num,job,managers,job,manager,rpc,services,catch,exception,e,try,shutdown,internally,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1482522864;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", config)___			final Configuration configuration = new UnmodifiableConfiguration(config.getConfiguration())__			final Time rpcTimeout = config.getRpcTimeout()__			final int numJobManagers = config.getNumJobManagers()__			final int numTaskManagers = config.getNumTaskManagers()__			final int numResourceManagers = config.getNumResourceManagers()__			final boolean singleRpc = config.getUseSingleRpcSystem()___			try {_				metricRegistry = createMetricRegistry(configuration)___				RpcService[] jobManagerRpcServices = new RpcService[numJobManagers]__				RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]__				RpcService[] resourceManagerRpcServices = new RpcService[numResourceManagers]___				_				if (singleRpc) {_					_					commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___					_					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = commonRpcService__					}__					this.resourceManagerRpcServices = null__					this.jobManagerRpcServices = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = config.getJobManagerBindAddress()__					final String taskManagerBindAddress = config.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = config.getResourceManagerBindAddress()___					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, jobManagerBindAddress)__					}__					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, resourceManagerBindAddress)__					}__					this.jobManagerRpcServices = jobManagerRpcServices__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcServices = resourceManagerRpcServices__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(configuration)___				_				LOG.info("Starting {} ResourceManger(s)", numResourceManagers)__				resourceManagerRunners = startResourceManagers(_						configuration, haServices, metricRegistry, numResourceManagers, resourceManagerRpcServices)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagerRunners = startTaskManagers(_						configuration, haServices, metricRegistry, numTaskManagers, taskManagerRpcServices)___				_				LOG.info("Starting job dispatcher for {} JobManger(s)", numJobManagers)__				jobDispatcher = new MiniClusterJobDispatcher(_						configuration, haServices, metricRegistry, numJobManagers, jobManagerRpcServices)__			}_			catch (Exception e) {_				_				try {_					shutdownInternally()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,config,final,configuration,configuration,new,unmodifiable,configuration,config,get,configuration,final,time,rpc,timeout,config,get,rpc,timeout,final,int,num,job,managers,config,get,num,job,managers,final,int,num,task,managers,config,get,num,task,managers,final,int,num,resource,managers,config,get,num,resource,managers,final,boolean,single,rpc,config,get,use,single,rpc,system,try,metric,registry,create,metric,registry,configuration,rpc,service,job,manager,rpc,services,new,rpc,service,num,job,managers,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,rpc,service,resource,manager,rpc,services,new,rpc,service,num,resource,managers,if,single,rpc,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,common,rpc,service,this,resource,manager,rpc,services,null,this,job,manager,rpc,services,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,config,get,job,manager,bind,address,final,string,task,manager,bind,address,config,get,task,manager,bind,address,final,string,resource,manager,bind,address,config,get,resource,manager,bind,address,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,this,job,manager,rpc,services,job,manager,rpc,services,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,services,resource,manager,rpc,services,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,log,info,starting,resource,manger,s,num,resource,managers,resource,manager,runners,start,resource,managers,configuration,ha,services,metric,registry,num,resource,managers,resource,manager,rpc,services,log,info,starting,task,manger,s,num,task,managers,task,manager,runners,start,task,managers,configuration,ha,services,metric,registry,num,task,managers,task,manager,rpc,services,log,info,starting,job,dispatcher,for,job,manger,s,num,job,managers,job,dispatcher,new,mini,cluster,job,dispatcher,configuration,ha,services,metric,registry,num,job,managers,job,manager,rpc,services,catch,exception,e,try,shutdown,internally,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1482522864;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", config)___			final Configuration configuration = new UnmodifiableConfiguration(config.generateConfiguration())__			final Time rpcTimeout = config.getRpcTimeout()__			final int numJobManagers = config.getNumJobManagers()__			final int numTaskManagers = config.getNumTaskManagers()__			final int numResourceManagers = config.getNumResourceManagers()__			final boolean singleRpc = config.getUseSingleRpcSystem()___			try {_				metricRegistry = createMetricRegistry(configuration)___				RpcService[] jobManagerRpcServices = new RpcService[numJobManagers]__				RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]__				RpcService[] resourceManagerRpcServices = new RpcService[numResourceManagers]___				_				if (singleRpc) {_					_					commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___					_					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = commonRpcService__					}__					this.resourceManagerRpcServices = null__					this.jobManagerRpcServices = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = config.getJobManagerBindAddress()__					final String taskManagerBindAddress = config.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = config.getResourceManagerBindAddress()___					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, jobManagerBindAddress)__					}__					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, resourceManagerBindAddress)__					}__					this.jobManagerRpcServices = jobManagerRpcServices__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcServices = resourceManagerRpcServices__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(configuration)___				_				LOG.info("Starting {} ResourceManger(s)", numResourceManagers)__				resourceManagerRunners = startResourceManagers(_						configuration, haServices, metricRegistry, numResourceManagers, resourceManagerRpcServices)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagerRunners = startTaskManagers(_						configuration, haServices, metricRegistry, numTaskManagers, taskManagerRpcServices)___				_				LOG.info("Starting job dispatcher for {} JobManger(s)", numJobManagers)__				jobDispatcher = new MiniClusterJobDispatcher(_						configuration, haServices, metricRegistry, numJobManagers, jobManagerRpcServices)__			}_			catch (Exception e) {_				_				try {_					shutdownInternally()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,config,final,configuration,configuration,new,unmodifiable,configuration,config,generate,configuration,final,time,rpc,timeout,config,get,rpc,timeout,final,int,num,job,managers,config,get,num,job,managers,final,int,num,task,managers,config,get,num,task,managers,final,int,num,resource,managers,config,get,num,resource,managers,final,boolean,single,rpc,config,get,use,single,rpc,system,try,metric,registry,create,metric,registry,configuration,rpc,service,job,manager,rpc,services,new,rpc,service,num,job,managers,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,rpc,service,resource,manager,rpc,services,new,rpc,service,num,resource,managers,if,single,rpc,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,common,rpc,service,this,resource,manager,rpc,services,null,this,job,manager,rpc,services,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,config,get,job,manager,bind,address,final,string,task,manager,bind,address,config,get,task,manager,bind,address,final,string,resource,manager,bind,address,config,get,resource,manager,bind,address,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,this,job,manager,rpc,services,job,manager,rpc,services,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,services,resource,manager,rpc,services,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,log,info,starting,resource,manger,s,num,resource,managers,resource,manager,runners,start,resource,managers,configuration,ha,services,metric,registry,num,resource,managers,resource,manager,rpc,services,log,info,starting,task,manger,s,num,task,managers,task,manager,runners,start,task,managers,configuration,ha,services,metric,registry,num,task,managers,task,manager,rpc,services,log,info,starting,job,dispatcher,for,job,manger,s,num,job,managers,job,dispatcher,new,mini,cluster,job,dispatcher,configuration,ha,services,metric,registry,num,job,managers,job,manager,rpc,services,catch,exception,e,try,shutdown,internally,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1482522866;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", config)___			final Configuration configuration = new UnmodifiableConfiguration(config.generateConfiguration())__			final Time rpcTimeout = config.getRpcTimeout()__			final int numJobManagers = config.getNumJobManagers()__			final int numTaskManagers = config.getNumTaskManagers()__			final int numResourceManagers = config.getNumResourceManagers()__			final boolean singleRpc = config.getUseSingleRpcSystem()___			try {_				metricRegistry = createMetricRegistry(configuration)___				RpcService[] jobManagerRpcServices = new RpcService[numJobManagers]__				RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]__				RpcService[] resourceManagerRpcServices = new RpcService[numResourceManagers]___				_				if (singleRpc) {_					_					commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___					_					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = commonRpcService__					}__					this.resourceManagerRpcServices = null__					this.jobManagerRpcServices = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = config.getJobManagerBindAddress()__					final String taskManagerBindAddress = config.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = config.getResourceManagerBindAddress()___					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, jobManagerBindAddress)__					}__					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, resourceManagerBindAddress)__					}__					this.jobManagerRpcServices = jobManagerRpcServices__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcServices = resourceManagerRpcServices__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(configuration)___				_				LOG.info("Starting {} ResourceManger(s)", numResourceManagers)__				resourceManagerRunners = startResourceManagers(_						configuration, haServices, metricRegistry, numResourceManagers, resourceManagerRpcServices)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagerRunners = startTaskManagers(_						configuration, haServices, metricRegistry, numTaskManagers, taskManagerRpcServices)___				_				LOG.info("Starting job dispatcher for {} JobManger(s)", numJobManagers)__				jobDispatcher = new MiniClusterJobDispatcher(_						configuration, haServices, metricRegistry, numJobManagers, jobManagerRpcServices)__			}_			catch (Exception e) {_				_				try {_					shutdownInternally()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,config,final,configuration,configuration,new,unmodifiable,configuration,config,generate,configuration,final,time,rpc,timeout,config,get,rpc,timeout,final,int,num,job,managers,config,get,num,job,managers,final,int,num,task,managers,config,get,num,task,managers,final,int,num,resource,managers,config,get,num,resource,managers,final,boolean,single,rpc,config,get,use,single,rpc,system,try,metric,registry,create,metric,registry,configuration,rpc,service,job,manager,rpc,services,new,rpc,service,num,job,managers,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,rpc,service,resource,manager,rpc,services,new,rpc,service,num,resource,managers,if,single,rpc,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,common,rpc,service,this,resource,manager,rpc,services,null,this,job,manager,rpc,services,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,config,get,job,manager,bind,address,final,string,task,manager,bind,address,config,get,task,manager,bind,address,final,string,resource,manager,bind,address,config,get,resource,manager,bind,address,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,this,job,manager,rpc,services,job,manager,rpc,services,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,services,resource,manager,rpc,services,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,log,info,starting,resource,manger,s,num,resource,managers,resource,manager,runners,start,resource,managers,configuration,ha,services,metric,registry,num,resource,managers,resource,manager,rpc,services,log,info,starting,task,manger,s,num,task,managers,task,manager,runners,start,task,managers,configuration,ha,services,metric,registry,num,task,managers,task,manager,rpc,services,log,info,starting,job,dispatcher,for,job,manger,s,num,job,managers,job,dispatcher,new,mini,cluster,job,dispatcher,configuration,ha,services,metric,registry,num,job,managers,job,manager,rpc,services,catch,exception,e,try,shutdown,internally,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1482522866;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", config)___			final Configuration configuration = new UnmodifiableConfiguration(config.generateConfiguration())__			final Time rpcTimeout = config.getRpcTimeout()__			final int numJobManagers = config.getNumJobManagers()__			final int numTaskManagers = config.getNumTaskManagers()__			final int numResourceManagers = config.getNumResourceManagers()__			final boolean singleRpc = config.getUseSingleRpcSystem()___			try {_				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				RpcService[] jobManagerRpcServices = new RpcService[numJobManagers]__				RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]__				RpcService[] resourceManagerRpcServices = new RpcService[numResourceManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				if (singleRpc) {_					_					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = commonRpcService__					}__					this.resourceManagerRpcServices = null__					this.jobManagerRpcServices = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = config.getJobManagerBindAddress()__					final String taskManagerBindAddress = config.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = config.getResourceManagerBindAddress()___					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, jobManagerBindAddress)__					}__					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, resourceManagerBindAddress)__					}__					this.jobManagerRpcServices = jobManagerRpcServices__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcServices = resourceManagerRpcServices__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(configuration)___				_				LOG.info("Starting {} ResourceManger(s)", numResourceManagers)__				resourceManagerRunners = startResourceManagers(_						configuration, haServices, metricRegistry, numResourceManagers, resourceManagerRpcServices)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagerRunners = startTaskManagers(_						configuration, haServices, metricRegistry, numTaskManagers, taskManagerRpcServices)___				_				LOG.info("Starting job dispatcher(s) for {} JobManger(s)", numJobManagers)__				jobDispatcher = new MiniClusterJobDispatcher(_						configuration, haServices, metricRegistry, numJobManagers, jobManagerRpcServices)__			}_			catch (Exception e) {_				_				try {_					shutdownInternally()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,config,final,configuration,configuration,new,unmodifiable,configuration,config,generate,configuration,final,time,rpc,timeout,config,get,rpc,timeout,final,int,num,job,managers,config,get,num,job,managers,final,int,num,task,managers,config,get,num,task,managers,final,int,num,resource,managers,config,get,num,resource,managers,final,boolean,single,rpc,config,get,use,single,rpc,system,try,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,rpc,service,job,manager,rpc,services,new,rpc,service,num,job,managers,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,rpc,service,resource,manager,rpc,services,new,rpc,service,num,resource,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,if,single,rpc,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,common,rpc,service,this,resource,manager,rpc,services,null,this,job,manager,rpc,services,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,config,get,job,manager,bind,address,final,string,task,manager,bind,address,config,get,task,manager,bind,address,final,string,resource,manager,bind,address,config,get,resource,manager,bind,address,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,this,job,manager,rpc,services,job,manager,rpc,services,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,services,resource,manager,rpc,services,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,log,info,starting,resource,manger,s,num,resource,managers,resource,manager,runners,start,resource,managers,configuration,ha,services,metric,registry,num,resource,managers,resource,manager,rpc,services,log,info,starting,task,manger,s,num,task,managers,task,manager,runners,start,task,managers,configuration,ha,services,metric,registry,num,task,managers,task,manager,rpc,services,log,info,starting,job,dispatcher,s,for,job,manger,s,num,job,managers,job,dispatcher,new,mini,cluster,job,dispatcher,configuration,ha,services,metric,registry,num,job,managers,job,manager,rpc,services,catch,exception,e,try,shutdown,internally,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1482522866;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", config)___			final Configuration configuration = new UnmodifiableConfiguration(config.generateConfiguration())__			final Time rpcTimeout = config.getRpcTimeout()__			final int numJobManagers = config.getNumJobManagers()__			final int numTaskManagers = config.getNumTaskManagers()__			final int numResourceManagers = config.getNumResourceManagers()__			final boolean singleRpc = config.getUseSingleRpcSystem()___			try {_				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				RpcService[] jobManagerRpcServices = new RpcService[numJobManagers]__				RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]__				RpcService[] resourceManagerRpcServices = new RpcService[numResourceManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				if (singleRpc) {_					_					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = commonRpcService__					}__					this.resourceManagerRpcServices = null__					this.jobManagerRpcServices = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = config.getJobManagerBindAddress()__					final String taskManagerBindAddress = config.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = config.getResourceManagerBindAddress()___					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, jobManagerBindAddress)__					}__					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, resourceManagerBindAddress)__					}__					this.jobManagerRpcServices = jobManagerRpcServices__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcServices = resourceManagerRpcServices__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(configuration)___				_				LOG.info("Starting {} ResourceManger(s)", numResourceManagers)__				resourceManagerRunners = startResourceManagers(_						configuration, haServices, metricRegistry, numResourceManagers, resourceManagerRpcServices)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagerRunners = startTaskManagers(_						configuration, haServices, metricRegistry, numTaskManagers, taskManagerRpcServices)___				_				LOG.info("Starting job dispatcher(s) for {} JobManger(s)", numJobManagers)__				jobDispatcher = new MiniClusterJobDispatcher(_						configuration, haServices, metricRegistry, numJobManagers, jobManagerRpcServices)__			}_			catch (Exception e) {_				_				try {_					shutdownInternally()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,config,final,configuration,configuration,new,unmodifiable,configuration,config,generate,configuration,final,time,rpc,timeout,config,get,rpc,timeout,final,int,num,job,managers,config,get,num,job,managers,final,int,num,task,managers,config,get,num,task,managers,final,int,num,resource,managers,config,get,num,resource,managers,final,boolean,single,rpc,config,get,use,single,rpc,system,try,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,rpc,service,job,manager,rpc,services,new,rpc,service,num,job,managers,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,rpc,service,resource,manager,rpc,services,new,rpc,service,num,resource,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,if,single,rpc,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,common,rpc,service,this,resource,manager,rpc,services,null,this,job,manager,rpc,services,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,config,get,job,manager,bind,address,final,string,task,manager,bind,address,config,get,task,manager,bind,address,final,string,resource,manager,bind,address,config,get,resource,manager,bind,address,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,this,job,manager,rpc,services,job,manager,rpc,services,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,services,resource,manager,rpc,services,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,log,info,starting,resource,manger,s,num,resource,managers,resource,manager,runners,start,resource,managers,configuration,ha,services,metric,registry,num,resource,managers,resource,manager,rpc,services,log,info,starting,task,manger,s,num,task,managers,task,manager,runners,start,task,managers,configuration,ha,services,metric,registry,num,task,managers,task,manager,rpc,services,log,info,starting,job,dispatcher,s,for,job,manger,s,num,job,managers,job,dispatcher,new,mini,cluster,job,dispatcher,configuration,ha,services,metric,registry,num,job,managers,job,manager,rpc,services,catch,exception,e,try,shutdown,internally,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1482522867;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", config)___			final Configuration configuration = new UnmodifiableConfiguration(config.generateConfiguration())__			final Time rpcTimeout = config.getRpcTimeout()__			final int numJobManagers = config.getNumJobManagers()__			final int numTaskManagers = config.getNumTaskManagers()__			final int numResourceManagers = config.getNumResourceManagers()__			final boolean singleRpc = config.getUseSingleRpcSystem()___			try {_				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				RpcService[] jobManagerRpcServices = new RpcService[numJobManagers]__				RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]__				RpcService[] resourceManagerRpcServices = new RpcService[numResourceManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				if (singleRpc) {_					_					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = commonRpcService__					}__					this.resourceManagerRpcServices = null__					this.jobManagerRpcServices = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = config.getJobManagerBindAddress()__					final String taskManagerBindAddress = config.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = config.getResourceManagerBindAddress()___					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, jobManagerBindAddress)__					}__					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, resourceManagerBindAddress)__					}__					this.jobManagerRpcServices = jobManagerRpcServices__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcServices = resourceManagerRpcServices__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(configuration)___				_				LOG.info("Starting {} ResourceManger(s)", numResourceManagers)__				resourceManagerRunners = startResourceManagers(_						configuration, haServices, metricRegistry, numResourceManagers, resourceManagerRpcServices)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagerRunners = startTaskManagers(_						configuration, haServices, metricRegistry, numTaskManagers, taskManagerRpcServices)___				_				LOG.info("Starting job dispatcher(s) for {} JobManger(s)", numJobManagers)__				jobDispatcher = new MiniClusterJobDispatcher(_						configuration, haServices, metricRegistry, numJobManagers, jobManagerRpcServices)__			}_			catch (Exception e) {_				_				try {_					shutdownInternally()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,config,final,configuration,configuration,new,unmodifiable,configuration,config,generate,configuration,final,time,rpc,timeout,config,get,rpc,timeout,final,int,num,job,managers,config,get,num,job,managers,final,int,num,task,managers,config,get,num,task,managers,final,int,num,resource,managers,config,get,num,resource,managers,final,boolean,single,rpc,config,get,use,single,rpc,system,try,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,rpc,service,job,manager,rpc,services,new,rpc,service,num,job,managers,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,rpc,service,resource,manager,rpc,services,new,rpc,service,num,resource,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,if,single,rpc,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,common,rpc,service,this,resource,manager,rpc,services,null,this,job,manager,rpc,services,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,config,get,job,manager,bind,address,final,string,task,manager,bind,address,config,get,task,manager,bind,address,final,string,resource,manager,bind,address,config,get,resource,manager,bind,address,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,this,job,manager,rpc,services,job,manager,rpc,services,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,services,resource,manager,rpc,services,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,log,info,starting,resource,manger,s,num,resource,managers,resource,manager,runners,start,resource,managers,configuration,ha,services,metric,registry,num,resource,managers,resource,manager,rpc,services,log,info,starting,task,manger,s,num,task,managers,task,manager,runners,start,task,managers,configuration,ha,services,metric,registry,num,task,managers,task,manager,rpc,services,log,info,starting,job,dispatcher,s,for,job,manger,s,num,job,managers,job,dispatcher,new,mini,cluster,job,dispatcher,configuration,ha,services,metric,registry,num,job,managers,job,manager,rpc,services,catch,exception,e,try,shutdown,internally,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1489766405;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", config)___			final Configuration configuration = new UnmodifiableConfiguration(config.generateConfiguration())__			final Time rpcTimeout = config.getRpcTimeout()__			final int numJobManagers = config.getNumJobManagers()__			final int numTaskManagers = config.getNumTaskManagers()__			final int numResourceManagers = config.getNumResourceManagers()__			final boolean singleRpc = config.getUseSingleRpcSystem()___			try {_				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				RpcService[] jobManagerRpcServices = new RpcService[numJobManagers]__				RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]__				RpcService[] resourceManagerRpcServices = new RpcService[numResourceManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				if (singleRpc) {_					_					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = commonRpcService__					}__					this.resourceManagerRpcServices = null__					this.jobManagerRpcServices = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = config.getJobManagerBindAddress()__					final String taskManagerBindAddress = config.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = config.getResourceManagerBindAddress()___					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, jobManagerBindAddress)__					}__					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, resourceManagerBindAddress)__					}__					this.jobManagerRpcServices = jobManagerRpcServices__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcServices = resourceManagerRpcServices__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(configuration)___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting {} ResourceManger(s)", numResourceManagers)__				resourceManagerRunners = startResourceManagers(_						configuration, haServices, metricRegistry, numResourceManagers, resourceManagerRpcServices)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagerRunners = startTaskManagers(_						configuration, haServices, metricRegistry, numTaskManagers, taskManagerRpcServices)___				_				LOG.info("Starting job dispatcher(s) for {} JobManger(s)", numJobManagers)__				jobDispatcher = new MiniClusterJobDispatcher(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					numJobManagers,_					jobManagerRpcServices)__			}_			catch (Exception e) {_				_				try {_					shutdownInternally()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,config,final,configuration,configuration,new,unmodifiable,configuration,config,generate,configuration,final,time,rpc,timeout,config,get,rpc,timeout,final,int,num,job,managers,config,get,num,job,managers,final,int,num,task,managers,config,get,num,task,managers,final,int,num,resource,managers,config,get,num,resource,managers,final,boolean,single,rpc,config,get,use,single,rpc,system,try,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,rpc,service,job,manager,rpc,services,new,rpc,service,num,job,managers,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,rpc,service,resource,manager,rpc,services,new,rpc,service,num,resource,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,if,single,rpc,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,common,rpc,service,this,resource,manager,rpc,services,null,this,job,manager,rpc,services,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,config,get,job,manager,bind,address,final,string,task,manager,bind,address,config,get,task,manager,bind,address,final,string,resource,manager,bind,address,config,get,resource,manager,bind,address,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,this,job,manager,rpc,services,job,manager,rpc,services,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,services,resource,manager,rpc,services,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,s,num,resource,managers,resource,manager,runners,start,resource,managers,configuration,ha,services,metric,registry,num,resource,managers,resource,manager,rpc,services,log,info,starting,task,manger,s,num,task,managers,task,manager,runners,start,task,managers,configuration,ha,services,metric,registry,num,task,managers,task,manager,rpc,services,log,info,starting,job,dispatcher,s,for,job,manger,s,num,job,managers,job,dispatcher,new,mini,cluster,job,dispatcher,configuration,ha,services,heartbeat,services,metric,registry,num,job,managers,job,manager,rpc,services,catch,exception,e,try,shutdown,internally,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1490273924;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", config)___			final Configuration configuration = new UnmodifiableConfiguration(config.generateConfiguration())__			final Time rpcTimeout = config.getRpcTimeout()__			final int numJobManagers = config.getNumJobManagers()__			final int numTaskManagers = config.getNumTaskManagers()__			final int numResourceManagers = config.getNumResourceManagers()__			final boolean singleRpc = config.getUseSingleRpcSystem()___			try {_				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				RpcService[] jobManagerRpcServices = new RpcService[numJobManagers]__				RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]__				RpcService[] resourceManagerRpcServices = new RpcService[numResourceManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				if (singleRpc) {_					_					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = commonRpcService__					}__					this.resourceManagerRpcServices = null__					this.jobManagerRpcServices = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = config.getJobManagerBindAddress()__					final String taskManagerBindAddress = config.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = config.getResourceManagerBindAddress()___					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, jobManagerBindAddress)__					}__					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, resourceManagerBindAddress)__					}__					this.jobManagerRpcServices = jobManagerRpcServices__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcServices = resourceManagerRpcServices__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(configuration)___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting {} ResourceManger(s)", numResourceManagers)__				resourceManagerRunners = startResourceManagers(_						configuration, haServices, heartbeatServices, metricRegistry, numResourceManagers, resourceManagerRpcServices)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagerRunners = startTaskManagers(_						configuration, haServices, metricRegistry, numTaskManagers, taskManagerRpcServices)___				_				LOG.info("Starting job dispatcher(s) for {} JobManger(s)", numJobManagers)__				jobDispatcher = new MiniClusterJobDispatcher(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					numJobManagers,_					jobManagerRpcServices)__			}_			catch (Exception e) {_				_				try {_					shutdownInternally()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,config,final,configuration,configuration,new,unmodifiable,configuration,config,generate,configuration,final,time,rpc,timeout,config,get,rpc,timeout,final,int,num,job,managers,config,get,num,job,managers,final,int,num,task,managers,config,get,num,task,managers,final,int,num,resource,managers,config,get,num,resource,managers,final,boolean,single,rpc,config,get,use,single,rpc,system,try,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,rpc,service,job,manager,rpc,services,new,rpc,service,num,job,managers,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,rpc,service,resource,manager,rpc,services,new,rpc,service,num,resource,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,if,single,rpc,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,common,rpc,service,this,resource,manager,rpc,services,null,this,job,manager,rpc,services,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,config,get,job,manager,bind,address,final,string,task,manager,bind,address,config,get,task,manager,bind,address,final,string,resource,manager,bind,address,config,get,resource,manager,bind,address,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,this,job,manager,rpc,services,job,manager,rpc,services,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,services,resource,manager,rpc,services,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,s,num,resource,managers,resource,manager,runners,start,resource,managers,configuration,ha,services,heartbeat,services,metric,registry,num,resource,managers,resource,manager,rpc,services,log,info,starting,task,manger,s,num,task,managers,task,manager,runners,start,task,managers,configuration,ha,services,metric,registry,num,task,managers,task,manager,rpc,services,log,info,starting,job,dispatcher,s,for,job,manger,s,num,job,managers,job,dispatcher,new,mini,cluster,job,dispatcher,configuration,ha,services,heartbeat,services,metric,registry,num,job,managers,job,manager,rpc,services,catch,exception,e,try,shutdown,internally,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1490273924;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", config)___			final Configuration configuration = new UnmodifiableConfiguration(config.generateConfiguration())__			final Time rpcTimeout = config.getRpcTimeout()__			final int numJobManagers = config.getNumJobManagers()__			final int numTaskManagers = config.getNumTaskManagers()__			final int numResourceManagers = config.getNumResourceManagers()__			final boolean singleRpc = config.getUseSingleRpcSystem()___			try {_				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				RpcService[] jobManagerRpcServices = new RpcService[numJobManagers]__				RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]__				RpcService[] resourceManagerRpcServices = new RpcService[numResourceManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				if (singleRpc) {_					_					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = commonRpcService__					}__					this.resourceManagerRpcServices = null__					this.jobManagerRpcServices = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = config.getJobManagerBindAddress()__					final String taskManagerBindAddress = config.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = config.getResourceManagerBindAddress()___					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, jobManagerBindAddress)__					}__					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, resourceManagerBindAddress)__					}__					this.jobManagerRpcServices = jobManagerRpcServices__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcServices = resourceManagerRpcServices__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(configuration)___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting {} ResourceManger(s)", numResourceManagers)__				resourceManagerRunners = startResourceManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					numResourceManagers,_					resourceManagerRpcServices)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagerRunners = startTaskManagers(_						configuration, haServices, metricRegistry, numTaskManagers, taskManagerRpcServices)___				_				LOG.info("Starting job dispatcher(s) for {} JobManger(s)", numJobManagers)__				jobDispatcher = new MiniClusterJobDispatcher(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					numJobManagers,_					jobManagerRpcServices)__			}_			catch (Exception e) {_				_				try {_					shutdownInternally()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,config,final,configuration,configuration,new,unmodifiable,configuration,config,generate,configuration,final,time,rpc,timeout,config,get,rpc,timeout,final,int,num,job,managers,config,get,num,job,managers,final,int,num,task,managers,config,get,num,task,managers,final,int,num,resource,managers,config,get,num,resource,managers,final,boolean,single,rpc,config,get,use,single,rpc,system,try,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,rpc,service,job,manager,rpc,services,new,rpc,service,num,job,managers,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,rpc,service,resource,manager,rpc,services,new,rpc,service,num,resource,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,if,single,rpc,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,common,rpc,service,this,resource,manager,rpc,services,null,this,job,manager,rpc,services,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,config,get,job,manager,bind,address,final,string,task,manager,bind,address,config,get,task,manager,bind,address,final,string,resource,manager,bind,address,config,get,resource,manager,bind,address,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,this,job,manager,rpc,services,job,manager,rpc,services,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,services,resource,manager,rpc,services,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,s,num,resource,managers,resource,manager,runners,start,resource,managers,configuration,ha,services,heartbeat,services,metric,registry,num,resource,managers,resource,manager,rpc,services,log,info,starting,task,manger,s,num,task,managers,task,manager,runners,start,task,managers,configuration,ha,services,metric,registry,num,task,managers,task,manager,rpc,services,log,info,starting,job,dispatcher,s,for,job,manger,s,num,job,managers,job,dispatcher,new,mini,cluster,job,dispatcher,configuration,ha,services,heartbeat,services,metric,registry,num,job,managers,job,manager,rpc,services,catch,exception,e,try,shutdown,internally,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1493146240;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", config)___			final Configuration configuration = new UnmodifiableConfiguration(config.generateConfiguration())__			final Time rpcTimeout = config.getRpcTimeout()__			final int numJobManagers = config.getNumJobManagers()__			final int numTaskManagers = config.getNumTaskManagers()__			final int numResourceManagers = config.getNumResourceManagers()__			final boolean singleRpc = config.getUseSingleRpcSystem()___			try {_				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				RpcService[] jobManagerRpcServices = new RpcService[numJobManagers]__				RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]__				RpcService[] resourceManagerRpcServices = new RpcService[numResourceManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				if (singleRpc) {_					_					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = commonRpcService__					}__					this.resourceManagerRpcServices = null__					this.jobManagerRpcServices = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = config.getJobManagerBindAddress()__					final String taskManagerBindAddress = config.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = config.getResourceManagerBindAddress()___					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, jobManagerBindAddress)__					}__					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, resourceManagerBindAddress)__					}__					this.jobManagerRpcServices = jobManagerRpcServices__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcServices = resourceManagerRpcServices__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(configuration)___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting {} ResourceManger(s)", numResourceManagers)__				resourceManagerRunners = startResourceManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					numResourceManagers,_					resourceManagerRpcServices)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagerRunners = startTaskManagers(_						configuration, haServices, metricRegistry, numTaskManagers, taskManagerRpcServices)___				_				LOG.info("Starting job dispatcher(s) for {} JobManger(s)", numJobManagers)__				jobDispatcher = new MiniClusterJobDispatcher(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					numJobManagers,_					jobManagerRpcServices)__			}_			catch (Exception e) {_				_				try {_					shutdownInternally()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,config,final,configuration,configuration,new,unmodifiable,configuration,config,generate,configuration,final,time,rpc,timeout,config,get,rpc,timeout,final,int,num,job,managers,config,get,num,job,managers,final,int,num,task,managers,config,get,num,task,managers,final,int,num,resource,managers,config,get,num,resource,managers,final,boolean,single,rpc,config,get,use,single,rpc,system,try,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,rpc,service,job,manager,rpc,services,new,rpc,service,num,job,managers,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,rpc,service,resource,manager,rpc,services,new,rpc,service,num,resource,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,if,single,rpc,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,common,rpc,service,this,resource,manager,rpc,services,null,this,job,manager,rpc,services,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,config,get,job,manager,bind,address,final,string,task,manager,bind,address,config,get,task,manager,bind,address,final,string,resource,manager,bind,address,config,get,resource,manager,bind,address,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,this,job,manager,rpc,services,job,manager,rpc,services,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,services,resource,manager,rpc,services,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,s,num,resource,managers,resource,manager,runners,start,resource,managers,configuration,ha,services,heartbeat,services,metric,registry,num,resource,managers,resource,manager,rpc,services,log,info,starting,task,manger,s,num,task,managers,task,manager,runners,start,task,managers,configuration,ha,services,metric,registry,num,task,managers,task,manager,rpc,services,log,info,starting,job,dispatcher,s,for,job,manger,s,num,job,managers,job,dispatcher,new,mini,cluster,job,dispatcher,configuration,ha,services,heartbeat,services,metric,registry,num,job,managers,job,manager,rpc,services,catch,exception,e,try,shutdown,internally,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1493975155;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", config)___			final Configuration configuration = new UnmodifiableConfiguration(config.generateConfiguration())__			final Time rpcTimeout = config.getRpcTimeout()__			final int numJobManagers = config.getNumJobManagers()__			final int numTaskManagers = config.getNumTaskManagers()__			final int numResourceManagers = config.getNumResourceManagers()__			final boolean singleRpc = config.getUseSingleRpcSystem()___			try {_				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				RpcService[] jobManagerRpcServices = new RpcService[numJobManagers]__				RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]__				RpcService[] resourceManagerRpcServices = new RpcService[numResourceManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				if (singleRpc) {_					_					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = commonRpcService__					}__					this.resourceManagerRpcServices = null__					this.jobManagerRpcServices = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = config.getJobManagerBindAddress()__					final String taskManagerBindAddress = config.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = config.getResourceManagerBindAddress()___					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, jobManagerBindAddress)__					}__					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, resourceManagerBindAddress)__					}__					this.jobManagerRpcServices = jobManagerRpcServices__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcServices = resourceManagerRpcServices__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting {} ResourceManger(s)", numResourceManagers)__				resourceManagerRunners = startResourceManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					numResourceManagers,_					resourceManagerRpcServices)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagerRunners = startTaskManagers(_						configuration, haServices, metricRegistry, numTaskManagers, taskManagerRpcServices)___				_				LOG.info("Starting job dispatcher(s) for {} JobManger(s)", numJobManagers)__				jobDispatcher = new MiniClusterJobDispatcher(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					numJobManagers,_					jobManagerRpcServices)__			}_			catch (Exception e) {_				_				try {_					shutdownInternally()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,config,final,configuration,configuration,new,unmodifiable,configuration,config,generate,configuration,final,time,rpc,timeout,config,get,rpc,timeout,final,int,num,job,managers,config,get,num,job,managers,final,int,num,task,managers,config,get,num,task,managers,final,int,num,resource,managers,config,get,num,resource,managers,final,boolean,single,rpc,config,get,use,single,rpc,system,try,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,rpc,service,job,manager,rpc,services,new,rpc,service,num,job,managers,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,rpc,service,resource,manager,rpc,services,new,rpc,service,num,resource,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,if,single,rpc,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,common,rpc,service,this,resource,manager,rpc,services,null,this,job,manager,rpc,services,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,config,get,job,manager,bind,address,final,string,task,manager,bind,address,config,get,task,manager,bind,address,final,string,resource,manager,bind,address,config,get,resource,manager,bind,address,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,this,job,manager,rpc,services,job,manager,rpc,services,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,services,resource,manager,rpc,services,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,s,num,resource,managers,resource,manager,runners,start,resource,managers,configuration,ha,services,heartbeat,services,metric,registry,num,resource,managers,resource,manager,rpc,services,log,info,starting,task,manger,s,num,task,managers,task,manager,runners,start,task,managers,configuration,ha,services,metric,registry,num,task,managers,task,manager,rpc,services,log,info,starting,job,dispatcher,s,for,job,manger,s,num,job,managers,job,dispatcher,new,mini,cluster,job,dispatcher,configuration,ha,services,heartbeat,services,metric,registry,num,job,managers,job,manager,rpc,services,catch,exception,e,try,shutdown,internally,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1499254138;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", config)___			final Configuration configuration = new UnmodifiableConfiguration(config.generateConfiguration())__			final Time rpcTimeout = config.getRpcTimeout()__			final int numJobManagers = config.getNumJobManagers()__			final int numTaskManagers = config.getNumTaskManagers()__			final int numResourceManagers = config.getNumResourceManagers()__			final boolean singleRpc = config.getUseSingleRpcSystem()___			try {_				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				RpcService[] jobManagerRpcServices = new RpcService[numJobManagers]__				RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]__				RpcService[] resourceManagerRpcServices = new RpcService[numResourceManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				if (singleRpc) {_					_					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = commonRpcService__					}__					this.resourceManagerRpcServices = null__					this.jobManagerRpcServices = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = config.getJobManagerBindAddress()__					final String taskManagerBindAddress = config.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = config.getResourceManagerBindAddress()___					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, jobManagerBindAddress)__					}__					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, resourceManagerBindAddress)__					}__					this.jobManagerRpcServices = jobManagerRpcServices__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcServices = resourceManagerRpcServices__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting {} ResourceManger(s)", numResourceManagers)__				resourceManagerRunners = startResourceManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					numResourceManagers,_					resourceManagerRpcServices)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_						configuration, haServices, metricRegistry, numTaskManagers, taskManagerRpcServices)___				_				LOG.info("Starting job dispatcher(s) for {} JobManger(s)", numJobManagers)__				jobDispatcher = new MiniClusterJobDispatcher(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					numJobManagers,_					jobManagerRpcServices)__			}_			catch (Exception e) {_				_				try {_					shutdownInternally()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,config,final,configuration,configuration,new,unmodifiable,configuration,config,generate,configuration,final,time,rpc,timeout,config,get,rpc,timeout,final,int,num,job,managers,config,get,num,job,managers,final,int,num,task,managers,config,get,num,task,managers,final,int,num,resource,managers,config,get,num,resource,managers,final,boolean,single,rpc,config,get,use,single,rpc,system,try,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,rpc,service,job,manager,rpc,services,new,rpc,service,num,job,managers,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,rpc,service,resource,manager,rpc,services,new,rpc,service,num,resource,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,if,single,rpc,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,common,rpc,service,this,resource,manager,rpc,services,null,this,job,manager,rpc,services,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,config,get,job,manager,bind,address,final,string,task,manager,bind,address,config,get,task,manager,bind,address,final,string,resource,manager,bind,address,config,get,resource,manager,bind,address,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,this,job,manager,rpc,services,job,manager,rpc,services,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,services,resource,manager,rpc,services,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,s,num,resource,managers,resource,manager,runners,start,resource,managers,configuration,ha,services,heartbeat,services,metric,registry,num,resource,managers,resource,manager,rpc,services,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,metric,registry,num,task,managers,task,manager,rpc,services,log,info,starting,job,dispatcher,s,for,job,manger,s,num,job,managers,job,dispatcher,new,mini,cluster,job,dispatcher,configuration,ha,services,heartbeat,services,metric,registry,num,job,managers,job,manager,rpc,services,catch,exception,e,try,shutdown,internally,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1499789965;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", config)___			final Configuration configuration = new UnmodifiableConfiguration(config.generateConfiguration())__			final Time rpcTimeout = config.getRpcTimeout()__			final int numJobManagers = config.getNumJobManagers()__			final int numTaskManagers = config.getNumTaskManagers()__			final int numResourceManagers = config.getNumResourceManagers()__			final boolean singleRpc = config.getUseSingleRpcSystem()___			try {_				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				RpcService[] jobManagerRpcServices = new RpcService[numJobManagers]__				RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]__				RpcService[] resourceManagerRpcServices = new RpcService[numResourceManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				if (singleRpc) {_					_					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = commonRpcService__					}__					this.resourceManagerRpcServices = null__					this.jobManagerRpcServices = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = config.getJobManagerBindAddress()__					final String taskManagerBindAddress = config.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = config.getResourceManagerBindAddress()___					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, jobManagerBindAddress)__					}__					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, resourceManagerBindAddress)__					}__					this.jobManagerRpcServices = jobManagerRpcServices__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcServices = resourceManagerRpcServices__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting {} ResourceManger(s)", numResourceManagers)__				resourceManagerRunners = startResourceManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					numResourceManagers,_					resourceManagerRpcServices)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_						configuration, haServices, metricRegistry, numTaskManagers, taskManagerRpcServices)___				_				LOG.info("Starting job dispatcher(s) for {} JobManger(s)", numJobManagers)__				jobDispatcher = new MiniClusterJobDispatcher(_					configuration,_					haServices,_					blobServer,_					heartbeatServices,_					metricRegistry,_					numJobManagers,_					jobManagerRpcServices)__			}_			catch (Exception e) {_				_				try {_					shutdownInternally()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,config,final,configuration,configuration,new,unmodifiable,configuration,config,generate,configuration,final,time,rpc,timeout,config,get,rpc,timeout,final,int,num,job,managers,config,get,num,job,managers,final,int,num,task,managers,config,get,num,task,managers,final,int,num,resource,managers,config,get,num,resource,managers,final,boolean,single,rpc,config,get,use,single,rpc,system,try,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,rpc,service,job,manager,rpc,services,new,rpc,service,num,job,managers,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,rpc,service,resource,manager,rpc,services,new,rpc,service,num,resource,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,if,single,rpc,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,common,rpc,service,this,resource,manager,rpc,services,null,this,job,manager,rpc,services,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,config,get,job,manager,bind,address,final,string,task,manager,bind,address,config,get,task,manager,bind,address,final,string,resource,manager,bind,address,config,get,resource,manager,bind,address,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,this,job,manager,rpc,services,job,manager,rpc,services,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,services,resource,manager,rpc,services,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,s,num,resource,managers,resource,manager,runners,start,resource,managers,configuration,ha,services,heartbeat,services,metric,registry,num,resource,managers,resource,manager,rpc,services,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,metric,registry,num,task,managers,task,manager,rpc,services,log,info,starting,job,dispatcher,s,for,job,manger,s,num,job,managers,job,dispatcher,new,mini,cluster,job,dispatcher,configuration,ha,services,blob,server,heartbeat,services,metric,registry,num,job,managers,job,manager,rpc,services,catch,exception,e,try,shutdown,internally,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1501437265;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", config)___			final Configuration configuration = new UnmodifiableConfiguration(config.generateConfiguration())__			final Time rpcTimeout = config.getRpcTimeout()__			final int numJobManagers = config.getNumJobManagers()__			final int numTaskManagers = config.getNumTaskManagers()__			final int numResourceManagers = config.getNumResourceManagers()__			final boolean singleRpc = config.getUseSingleRpcSystem()___			try {_				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				RpcService[] jobManagerRpcServices = new RpcService[numJobManagers]__				RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]__				RpcService[] resourceManagerRpcServices = new RpcService[numResourceManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				if (singleRpc) {_					_					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = commonRpcService__					}__					this.resourceManagerRpcServices = null__					this.jobManagerRpcServices = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = config.getJobManagerBindAddress()__					final String taskManagerBindAddress = config.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = config.getResourceManagerBindAddress()___					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, jobManagerBindAddress)__					}__					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, resourceManagerBindAddress)__					}__					this.jobManagerRpcServices = jobManagerRpcServices__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcServices = resourceManagerRpcServices__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting {} ResourceManger(s)", numResourceManagers)__				resourceManagerRunners = startResourceManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					numResourceManagers,_					resourceManagerRpcServices)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_						configuration, haServices, metricRegistry, numTaskManagers, taskManagerRpcServices)___				_				LOG.info("Starting job dispatcher(s) for {} JobManger(s)", numJobManagers)__				jobDispatcher = new MiniClusterJobDispatcher(_					configuration,_					haServices,_					blobServer,_					heartbeatServices,_					metricRegistry,_					numJobManagers,_					jobManagerRpcServices)__			}_			catch (Exception e) {_				_				try {_					shutdownInternally()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,config,final,configuration,configuration,new,unmodifiable,configuration,config,generate,configuration,final,time,rpc,timeout,config,get,rpc,timeout,final,int,num,job,managers,config,get,num,job,managers,final,int,num,task,managers,config,get,num,task,managers,final,int,num,resource,managers,config,get,num,resource,managers,final,boolean,single,rpc,config,get,use,single,rpc,system,try,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,rpc,service,job,manager,rpc,services,new,rpc,service,num,job,managers,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,rpc,service,resource,manager,rpc,services,new,rpc,service,num,resource,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,if,single,rpc,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,common,rpc,service,this,resource,manager,rpc,services,null,this,job,manager,rpc,services,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,config,get,job,manager,bind,address,final,string,task,manager,bind,address,config,get,task,manager,bind,address,final,string,resource,manager,bind,address,config,get,resource,manager,bind,address,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,this,job,manager,rpc,services,job,manager,rpc,services,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,services,resource,manager,rpc,services,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,s,num,resource,managers,resource,manager,runners,start,resource,managers,configuration,ha,services,heartbeat,services,metric,registry,num,resource,managers,resource,manager,rpc,services,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,metric,registry,num,task,managers,task,manager,rpc,services,log,info,starting,job,dispatcher,s,for,job,manger,s,num,job,managers,job,dispatcher,new,mini,cluster,job,dispatcher,configuration,ha,services,blob,server,heartbeat,services,metric,registry,num,job,managers,job,manager,rpc,services,catch,exception,e,try,shutdown,internally,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1501660818;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", config)___			final Configuration configuration = new UnmodifiableConfiguration(config.generateConfiguration())__			final Time rpcTimeout = config.getRpcTimeout()__			final int numJobManagers = config.getNumJobManagers()__			final int numTaskManagers = config.getNumTaskManagers()__			final int numResourceManagers = config.getNumResourceManagers()__			final boolean singleRpc = config.getUseSingleRpcSystem()___			try {_				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				RpcService[] jobManagerRpcServices = new RpcService[numJobManagers]__				RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]__				RpcService[] resourceManagerRpcServices = new RpcService[numResourceManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				if (singleRpc) {_					_					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = commonRpcService__					}__					this.resourceManagerRpcServices = null__					this.jobManagerRpcServices = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = config.getJobManagerBindAddress()__					final String taskManagerBindAddress = config.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = config.getResourceManagerBindAddress()___					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, jobManagerBindAddress)__					}__					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, resourceManagerBindAddress)__					}__					this.jobManagerRpcServices = jobManagerRpcServices__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcServices = resourceManagerRpcServices__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting {} ResourceManger(s)", numResourceManagers)__				resourceManagerRunners = startResourceManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					numResourceManagers,_					resourceManagerRpcServices)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_						configuration, haServices, metricRegistry, numTaskManagers, taskManagerRpcServices)___				_				LOG.info("Starting job dispatcher(s) for {} JobManger(s)", numJobManagers)__				jobDispatcher = new MiniClusterJobDispatcher(_					configuration,_					haServices,_					blobServer,_					heartbeatServices,_					metricRegistry,_					numJobManagers,_					jobManagerRpcServices)__			}_			catch (Exception e) {_				_				try {_					shutdownInternally()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,config,final,configuration,configuration,new,unmodifiable,configuration,config,generate,configuration,final,time,rpc,timeout,config,get,rpc,timeout,final,int,num,job,managers,config,get,num,job,managers,final,int,num,task,managers,config,get,num,task,managers,final,int,num,resource,managers,config,get,num,resource,managers,final,boolean,single,rpc,config,get,use,single,rpc,system,try,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,rpc,service,job,manager,rpc,services,new,rpc,service,num,job,managers,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,rpc,service,resource,manager,rpc,services,new,rpc,service,num,resource,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,if,single,rpc,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,common,rpc,service,this,resource,manager,rpc,services,null,this,job,manager,rpc,services,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,config,get,job,manager,bind,address,final,string,task,manager,bind,address,config,get,task,manager,bind,address,final,string,resource,manager,bind,address,config,get,resource,manager,bind,address,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,this,job,manager,rpc,services,job,manager,rpc,services,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,services,resource,manager,rpc,services,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,s,num,resource,managers,resource,manager,runners,start,resource,managers,configuration,ha,services,heartbeat,services,metric,registry,num,resource,managers,resource,manager,rpc,services,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,metric,registry,num,task,managers,task,manager,rpc,services,log,info,starting,job,dispatcher,s,for,job,manger,s,num,job,managers,job,dispatcher,new,mini,cluster,job,dispatcher,configuration,ha,services,blob,server,heartbeat,services,metric,registry,num,job,managers,job,manager,rpc,services,catch,exception,e,try,shutdown,internally,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1504477043;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", config)___			final Configuration configuration = new UnmodifiableConfiguration(config.generateConfiguration())__			final Time rpcTimeout = config.getRpcTimeout()__			final int numJobManagers = config.getNumJobManagers()__			final int numTaskManagers = config.getNumTaskManagers()__			final int numResourceManagers = config.getNumResourceManagers()__			final boolean singleRpc = config.getUseSingleRpcSystem()___			try {_				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				RpcService[] jobManagerRpcServices = new RpcService[numJobManagers]__				RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]__				RpcService[] resourceManagerRpcServices = new RpcService[numResourceManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				if (singleRpc) {_					_					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = commonRpcService__					}__					this.resourceManagerRpcServices = null__					this.jobManagerRpcServices = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = config.getJobManagerBindAddress()__					final String taskManagerBindAddress = config.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = config.getResourceManagerBindAddress()___					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, jobManagerBindAddress)__					}__					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, resourceManagerBindAddress)__					}__					this.jobManagerRpcServices = jobManagerRpcServices__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcServices = resourceManagerRpcServices__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting {} ResourceManger(s)", numResourceManagers)__				resourceManagerRunners = startResourceManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					numResourceManagers,_					resourceManagerRpcServices)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_						configuration, haServices, metricRegistry, numTaskManagers, taskManagerRpcServices)___				_				LOG.info("Starting job dispatcher(s) for {} JobManger(s)", numJobManagers)__				jobDispatcher = new MiniClusterJobDispatcher(_					configuration,_					haServices,_					blobServer,_					heartbeatServices,_					metricRegistry,_					numJobManagers,_					jobManagerRpcServices)__			}_			catch (Exception e) {_				_				try {_					shutdownInternally()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,config,final,configuration,configuration,new,unmodifiable,configuration,config,generate,configuration,final,time,rpc,timeout,config,get,rpc,timeout,final,int,num,job,managers,config,get,num,job,managers,final,int,num,task,managers,config,get,num,task,managers,final,int,num,resource,managers,config,get,num,resource,managers,final,boolean,single,rpc,config,get,use,single,rpc,system,try,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,rpc,service,job,manager,rpc,services,new,rpc,service,num,job,managers,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,rpc,service,resource,manager,rpc,services,new,rpc,service,num,resource,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,if,single,rpc,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,common,rpc,service,this,resource,manager,rpc,services,null,this,job,manager,rpc,services,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,config,get,job,manager,bind,address,final,string,task,manager,bind,address,config,get,task,manager,bind,address,final,string,resource,manager,bind,address,config,get,resource,manager,bind,address,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,this,job,manager,rpc,services,job,manager,rpc,services,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,services,resource,manager,rpc,services,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,s,num,resource,managers,resource,manager,runners,start,resource,managers,configuration,ha,services,heartbeat,services,metric,registry,num,resource,managers,resource,manager,rpc,services,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,metric,registry,num,task,managers,task,manager,rpc,services,log,info,starting,job,dispatcher,s,for,job,manger,s,num,job,managers,job,dispatcher,new,mini,cluster,job,dispatcher,configuration,ha,services,blob,server,heartbeat,services,metric,registry,num,job,managers,job,manager,rpc,services,catch,exception,e,try,shutdown,internally,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1504525441;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", config)___			final Configuration configuration = new UnmodifiableConfiguration(config.generateConfiguration())__			final Time rpcTimeout = config.getRpcTimeout()__			final int numJobManagers = config.getNumJobManagers()__			final int numTaskManagers = config.getNumTaskManagers()__			final int numResourceManagers = config.getNumResourceManagers()__			final boolean singleRpc = config.getUseSingleRpcSystem()___			try {_				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				RpcService[] jobManagerRpcServices = new RpcService[numJobManagers]__				RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]__				RpcService[] resourceManagerRpcServices = new RpcService[numResourceManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				if (singleRpc) {_					_					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = commonRpcService__					}__					this.resourceManagerRpcServices = null__					this.jobManagerRpcServices = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = config.getJobManagerBindAddress()__					final String taskManagerBindAddress = config.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = config.getResourceManagerBindAddress()___					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, jobManagerBindAddress)__					}__					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, resourceManagerBindAddress)__					}__					this.jobManagerRpcServices = jobManagerRpcServices__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcServices = resourceManagerRpcServices__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting {} ResourceManger(s)", numResourceManagers)__				resourceManagerRunners = startResourceManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					numResourceManagers,_					resourceManagerRpcServices)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_						configuration, haServices, metricRegistry, numTaskManagers, taskManagerRpcServices)___				_				LOG.info("Starting job dispatcher(s) for {} JobManger(s)", numJobManagers)__				jobDispatcher = new MiniClusterJobDispatcher(_					configuration,_					haServices,_					blobServer,_					heartbeatServices,_					metricRegistry,_					numJobManagers,_					jobManagerRpcServices)__			}_			catch (Exception e) {_				_				try {_					shutdownInternally()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,config,final,configuration,configuration,new,unmodifiable,configuration,config,generate,configuration,final,time,rpc,timeout,config,get,rpc,timeout,final,int,num,job,managers,config,get,num,job,managers,final,int,num,task,managers,config,get,num,task,managers,final,int,num,resource,managers,config,get,num,resource,managers,final,boolean,single,rpc,config,get,use,single,rpc,system,try,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,rpc,service,job,manager,rpc,services,new,rpc,service,num,job,managers,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,rpc,service,resource,manager,rpc,services,new,rpc,service,num,resource,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,if,single,rpc,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,common,rpc,service,this,resource,manager,rpc,services,null,this,job,manager,rpc,services,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,config,get,job,manager,bind,address,final,string,task,manager,bind,address,config,get,task,manager,bind,address,final,string,resource,manager,bind,address,config,get,resource,manager,bind,address,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,this,job,manager,rpc,services,job,manager,rpc,services,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,services,resource,manager,rpc,services,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,s,num,resource,managers,resource,manager,runners,start,resource,managers,configuration,ha,services,heartbeat,services,metric,registry,num,resource,managers,resource,manager,rpc,services,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,metric,registry,num,task,managers,task,manager,rpc,services,log,info,starting,job,dispatcher,s,for,job,manger,s,num,job,managers,job,dispatcher,new,mini,cluster,job,dispatcher,configuration,ha,services,blob,server,heartbeat,services,metric,registry,num,job,managers,job,manager,rpc,services,catch,exception,e,try,shutdown,internally,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1504607872;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", config)___			final Configuration configuration = new UnmodifiableConfiguration(config.generateConfiguration())__			final Time rpcTimeout = config.getRpcTimeout()__			final int numJobManagers = config.getNumJobManagers()__			final int numTaskManagers = config.getNumTaskManagers()__			final int numResourceManagers = config.getNumResourceManagers()__			final boolean singleRpc = config.getUseSingleRpcSystem()___			try {_				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				RpcService[] jobManagerRpcServices = new RpcService[numJobManagers]__				RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]__				RpcService[] resourceManagerRpcServices = new RpcService[numResourceManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				if (singleRpc) {_					_					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = commonRpcService__					}__					this.resourceManagerRpcServices = null__					this.jobManagerRpcServices = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = config.getJobManagerBindAddress()__					final String taskManagerBindAddress = config.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = config.getResourceManagerBindAddress()___					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, jobManagerBindAddress)__					}__					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, resourceManagerBindAddress)__					}__					this.jobManagerRpcServices = jobManagerRpcServices__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcServices = resourceManagerRpcServices__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting {} ResourceManger(s)", numResourceManagers)__				resourceManagerRunners = startResourceManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					numResourceManagers,_					resourceManagerRpcServices)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_						configuration, haServices, metricRegistry, numTaskManagers, taskManagerRpcServices)___				_				LOG.info("Starting job dispatcher(s) for {} JobManger(s)", numJobManagers)__				jobDispatcher = new MiniClusterJobDispatcher(_					configuration,_					haServices,_					blobServer,_					heartbeatServices,_					metricRegistry,_					numJobManagers,_					jobManagerRpcServices)__			}_			catch (Exception e) {_				_				try {_					shutdownInternally()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,config,final,configuration,configuration,new,unmodifiable,configuration,config,generate,configuration,final,time,rpc,timeout,config,get,rpc,timeout,final,int,num,job,managers,config,get,num,job,managers,final,int,num,task,managers,config,get,num,task,managers,final,int,num,resource,managers,config,get,num,resource,managers,final,boolean,single,rpc,config,get,use,single,rpc,system,try,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,rpc,service,job,manager,rpc,services,new,rpc,service,num,job,managers,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,rpc,service,resource,manager,rpc,services,new,rpc,service,num,resource,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,if,single,rpc,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,common,rpc,service,this,resource,manager,rpc,services,null,this,job,manager,rpc,services,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,config,get,job,manager,bind,address,final,string,task,manager,bind,address,config,get,task,manager,bind,address,final,string,resource,manager,bind,address,config,get,resource,manager,bind,address,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,this,job,manager,rpc,services,job,manager,rpc,services,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,services,resource,manager,rpc,services,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,s,num,resource,managers,resource,manager,runners,start,resource,managers,configuration,ha,services,heartbeat,services,metric,registry,num,resource,managers,resource,manager,rpc,services,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,metric,registry,num,task,managers,task,manager,rpc,services,log,info,starting,job,dispatcher,s,for,job,manger,s,num,job,managers,job,dispatcher,new,mini,cluster,job,dispatcher,configuration,ha,services,blob,server,heartbeat,services,metric,registry,num,job,managers,job,manager,rpc,services,catch,exception,e,try,shutdown,internally,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1507212387;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", config)___			final Configuration configuration = new UnmodifiableConfiguration(config.generateConfiguration())__			final Time rpcTimeout = config.getRpcTimeout()__			final int numJobManagers = config.getNumJobManagers()__			final int numTaskManagers = config.getNumTaskManagers()__			final int numResourceManagers = config.getNumResourceManagers()__			final boolean singleRpc = config.getUseSingleRpcSystem()___			try {_				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				RpcService[] jobManagerRpcServices = new RpcService[numJobManagers]__				RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]__				RpcService[] resourceManagerRpcServices = new RpcService[numResourceManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				if (singleRpc) {_					_					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = commonRpcService__					}__					this.resourceManagerRpcServices = null__					this.jobManagerRpcServices = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = config.getJobManagerBindAddress()__					final String taskManagerBindAddress = config.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = config.getResourceManagerBindAddress()___					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, jobManagerBindAddress)__					}__					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, resourceManagerBindAddress)__					}__					this.jobManagerRpcServices = jobManagerRpcServices__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcServices = resourceManagerRpcServices__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting {} ResourceManger(s)", numResourceManagers)__				resourceManagerRunners = startResourceManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					numResourceManagers,_					resourceManagerRpcServices)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_						configuration, haServices, metricRegistry, numTaskManagers, taskManagerRpcServices)___				_				LOG.info("Starting job dispatcher(s) for {} JobManger(s)", numJobManagers)__				jobDispatcher = new MiniClusterJobDispatcher(_					configuration,_					haServices,_					blobServer,_					heartbeatServices,_					metricRegistry,_					numJobManagers,_					jobManagerRpcServices)__			}_			catch (Exception e) {_				_				try {_					shutdownInternally()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,config,final,configuration,configuration,new,unmodifiable,configuration,config,generate,configuration,final,time,rpc,timeout,config,get,rpc,timeout,final,int,num,job,managers,config,get,num,job,managers,final,int,num,task,managers,config,get,num,task,managers,final,int,num,resource,managers,config,get,num,resource,managers,final,boolean,single,rpc,config,get,use,single,rpc,system,try,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,rpc,service,job,manager,rpc,services,new,rpc,service,num,job,managers,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,rpc,service,resource,manager,rpc,services,new,rpc,service,num,resource,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,if,single,rpc,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,common,rpc,service,this,resource,manager,rpc,services,null,this,job,manager,rpc,services,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,config,get,job,manager,bind,address,final,string,task,manager,bind,address,config,get,task,manager,bind,address,final,string,resource,manager,bind,address,config,get,resource,manager,bind,address,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,this,job,manager,rpc,services,job,manager,rpc,services,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,services,resource,manager,rpc,services,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,s,num,resource,managers,resource,manager,runners,start,resource,managers,configuration,ha,services,heartbeat,services,metric,registry,num,resource,managers,resource,manager,rpc,services,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,metric,registry,num,task,managers,task,manager,rpc,services,log,info,starting,job,dispatcher,s,for,job,manger,s,num,job,managers,job,dispatcher,new,mini,cluster,job,dispatcher,configuration,ha,services,blob,server,heartbeat,services,metric,registry,num,job,managers,job,manager,rpc,services,catch,exception,e,try,shutdown,internally,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1509006142;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numJobManagers = miniClusterConfiguration.getNumJobManagers()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final int numResourceManagers = miniClusterConfiguration.getNumResourceManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == MiniClusterConfiguration.RpcServiceSharing.SHARED___			try {_				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				RpcService[] jobManagerRpcServices = new RpcService[numJobManagers]__				RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]__				RpcService[] resourceManagerRpcServices = new RpcService[numResourceManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				if (useSingleRpcService) {_					_					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = commonRpcService__					}__					this.resourceManagerRpcServices = null__					this.jobManagerRpcServices = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, jobManagerBindAddress)__					}__					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, resourceManagerBindAddress)__					}__					this.jobManagerRpcServices = jobManagerRpcServices__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcServices = resourceManagerRpcServices__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting {} ResourceManger(s)", numResourceManagers)__				resourceManagerRunners = startResourceManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					numResourceManagers,_					resourceManagerRpcServices)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_						configuration, haServices, metricRegistry, numTaskManagers, taskManagerRpcServices)___				_				LOG.info("Starting job dispatcher(s) for {} JobManger(s)", numJobManagers)__				jobDispatcher = new MiniClusterJobDispatcher(_					configuration,_					haServices,_					blobServer,_					heartbeatServices,_					metricRegistry,_					numJobManagers,_					jobManagerRpcServices)__			}_			catch (Exception e) {_				_				try {_					shutdownInternally()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,job,managers,mini,cluster,configuration,get,num,job,managers,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,int,num,resource,managers,mini,cluster,configuration,get,num,resource,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,mini,cluster,configuration,rpc,service,sharing,shared,try,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,rpc,service,job,manager,rpc,services,new,rpc,service,num,job,managers,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,rpc,service,resource,manager,rpc,services,new,rpc,service,num,resource,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,if,use,single,rpc,service,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,common,rpc,service,this,resource,manager,rpc,services,null,this,job,manager,rpc,services,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,this,job,manager,rpc,services,job,manager,rpc,services,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,services,resource,manager,rpc,services,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,s,num,resource,managers,resource,manager,runners,start,resource,managers,configuration,ha,services,heartbeat,services,metric,registry,num,resource,managers,resource,manager,rpc,services,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,metric,registry,num,task,managers,task,manager,rpc,services,log,info,starting,job,dispatcher,s,for,job,manger,s,num,job,managers,job,dispatcher,new,mini,cluster,job,dispatcher,configuration,ha,services,blob,server,heartbeat,services,metric,registry,num,job,managers,job,manager,rpc,services,catch,exception,e,try,shutdown,internally,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1509547920;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numJobManagers = miniClusterConfiguration.getNumJobManagers()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final int numResourceManagers = miniClusterConfiguration.getNumResourceManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == MiniClusterConfiguration.RpcServiceSharing.SHARED___			try {_				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				RpcService[] jobManagerRpcServices = new RpcService[numJobManagers]__				RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]__				RpcService[] resourceManagerRpcServices = new RpcService[numResourceManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				if (useSingleRpcService) {_					_					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = commonRpcService__					}__					this.resourceManagerRpcServices = null__					this.jobManagerRpcServices = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, jobManagerBindAddress)__					}__					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, resourceManagerBindAddress)__					}__					this.jobManagerRpcServices = jobManagerRpcServices__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcServices = resourceManagerRpcServices__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting {} ResourceManger(s)", numResourceManagers)__				resourceManagerRunners = startResourceManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					numResourceManagers,_					resourceManagerRpcServices)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_						configuration, haServices, metricRegistry, numTaskManagers, taskManagerRpcServices)___				_				LOG.info("Starting job dispatcher(s) for {} JobManger(s)", numJobManagers)__				jobDispatcher = new MiniClusterJobDispatcher(_					configuration,_					haServices,_					blobServer,_					heartbeatServices,_					metricRegistry,_					numJobManagers,_					jobManagerRpcServices)__			}_			catch (Exception e) {_				_				try {_					shutdownInternally()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,job,managers,mini,cluster,configuration,get,num,job,managers,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,int,num,resource,managers,mini,cluster,configuration,get,num,resource,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,mini,cluster,configuration,rpc,service,sharing,shared,try,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,rpc,service,job,manager,rpc,services,new,rpc,service,num,job,managers,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,rpc,service,resource,manager,rpc,services,new,rpc,service,num,resource,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,if,use,single,rpc,service,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,common,rpc,service,this,resource,manager,rpc,services,null,this,job,manager,rpc,services,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,this,job,manager,rpc,services,job,manager,rpc,services,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,services,resource,manager,rpc,services,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,s,num,resource,managers,resource,manager,runners,start,resource,managers,configuration,ha,services,heartbeat,services,metric,registry,num,resource,managers,resource,manager,rpc,services,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,metric,registry,num,task,managers,task,manager,rpc,services,log,info,starting,job,dispatcher,s,for,job,manger,s,num,job,managers,job,dispatcher,new,mini,cluster,job,dispatcher,configuration,ha,services,blob,server,heartbeat,services,metric,registry,num,job,managers,job,manager,rpc,services,catch,exception,e,try,shutdown,internally,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1509547921;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numJobManagers = miniClusterConfiguration.getNumJobManagers()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final int numResourceManagers = miniClusterConfiguration.getNumResourceManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == MiniClusterConfiguration.RpcServiceSharing.SHARED___			try {_				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				RpcService[] jobManagerRpcServices = new RpcService[numJobManagers]__				RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]__				RpcService[] resourceManagerRpcServices = new RpcService[numResourceManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					_					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = commonRpcService__					}__					this.resourceManagerRpcServices = null__					this.jobManagerRpcServices = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, jobManagerBindAddress)__					}__					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, resourceManagerBindAddress)__					}__					this.jobManagerRpcServices = jobManagerRpcServices__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcServices = resourceManagerRpcServices__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting {} ResourceManger(s)", numResourceManagers)__				resourceManagerRunners = startResourceManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					numResourceManagers,_					resourceManagerRpcServices)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_						configuration, haServices, metricRegistry, numTaskManagers, taskManagerRpcServices)___				_				LOG.info("Starting job dispatcher(s) for {} JobManger(s)", numJobManagers)__				jobDispatcher = new MiniClusterJobDispatcher(_					configuration,_					haServices,_					blobServer,_					heartbeatServices,_					metricRegistry,_					numJobManagers,_					jobManagerRpcServices)__			}_			catch (Exception e) {_				_				try {_					shutdownInternally()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,job,managers,mini,cluster,configuration,get,num,job,managers,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,int,num,resource,managers,mini,cluster,configuration,get,num,resource,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,mini,cluster,configuration,rpc,service,sharing,shared,try,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,rpc,service,job,manager,rpc,services,new,rpc,service,num,job,managers,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,rpc,service,resource,manager,rpc,services,new,rpc,service,num,resource,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,common,rpc,service,this,resource,manager,rpc,services,null,this,job,manager,rpc,services,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,this,job,manager,rpc,services,job,manager,rpc,services,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,services,resource,manager,rpc,services,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,s,num,resource,managers,resource,manager,runners,start,resource,managers,configuration,ha,services,heartbeat,services,metric,registry,num,resource,managers,resource,manager,rpc,services,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,metric,registry,num,task,managers,task,manager,rpc,services,log,info,starting,job,dispatcher,s,for,job,manger,s,num,job,managers,job,dispatcher,new,mini,cluster,job,dispatcher,configuration,ha,services,blob,server,heartbeat,services,metric,registry,num,job,managers,job,manager,rpc,services,catch,exception,e,try,shutdown,internally,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1515583830;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numJobManagers = miniClusterConfiguration.getNumJobManagers()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final int numResourceManagers = miniClusterConfiguration.getNumResourceManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == MiniClusterConfiguration.RpcServiceSharing.SHARED___			try {_				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				RpcService[] jobManagerRpcServices = new RpcService[numJobManagers]__				RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]__				RpcService[] resourceManagerRpcServices = new RpcService[numResourceManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					_					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = commonRpcService__					}__					this.resourceManagerRpcServices = null__					this.jobManagerRpcServices = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, jobManagerBindAddress)__					}__					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, resourceManagerBindAddress)__					}__					this.jobManagerRpcServices = jobManagerRpcServices__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcServices = resourceManagerRpcServices__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting {} ResourceManger(s)", numResourceManagers)__				resourceManagerRunners = startResourceManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					numResourceManagers,_					resourceManagerRpcServices)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_						configuration, haServices, metricRegistry, numTaskManagers, taskManagerRpcServices)___				_				LOG.info("Starting job dispatcher(s) for {} JobManger(s)", numJobManagers)__				jobDispatcher = new MiniClusterJobDispatcher(_					configuration,_					haServices,_					blobServer,_					heartbeatServices,_					metricRegistry,_					numJobManagers,_					jobManagerRpcServices)__			}_			catch (Exception e) {_				_				try {_					shutdownInternally()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,job,managers,mini,cluster,configuration,get,num,job,managers,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,int,num,resource,managers,mini,cluster,configuration,get,num,resource,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,mini,cluster,configuration,rpc,service,sharing,shared,try,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,rpc,service,job,manager,rpc,services,new,rpc,service,num,job,managers,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,rpc,service,resource,manager,rpc,services,new,rpc,service,num,resource,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,common,rpc,service,this,resource,manager,rpc,services,null,this,job,manager,rpc,services,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,this,job,manager,rpc,services,job,manager,rpc,services,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,services,resource,manager,rpc,services,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,s,num,resource,managers,resource,manager,runners,start,resource,managers,configuration,ha,services,heartbeat,services,metric,registry,num,resource,managers,resource,manager,rpc,services,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,metric,registry,num,task,managers,task,manager,rpc,services,log,info,starting,job,dispatcher,s,for,job,manger,s,num,job,managers,job,dispatcher,new,mini,cluster,job,dispatcher,configuration,ha,services,blob,server,heartbeat,services,metric,registry,num,job,managers,job,manager,rpc,services,catch,exception,e,try,shutdown,internally,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1515600854;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numJobManagers = miniClusterConfiguration.getNumJobManagers()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final int numResourceManagers = miniClusterConfiguration.getNumResourceManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == MiniClusterConfiguration.RpcServiceSharing.SHARED___			try {_				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				RpcService[] jobManagerRpcServices = new RpcService[numJobManagers]__				RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]__				RpcService[] resourceManagerRpcServices = new RpcService[numResourceManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					_					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = commonRpcService__					}__					this.resourceManagerRpcServices = null__					this.jobManagerRpcServices = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, jobManagerBindAddress)__					}__					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, resourceManagerBindAddress)__					}__					this.jobManagerRpcServices = jobManagerRpcServices__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcServices = resourceManagerRpcServices__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting {} ResourceManger(s)", numResourceManagers)__				resourceManagerRunners = startResourceManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					numResourceManagers,_					resourceManagerRpcServices)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_						configuration, haServices, metricRegistry, numTaskManagers, taskManagerRpcServices)___				_				LOG.info("Starting job dispatcher(s) for {} JobManger(s)", numJobManagers)__				jobDispatcher = new MiniClusterJobDispatcher(_					configuration,_					haServices,_					blobServer,_					heartbeatServices,_					metricRegistry,_					numJobManagers,_					jobManagerRpcServices)__			}_			catch (Exception e) {_				_				try {_					shutdownInternally()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,job,managers,mini,cluster,configuration,get,num,job,managers,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,int,num,resource,managers,mini,cluster,configuration,get,num,resource,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,mini,cluster,configuration,rpc,service,sharing,shared,try,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,rpc,service,job,manager,rpc,services,new,rpc,service,num,job,managers,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,rpc,service,resource,manager,rpc,services,new,rpc,service,num,resource,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,common,rpc,service,this,resource,manager,rpc,services,null,this,job,manager,rpc,services,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,this,job,manager,rpc,services,job,manager,rpc,services,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,services,resource,manager,rpc,services,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,s,num,resource,managers,resource,manager,runners,start,resource,managers,configuration,ha,services,heartbeat,services,metric,registry,num,resource,managers,resource,manager,rpc,services,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,metric,registry,num,task,managers,task,manager,rpc,services,log,info,starting,job,dispatcher,s,for,job,manger,s,num,job,managers,job,dispatcher,new,mini,cluster,job,dispatcher,configuration,ha,services,blob,server,heartbeat,services,metric,registry,num,job,managers,job,manager,rpc,services,catch,exception,e,try,shutdown,internally,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1517915730;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numJobManagers = miniClusterConfiguration.getNumJobManagers()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final int numResourceManagers = miniClusterConfiguration.getNumResourceManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == MiniClusterConfiguration.RpcServiceSharing.SHARED___			try {_				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				RpcService[] jobManagerRpcServices = new RpcService[numJobManagers]__				RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]__				RpcService[] resourceManagerRpcServices = new RpcService[numResourceManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					_					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = commonRpcService__					}__					this.resourceManagerRpcServices = null__					this.jobManagerRpcServices = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, jobManagerBindAddress)__					}__					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, resourceManagerBindAddress)__					}__					this.jobManagerRpcServices = jobManagerRpcServices__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcServices = resourceManagerRpcServices__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting {} ResourceManger(s)", numResourceManagers)__				resourceManagerRunners = startResourceManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					numResourceManagers,_					resourceManagerRpcServices,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting job dispatcher(s) for {} JobManger(s)", numJobManagers)__				jobDispatcher = new MiniClusterJobDispatcher(_					configuration,_					haServices,_					blobServer,_					heartbeatServices,_					metricRegistry,_					numJobManagers,_					jobManagerRpcServices)__			}_			catch (Exception e) {_				_				try {_					shutdownInternally()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,job,managers,mini,cluster,configuration,get,num,job,managers,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,int,num,resource,managers,mini,cluster,configuration,get,num,resource,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,mini,cluster,configuration,rpc,service,sharing,shared,try,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,rpc,service,job,manager,rpc,services,new,rpc,service,num,job,managers,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,rpc,service,resource,manager,rpc,services,new,rpc,service,num,resource,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,common,rpc,service,this,resource,manager,rpc,services,null,this,job,manager,rpc,services,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,this,job,manager,rpc,services,job,manager,rpc,services,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,services,resource,manager,rpc,services,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,s,num,resource,managers,resource,manager,runners,start,resource,managers,configuration,ha,services,heartbeat,services,metric,registry,num,resource,managers,resource,manager,rpc,services,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,job,dispatcher,s,for,job,manger,s,num,job,managers,job,dispatcher,new,mini,cluster,job,dispatcher,configuration,ha,services,blob,server,heartbeat,services,metric,registry,num,job,managers,job,manager,rpc,services,catch,exception,e,try,shutdown,internally,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1519121818;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numJobManagers = miniClusterConfiguration.getNumJobManagers()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final int numResourceManagers = miniClusterConfiguration.getNumResourceManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == MiniClusterConfiguration.RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				RpcService[] jobManagerRpcServices = new RpcService[numJobManagers]__				RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]__				RpcService[] resourceManagerRpcServices = new RpcService[numResourceManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					_					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}_					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = commonRpcService__					}__					this.resourceManagerRpcServices = null__					this.jobManagerRpcServices = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					for (int i = 0_ i < numJobManagers_ i++) {_						jobManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, jobManagerBindAddress)__					}__					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					for (int i = 0_ i < numResourceManagers_ i++) {_						resourceManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, resourceManagerBindAddress)__					}__					this.jobManagerRpcServices = jobManagerRpcServices__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcServices = resourceManagerRpcServices__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting {} ResourceManger(s)", numResourceManagers)__				resourceManagerRunners = startResourceManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					numResourceManagers,_					resourceManagerRpcServices,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting job dispatcher(s) for {} JobManger(s)", numJobManagers)__				jobDispatcher = new MiniClusterJobDispatcher(_					configuration,_					haServices,_					blobServer,_					heartbeatServices,_					metricRegistry,_					numJobManagers,_					jobManagerRpcServices)__			}_			catch (Exception e) {_				_				try {_					shutdownInternally()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,job,managers,mini,cluster,configuration,get,num,job,managers,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,int,num,resource,managers,mini,cluster,configuration,get,num,resource,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,mini,cluster,configuration,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,rpc,service,job,manager,rpc,services,new,rpc,service,num,job,managers,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,rpc,service,resource,manager,rpc,services,new,rpc,service,num,resource,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,common,rpc,service,this,resource,manager,rpc,services,null,this,job,manager,rpc,services,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,for,int,i,0,i,num,job,managers,i,job,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,for,int,i,0,i,num,resource,managers,i,resource,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,this,job,manager,rpc,services,job,manager,rpc,services,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,services,resource,manager,rpc,services,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,s,num,resource,managers,resource,manager,runners,start,resource,managers,configuration,ha,services,heartbeat,services,metric,registry,num,resource,managers,resource,manager,rpc,services,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,job,dispatcher,s,for,job,manger,s,num,job,managers,job,dispatcher,new,mini,cluster,job,dispatcher,configuration,ha,services,blob,server,heartbeat,services,metric,registry,num,job,managers,job,manager,rpc,services,catch,exception,e,try,shutdown,internally,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1519249745;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == MiniClusterConfiguration.RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::new,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::new,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					commonRpcService.getExecutor(),_					new AkkaQueryServiceRetriever(_						actorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestAddress())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					metricRegistry,_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestAddress())___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					shutdownInternally()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,mini,cluster,configuration,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,new,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,new,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,common,rpc,service,get,executor,new,akka,query,service,retriever,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,address,log,info,starting,job,dispatcher,s,for,job,manger,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,metric,registry,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,address,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,shutdown,internally,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1519406526;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == MiniClusterConfiguration.RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::new,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::new,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					commonRpcService.getExecutor(),_					new AkkaQueryServiceRetriever(_						actorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestAddress())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					metricRegistry,_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestAddress())___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					shutdownInternally()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,mini,cluster,configuration,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,new,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,new,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,common,rpc,service,get,executor,new,akka,query,service,retriever,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,address,log,info,starting,job,dispatcher,s,for,job,manger,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,metric,registry,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,address,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,shutdown,internally,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1519406527;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == MiniClusterConfiguration.RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::new,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::new,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					commonRpcService.getExecutor(),_					new AkkaQueryServiceRetriever(_						actorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestAddress())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					metricRegistry,_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestAddress())___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					shutdownInternally()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,mini,cluster,configuration,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,new,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,new,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,common,rpc,service,get,executor,new,akka,query,service,retriever,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,address,log,info,starting,job,dispatcher,s,for,job,manger,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,metric,registry,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,address,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,shutdown,internally,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1519406529;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == MiniClusterConfiguration.RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::new,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::new,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					commonRpcService.getExecutor(),_					new AkkaQueryServiceRetriever(_						actorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestAddress())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					metricRegistry,_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestAddress())___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					shutdownInternally()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,mini,cluster,configuration,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,new,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,new,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,common,rpc,service,get,executor,new,akka,query,service,retriever,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,address,log,info,starting,job,dispatcher,s,for,job,manger,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,metric,registry,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,address,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,shutdown,internally,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1519510773;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == MiniClusterConfiguration.RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::new,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::new,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					commonRpcService.getExecutor(),_					new AkkaQueryServiceRetriever(_						actorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestAddress())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					metricRegistry,_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestAddress())___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					shutdownInternally()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,mini,cluster,configuration,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,new,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,new,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,common,rpc,service,get,executor,new,akka,query,service,retriever,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,address,log,info,starting,job,dispatcher,s,for,job,manger,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,metric,registry,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,address,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,shutdown,internally,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1519512293;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			_			terminationFuture = new CompletableFuture<>()___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == MiniClusterConfiguration.RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::new,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::new,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					commonRpcService.getExecutor(),_					new AkkaQueryServiceRetriever(_						actorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestAddress())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					metricRegistry,_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestAddress())___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,termination,future,new,completable,future,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,mini,cluster,configuration,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,new,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,new,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,common,rpc,service,get,executor,new,akka,query,service,retriever,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,address,log,info,starting,job,dispatcher,s,for,job,manger,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,metric,registry,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,address,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1519977151;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			_			terminationFuture = new CompletableFuture<>()___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == MiniClusterConfiguration.RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::new,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::new,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					commonRpcService.getExecutor(),_					new AkkaQueryServiceRetriever(_						actorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestAddress())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					metricRegistry,_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestAddress())___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,termination,future,new,completable,future,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,mini,cluster,configuration,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,new,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,new,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,common,rpc,service,get,executor,new,akka,query,service,retriever,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,address,log,info,starting,job,dispatcher,s,for,job,manger,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,metric,registry,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,address,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1519977152;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			_			terminationFuture = new CompletableFuture<>()___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == MiniClusterConfiguration.RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::new,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::new,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					commonRpcService.getExecutor(),_					new AkkaQueryServiceRetriever(_						actorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestAddress())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					metricRegistry,_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestAddress())___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,termination,future,new,completable,future,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,mini,cluster,configuration,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,new,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,new,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,common,rpc,service,get,executor,new,akka,query,service,retriever,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,address,log,info,starting,job,dispatcher,s,for,job,manger,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,metric,registry,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,address,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1519977152;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			_			terminationFuture = new CompletableFuture<>()___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == MiniClusterConfiguration.RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::new,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::new,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					commonRpcService.getExecutor(),_					new AkkaQueryServiceRetriever(_						actorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestAddress())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					metricRegistry,_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestAddress())___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,termination,future,new,completable,future,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,mini,cluster,configuration,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,new,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,new,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,common,rpc,service,get,executor,new,akka,query,service,retriever,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,address,log,info,starting,job,dispatcher,s,for,job,manger,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,metric,registry,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,address,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1519977155;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			_			terminationFuture = new CompletableFuture<>()___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == MiniClusterConfiguration.RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::new,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::new,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					commonRpcService.getExecutor(),_					new AkkaQueryServiceRetriever(_						actorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestAddress())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					metricRegistry,_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestAddress())___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,termination,future,new,completable,future,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,mini,cluster,configuration,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,new,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,new,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,common,rpc,service,get,executor,new,akka,query,service,retriever,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,address,log,info,starting,job,dispatcher,s,for,job,manger,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,metric,registry,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,address,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1520032992;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			_			terminationFuture = new CompletableFuture<>()___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == MiniClusterConfiguration.RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::new,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::new,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					commonRpcService.getExecutor(),_					new AkkaQueryServiceRetriever(_						actorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestAddress())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					metricRegistry,_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestAddress())___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,termination,future,new,completable,future,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,mini,cluster,configuration,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,new,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,new,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,common,rpc,service,get,executor,new,akka,query,service,retriever,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,address,log,info,starting,job,dispatcher,s,for,job,manger,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,metric,registry,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,address,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1521379500;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			_			terminationFuture = new CompletableFuture<>()___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == MiniClusterConfiguration.RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::new,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::new,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					commonRpcService.getExecutor(),_					new AkkaQueryServiceRetriever(_						actorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestAddress())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(metricRegistry, "localhost")___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestAddress())___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,termination,future,new,completable,future,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,mini,cluster,configuration,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,new,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,new,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,common,rpc,service,get,executor,new,akka,query,service,retriever,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,address,log,info,starting,job,dispatcher,s,for,job,manger,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,address,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1521385093;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == MiniClusterConfiguration.RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::new,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::new,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					commonRpcService.getExecutor(),_					new AkkaQueryServiceRetriever(_						actorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestAddress())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(metricRegistry, "localhost")___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestAddress())___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,mini,cluster,configuration,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,new,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,new,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,common,rpc,service,get,executor,new,akka,query,service,retriever,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,address,log,info,starting,job,dispatcher,s,for,job,manger,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,address,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1521385094;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == MiniClusterConfiguration.RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::new,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::new,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					commonRpcService.getExecutor(),_					new AkkaQueryServiceRetriever(_						actorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestBaseUrl())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(metricRegistry, "localhost")___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestBaseUrl())___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,mini,cluster,configuration,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,new,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,new,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,common,rpc,service,get,executor,new,akka,query,service,retriever,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,base,url,log,info,starting,job,dispatcher,s,for,job,manger,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,base,url,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1521537266;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == MiniClusterConfiguration.RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::new,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::new,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					commonRpcService.getExecutor(),_					new AkkaQueryServiceRetriever(_						actorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestBaseUrl())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(metricRegistry, "localhost")___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestBaseUrl())___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,mini,cluster,configuration,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,new,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,new,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,common,rpc,service,get,executor,new,akka,query,service,retriever,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,base,url,log,info,starting,job,dispatcher,s,for,job,manger,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,base,url,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1521537266;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == MiniClusterConfiguration.RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::new,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::new,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					commonRpcService.getExecutor(),_					new AkkaQueryServiceRetriever(_						actorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestBaseUrl())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(metricRegistry, "localhost")___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestBaseUrl())___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,mini,cluster,configuration,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,new,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,new,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,common,rpc,service,get,executor,new,akka,query,service,retriever,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,base,url,log,info,starting,job,dispatcher,s,for,job,manger,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,base,url,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1521537266;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == MiniClusterConfiguration.RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::new,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::new,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					commonRpcService.getExecutor(),_					new AkkaQueryServiceRetriever(_						actorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestBaseUrl())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(metricRegistry, "localhost")___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestBaseUrl())___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,mini,cluster,configuration,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,new,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,new,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,common,rpc,service,get,executor,new,akka,query,service,retriever,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,base,url,log,info,starting,job,dispatcher,s,for,job,manger,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,base,url,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1521804758;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == MiniClusterConfiguration.RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::new,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::new,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					commonRpcService.getExecutor(),_					new AkkaQueryServiceRetriever(_						actorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestBaseUrl())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(metricRegistry, "localhost")___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestBaseUrl())___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,mini,cluster,configuration,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,new,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,new,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,common,rpc,service,get,executor,new,akka,query,service,retriever,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,base,url,log,info,starting,job,dispatcher,s,for,job,manger,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,base,url,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1522132482;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == MiniClusterConfiguration.RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::new,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::new,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					commonRpcService.getExecutor(),_					new AkkaQueryServiceRetriever(_						actorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestBaseUrl())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(metricRegistry, "localhost")___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestBaseUrl())___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,mini,cluster,configuration,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,new,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,new,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,common,rpc,service,get,executor,new,akka,query,service,retriever,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,base,url,log,info,starting,job,dispatcher,s,for,job,manger,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,base,url,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1522681180;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == MiniClusterConfiguration.RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::new,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::new,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					commonRpcService.getExecutor(),_					new AkkaQueryServiceRetriever(_						actorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestBaseUrl())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(metricRegistry, "localhost")___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestBaseUrl())___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,mini,cluster,configuration,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,new,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,new,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,common,rpc,service,get,executor,new,akka,query,service,retriever,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,base,url,log,info,starting,job,dispatcher,s,for,job,manger,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,base,url,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1522759723;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == MiniClusterConfiguration.RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::new,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::new,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					commonRpcService.getExecutor(),_					new AkkaQueryServiceRetriever(_						actorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestBaseUrl())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(metricRegistry, "localhost")___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestBaseUrl())___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,mini,cluster,configuration,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,new,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,new,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,common,rpc,service,get,executor,new,akka,query,service,retriever,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,base,url,log,info,starting,job,dispatcher,s,for,job,manger,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,base,url,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1522825170;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == MiniClusterConfiguration.RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::new,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::new,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					commonRpcService.getExecutor(),_					new AkkaQueryServiceRetriever(_						actorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestBaseUrl())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(metricRegistry, "localhost")___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestBaseUrl())___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,mini,cluster,configuration,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,new,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,new,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,common,rpc,service,get,executor,new,akka,query,service,retriever,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,base,url,log,info,starting,job,dispatcher,s,for,job,manger,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,base,url,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1525420604;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == MiniClusterConfiguration.RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::new,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::new,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					commonRpcService.getExecutor(),_					new AkkaQueryServiceRetriever(_						actorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestBaseUrl())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(metricRegistry, "localhost")___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestBaseUrl())___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,mini,cluster,configuration,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,new,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,new,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,common,rpc,service,get,executor,new,akka,query,service,retriever,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,base,url,log,info,starting,job,dispatcher,s,for,job,manger,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,base,url,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1525452496;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == MiniClusterConfiguration.RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::fromUuid,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::fromUuid,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					commonRpcService.getExecutor(),_					new AkkaQueryServiceRetriever(_						actorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestBaseUrl())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(metricRegistry, "localhost")___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestBaseUrl())___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,mini,cluster,configuration,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,from,uuid,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,from,uuid,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,common,rpc,service,get,executor,new,akka,query,service,retriever,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,base,url,log,info,starting,job,dispatcher,s,for,job,manger,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,base,url,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1526334048;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == MiniClusterConfiguration.RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::fromUuid,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::fromUuid,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					commonRpcService.getExecutor(),_					new AkkaQueryServiceRetriever(_						actorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestBaseUrl())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(metricRegistry, "localhost")___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestBaseUrl(),_					dispatcherRestEndpoint)___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,mini,cluster,configuration,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,from,uuid,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,from,uuid,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,common,rpc,service,get,executor,new,akka,query,service,retriever,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,base,url,log,info,starting,job,dispatcher,s,for,job,manger,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,base,url,dispatcher,rest,endpoint,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1526336566;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == MiniClusterConfiguration.RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::fromUuid,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::fromUuid,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					commonRpcService.getExecutor(),_					new AkkaQueryServiceRetriever(_						actorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestBaseUrl())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(metricRegistry, "localhost")___				final HistoryServerArchivist historyServerArchivist = HistoryServerArchivist.createHistoryServerArchivist(configuration, dispatcherRestEndpoint)___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestBaseUrl(),_					historyServerArchivist)___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,mini,cluster,configuration,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,from,uuid,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,from,uuid,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,common,rpc,service,get,executor,new,akka,query,service,retriever,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,base,url,log,info,starting,job,dispatcher,s,for,job,manger,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,final,history,server,archivist,history,server,archivist,history,server,archivist,create,history,server,archivist,configuration,dispatcher,rest,endpoint,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,base,url,history,server,archivist,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1529682304;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::fromUuid,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::fromUuid,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					commonRpcService.getExecutor(),_					new AkkaQueryServiceRetriever(_						actorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestBaseUrl())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(metricRegistry, "localhost")___				final HistoryServerArchivist historyServerArchivist = HistoryServerArchivist.createHistoryServerArchivist(configuration, dispatcherRestEndpoint)___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestBaseUrl(),_					historyServerArchivist)___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,from,uuid,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,from,uuid,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,common,rpc,service,get,executor,new,akka,query,service,retriever,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,base,url,log,info,starting,job,dispatcher,s,for,job,manger,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,final,history,server,archivist,history,server,archivist,history,server,archivist,create,history,server,archivist,configuration,dispatcher,rest,endpoint,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,base,url,history,server,archivist,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1530181266;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::fromUuid,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::fromUuid,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					commonRpcService.getExecutor(),_					new AkkaQueryServiceRetriever(_						actorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestBaseUrl())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(metricRegistry, "localhost")___				final HistoryServerArchivist historyServerArchivist = HistoryServerArchivist.createHistoryServerArchivist(configuration, dispatcherRestEndpoint)___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestBaseUrl(),_					historyServerArchivist)___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,from,uuid,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,from,uuid,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,common,rpc,service,get,executor,new,akka,query,service,retriever,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,base,url,log,info,starting,job,dispatcher,s,for,job,manger,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,final,history,server,archivist,history,server,archivist,history,server,archivist,create,history,server,archivist,configuration,dispatcher,rest,endpoint,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,base,url,history,server,archivist,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1530644925;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::fromUuid,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::fromUuid,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					commonRpcService.getExecutor(),_					new AkkaQueryServiceRetriever(_						actorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestBaseUrl())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(metricRegistry, "localhost")___				final HistoryServerArchivist historyServerArchivist = HistoryServerArchivist.createHistoryServerArchivist(configuration, dispatcherRestEndpoint)___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestBaseUrl(),_					historyServerArchivist)___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,from,uuid,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,from,uuid,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,common,rpc,service,get,executor,new,akka,query,service,retriever,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,base,url,log,info,starting,job,dispatcher,s,for,job,manger,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,final,history,server,archivist,history,server,archivist,history,server,archivist,create,history,server,archivist,configuration,dispatcher,rest,endpoint,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,base,url,history,server,archivist,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1533555608;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::fromUuid,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::fromUuid,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					commonRpcService.getExecutor(),_					new AkkaQueryServiceRetriever(_						actorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestBaseUrl())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(_					metricRegistry,_					"localhost",_					ConfigurationUtils.getSystemResourceMetricsProbingInterval(configuration))___				final HistoryServerArchivist historyServerArchivist = HistoryServerArchivist.createHistoryServerArchivist(configuration, dispatcherRestEndpoint)___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestBaseUrl(),_					historyServerArchivist)___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,from,uuid,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,from,uuid,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,common,rpc,service,get,executor,new,akka,query,service,retriever,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,base,url,log,info,starting,job,dispatcher,s,for,job,manger,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,configuration,utils,get,system,resource,metrics,probing,interval,configuration,final,history,server,archivist,history,server,archivist,history,server,archivist,create,history,server,archivist,configuration,dispatcher,rest,endpoint,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,base,url,history,server,archivist,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1538042094;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::fromUuid,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::fromUuid,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					commonRpcService.getExecutor(),_					new AkkaQueryServiceRetriever(_						actorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestBaseUrl())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(_					metricRegistry,_					"localhost",_					ConfigurationUtils.getSystemResourceMetricsProbingInterval(configuration))___				final HistoryServerArchivist historyServerArchivist = HistoryServerArchivist.createHistoryServerArchivist(configuration, dispatcherRestEndpoint)___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestBaseUrl(),_					historyServerArchivist)___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,from,uuid,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,from,uuid,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,common,rpc,service,get,executor,new,akka,query,service,retriever,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,base,url,log,info,starting,job,dispatcher,s,for,job,manger,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,configuration,utils,get,system,resource,metrics,probing,interval,configuration,final,history,server,archivist,history,server,archivist,history,server,archivist,create,history,server,archivist,configuration,dispatcher,rest,endpoint,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,base,url,history,server,archivist,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1539169204;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				final ActorSystem actorSystem = ((AkkaRpcService) commonRpcService).getActorSystem()__				metricRegistry.startQueryService(actorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::fromUuid,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::fromUuid,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					WebMonitorEndpoint.createExecutorService(_						configuration.getInteger(RestOptions.SERVER_NUM_THREADS, 1),_						"DispatcherRestEndpoint"),_					new AkkaQueryServiceRetriever(_						actorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestBaseUrl())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(_					metricRegistry,_					"localhost",_					ConfigurationUtils.getSystemResourceMetricsProbingInterval(configuration))___				final HistoryServerArchivist historyServerArchivist = HistoryServerArchivist.createHistoryServerArchivist(configuration, dispatcherRestEndpoint)___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestBaseUrl(),_					historyServerArchivist)___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,final,actor,system,actor,system,akka,rpc,service,common,rpc,service,get,actor,system,metric,registry,start,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,from,uuid,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,from,uuid,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,web,monitor,endpoint,create,executor,service,configuration,get,integer,rest,options,1,dispatcher,rest,endpoint,new,akka,query,service,retriever,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,base,url,log,info,starting,job,dispatcher,s,for,job,manger,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,configuration,utils,get,system,resource,metrics,probing,interval,configuration,final,history,server,archivist,history,server,archivist,history,server,archivist,create,history,server,archivist,configuration,dispatcher,rest,endpoint,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,base,url,history,server,archivist,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1539176686;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				metricQueryServiceActorSystem = BootstrapTools.startActorSystem(configuration, commonRpcService.getAddress(), 0, LOG, FIXED_THREAD_POOL_EXECUTOR)__				metricRegistry.startQueryService(metricQueryServiceActorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::fromUuid,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::fromUuid,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					WebMonitorEndpoint.createExecutorService(_						configuration.getInteger(RestOptions.SERVER_NUM_THREADS, 1),_						"DispatcherRestEndpoint"),_					new AkkaQueryServiceRetriever(_						metricQueryServiceActorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestBaseUrl())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(_					metricRegistry,_					"localhost",_					ConfigurationUtils.getSystemResourceMetricsProbingInterval(configuration))___				final HistoryServerArchivist historyServerArchivist = HistoryServerArchivist.createHistoryServerArchivist(configuration, dispatcherRestEndpoint)___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestBaseUrl(),_					historyServerArchivist)___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,metric,query,service,actor,system,bootstrap,tools,start,actor,system,configuration,common,rpc,service,get,address,0,log,metric,registry,start,query,service,metric,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,from,uuid,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,from,uuid,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,web,monitor,endpoint,create,executor,service,configuration,get,integer,rest,options,1,dispatcher,rest,endpoint,new,akka,query,service,retriever,metric,query,service,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,base,url,log,info,starting,job,dispatcher,s,for,job,manger,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,configuration,utils,get,system,resource,metrics,probing,interval,configuration,final,history,server,archivist,history,server,archivist,history,server,archivist,create,history,server,archivist,configuration,dispatcher,rest,endpoint,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,base,url,history,server,archivist,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1539176687;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				metricQueryServiceActorSystem = BootstrapTools.startActorSystem(_					configuration,_					"metrics",_					commonRpcService.getAddress(),_					0,_					LOG,_					FIXED_THREAD_POOL_EXECUTOR)__				metricRegistry.startQueryService(metricQueryServiceActorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::fromUuid,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::fromUuid,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					WebMonitorEndpoint.createExecutorService(_						configuration.getInteger(RestOptions.SERVER_NUM_THREADS, 1),_						"DispatcherRestEndpoint"),_					new AkkaQueryServiceRetriever(_						metricQueryServiceActorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestBaseUrl())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(_					metricRegistry,_					"localhost",_					ConfigurationUtils.getSystemResourceMetricsProbingInterval(configuration))___				final HistoryServerArchivist historyServerArchivist = HistoryServerArchivist.createHistoryServerArchivist(configuration, dispatcherRestEndpoint)___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestBaseUrl(),_					historyServerArchivist)___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,metric,query,service,actor,system,bootstrap,tools,start,actor,system,configuration,metrics,common,rpc,service,get,address,0,log,metric,registry,start,query,service,metric,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,from,uuid,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,from,uuid,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,web,monitor,endpoint,create,executor,service,configuration,get,integer,rest,options,1,dispatcher,rest,endpoint,new,akka,query,service,retriever,metric,query,service,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,base,url,log,info,starting,job,dispatcher,s,for,job,manger,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,configuration,utils,get,system,resource,metrics,probing,interval,configuration,final,history,server,archivist,history,server,archivist,history,server,archivist,create,history,server,archivist,configuration,dispatcher,rest,endpoint,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,base,url,history,server,archivist,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1539176687;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				metricQueryServiceActorSystem = MetricUtils.startMetricsActorSystem(_					configuration,_					commonRpcService.getAddress(),_					LOG)__				metricRegistry.startQueryService(metricQueryServiceActorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()))___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::fromUuid,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::fromUuid,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					WebMonitorEndpoint.createExecutorService(_						configuration.getInteger(RestOptions.SERVER_NUM_THREADS, 1),_						"DispatcherRestEndpoint"),_					new AkkaQueryServiceRetriever(_						metricQueryServiceActorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestBaseUrl())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(_					metricRegistry,_					"localhost",_					ConfigurationUtils.getSystemResourceMetricsProbingInterval(configuration))___				final HistoryServerArchivist historyServerArchivist = HistoryServerArchivist.createHistoryServerArchivist(configuration, dispatcherRestEndpoint)___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestBaseUrl(),_					historyServerArchivist)___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,metric,query,service,actor,system,metric,utils,start,metrics,actor,system,configuration,common,rpc,service,get,address,log,metric,registry,start,query,service,metric,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,from,uuid,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,from,uuid,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,web,monitor,endpoint,create,executor,service,configuration,get,integer,rest,options,1,dispatcher,rest,endpoint,new,akka,query,service,retriever,metric,query,service,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,base,url,log,info,starting,job,dispatcher,s,for,job,manger,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,configuration,utils,get,system,resource,metrics,probing,interval,configuration,final,history,server,archivist,history,server,archivist,history,server,archivist,create,history,server,archivist,configuration,dispatcher,rest,endpoint,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,base,url,history,server,archivist,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1539582211;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)__				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(_					metricRegistry,_					"localhost",_					ConfigurationUtils.getSystemResourceMetricsProbingInterval(configuration))___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				metricQueryServiceActorSystem = MetricUtils.startMetricsActorSystem(_					configuration,_					commonRpcService.getAddress(),_					LOG)__				metricRegistry.startQueryService(metricQueryServiceActorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()),_					jobManagerMetricGroup)___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::fromUuid,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::fromUuid,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					WebMonitorEndpoint.createExecutorService(_						configuration.getInteger(RestOptions.SERVER_NUM_THREADS, 1),_						"DispatcherRestEndpoint"),_					new AkkaQueryServiceRetriever(_						metricQueryServiceActorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestBaseUrl())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				final HistoryServerArchivist historyServerArchivist = HistoryServerArchivist.createHistoryServerArchivist(configuration, dispatcherRestEndpoint)___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestBaseUrl(),_					historyServerArchivist)___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,configuration,utils,get,system,resource,metrics,probing,interval,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,metric,query,service,actor,system,metric,utils,start,metrics,actor,system,configuration,common,rpc,service,get,address,log,metric,registry,start,query,service,metric,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,job,manager,metric,group,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,from,uuid,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,from,uuid,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,web,monitor,endpoint,create,executor,service,configuration,get,integer,rest,options,1,dispatcher,rest,endpoint,new,akka,query,service,retriever,metric,query,service,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,base,url,log,info,starting,job,dispatcher,s,for,job,manger,final,history,server,archivist,history,server,archivist,history,server,archivist,create,history,server,archivist,configuration,dispatcher,rest,endpoint,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,base,url,history,server,archivist,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1539787538;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)__				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(_					metricRegistry,_					"localhost",_					ConfigurationUtils.getSystemResourceMetricsProbingInterval(configuration))___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				metricQueryServiceActorSystem = MetricUtils.startMetricsActorSystem(_					configuration,_					commonRpcService.getAddress(),_					LOG)__				metricRegistry.startQueryService(metricQueryServiceActorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()),_					jobManagerMetricGroup)___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::fromUuid,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::fromUuid,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					WebMonitorEndpoint.createExecutorService(_						configuration.getInteger(RestOptions.SERVER_NUM_THREADS, 1),_						configuration.getInteger(RestOptions.SERVER_THREAD_PRIORITY),_						"DispatcherRestEndpoint"),_					new AkkaQueryServiceRetriever(_						metricQueryServiceActorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestBaseUrl())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				final HistoryServerArchivist historyServerArchivist = HistoryServerArchivist.createHistoryServerArchivist(configuration, dispatcherRestEndpoint)___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					dispatcherRestEndpoint.getRestBaseUrl(),_					historyServerArchivist)___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,configuration,utils,get,system,resource,metrics,probing,interval,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,metric,query,service,actor,system,metric,utils,start,metrics,actor,system,configuration,common,rpc,service,get,address,log,metric,registry,start,query,service,metric,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,job,manager,metric,group,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,from,uuid,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,from,uuid,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,web,monitor,endpoint,create,executor,service,configuration,get,integer,rest,options,1,configuration,get,integer,rest,options,dispatcher,rest,endpoint,new,akka,query,service,retriever,metric,query,service,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,base,url,log,info,starting,job,dispatcher,s,for,job,manger,final,history,server,archivist,history,server,archivist,history,server,archivist,create,history,server,archivist,configuration,dispatcher,rest,endpoint,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,get,rest,base,url,history,server,archivist,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1545326469;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)__				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(_					metricRegistry,_					"localhost",_					ConfigurationUtils.getSystemResourceMetricsProbingInterval(configuration))___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				metricQueryServiceActorSystem = MetricUtils.startMetricsActorSystem(_					configuration,_					commonRpcService.getAddress(),_					LOG)__				metricRegistry.startQueryService(metricQueryServiceActorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()),_					jobManagerMetricGroup)___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::fromUuid,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::fromUuid,_					20,_					Time.milliseconds(20L))___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					WebMonitorEndpoint.createExecutorService(_						configuration.getInteger(RestOptions.SERVER_NUM_THREADS, 1),_						configuration.getInteger(RestOptions.SERVER_THREAD_PRIORITY),_						"DispatcherRestEndpoint"),_					new AkkaQueryServiceRetriever(_						metricQueryServiceActorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				dispatcherRestEndpoint.start()___				restAddressURI = new URI(dispatcherRestEndpoint.getRestBaseUrl())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				final HistoryServerArchivist historyServerArchivist = HistoryServerArchivist.createHistoryServerArchivist(configuration, dispatcherRestEndpoint)___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					historyServerArchivist)___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,configuration,utils,get,system,resource,metrics,probing,interval,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,metric,query,service,actor,system,metric,utils,start,metrics,actor,system,configuration,common,rpc,service,get,address,log,metric,registry,start,query,service,metric,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,job,manager,metric,group,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,from,uuid,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,from,uuid,20,time,milliseconds,20l,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,web,monitor,endpoint,create,executor,service,configuration,get,integer,rest,options,1,configuration,get,integer,rest,options,dispatcher,rest,endpoint,new,akka,query,service,retriever,metric,query,service,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,dispatcher,rest,endpoint,get,rest,base,url,log,info,starting,job,dispatcher,s,for,job,manger,final,history,server,archivist,history,server,archivist,history,server,archivist,create,history,server,archivist,configuration,dispatcher,rest,endpoint,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,history,server,archivist,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1547675340;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)__				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(_					metricRegistry,_					"localhost",_					ConfigurationUtils.getSystemResourceMetricsProbingInterval(configuration))___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				metricQueryServiceActorSystem = MetricUtils.startMetricsActorSystem(_					configuration,_					commonRpcService.getAddress(),_					LOG)__				metricRegistry.startQueryService(metricQueryServiceActorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()),_					jobManagerMetricGroup)___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::fromUuid,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::fromUuid,_					20,_					Time.milliseconds(20L))___				final ExecutorService executor = WebMonitorEndpoint.createExecutorService(_					configuration.getInteger(RestOptions.SERVER_NUM_THREADS, 1),_					configuration.getInteger(RestOptions.SERVER_THREAD_PRIORITY),_					"DispatcherRestEndpoint")___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					executor,_					new AkkaQueryServiceRetriever(_						metricQueryServiceActorSystem,_						Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				this.dispatcherRestEndpoint.start()___				restAddressURI = new URI(this.dispatcherRestEndpoint.getRestBaseUrl())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				final HistoryServerArchivist historyServerArchivist = HistoryServerArchivist.createHistoryServerArchivist(configuration, this.dispatcherRestEndpoint)___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					historyServerArchivist)___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,configuration,utils,get,system,resource,metrics,probing,interval,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,metric,query,service,actor,system,metric,utils,start,metrics,actor,system,configuration,common,rpc,service,get,address,log,metric,registry,start,query,service,metric,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,job,manager,metric,group,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,from,uuid,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,from,uuid,20,time,milliseconds,20l,final,executor,service,executor,web,monitor,endpoint,create,executor,service,configuration,get,integer,rest,options,1,configuration,get,integer,rest,options,dispatcher,rest,endpoint,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,executor,new,akka,query,service,retriever,metric,query,service,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,this,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,this,dispatcher,rest,endpoint,get,rest,base,url,log,info,starting,job,dispatcher,s,for,job,manger,final,history,server,archivist,history,server,archivist,history,server,archivist,create,history,server,archivist,configuration,this,dispatcher,rest,endpoint,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,history,server,archivist,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1547675341;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)__				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(_					metricRegistry,_					"localhost",_					ConfigurationUtils.getSystemResourceMetricsProbingInterval(configuration))___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				metricQueryServiceActorSystem = MetricUtils.startMetricsActorSystem(_					configuration,_					commonRpcService.getAddress(),_					LOG)__				metricRegistry.startQueryService(metricQueryServiceActorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()),_					jobManagerMetricGroup)___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::fromUuid,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::fromUuid,_					20,_					Time.milliseconds(20L))___				final ExecutorService executor = WebMonitorEndpoint.createExecutorService(_					configuration.getInteger(RestOptions.SERVER_NUM_THREADS, 1),_					configuration.getInteger(RestOptions.SERVER_THREAD_PRIORITY),_					"DispatcherRestEndpoint")___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					executor,_					MetricFetcherImpl.fromConfiguration(_						configuration,_						new AkkaQueryServiceRetriever(_							metricQueryServiceActorSystem,_							Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_						dispatcherGatewayRetriever,_						executor),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				this.dispatcherRestEndpoint.start()___				restAddressURI = new URI(this.dispatcherRestEndpoint.getRestBaseUrl())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				final HistoryServerArchivist historyServerArchivist = HistoryServerArchivist.createHistoryServerArchivist(configuration, this.dispatcherRestEndpoint)___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					historyServerArchivist)___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,configuration,utils,get,system,resource,metrics,probing,interval,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,metric,query,service,actor,system,metric,utils,start,metrics,actor,system,configuration,common,rpc,service,get,address,log,metric,registry,start,query,service,metric,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,job,manager,metric,group,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,from,uuid,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,from,uuid,20,time,milliseconds,20l,final,executor,service,executor,web,monitor,endpoint,create,executor,service,configuration,get,integer,rest,options,1,configuration,get,integer,rest,options,dispatcher,rest,endpoint,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,executor,metric,fetcher,impl,from,configuration,configuration,new,akka,query,service,retriever,metric,query,service,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,dispatcher,gateway,retriever,executor,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,this,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,this,dispatcher,rest,endpoint,get,rest,base,url,log,info,starting,job,dispatcher,s,for,job,manger,final,history,server,archivist,history,server,archivist,history,server,archivist,create,history,server,archivist,configuration,this,dispatcher,rest,endpoint,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,history,server,archivist,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1548249770;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)__				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(_					metricRegistry,_					"localhost",_					ConfigurationUtils.getSystemResourceMetricsProbingInterval(configuration))___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				_				commonRpcService = createRpcService(configuration, rpcTimeout, false, null)___				_				metricQueryServiceActorSystem = MetricUtils.startMetricsActorSystem(_					configuration,_					commonRpcService.getAddress(),_					LOG)__				metricRegistry.startQueryService(metricQueryServiceActorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(configuration, rpcTimeout, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(configuration, rpcTimeout, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(_								configuration, rpcTimeout, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()),_					jobManagerMetricGroup)___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::fromUuid,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::fromUuid,_					20,_					Time.milliseconds(20L))___				final ExecutorService executor = WebMonitorEndpoint.createExecutorService(_					configuration.getInteger(RestOptions.SERVER_NUM_THREADS, 1),_					configuration.getInteger(RestOptions.SERVER_THREAD_PRIORITY),_					"DispatcherRestEndpoint")___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					executor,_					MetricFetcherImpl.fromConfiguration(_						configuration,_						new AkkaQueryServiceRetriever(_							metricQueryServiceActorSystem,_							Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_						dispatcherGatewayRetriever,_						executor),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				this.dispatcherRestEndpoint.start()___				restAddressURI = new URI(this.dispatcherRestEndpoint.getRestBaseUrl())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				final HistoryServerArchivist historyServerArchivist = HistoryServerArchivist.createHistoryServerArchivist(configuration, this.dispatcherRestEndpoint)___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					historyServerArchivist)___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,configuration,utils,get,system,resource,metrics,probing,interval,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,common,rpc,service,create,rpc,service,configuration,rpc,timeout,false,null,metric,query,service,actor,system,metric,utils,start,metrics,actor,system,configuration,common,rpc,service,get,address,log,metric,registry,start,query,service,metric,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,configuration,rpc,timeout,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,configuration,rpc,timeout,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,job,manager,metric,group,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,from,uuid,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,from,uuid,20,time,milliseconds,20l,final,executor,service,executor,web,monitor,endpoint,create,executor,service,configuration,get,integer,rest,options,1,configuration,get,integer,rest,options,dispatcher,rest,endpoint,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,executor,metric,fetcher,impl,from,configuration,configuration,new,akka,query,service,retriever,metric,query,service,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,dispatcher,gateway,retriever,executor,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,this,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,this,dispatcher,rest,endpoint,get,rest,base,url,log,info,starting,job,dispatcher,s,for,job,manger,final,history,server,archivist,history,server,archivist,history,server,archivist,create,history,server,archivist,configuration,this,dispatcher,rest,endpoint,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,history,server,archivist,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1548326020;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)__				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(_					metricRegistry,_					"localhost",_					ConfigurationUtils.getSystemResourceMetricsProbingInterval(configuration))___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				AkkaRpcServiceConfiguration akkaRpcServiceConfig = AkkaRpcServiceConfiguration.fromConfiguration(configuration)__				_				commonRpcService = createRpcService(akkaRpcServiceConfig, false, null)___				_				metricQueryServiceActorSystem = MetricUtils.startMetricsActorSystem(_					configuration,_					commonRpcService.getAddress(),_					LOG)__				metricRegistry.startQueryService(metricQueryServiceActorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(akkaRpcServiceConfig, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(akkaRpcServiceConfig, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(akkaRpcServiceConfig, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()),_					jobManagerMetricGroup)___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::fromUuid,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::fromUuid,_					20,_					Time.milliseconds(20L))___				final ExecutorService executor = WebMonitorEndpoint.createExecutorService(_					configuration.getInteger(RestOptions.SERVER_NUM_THREADS, 1),_					configuration.getInteger(RestOptions.SERVER_THREAD_PRIORITY),_					"DispatcherRestEndpoint")___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					executor,_					MetricFetcherImpl.fromConfiguration(_						configuration,_						new AkkaQueryServiceRetriever(_							metricQueryServiceActorSystem,_							Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_						dispatcherGatewayRetriever,_						executor),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				this.dispatcherRestEndpoint.start()___				restAddressURI = new URI(this.dispatcherRestEndpoint.getRestBaseUrl())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				final HistoryServerArchivist historyServerArchivist = HistoryServerArchivist.createHistoryServerArchivist(configuration, this.dispatcherRestEndpoint)___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					Dispatcher.DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					historyServerArchivist)___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,configuration,utils,get,system,resource,metrics,probing,interval,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,akka,rpc,service,configuration,akka,rpc,service,config,akka,rpc,service,configuration,from,configuration,configuration,common,rpc,service,create,rpc,service,akka,rpc,service,config,false,null,metric,query,service,actor,system,metric,utils,start,metrics,actor,system,configuration,common,rpc,service,get,address,log,metric,registry,start,query,service,metric,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,akka,rpc,service,config,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,akka,rpc,service,config,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,akka,rpc,service,config,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,job,manager,metric,group,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,from,uuid,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,from,uuid,20,time,milliseconds,20l,final,executor,service,executor,web,monitor,endpoint,create,executor,service,configuration,get,integer,rest,options,1,configuration,get,integer,rest,options,dispatcher,rest,endpoint,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,executor,metric,fetcher,impl,from,configuration,configuration,new,akka,query,service,retriever,metric,query,service,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,dispatcher,gateway,retriever,executor,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,this,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,this,dispatcher,rest,endpoint,get,rest,base,url,log,info,starting,job,dispatcher,s,for,job,manger,final,history,server,archivist,history,server,archivist,history,server,archivist,create,history,server,archivist,configuration,this,dispatcher,rest,endpoint,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,dispatcher,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,history,server,archivist,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1548846699;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)__				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(_					metricRegistry,_					"localhost",_					ConfigurationUtils.getSystemResourceMetricsProbingInterval(configuration))___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				AkkaRpcServiceConfiguration akkaRpcServiceConfig = AkkaRpcServiceConfiguration.fromConfiguration(configuration)__				_				commonRpcService = createRpcService(akkaRpcServiceConfig, false, null)___				_				metricQueryServiceActorSystem = MetricUtils.startMetricsActorSystem(_					configuration,_					commonRpcService.getAddress(),_					LOG)__				metricRegistry.startQueryService(metricQueryServiceActorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(akkaRpcServiceConfig, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(akkaRpcServiceConfig, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(akkaRpcServiceConfig, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				_				LOG.info("Starting high-availability services")__				haServices = HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(_					configuration,_					commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()),_					jobManagerMetricGroup)___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::fromUuid,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::fromUuid,_					20,_					Time.milliseconds(20L))___				final ExecutorService executor = WebMonitorEndpoint.createExecutorService(_					configuration.getInteger(RestOptions.SERVER_NUM_THREADS, 1),_					configuration.getInteger(RestOptions.SERVER_THREAD_PRIORITY),_					"DispatcherRestEndpoint")___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					executor,_					MetricFetcherImpl.fromConfiguration(_						configuration,_						new AkkaQueryServiceRetriever(_							metricQueryServiceActorSystem,_							Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_						dispatcherGatewayRetriever,_						executor),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				this.dispatcherRestEndpoint.start()___				restAddressURI = new URI(this.dispatcherRestEndpoint.getRestBaseUrl())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				final HistoryServerArchivist historyServerArchivist = HistoryServerArchivist.createHistoryServerArchivist(configuration, this.dispatcherRestEndpoint)___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					historyServerArchivist)___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,configuration,utils,get,system,resource,metrics,probing,interval,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,akka,rpc,service,configuration,akka,rpc,service,config,akka,rpc,service,configuration,from,configuration,configuration,common,rpc,service,create,rpc,service,akka,rpc,service,config,false,null,metric,query,service,actor,system,metric,utils,start,metrics,actor,system,configuration,common,rpc,service,get,address,log,metric,registry,start,query,service,metric,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,akka,rpc,service,config,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,akka,rpc,service,config,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,akka,rpc,service,config,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,log,info,starting,high,availability,services,ha,services,high,availability,services,utils,create,available,or,embedded,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,job,manager,metric,group,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,from,uuid,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,from,uuid,20,time,milliseconds,20l,final,executor,service,executor,web,monitor,endpoint,create,executor,service,configuration,get,integer,rest,options,1,configuration,get,integer,rest,options,dispatcher,rest,endpoint,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,executor,metric,fetcher,impl,from,configuration,configuration,new,akka,query,service,retriever,metric,query,service,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,dispatcher,gateway,retriever,executor,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,this,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,this,dispatcher,rest,endpoint,get,rest,base,url,log,info,starting,job,dispatcher,s,for,job,manger,final,history,server,archivist,history,server,archivist,history,server,archivist,create,history,server,archivist,configuration,this,dispatcher,rest,endpoint,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,history,server,archivist,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1548866156;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)__				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(_					metricRegistry,_					"localhost",_					ConfigurationUtils.getSystemResourceMetricsProbingInterval(configuration))___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				AkkaRpcServiceConfiguration akkaRpcServiceConfig = AkkaRpcServiceConfiguration.fromConfiguration(configuration)__				_				commonRpcService = createRpcService(akkaRpcServiceConfig, false, null)___				_				metricQueryServiceActorSystem = MetricUtils.startMetricsActorSystem(_					configuration,_					commonRpcService.getAddress(),_					LOG)__				metricRegistry.startQueryService(metricQueryServiceActorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(akkaRpcServiceConfig, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(akkaRpcServiceConfig, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(akkaRpcServiceConfig, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				haServices = createHighAvailabilityServices(configuration, commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()),_					jobManagerMetricGroup)___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::fromUuid,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::fromUuid,_					20,_					Time.milliseconds(20L))___				final ExecutorService executor = WebMonitorEndpoint.createExecutorService(_					configuration.getInteger(RestOptions.SERVER_NUM_THREADS, 1),_					configuration.getInteger(RestOptions.SERVER_THREAD_PRIORITY),_					"DispatcherRestEndpoint")___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					executor,_					MetricFetcherImpl.fromConfiguration(_						configuration,_						new AkkaQueryServiceRetriever(_							metricQueryServiceActorSystem,_							Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))),_						dispatcherGatewayRetriever,_						executor),_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				this.dispatcherRestEndpoint.start()___				restAddressURI = new URI(this.dispatcherRestEndpoint.getRestBaseUrl())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				final HistoryServerArchivist historyServerArchivist = HistoryServerArchivist.createHistoryServerArchivist(configuration, this.dispatcherRestEndpoint)___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					historyServerArchivist)___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,configuration,utils,get,system,resource,metrics,probing,interval,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,akka,rpc,service,configuration,akka,rpc,service,config,akka,rpc,service,configuration,from,configuration,configuration,common,rpc,service,create,rpc,service,akka,rpc,service,config,false,null,metric,query,service,actor,system,metric,utils,start,metrics,actor,system,configuration,common,rpc,service,get,address,log,metric,registry,start,query,service,metric,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,akka,rpc,service,config,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,akka,rpc,service,config,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,akka,rpc,service,config,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,ha,services,create,high,availability,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,job,manager,metric,group,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,from,uuid,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,from,uuid,20,time,milliseconds,20l,final,executor,service,executor,web,monitor,endpoint,create,executor,service,configuration,get,integer,rest,options,1,configuration,get,integer,rest,options,dispatcher,rest,endpoint,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,executor,metric,fetcher,impl,from,configuration,configuration,new,akka,query,service,retriever,metric,query,service,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,dispatcher,gateway,retriever,executor,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,this,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,this,dispatcher,rest,endpoint,get,rest,base,url,log,info,starting,job,dispatcher,s,for,job,manger,final,history,server,archivist,history,server,archivist,history,server,archivist,create,history,server,archivist,configuration,this,dispatcher,rest,endpoint,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,history,server,archivist,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1548966387;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)__				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(_					metricRegistry,_					"localhost",_					ConfigurationUtils.getSystemResourceMetricsProbingInterval(configuration))___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				AkkaRpcServiceConfiguration akkaRpcServiceConfig = AkkaRpcServiceConfiguration.fromConfiguration(configuration)__				_				commonRpcService = createRpcService(akkaRpcServiceConfig, false, null)___				_				metricQueryServiceActorSystem = MetricUtils.startMetricsActorSystem(_					configuration,_					commonRpcService.getAddress(),_					LOG)__				metricRegistry.startQueryService(metricQueryServiceActorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(akkaRpcServiceConfig, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(akkaRpcServiceConfig, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(akkaRpcServiceConfig, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				haServices = createHighAvailabilityServices(configuration, commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()),_					jobManagerMetricGroup)___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::fromUuid,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::fromUuid,_					20,_					Time.milliseconds(20L))___				final ExecutorService executor = WebMonitorEndpoint.createExecutorService(_					configuration.getInteger(RestOptions.SERVER_NUM_THREADS, 1),_					configuration.getInteger(RestOptions.SERVER_THREAD_PRIORITY),_					"DispatcherRestEndpoint")___				final long updateInterval = configuration.getLong(MetricOptions.METRIC_FETCHER_UPDATE_INTERVAL)__				final MetricFetcher metricFetcher = updateInterval == 0_					? VoidMetricFetcher.INSTANCE_					: MetricFetcherImpl.fromConfiguration(configuration,_						new AkkaQueryServiceRetriever(_							metricQueryServiceActorSystem,_							Time.milliseconds(_							configuration.getLong(WebOptions.TIMEOUT))),_						dispatcherGatewayRetriever, executor)___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					executor,_					metricFetcher,_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				this.dispatcherRestEndpoint.start()___				restAddressURI = new URI(this.dispatcherRestEndpoint.getRestBaseUrl())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				final HistoryServerArchivist historyServerArchivist = HistoryServerArchivist.createHistoryServerArchivist(configuration, this.dispatcherRestEndpoint)___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					historyServerArchivist)___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,configuration,utils,get,system,resource,metrics,probing,interval,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,akka,rpc,service,configuration,akka,rpc,service,config,akka,rpc,service,configuration,from,configuration,configuration,common,rpc,service,create,rpc,service,akka,rpc,service,config,false,null,metric,query,service,actor,system,metric,utils,start,metrics,actor,system,configuration,common,rpc,service,get,address,log,metric,registry,start,query,service,metric,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,akka,rpc,service,config,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,akka,rpc,service,config,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,akka,rpc,service,config,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,ha,services,create,high,availability,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,job,manager,metric,group,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,from,uuid,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,from,uuid,20,time,milliseconds,20l,final,executor,service,executor,web,monitor,endpoint,create,executor,service,configuration,get,integer,rest,options,1,configuration,get,integer,rest,options,dispatcher,rest,endpoint,final,long,update,interval,configuration,get,long,metric,options,final,metric,fetcher,metric,fetcher,update,interval,0,void,metric,fetcher,instance,metric,fetcher,impl,from,configuration,configuration,new,akka,query,service,retriever,metric,query,service,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,dispatcher,gateway,retriever,executor,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,executor,metric,fetcher,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,this,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,this,dispatcher,rest,endpoint,get,rest,base,url,log,info,starting,job,dispatcher,s,for,job,manger,final,history,server,archivist,history,server,archivist,history,server,archivist,create,history,server,archivist,configuration,this,dispatcher,rest,endpoint,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,history,server,archivist,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1549360057;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)__				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(_					metricRegistry,_					"localhost",_					ConfigurationUtils.getSystemResourceMetricsProbingInterval(configuration))___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				AkkaRpcServiceConfiguration akkaRpcServiceConfig = AkkaRpcServiceConfiguration.fromConfiguration(configuration)__				_				commonRpcService = createRpcService(akkaRpcServiceConfig, false, null)___				_				metricQueryServiceActorSystem = MetricUtils.startMetricsActorSystem(_					configuration,_					commonRpcService.getAddress(),_					LOG)__				metricRegistry.startQueryService(metricQueryServiceActorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(akkaRpcServiceConfig, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(akkaRpcServiceConfig, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(akkaRpcServiceConfig, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				haServices = createHighAvailabilityServices(configuration, commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()),_					jobManagerMetricGroup)___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::fromUuid,_					20,_					Time.milliseconds(20L))__				final RpcGatewayRetriever<ResourceManagerId, ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::fromUuid,_					20,_					Time.milliseconds(20L))___				final ExecutorService executor = WebMonitorEndpoint.createExecutorService(_					configuration.getInteger(RestOptions.SERVER_NUM_THREADS, 1),_					configuration.getInteger(RestOptions.SERVER_THREAD_PRIORITY),_					"DispatcherRestEndpoint")___				final long updateInterval = configuration.getLong(MetricOptions.METRIC_FETCHER_UPDATE_INTERVAL)__				final MetricFetcher metricFetcher = updateInterval == 0_					? VoidMetricFetcher.INSTANCE_					: MetricFetcherImpl.fromConfiguration(configuration,_						new AkkaQueryServiceRetriever(_							metricQueryServiceActorSystem,_							Time.milliseconds(_							configuration.getLong(WebOptions.TIMEOUT))),_						dispatcherGatewayRetriever, executor)___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					executor,_					metricFetcher,_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				this.dispatcherRestEndpoint.start()___				restAddressURI = new URI(this.dispatcherRestEndpoint.getRestBaseUrl())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				final HistoryServerArchivist historyServerArchivist = HistoryServerArchivist.createHistoryServerArchivist(configuration, this.dispatcherRestEndpoint)___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					historyServerArchivist)___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,configuration,utils,get,system,resource,metrics,probing,interval,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,akka,rpc,service,configuration,akka,rpc,service,config,akka,rpc,service,configuration,from,configuration,configuration,common,rpc,service,create,rpc,service,akka,rpc,service,config,false,null,metric,query,service,actor,system,metric,utils,start,metrics,actor,system,configuration,common,rpc,service,get,address,log,metric,registry,start,query,service,metric,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,akka,rpc,service,config,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,akka,rpc,service,config,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,akka,rpc,service,config,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,ha,services,create,high,availability,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,job,manager,metric,group,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,from,uuid,20,time,milliseconds,20l,final,rpc,gateway,retriever,resource,manager,id,resource,manager,gateway,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,from,uuid,20,time,milliseconds,20l,final,executor,service,executor,web,monitor,endpoint,create,executor,service,configuration,get,integer,rest,options,1,configuration,get,integer,rest,options,dispatcher,rest,endpoint,final,long,update,interval,configuration,get,long,metric,options,final,metric,fetcher,metric,fetcher,update,interval,0,void,metric,fetcher,instance,metric,fetcher,impl,from,configuration,configuration,new,akka,query,service,retriever,metric,query,service,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,dispatcher,gateway,retriever,executor,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,executor,metric,fetcher,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,this,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,this,dispatcher,rest,endpoint,get,rest,base,url,log,info,starting,job,dispatcher,s,for,job,manger,final,history,server,archivist,history,server,archivist,history,server,archivist,create,history,server,archivist,configuration,this,dispatcher,rest,endpoint,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,history,server,archivist,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1549360057;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)__				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(_					metricRegistry,_					"localhost",_					ConfigurationUtils.getSystemResourceMetricsProbingInterval(configuration))___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				AkkaRpcServiceConfiguration akkaRpcServiceConfig = AkkaRpcServiceConfiguration.fromConfiguration(configuration)__				_				commonRpcService = createRpcService(akkaRpcServiceConfig, false, null)___				_				metricQueryServiceActorSystem = MetricUtils.startMetricsActorSystem(_					configuration,_					commonRpcService.getAddress(),_					LOG)__				metricRegistry.startQueryService(metricQueryServiceActorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(akkaRpcServiceConfig, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(akkaRpcServiceConfig, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(akkaRpcServiceConfig, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				haServices = createHighAvailabilityServices(configuration, commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()),_					jobManagerMetricGroup)___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::fromUuid,_					20,_					Time.milliseconds(20L))__				resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::fromUuid,_					20,_					Time.milliseconds(20L))___				final ExecutorService executor = WebMonitorEndpoint.createExecutorService(_					configuration.getInteger(RestOptions.SERVER_NUM_THREADS, 1),_					configuration.getInteger(RestOptions.SERVER_THREAD_PRIORITY),_					"DispatcherRestEndpoint")___				final long updateInterval = configuration.getLong(MetricOptions.METRIC_FETCHER_UPDATE_INTERVAL)__				final MetricFetcher metricFetcher = updateInterval == 0_					? VoidMetricFetcher.INSTANCE_					: MetricFetcherImpl.fromConfiguration(configuration,_						new AkkaQueryServiceRetriever(_							metricQueryServiceActorSystem,_							Time.milliseconds(_							configuration.getLong(WebOptions.TIMEOUT))),_						dispatcherGatewayRetriever, executor)___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					executor,_					metricFetcher,_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				this.dispatcherRestEndpoint.start()___				restAddressURI = new URI(this.dispatcherRestEndpoint.getRestBaseUrl())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				final HistoryServerArchivist historyServerArchivist = HistoryServerArchivist.createHistoryServerArchivist(configuration, this.dispatcherRestEndpoint)___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					historyServerArchivist)___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,configuration,utils,get,system,resource,metrics,probing,interval,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,akka,rpc,service,configuration,akka,rpc,service,config,akka,rpc,service,configuration,from,configuration,configuration,common,rpc,service,create,rpc,service,akka,rpc,service,config,false,null,metric,query,service,actor,system,metric,utils,start,metrics,actor,system,configuration,common,rpc,service,get,address,log,metric,registry,start,query,service,metric,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,akka,rpc,service,config,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,akka,rpc,service,config,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,akka,rpc,service,config,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,ha,services,create,high,availability,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,job,manager,metric,group,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,from,uuid,20,time,milliseconds,20l,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,from,uuid,20,time,milliseconds,20l,final,executor,service,executor,web,monitor,endpoint,create,executor,service,configuration,get,integer,rest,options,1,configuration,get,integer,rest,options,dispatcher,rest,endpoint,final,long,update,interval,configuration,get,long,metric,options,final,metric,fetcher,metric,fetcher,update,interval,0,void,metric,fetcher,instance,metric,fetcher,impl,from,configuration,configuration,new,akka,query,service,retriever,metric,query,service,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,dispatcher,gateway,retriever,executor,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,executor,metric,fetcher,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,this,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,this,dispatcher,rest,endpoint,get,rest,base,url,log,info,starting,job,dispatcher,s,for,job,manger,final,history,server,archivist,history,server,archivist,history,server,archivist,create,history,server,archivist,configuration,this,dispatcher,rest,endpoint,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,history,server,archivist,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1549360057;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final Time rpcTimeout = miniClusterConfiguration.getRpcTimeout()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)__				this.jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(_					metricRegistry,_					"localhost",_					ConfigurationUtils.getSystemResourceMetricsProbingInterval(configuration))___				final RpcService jobManagerRpcService__				final RpcService resourceManagerRpcService__				final RpcService[] taskManagerRpcServices = new RpcService[numTaskManagers]___				_				LOG.info("Starting RPC Service(s)")___				AkkaRpcServiceConfiguration akkaRpcServiceConfig = AkkaRpcServiceConfiguration.fromConfiguration(configuration)__				_				commonRpcService = createRpcService(akkaRpcServiceConfig, false, null)___				_				metricQueryServiceActorSystem = MetricUtils.startMetricsActorSystem(_					configuration,_					commonRpcService.getAddress(),_					LOG)__				metricRegistry.startQueryService(metricQueryServiceActorSystem, null)___				if (useSingleRpcService) {_					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = commonRpcService__					}__					jobManagerRpcService = commonRpcService__					resourceManagerRpcService = commonRpcService___					this.resourceManagerRpcService = null__					this.jobManagerRpcService = null__					this.taskManagerRpcServices = null__				}_				else {_					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()__					final String resourceManagerBindAddress = miniClusterConfiguration.getResourceManagerBindAddress()___					jobManagerRpcService = createRpcService(akkaRpcServiceConfig, true, jobManagerBindAddress)__					resourceManagerRpcService = createRpcService(akkaRpcServiceConfig, true, resourceManagerBindAddress)___					for (int i = 0_ i < numTaskManagers_ i++) {_						taskManagerRpcServices[i] = createRpcService(akkaRpcServiceConfig, true, taskManagerBindAddress)__					}__					this.jobManagerRpcService = jobManagerRpcService__					this.taskManagerRpcServices = taskManagerRpcServices__					this.resourceManagerRpcService = resourceManagerRpcService__				}__				haServices = createHighAvailabilityServices(configuration, commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				_				LOG.info("Starting ResourceManger")__				resourceManagerRunner = startResourceManager(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					resourceManagerRpcService,_					new ClusterInformation("localhost", blobServer.getPort()),_					jobManagerMetricGroup)___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServices)___				_				LOG.info("Starting dispatcher rest endpoint.")___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					DispatcherGateway.class,_					DispatcherId::fromUuid,_					20,_					Time.milliseconds(20L))__				resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					jobManagerRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::fromUuid,_					20,_					Time.milliseconds(20L))___				final ExecutorService executor = WebMonitorEndpoint.createExecutorService(_					configuration.getInteger(RestOptions.SERVER_NUM_THREADS, 1),_					configuration.getInteger(RestOptions.SERVER_THREAD_PRIORITY),_					"DispatcherRestEndpoint")___				final long updateInterval = configuration.getLong(MetricOptions.METRIC_FETCHER_UPDATE_INTERVAL)__				final MetricFetcher metricFetcher = updateInterval == 0_					? VoidMetricFetcher.INSTANCE_					: MetricFetcherImpl.fromConfiguration(configuration,_						new AkkaQueryServiceRetriever(_							metricQueryServiceActorSystem,_							Time.milliseconds(_							configuration.getLong(WebOptions.TIMEOUT))),_						dispatcherGatewayRetriever, executor)___				this.dispatcherRestEndpoint = new DispatcherRestEndpoint(_					RestServerEndpointConfiguration.fromConfiguration(configuration),_					dispatcherGatewayRetriever,_					configuration,_					RestHandlerConfiguration.fromConfiguration(configuration),_					resourceManagerGatewayRetriever,_					blobServer.getTransientBlobService(),_					executor,_					metricFetcher,_					haServices.getWebMonitorLeaderElectionService(),_					new ShutDownFatalErrorHandler())___				this.dispatcherRestEndpoint.start()___				restAddressURI = new URI(this.dispatcherRestEndpoint.getRestBaseUrl())___				_				LOG.info("Starting job dispatcher(s) for JobManger")___				final HistoryServerArchivist historyServerArchivist = HistoryServerArchivist.createHistoryServerArchivist(configuration, this.dispatcherRestEndpoint)___				dispatcher = new StandaloneDispatcher(_					jobManagerRpcService,_					Dispatcher.DISPATCHER_NAME + UUID.randomUUID(),_					configuration,_					haServices,_					resourceManagerRunner.getResourceManageGateway(),_					blobServer,_					heartbeatServices,_					jobManagerMetricGroup,_					metricRegistry.getMetricQueryServicePath(),_					new MemoryArchivedExecutionGraphStore(),_					DefaultJobManagerRunnerFactory.INSTANCE,_					new ShutDownFatalErrorHandler(),_					historyServerArchivist)___				dispatcher.start()___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,time,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,this,job,manager,metric,group,metric,utils,instantiate,job,manager,metric,group,metric,registry,localhost,configuration,utils,get,system,resource,metrics,probing,interval,configuration,final,rpc,service,job,manager,rpc,service,final,rpc,service,resource,manager,rpc,service,final,rpc,service,task,manager,rpc,services,new,rpc,service,num,task,managers,log,info,starting,rpc,service,s,akka,rpc,service,configuration,akka,rpc,service,config,akka,rpc,service,configuration,from,configuration,configuration,common,rpc,service,create,rpc,service,akka,rpc,service,config,false,null,metric,query,service,actor,system,metric,utils,start,metrics,actor,system,configuration,common,rpc,service,get,address,log,metric,registry,start,query,service,metric,query,service,actor,system,null,if,use,single,rpc,service,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,common,rpc,service,job,manager,rpc,service,common,rpc,service,resource,manager,rpc,service,common,rpc,service,this,resource,manager,rpc,service,null,this,job,manager,rpc,service,null,this,task,manager,rpc,services,null,else,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,final,string,resource,manager,bind,address,mini,cluster,configuration,get,resource,manager,bind,address,job,manager,rpc,service,create,rpc,service,akka,rpc,service,config,true,job,manager,bind,address,resource,manager,rpc,service,create,rpc,service,akka,rpc,service,config,true,resource,manager,bind,address,for,int,i,0,i,num,task,managers,i,task,manager,rpc,services,i,create,rpc,service,akka,rpc,service,config,true,task,manager,bind,address,this,job,manager,rpc,service,job,manager,rpc,service,this,task,manager,rpc,services,task,manager,rpc,services,this,resource,manager,rpc,service,resource,manager,rpc,service,ha,services,create,high,availability,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,log,info,starting,resource,manger,resource,manager,runner,start,resource,manager,configuration,ha,services,heartbeat,services,metric,registry,resource,manager,rpc,service,new,cluster,information,localhost,blob,server,get,port,job,manager,metric,group,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,services,log,info,starting,dispatcher,rest,endpoint,dispatcher,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,dispatcher,gateway,class,dispatcher,id,from,uuid,20,time,milliseconds,20l,resource,manager,gateway,retriever,new,rpc,gateway,retriever,job,manager,rpc,service,resource,manager,gateway,class,resource,manager,id,from,uuid,20,time,milliseconds,20l,final,executor,service,executor,web,monitor,endpoint,create,executor,service,configuration,get,integer,rest,options,1,configuration,get,integer,rest,options,dispatcher,rest,endpoint,final,long,update,interval,configuration,get,long,metric,options,final,metric,fetcher,metric,fetcher,update,interval,0,void,metric,fetcher,instance,metric,fetcher,impl,from,configuration,configuration,new,akka,query,service,retriever,metric,query,service,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,dispatcher,gateway,retriever,executor,this,dispatcher,rest,endpoint,new,dispatcher,rest,endpoint,rest,server,endpoint,configuration,from,configuration,configuration,dispatcher,gateway,retriever,configuration,rest,handler,configuration,from,configuration,configuration,resource,manager,gateway,retriever,blob,server,get,transient,blob,service,executor,metric,fetcher,ha,services,get,web,monitor,leader,election,service,new,shut,down,fatal,error,handler,this,dispatcher,rest,endpoint,start,rest,address,uri,new,uri,this,dispatcher,rest,endpoint,get,rest,base,url,log,info,starting,job,dispatcher,s,for,job,manger,final,history,server,archivist,history,server,archivist,history,server,archivist,create,history,server,archivist,configuration,this,dispatcher,rest,endpoint,dispatcher,new,standalone,dispatcher,job,manager,rpc,service,dispatcher,uuid,random,uuid,configuration,ha,services,resource,manager,runner,get,resource,manage,gateway,blob,server,heartbeat,services,job,manager,metric,group,metric,registry,get,metric,query,service,path,new,memory,archived,execution,graph,store,default,job,manager,runner,factory,instance,new,shut,down,fatal,error,handler,history,server,archivist,dispatcher,start,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1549360057;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				_				LOG.info("Starting RPC Service(s)")___				AkkaRpcServiceConfiguration akkaRpcServiceConfig = AkkaRpcServiceConfiguration.fromConfiguration(configuration)___				final RpcServiceFactory taskManagerRpcServiceFactory__				final RpcServiceFactory dispatcherResourceManagreComponentRpcServiceFactory___				if (useSingleRpcService) {_					_					commonRpcService = createRpcService(akkaRpcServiceConfig, false, null)__					final CommonRpcServiceFactory commonRpcServiceFactory = new CommonRpcServiceFactory(commonRpcService)__					taskManagerRpcServiceFactory = commonRpcServiceFactory__					dispatcherResourceManagreComponentRpcServiceFactory = commonRpcServiceFactory__				} else {_					_					commonRpcService = createRpcService(akkaRpcServiceConfig, true, null)___					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()___					dispatcherResourceManagreComponentRpcServiceFactory = new DedicatedRpcServiceFactory(akkaRpcServiceConfig, jobManagerBindAddress)__					taskManagerRpcServiceFactory = new DedicatedRpcServiceFactory(akkaRpcServiceConfig, taskManagerBindAddress)__				}__				_				metricQueryServiceActorSystem = MetricUtils.startMetricsActorSystem(_					configuration,_					commonRpcService.getAddress(),_					LOG)__				metricRegistry.startQueryService(metricQueryServiceActorSystem, null)___				haServices = createHighAvailabilityServices(configuration, commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServiceFactory)___				MetricQueryServiceRetriever metricQueryServiceRetriever = new AkkaQueryServiceRetriever(_					metricQueryServiceActorSystem,_					Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT)))___				dispatcherResourceManagerComponents.addAll(createDispatcherResourceManagerComponents(_					configuration,_					dispatcherResourceManagreComponentRpcServiceFactory,_					haServices,_					blobServer,_					heartbeatServices,_					metricRegistry,_					metricQueryServiceRetriever,_					new ShutDownFatalErrorHandler()_				))___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()__				webMonitorLeaderRetrievalService = haServices.getWebMonitorLeaderRetriever()___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					commonRpcService,_					DispatcherGateway.class,_					DispatcherId::fromUuid,_					20,_					Time.milliseconds(20L))__				resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					commonRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::fromUuid,_					20,_					Time.milliseconds(20L))__				webMonitorLeaderRetriever = new LeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__				webMonitorLeaderRetrievalService.start(webMonitorLeaderRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,log,info,starting,rpc,service,s,akka,rpc,service,configuration,akka,rpc,service,config,akka,rpc,service,configuration,from,configuration,configuration,final,rpc,service,factory,task,manager,rpc,service,factory,final,rpc,service,factory,dispatcher,resource,managre,component,rpc,service,factory,if,use,single,rpc,service,common,rpc,service,create,rpc,service,akka,rpc,service,config,false,null,final,common,rpc,service,factory,common,rpc,service,factory,new,common,rpc,service,factory,common,rpc,service,task,manager,rpc,service,factory,common,rpc,service,factory,dispatcher,resource,managre,component,rpc,service,factory,common,rpc,service,factory,else,common,rpc,service,create,rpc,service,akka,rpc,service,config,true,null,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,dispatcher,resource,managre,component,rpc,service,factory,new,dedicated,rpc,service,factory,akka,rpc,service,config,job,manager,bind,address,task,manager,rpc,service,factory,new,dedicated,rpc,service,factory,akka,rpc,service,config,task,manager,bind,address,metric,query,service,actor,system,metric,utils,start,metrics,actor,system,configuration,common,rpc,service,get,address,log,metric,registry,start,query,service,metric,query,service,actor,system,null,ha,services,create,high,availability,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,service,factory,metric,query,service,retriever,metric,query,service,retriever,new,akka,query,service,retriever,metric,query,service,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,dispatcher,resource,manager,components,add,all,create,dispatcher,resource,manager,components,configuration,dispatcher,resource,managre,component,rpc,service,factory,ha,services,blob,server,heartbeat,services,metric,registry,metric,query,service,retriever,new,shut,down,fatal,error,handler,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,web,monitor,leader,retrieval,service,ha,services,get,web,monitor,leader,retriever,dispatcher,gateway,retriever,new,rpc,gateway,retriever,common,rpc,service,dispatcher,gateway,class,dispatcher,id,from,uuid,20,time,milliseconds,20l,resource,manager,gateway,retriever,new,rpc,gateway,retriever,common,rpc,service,resource,manager,gateway,class,resource,manager,id,from,uuid,20,time,milliseconds,20l,web,monitor,leader,retriever,new,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,web,monitor,leader,retrieval,service,start,web,monitor,leader,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1549360057;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				_				LOG.info("Starting RPC Service(s)")___				AkkaRpcServiceConfiguration akkaRpcServiceConfig = AkkaRpcServiceConfiguration.fromConfiguration(configuration)___				final RpcServiceFactory taskManagerRpcServiceFactory__				final RpcServiceFactory dispatcherResourceManagreComponentRpcServiceFactory___				if (useSingleRpcService) {_					_					commonRpcService = createRpcService(akkaRpcServiceConfig, false, null)__					final CommonRpcServiceFactory commonRpcServiceFactory = new CommonRpcServiceFactory(commonRpcService)__					taskManagerRpcServiceFactory = commonRpcServiceFactory__					dispatcherResourceManagreComponentRpcServiceFactory = commonRpcServiceFactory__				} else {_					_					commonRpcService = createRpcService(akkaRpcServiceConfig, true, null)___					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()___					dispatcherResourceManagreComponentRpcServiceFactory = new DedicatedRpcServiceFactory(akkaRpcServiceConfig, jobManagerBindAddress)__					taskManagerRpcServiceFactory = new DedicatedRpcServiceFactory(akkaRpcServiceConfig, taskManagerBindAddress)__				}__				_				metricQueryServiceActorSystem = MetricUtils.startMetricsActorSystem(_					configuration,_					commonRpcService.getAddress(),_					LOG)__				metricRegistry.startQueryService(metricQueryServiceActorSystem, null)___				haServices = createHighAvailabilityServices(configuration, commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServiceFactory)___				MetricQueryServiceRetriever metricQueryServiceRetriever = new AkkaQueryServiceRetriever(_					metricQueryServiceActorSystem,_					Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT)))___				dispatcherResourceManagerComponents.addAll(createDispatcherResourceManagerComponents(_					configuration,_					dispatcherResourceManagreComponentRpcServiceFactory,_					haServices,_					blobServer,_					heartbeatServices,_					metricRegistry,_					metricQueryServiceRetriever,_					new ShutDownFatalErrorHandler()_				))___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()__				webMonitorLeaderRetrievalService = haServices.getWebMonitorLeaderRetriever()___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					commonRpcService,_					DispatcherGateway.class,_					DispatcherId::fromUuid,_					20,_					Time.milliseconds(20L))__				resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					commonRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::fromUuid,_					20,_					Time.milliseconds(20L))__				webMonitorLeaderRetriever = new LeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__				webMonitorLeaderRetrievalService.start(webMonitorLeaderRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,log,info,starting,rpc,service,s,akka,rpc,service,configuration,akka,rpc,service,config,akka,rpc,service,configuration,from,configuration,configuration,final,rpc,service,factory,task,manager,rpc,service,factory,final,rpc,service,factory,dispatcher,resource,managre,component,rpc,service,factory,if,use,single,rpc,service,common,rpc,service,create,rpc,service,akka,rpc,service,config,false,null,final,common,rpc,service,factory,common,rpc,service,factory,new,common,rpc,service,factory,common,rpc,service,task,manager,rpc,service,factory,common,rpc,service,factory,dispatcher,resource,managre,component,rpc,service,factory,common,rpc,service,factory,else,common,rpc,service,create,rpc,service,akka,rpc,service,config,true,null,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,dispatcher,resource,managre,component,rpc,service,factory,new,dedicated,rpc,service,factory,akka,rpc,service,config,job,manager,bind,address,task,manager,rpc,service,factory,new,dedicated,rpc,service,factory,akka,rpc,service,config,task,manager,bind,address,metric,query,service,actor,system,metric,utils,start,metrics,actor,system,configuration,common,rpc,service,get,address,log,metric,registry,start,query,service,metric,query,service,actor,system,null,ha,services,create,high,availability,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,service,factory,metric,query,service,retriever,metric,query,service,retriever,new,akka,query,service,retriever,metric,query,service,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,dispatcher,resource,manager,components,add,all,create,dispatcher,resource,manager,components,configuration,dispatcher,resource,managre,component,rpc,service,factory,ha,services,blob,server,heartbeat,services,metric,registry,metric,query,service,retriever,new,shut,down,fatal,error,handler,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,web,monitor,leader,retrieval,service,ha,services,get,web,monitor,leader,retriever,dispatcher,gateway,retriever,new,rpc,gateway,retriever,common,rpc,service,dispatcher,gateway,class,dispatcher,id,from,uuid,20,time,milliseconds,20l,resource,manager,gateway,retriever,new,rpc,gateway,retriever,common,rpc,service,resource,manager,gateway,class,resource,manager,id,from,uuid,20,time,milliseconds,20l,web,monitor,leader,retriever,new,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,web,monitor,leader,retrieval,service,start,web,monitor,leader,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1549360058;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				_				LOG.info("Starting RPC Service(s)")___				AkkaRpcServiceConfiguration akkaRpcServiceConfig = AkkaRpcServiceConfiguration.fromConfiguration(configuration)___				final RpcServiceFactory taskManagerRpcServiceFactory__				final RpcServiceFactory dispatcherResourceManagreComponentRpcServiceFactory___				if (useSingleRpcService) {_					_					commonRpcService = createRpcService(akkaRpcServiceConfig, false, null)__					final CommonRpcServiceFactory commonRpcServiceFactory = new CommonRpcServiceFactory(commonRpcService)__					taskManagerRpcServiceFactory = commonRpcServiceFactory__					dispatcherResourceManagreComponentRpcServiceFactory = commonRpcServiceFactory__				} else {_					_					commonRpcService = createRpcService(akkaRpcServiceConfig, true, null)___					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()___					dispatcherResourceManagreComponentRpcServiceFactory = new DedicatedRpcServiceFactory(akkaRpcServiceConfig, jobManagerBindAddress)__					taskManagerRpcServiceFactory = new DedicatedRpcServiceFactory(akkaRpcServiceConfig, taskManagerBindAddress)__				}__				_				metricQueryServiceActorSystem = MetricUtils.startMetricsActorSystem(_					configuration,_					commonRpcService.getAddress(),_					LOG)__				metricRegistry.startQueryService(metricQueryServiceActorSystem, null)___				haServices = createHighAvailabilityServices(configuration, commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServiceFactory)___				MetricQueryServiceRetriever metricQueryServiceRetriever = new AkkaQueryServiceRetriever(_					metricQueryServiceActorSystem,_					Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT)))___				dispatcherResourceManagerComponents.addAll(createDispatcherResourceManagerComponents(_					configuration,_					dispatcherResourceManagreComponentRpcServiceFactory,_					haServices,_					blobServer,_					heartbeatServices,_					metricRegistry,_					metricQueryServiceRetriever,_					new ShutDownFatalErrorHandler()_				))___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()__				webMonitorLeaderRetrievalService = haServices.getWebMonitorLeaderRetriever()___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					commonRpcService,_					DispatcherGateway.class,_					DispatcherId::fromUuid,_					20,_					Time.milliseconds(20L))__				resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					commonRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::fromUuid,_					20,_					Time.milliseconds(20L))__				webMonitorLeaderRetriever = new LeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__				webMonitorLeaderRetrievalService.start(webMonitorLeaderRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,log,info,starting,rpc,service,s,akka,rpc,service,configuration,akka,rpc,service,config,akka,rpc,service,configuration,from,configuration,configuration,final,rpc,service,factory,task,manager,rpc,service,factory,final,rpc,service,factory,dispatcher,resource,managre,component,rpc,service,factory,if,use,single,rpc,service,common,rpc,service,create,rpc,service,akka,rpc,service,config,false,null,final,common,rpc,service,factory,common,rpc,service,factory,new,common,rpc,service,factory,common,rpc,service,task,manager,rpc,service,factory,common,rpc,service,factory,dispatcher,resource,managre,component,rpc,service,factory,common,rpc,service,factory,else,common,rpc,service,create,rpc,service,akka,rpc,service,config,true,null,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,dispatcher,resource,managre,component,rpc,service,factory,new,dedicated,rpc,service,factory,akka,rpc,service,config,job,manager,bind,address,task,manager,rpc,service,factory,new,dedicated,rpc,service,factory,akka,rpc,service,config,task,manager,bind,address,metric,query,service,actor,system,metric,utils,start,metrics,actor,system,configuration,common,rpc,service,get,address,log,metric,registry,start,query,service,metric,query,service,actor,system,null,ha,services,create,high,availability,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,service,factory,metric,query,service,retriever,metric,query,service,retriever,new,akka,query,service,retriever,metric,query,service,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,dispatcher,resource,manager,components,add,all,create,dispatcher,resource,manager,components,configuration,dispatcher,resource,managre,component,rpc,service,factory,ha,services,blob,server,heartbeat,services,metric,registry,metric,query,service,retriever,new,shut,down,fatal,error,handler,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,web,monitor,leader,retrieval,service,ha,services,get,web,monitor,leader,retriever,dispatcher,gateway,retriever,new,rpc,gateway,retriever,common,rpc,service,dispatcher,gateway,class,dispatcher,id,from,uuid,20,time,milliseconds,20l,resource,manager,gateway,retriever,new,rpc,gateway,retriever,common,rpc,service,resource,manager,gateway,class,resource,manager,id,from,uuid,20,time,milliseconds,20l,web,monitor,leader,retriever,new,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,web,monitor,leader,retrieval,service,start,web,monitor,leader,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1550005040;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				_				LOG.info("Starting RPC Service(s)")___				AkkaRpcServiceConfiguration akkaRpcServiceConfig = AkkaRpcServiceConfiguration.fromConfiguration(configuration)___				final RpcServiceFactory taskManagerRpcServiceFactory__				final RpcServiceFactory dispatcherResourceManagreComponentRpcServiceFactory___				if (useSingleRpcService) {_					_					commonRpcService = createRpcService(akkaRpcServiceConfig, false, null)__					final CommonRpcServiceFactory commonRpcServiceFactory = new CommonRpcServiceFactory(commonRpcService)__					taskManagerRpcServiceFactory = commonRpcServiceFactory__					dispatcherResourceManagreComponentRpcServiceFactory = commonRpcServiceFactory__				} else {_					_					commonRpcService = createRpcService(akkaRpcServiceConfig, true, null)___					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()___					dispatcherResourceManagreComponentRpcServiceFactory = new DedicatedRpcServiceFactory(akkaRpcServiceConfig, jobManagerBindAddress)__					taskManagerRpcServiceFactory = new DedicatedRpcServiceFactory(akkaRpcServiceConfig, taskManagerBindAddress)__				}__				_				metricQueryServiceActorSystem = MetricUtils.startMetricsActorSystem(_					configuration,_					commonRpcService.getAddress(),_					LOG)__				metricRegistry.startQueryService(metricQueryServiceActorSystem, null)___				haServices = createHighAvailabilityServices(configuration, commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				_				LOG.info("Starting {} TaskManger(s)", numTaskManagers)__				taskManagers = startTaskManagers(_					configuration,_					haServices,_					heartbeatServices,_					metricRegistry,_					blobCacheService,_					numTaskManagers,_					taskManagerRpcServiceFactory)___				MetricQueryServiceRetriever metricQueryServiceRetriever = new AkkaQueryServiceRetriever(_					metricQueryServiceActorSystem,_					Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT)))___				dispatcherResourceManagerComponents.addAll(createDispatcherResourceManagerComponents(_					configuration,_					dispatcherResourceManagreComponentRpcServiceFactory,_					haServices,_					blobServer,_					heartbeatServices,_					metricRegistry,_					metricQueryServiceRetriever,_					new ShutDownFatalErrorHandler()_				))___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()__				webMonitorLeaderRetrievalService = haServices.getWebMonitorLeaderRetriever()___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					commonRpcService,_					DispatcherGateway.class,_					DispatcherId::fromUuid,_					20,_					Time.milliseconds(20L))__				resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					commonRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::fromUuid,_					20,_					Time.milliseconds(20L))__				webMonitorLeaderRetriever = new LeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__				webMonitorLeaderRetrievalService.start(webMonitorLeaderRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,int,num,task,managers,mini,cluster,configuration,get,num,task,managers,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,log,info,starting,rpc,service,s,akka,rpc,service,configuration,akka,rpc,service,config,akka,rpc,service,configuration,from,configuration,configuration,final,rpc,service,factory,task,manager,rpc,service,factory,final,rpc,service,factory,dispatcher,resource,managre,component,rpc,service,factory,if,use,single,rpc,service,common,rpc,service,create,rpc,service,akka,rpc,service,config,false,null,final,common,rpc,service,factory,common,rpc,service,factory,new,common,rpc,service,factory,common,rpc,service,task,manager,rpc,service,factory,common,rpc,service,factory,dispatcher,resource,managre,component,rpc,service,factory,common,rpc,service,factory,else,common,rpc,service,create,rpc,service,akka,rpc,service,config,true,null,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,dispatcher,resource,managre,component,rpc,service,factory,new,dedicated,rpc,service,factory,akka,rpc,service,config,job,manager,bind,address,task,manager,rpc,service,factory,new,dedicated,rpc,service,factory,akka,rpc,service,config,task,manager,bind,address,metric,query,service,actor,system,metric,utils,start,metrics,actor,system,configuration,common,rpc,service,get,address,log,metric,registry,start,query,service,metric,query,service,actor,system,null,ha,services,create,high,availability,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,log,info,starting,task,manger,s,num,task,managers,task,managers,start,task,managers,configuration,ha,services,heartbeat,services,metric,registry,blob,cache,service,num,task,managers,task,manager,rpc,service,factory,metric,query,service,retriever,metric,query,service,retriever,new,akka,query,service,retriever,metric,query,service,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,dispatcher,resource,manager,components,add,all,create,dispatcher,resource,manager,components,configuration,dispatcher,resource,managre,component,rpc,service,factory,ha,services,blob,server,heartbeat,services,metric,registry,metric,query,service,retriever,new,shut,down,fatal,error,handler,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,web,monitor,leader,retrieval,service,ha,services,get,web,monitor,leader,retriever,dispatcher,gateway,retriever,new,rpc,gateway,retriever,common,rpc,service,dispatcher,gateway,class,dispatcher,id,from,uuid,20,time,milliseconds,20l,resource,manager,gateway,retriever,new,rpc,gateway,retriever,common,rpc,service,resource,manager,gateway,class,resource,manager,id,from,uuid,20,time,milliseconds,20l,web,monitor,leader,retriever,new,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,web,monitor,leader,retrieval,service,start,web,monitor,leader,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1550069788;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				_				LOG.info("Starting RPC Service(s)")___				AkkaRpcServiceConfiguration akkaRpcServiceConfig = AkkaRpcServiceConfiguration.fromConfiguration(configuration)___				final RpcServiceFactory dispatcherResourceManagreComponentRpcServiceFactory___				if (useSingleRpcService) {_					_					commonRpcService = createRpcService(akkaRpcServiceConfig, false, null)__					final CommonRpcServiceFactory commonRpcServiceFactory = new CommonRpcServiceFactory(commonRpcService)__					taskManagerRpcServiceFactory = commonRpcServiceFactory__					dispatcherResourceManagreComponentRpcServiceFactory = commonRpcServiceFactory__				} else {_					_					commonRpcService = createRpcService(akkaRpcServiceConfig, true, null)___					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()___					dispatcherResourceManagreComponentRpcServiceFactory = new DedicatedRpcServiceFactory(akkaRpcServiceConfig, jobManagerBindAddress)__					taskManagerRpcServiceFactory = new DedicatedRpcServiceFactory(akkaRpcServiceConfig, taskManagerBindAddress)__				}__				_				metricQueryServiceActorSystem = MetricUtils.startMetricsActorSystem(_					configuration,_					commonRpcService.getAddress(),_					LOG)__				metricRegistry.startQueryService(metricQueryServiceActorSystem, null)___				haServices = createHighAvailabilityServices(configuration, commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				startTaskManagers()___				MetricQueryServiceRetriever metricQueryServiceRetriever = new AkkaQueryServiceRetriever(_					metricQueryServiceActorSystem,_					Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT)))___				dispatcherResourceManagerComponents.addAll(createDispatcherResourceManagerComponents(_					configuration,_					dispatcherResourceManagreComponentRpcServiceFactory,_					haServices,_					blobServer,_					heartbeatServices,_					metricRegistry,_					metricQueryServiceRetriever,_					new ShutDownFatalErrorHandler()_				))___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()__				webMonitorLeaderRetrievalService = haServices.getWebMonitorLeaderRetriever()___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					commonRpcService,_					DispatcherGateway.class,_					DispatcherId::fromUuid,_					20,_					Time.milliseconds(20L))__				resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					commonRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::fromUuid,_					20,_					Time.milliseconds(20L))__				webMonitorLeaderRetriever = new LeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__				webMonitorLeaderRetrievalService.start(webMonitorLeaderRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,log,info,starting,rpc,service,s,akka,rpc,service,configuration,akka,rpc,service,config,akka,rpc,service,configuration,from,configuration,configuration,final,rpc,service,factory,dispatcher,resource,managre,component,rpc,service,factory,if,use,single,rpc,service,common,rpc,service,create,rpc,service,akka,rpc,service,config,false,null,final,common,rpc,service,factory,common,rpc,service,factory,new,common,rpc,service,factory,common,rpc,service,task,manager,rpc,service,factory,common,rpc,service,factory,dispatcher,resource,managre,component,rpc,service,factory,common,rpc,service,factory,else,common,rpc,service,create,rpc,service,akka,rpc,service,config,true,null,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,dispatcher,resource,managre,component,rpc,service,factory,new,dedicated,rpc,service,factory,akka,rpc,service,config,job,manager,bind,address,task,manager,rpc,service,factory,new,dedicated,rpc,service,factory,akka,rpc,service,config,task,manager,bind,address,metric,query,service,actor,system,metric,utils,start,metrics,actor,system,configuration,common,rpc,service,get,address,log,metric,registry,start,query,service,metric,query,service,actor,system,null,ha,services,create,high,availability,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,start,task,managers,metric,query,service,retriever,metric,query,service,retriever,new,akka,query,service,retriever,metric,query,service,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,dispatcher,resource,manager,components,add,all,create,dispatcher,resource,manager,components,configuration,dispatcher,resource,managre,component,rpc,service,factory,ha,services,blob,server,heartbeat,services,metric,registry,metric,query,service,retriever,new,shut,down,fatal,error,handler,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,web,monitor,leader,retrieval,service,ha,services,get,web,monitor,leader,retriever,dispatcher,gateway,retriever,new,rpc,gateway,retriever,common,rpc,service,dispatcher,gateway,class,dispatcher,id,from,uuid,20,time,milliseconds,20l,resource,manager,gateway,retriever,new,rpc,gateway,retriever,common,rpc,service,resource,manager,gateway,class,resource,manager,id,from,uuid,20,time,milliseconds,20l,web,monitor,leader,retriever,new,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,web,monitor,leader,retrieval,service,start,web,monitor,leader,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1550228244;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "FlinkMiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				_				LOG.info("Starting RPC Service(s)")___				AkkaRpcServiceConfiguration akkaRpcServiceConfig = AkkaRpcServiceConfiguration.fromConfiguration(configuration)___				final RpcServiceFactory dispatcherResourceManagreComponentRpcServiceFactory___				if (useSingleRpcService) {_					_					commonRpcService = createRpcService(akkaRpcServiceConfig, false, null)__					final CommonRpcServiceFactory commonRpcServiceFactory = new CommonRpcServiceFactory(commonRpcService)__					taskManagerRpcServiceFactory = commonRpcServiceFactory__					dispatcherResourceManagreComponentRpcServiceFactory = commonRpcServiceFactory__				} else {_					_					commonRpcService = createRpcService(akkaRpcServiceConfig, true, null)___					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()___					dispatcherResourceManagreComponentRpcServiceFactory = new DedicatedRpcServiceFactory(akkaRpcServiceConfig, jobManagerBindAddress)__					taskManagerRpcServiceFactory = new DedicatedRpcServiceFactory(akkaRpcServiceConfig, taskManagerBindAddress)__				}__				_				metricQueryServiceActorSystem = MetricUtils.startMetricsActorSystem(_					configuration,_					commonRpcService.getAddress(),_					LOG)__				metricRegistry.startQueryService(metricQueryServiceActorSystem, null)___				haServices = createHighAvailabilityServices(configuration, commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				startTaskManagers()___				MetricQueryServiceRetriever metricQueryServiceRetriever = new AkkaQueryServiceRetriever(_					metricQueryServiceActorSystem,_					Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT)))___				dispatcherResourceManagerComponents.addAll(createDispatcherResourceManagerComponents(_					configuration,_					dispatcherResourceManagreComponentRpcServiceFactory,_					haServices,_					blobServer,_					heartbeatServices,_					metricRegistry,_					metricQueryServiceRetriever,_					new ShutDownFatalErrorHandler()_				))___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()__				webMonitorLeaderRetrievalService = haServices.getWebMonitorLeaderRetriever()___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					commonRpcService,_					DispatcherGateway.class,_					DispatcherId::fromUuid,_					20,_					Time.milliseconds(20L))__				resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					commonRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::fromUuid,_					20,_					Time.milliseconds(20L))__				webMonitorLeaderRetriever = new LeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__				webMonitorLeaderRetrievalService.start(webMonitorLeaderRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,flink,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,log,info,starting,rpc,service,s,akka,rpc,service,configuration,akka,rpc,service,config,akka,rpc,service,configuration,from,configuration,configuration,final,rpc,service,factory,dispatcher,resource,managre,component,rpc,service,factory,if,use,single,rpc,service,common,rpc,service,create,rpc,service,akka,rpc,service,config,false,null,final,common,rpc,service,factory,common,rpc,service,factory,new,common,rpc,service,factory,common,rpc,service,task,manager,rpc,service,factory,common,rpc,service,factory,dispatcher,resource,managre,component,rpc,service,factory,common,rpc,service,factory,else,common,rpc,service,create,rpc,service,akka,rpc,service,config,true,null,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,dispatcher,resource,managre,component,rpc,service,factory,new,dedicated,rpc,service,factory,akka,rpc,service,config,job,manager,bind,address,task,manager,rpc,service,factory,new,dedicated,rpc,service,factory,akka,rpc,service,config,task,manager,bind,address,metric,query,service,actor,system,metric,utils,start,metrics,actor,system,configuration,common,rpc,service,get,address,log,metric,registry,start,query,service,metric,query,service,actor,system,null,ha,services,create,high,availability,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,start,task,managers,metric,query,service,retriever,metric,query,service,retriever,new,akka,query,service,retriever,metric,query,service,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,dispatcher,resource,manager,components,add,all,create,dispatcher,resource,manager,components,configuration,dispatcher,resource,managre,component,rpc,service,factory,ha,services,blob,server,heartbeat,services,metric,registry,metric,query,service,retriever,new,shut,down,fatal,error,handler,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,web,monitor,leader,retrieval,service,ha,services,get,web,monitor,leader,retriever,dispatcher,gateway,retriever,new,rpc,gateway,retriever,common,rpc,service,dispatcher,gateway,class,dispatcher,id,from,uuid,20,time,milliseconds,20l,resource,manager,gateway,retriever,new,rpc,gateway,retriever,common,rpc,service,resource,manager,gateway,class,resource,manager,id,from,uuid,20,time,milliseconds,20l,web,monitor,leader,retriever,new,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,web,monitor,leader,retrieval,service,start,web,monitor,leader,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1550483152;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "MiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				_				LOG.info("Starting RPC Service(s)")___				AkkaRpcServiceConfiguration akkaRpcServiceConfig = AkkaRpcServiceConfiguration.fromConfiguration(configuration)___				final RpcServiceFactory dispatcherResourceManagreComponentRpcServiceFactory___				if (useSingleRpcService) {_					_					commonRpcService = createRpcService(akkaRpcServiceConfig, false, null)__					final CommonRpcServiceFactory commonRpcServiceFactory = new CommonRpcServiceFactory(commonRpcService)__					taskManagerRpcServiceFactory = commonRpcServiceFactory__					dispatcherResourceManagreComponentRpcServiceFactory = commonRpcServiceFactory__				} else {_					_					commonRpcService = createRpcService(akkaRpcServiceConfig, true, null)___					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()___					dispatcherResourceManagreComponentRpcServiceFactory = new DedicatedRpcServiceFactory(akkaRpcServiceConfig, jobManagerBindAddress)__					taskManagerRpcServiceFactory = new DedicatedRpcServiceFactory(akkaRpcServiceConfig, taskManagerBindAddress)__				}__				_				metricQueryServiceActorSystem = MetricUtils.startMetricsActorSystem(_					configuration,_					commonRpcService.getAddress(),_					LOG)__				metricRegistry.startQueryService(metricQueryServiceActorSystem, null)___				haServices = createHighAvailabilityServices(configuration, commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				startTaskManagers()___				MetricQueryServiceRetriever metricQueryServiceRetriever = new AkkaQueryServiceRetriever(_					metricQueryServiceActorSystem,_					Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT)))___				dispatcherResourceManagerComponents.addAll(createDispatcherResourceManagerComponents(_					configuration,_					dispatcherResourceManagreComponentRpcServiceFactory,_					haServices,_					blobServer,_					heartbeatServices,_					metricRegistry,_					metricQueryServiceRetriever,_					new ShutDownFatalErrorHandler()_				))___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()__				webMonitorLeaderRetrievalService = haServices.getWebMonitorLeaderRetriever()___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					commonRpcService,_					DispatcherGateway.class,_					DispatcherId::fromUuid,_					20,_					Time.milliseconds(20L))__				resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					commonRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::fromUuid,_					20,_					Time.milliseconds(20L))__				webMonitorLeaderRetriever = new LeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__				webMonitorLeaderRetrievalService.start(webMonitorLeaderRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,log,info,starting,rpc,service,s,akka,rpc,service,configuration,akka,rpc,service,config,akka,rpc,service,configuration,from,configuration,configuration,final,rpc,service,factory,dispatcher,resource,managre,component,rpc,service,factory,if,use,single,rpc,service,common,rpc,service,create,rpc,service,akka,rpc,service,config,false,null,final,common,rpc,service,factory,common,rpc,service,factory,new,common,rpc,service,factory,common,rpc,service,task,manager,rpc,service,factory,common,rpc,service,factory,dispatcher,resource,managre,component,rpc,service,factory,common,rpc,service,factory,else,common,rpc,service,create,rpc,service,akka,rpc,service,config,true,null,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,dispatcher,resource,managre,component,rpc,service,factory,new,dedicated,rpc,service,factory,akka,rpc,service,config,job,manager,bind,address,task,manager,rpc,service,factory,new,dedicated,rpc,service,factory,akka,rpc,service,config,task,manager,bind,address,metric,query,service,actor,system,metric,utils,start,metrics,actor,system,configuration,common,rpc,service,get,address,log,metric,registry,start,query,service,metric,query,service,actor,system,null,ha,services,create,high,availability,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,start,task,managers,metric,query,service,retriever,metric,query,service,retriever,new,akka,query,service,retriever,metric,query,service,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,dispatcher,resource,manager,components,add,all,create,dispatcher,resource,manager,components,configuration,dispatcher,resource,managre,component,rpc,service,factory,ha,services,blob,server,heartbeat,services,metric,registry,metric,query,service,retriever,new,shut,down,fatal,error,handler,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,web,monitor,leader,retrieval,service,ha,services,get,web,monitor,leader,retriever,dispatcher,gateway,retriever,new,rpc,gateway,retriever,common,rpc,service,dispatcher,gateway,class,dispatcher,id,from,uuid,20,time,milliseconds,20l,resource,manager,gateway,retriever,new,rpc,gateway,retriever,common,rpc,service,resource,manager,gateway,class,resource,manager,id,from,uuid,20,time,milliseconds,20l,web,monitor,leader,retriever,new,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,web,monitor,leader,retrieval,service,start,web,monitor,leader,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public void start() throws Exception;1550823915;Starts the mini cluster, based on the configured properties.__@throws Exception This method passes on any exception that occurs during the startup of_the mini cluster.;public void start() throws Exception {_		synchronized (lock) {_			checkState(!running, "MiniCluster is already running")___			LOG.info("Starting Flink Mini Cluster")__			LOG.debug("Using configuration {}", miniClusterConfiguration)___			final Configuration configuration = miniClusterConfiguration.getConfiguration()__			final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == RpcServiceSharing.SHARED___			try {_				initializeIOFormatClasses(configuration)___				LOG.info("Starting Metrics Registry")__				metricRegistry = createMetricRegistry(configuration)___				_				LOG.info("Starting RPC Service(s)")___				AkkaRpcServiceConfiguration akkaRpcServiceConfig = AkkaRpcServiceConfiguration.fromConfiguration(configuration)___				final RpcServiceFactory dispatcherResourceManagreComponentRpcServiceFactory___				if (useSingleRpcService) {_					_					commonRpcService = createRpcService(akkaRpcServiceConfig, false, null)__					final CommonRpcServiceFactory commonRpcServiceFactory = new CommonRpcServiceFactory(commonRpcService)__					taskManagerRpcServiceFactory = commonRpcServiceFactory__					dispatcherResourceManagreComponentRpcServiceFactory = commonRpcServiceFactory__				} else {_					_					commonRpcService = createRpcService(akkaRpcServiceConfig, true, null)___					_					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress()__					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress()___					dispatcherResourceManagreComponentRpcServiceFactory = new DedicatedRpcServiceFactory(akkaRpcServiceConfig, jobManagerBindAddress)__					taskManagerRpcServiceFactory = new DedicatedRpcServiceFactory(akkaRpcServiceConfig, taskManagerBindAddress)__				}__				_				metricQueryServiceActorSystem = MetricUtils.startMetricsActorSystem(_					configuration,_					commonRpcService.getAddress(),_					LOG)__				metricRegistry.startQueryService(metricQueryServiceActorSystem, null)___				haServices = createHighAvailabilityServices(configuration, commonRpcService.getExecutor())___				blobServer = new BlobServer(configuration, haServices.createBlobStore())__				blobServer.start()___				heartbeatServices = HeartbeatServices.fromConfiguration(configuration)___				blobCacheService = new BlobCacheService(_					configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())_				)___				startTaskManagers()___				MetricQueryServiceRetriever metricQueryServiceRetriever = new AkkaQueryServiceRetriever(_					metricQueryServiceActorSystem,_					Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT)))___				dispatcherResourceManagerComponents.addAll(createDispatcherResourceManagerComponents(_					configuration,_					dispatcherResourceManagreComponentRpcServiceFactory,_					haServices,_					blobServer,_					heartbeatServices,_					metricRegistry,_					metricQueryServiceRetriever,_					new ShutDownFatalErrorHandler()_				))___				resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever()__				dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever()__				webMonitorLeaderRetrievalService = haServices.getWebMonitorLeaderRetriever()___				dispatcherGatewayRetriever = new RpcGatewayRetriever<>(_					commonRpcService,_					DispatcherGateway.class,_					DispatcherId::fromUuid,_					20,_					Time.milliseconds(20L))__				resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(_					commonRpcService,_					ResourceManagerGateway.class,_					ResourceManagerId::fromUuid,_					20,_					Time.milliseconds(20L))__				webMonitorLeaderRetriever = new LeaderRetriever()___				resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever)__				dispatcherLeaderRetriever.start(dispatcherGatewayRetriever)__				webMonitorLeaderRetrievalService.start(webMonitorLeaderRetriever)__			}_			catch (Exception e) {_				_				try {_					close()__				} catch (Exception ee) {_					e.addSuppressed(ee)__				}_				throw e__			}__			_			terminationFuture = new CompletableFuture<>()___			_			running = true___			LOG.info("Flink Mini Cluster started successfully")__		}_	};starts,the,mini,cluster,based,on,the,configured,properties,throws,exception,this,method,passes,on,any,exception,that,occurs,during,the,startup,of,the,mini,cluster;public,void,start,throws,exception,synchronized,lock,check,state,running,mini,cluster,is,already,running,log,info,starting,flink,mini,cluster,log,debug,using,configuration,mini,cluster,configuration,final,configuration,configuration,mini,cluster,configuration,get,configuration,final,boolean,use,single,rpc,service,mini,cluster,configuration,get,rpc,service,sharing,rpc,service,sharing,shared,try,initialize,ioformat,classes,configuration,log,info,starting,metrics,registry,metric,registry,create,metric,registry,configuration,log,info,starting,rpc,service,s,akka,rpc,service,configuration,akka,rpc,service,config,akka,rpc,service,configuration,from,configuration,configuration,final,rpc,service,factory,dispatcher,resource,managre,component,rpc,service,factory,if,use,single,rpc,service,common,rpc,service,create,rpc,service,akka,rpc,service,config,false,null,final,common,rpc,service,factory,common,rpc,service,factory,new,common,rpc,service,factory,common,rpc,service,task,manager,rpc,service,factory,common,rpc,service,factory,dispatcher,resource,managre,component,rpc,service,factory,common,rpc,service,factory,else,common,rpc,service,create,rpc,service,akka,rpc,service,config,true,null,final,string,job,manager,bind,address,mini,cluster,configuration,get,job,manager,bind,address,final,string,task,manager,bind,address,mini,cluster,configuration,get,task,manager,bind,address,dispatcher,resource,managre,component,rpc,service,factory,new,dedicated,rpc,service,factory,akka,rpc,service,config,job,manager,bind,address,task,manager,rpc,service,factory,new,dedicated,rpc,service,factory,akka,rpc,service,config,task,manager,bind,address,metric,query,service,actor,system,metric,utils,start,metrics,actor,system,configuration,common,rpc,service,get,address,log,metric,registry,start,query,service,metric,query,service,actor,system,null,ha,services,create,high,availability,services,configuration,common,rpc,service,get,executor,blob,server,new,blob,server,configuration,ha,services,create,blob,store,blob,server,start,heartbeat,services,heartbeat,services,from,configuration,configuration,blob,cache,service,new,blob,cache,service,configuration,ha,services,create,blob,store,new,inet,socket,address,inet,address,get,local,host,blob,server,get,port,start,task,managers,metric,query,service,retriever,metric,query,service,retriever,new,akka,query,service,retriever,metric,query,service,actor,system,time,milliseconds,configuration,get,long,web,options,timeout,dispatcher,resource,manager,components,add,all,create,dispatcher,resource,manager,components,configuration,dispatcher,resource,managre,component,rpc,service,factory,ha,services,blob,server,heartbeat,services,metric,registry,metric,query,service,retriever,new,shut,down,fatal,error,handler,resource,manager,leader,retriever,ha,services,get,resource,manager,leader,retriever,dispatcher,leader,retriever,ha,services,get,dispatcher,leader,retriever,web,monitor,leader,retrieval,service,ha,services,get,web,monitor,leader,retriever,dispatcher,gateway,retriever,new,rpc,gateway,retriever,common,rpc,service,dispatcher,gateway,class,dispatcher,id,from,uuid,20,time,milliseconds,20l,resource,manager,gateway,retriever,new,rpc,gateway,retriever,common,rpc,service,resource,manager,gateway,class,resource,manager,id,from,uuid,20,time,milliseconds,20l,web,monitor,leader,retriever,new,leader,retriever,resource,manager,leader,retriever,start,resource,manager,gateway,retriever,dispatcher,leader,retriever,start,dispatcher,gateway,retriever,web,monitor,leader,retrieval,service,start,web,monitor,leader,retriever,catch,exception,e,try,close,catch,exception,ee,e,add,suppressed,ee,throw,e,termination,future,new,completable,future,running,true,log,info,flink,mini,cluster,started,successfully
MiniCluster -> public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1482522863;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		MiniClusterJobDispatcher dispatcher__		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			dispatcher = this.jobDispatcher__		}__		return dispatcher.runJobBlocking(job)__	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,job,execution,result,run,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,mini,cluster,job,dispatcher,dispatcher,synchronized,lock,check,state,running,mini,cluster,is,not,running,dispatcher,this,job,dispatcher,return,dispatcher,run,job,blocking,job
MiniCluster -> public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1482522863;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		MiniClusterJobDispatcher dispatcher__		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			dispatcher = this.jobDispatcher__		}__		return dispatcher.runJobBlocking(job)__	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,job,execution,result,run,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,mini,cluster,job,dispatcher,dispatcher,synchronized,lock,check,state,running,mini,cluster,is,not,running,dispatcher,this,job,dispatcher,return,dispatcher,run,job,blocking,job
MiniCluster -> public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1482522864;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		MiniClusterJobDispatcher dispatcher__		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			dispatcher = this.jobDispatcher__		}__		return dispatcher.runJobBlocking(job)__	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,job,execution,result,run,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,mini,cluster,job,dispatcher,dispatcher,synchronized,lock,check,state,running,mini,cluster,is,not,running,dispatcher,this,job,dispatcher,return,dispatcher,run,job,blocking,job
MiniCluster -> public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1482522864;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		MiniClusterJobDispatcher dispatcher__		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			dispatcher = this.jobDispatcher__		}__		return dispatcher.runJobBlocking(job)__	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,job,execution,result,run,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,mini,cluster,job,dispatcher,dispatcher,synchronized,lock,check,state,running,mini,cluster,is,not,running,dispatcher,this,job,dispatcher,return,dispatcher,run,job,blocking,job
MiniCluster -> public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1482522864;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		MiniClusterJobDispatcher dispatcher__		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			dispatcher = this.jobDispatcher__		}__		return dispatcher.runJobBlocking(job)__	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,job,execution,result,run,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,mini,cluster,job,dispatcher,dispatcher,synchronized,lock,check,state,running,mini,cluster,is,not,running,dispatcher,this,job,dispatcher,return,dispatcher,run,job,blocking,job
MiniCluster -> public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1482522864;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		MiniClusterJobDispatcher dispatcher__		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			dispatcher = this.jobDispatcher__		}__		return dispatcher.runJobBlocking(job)__	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,job,execution,result,run,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,mini,cluster,job,dispatcher,dispatcher,synchronized,lock,check,state,running,mini,cluster,is,not,running,dispatcher,this,job,dispatcher,return,dispatcher,run,job,blocking,job
MiniCluster -> public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1482522866;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		MiniClusterJobDispatcher dispatcher__		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			dispatcher = this.jobDispatcher__		}__		return dispatcher.runJobBlocking(job)__	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,job,execution,result,run,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,mini,cluster,job,dispatcher,dispatcher,synchronized,lock,check,state,running,mini,cluster,is,not,running,dispatcher,this,job,dispatcher,return,dispatcher,run,job,blocking,job
MiniCluster -> public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1482522866;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		MiniClusterJobDispatcher dispatcher__		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			dispatcher = this.jobDispatcher__		}__		return dispatcher.runJobBlocking(job)__	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,job,execution,result,run,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,mini,cluster,job,dispatcher,dispatcher,synchronized,lock,check,state,running,mini,cluster,is,not,running,dispatcher,this,job,dispatcher,return,dispatcher,run,job,blocking,job
MiniCluster -> public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1482522866;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		MiniClusterJobDispatcher dispatcher__		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			dispatcher = this.jobDispatcher__		}__		return dispatcher.runJobBlocking(job)__	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,job,execution,result,run,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,mini,cluster,job,dispatcher,dispatcher,synchronized,lock,check,state,running,mini,cluster,is,not,running,dispatcher,this,job,dispatcher,return,dispatcher,run,job,blocking,job
MiniCluster -> public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1482522867;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		MiniClusterJobDispatcher dispatcher__		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			dispatcher = this.jobDispatcher__		}__		return dispatcher.runJobBlocking(job)__	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,job,execution,result,run,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,mini,cluster,job,dispatcher,dispatcher,synchronized,lock,check,state,running,mini,cluster,is,not,running,dispatcher,this,job,dispatcher,return,dispatcher,run,job,blocking,job
MiniCluster -> public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1489766405;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		MiniClusterJobDispatcher dispatcher__		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			dispatcher = this.jobDispatcher__		}__		return dispatcher.runJobBlocking(job)__	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,job,execution,result,run,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,mini,cluster,job,dispatcher,dispatcher,synchronized,lock,check,state,running,mini,cluster,is,not,running,dispatcher,this,job,dispatcher,return,dispatcher,run,job,blocking,job
MiniCluster -> public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1490273924;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		MiniClusterJobDispatcher dispatcher__		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			dispatcher = this.jobDispatcher__		}__		return dispatcher.runJobBlocking(job)__	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,job,execution,result,run,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,mini,cluster,job,dispatcher,dispatcher,synchronized,lock,check,state,running,mini,cluster,is,not,running,dispatcher,this,job,dispatcher,return,dispatcher,run,job,blocking,job
MiniCluster -> public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1490273924;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		MiniClusterJobDispatcher dispatcher__		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			dispatcher = this.jobDispatcher__		}__		return dispatcher.runJobBlocking(job)__	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,job,execution,result,run,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,mini,cluster,job,dispatcher,dispatcher,synchronized,lock,check,state,running,mini,cluster,is,not,running,dispatcher,this,job,dispatcher,return,dispatcher,run,job,blocking,job
MiniCluster -> public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1493146240;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		MiniClusterJobDispatcher dispatcher__		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			dispatcher = this.jobDispatcher__		}__		return dispatcher.runJobBlocking(job)__	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,job,execution,result,run,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,mini,cluster,job,dispatcher,dispatcher,synchronized,lock,check,state,running,mini,cluster,is,not,running,dispatcher,this,job,dispatcher,return,dispatcher,run,job,blocking,job
MiniCluster -> public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1493975155;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		MiniClusterJobDispatcher dispatcher__		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			dispatcher = this.jobDispatcher__		}__		return dispatcher.runJobBlocking(job)__	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,job,execution,result,run,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,mini,cluster,job,dispatcher,dispatcher,synchronized,lock,check,state,running,mini,cluster,is,not,running,dispatcher,this,job,dispatcher,return,dispatcher,run,job,blocking,job
MiniCluster -> public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1499254138;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		MiniClusterJobDispatcher dispatcher__		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			dispatcher = this.jobDispatcher__		}__		return dispatcher.runJobBlocking(job)__	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,job,execution,result,run,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,mini,cluster,job,dispatcher,dispatcher,synchronized,lock,check,state,running,mini,cluster,is,not,running,dispatcher,this,job,dispatcher,return,dispatcher,run,job,blocking,job
MiniCluster -> public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1499789965;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		MiniClusterJobDispatcher dispatcher__		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			dispatcher = this.jobDispatcher__		}__		return dispatcher.runJobBlocking(job)__	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,job,execution,result,run,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,mini,cluster,job,dispatcher,dispatcher,synchronized,lock,check,state,running,mini,cluster,is,not,running,dispatcher,this,job,dispatcher,return,dispatcher,run,job,blocking,job
MiniCluster -> public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1501437265;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		MiniClusterJobDispatcher dispatcher__		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			dispatcher = this.jobDispatcher__		}__		return dispatcher.runJobBlocking(job)__	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,job,execution,result,run,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,mini,cluster,job,dispatcher,dispatcher,synchronized,lock,check,state,running,mini,cluster,is,not,running,dispatcher,this,job,dispatcher,return,dispatcher,run,job,blocking,job
MiniCluster -> public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1501660818;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		MiniClusterJobDispatcher dispatcher__		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			dispatcher = this.jobDispatcher__		}__		return dispatcher.runJobBlocking(job)__	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,job,execution,result,run,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,mini,cluster,job,dispatcher,dispatcher,synchronized,lock,check,state,running,mini,cluster,is,not,running,dispatcher,this,job,dispatcher,return,dispatcher,run,job,blocking,job
MiniCluster -> public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1504477043;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		MiniClusterJobDispatcher dispatcher__		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			dispatcher = this.jobDispatcher__		}__		return dispatcher.runJobBlocking(job)__	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,job,execution,result,run,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,mini,cluster,job,dispatcher,dispatcher,synchronized,lock,check,state,running,mini,cluster,is,not,running,dispatcher,this,job,dispatcher,return,dispatcher,run,job,blocking,job
MiniCluster -> public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1504525441;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		MiniClusterJobDispatcher dispatcher__		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			dispatcher = this.jobDispatcher__		}__		return dispatcher.runJobBlocking(job)__	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,job,execution,result,run,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,mini,cluster,job,dispatcher,dispatcher,synchronized,lock,check,state,running,mini,cluster,is,not,running,dispatcher,this,job,dispatcher,return,dispatcher,run,job,blocking,job
MiniCluster -> public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1504607872;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		MiniClusterJobDispatcher dispatcher__		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			dispatcher = this.jobDispatcher__		}__		return dispatcher.runJobBlocking(job)__	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,job,execution,result,run,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,mini,cluster,job,dispatcher,dispatcher,synchronized,lock,check,state,running,mini,cluster,is,not,running,dispatcher,this,job,dispatcher,return,dispatcher,run,job,blocking,job
MiniCluster -> public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1507212387;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		MiniClusterJobDispatcher dispatcher__		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			dispatcher = this.jobDispatcher__		}__		return dispatcher.runJobBlocking(job)__	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,job,execution,result,run,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,mini,cluster,job,dispatcher,dispatcher,synchronized,lock,check,state,running,mini,cluster,is,not,running,dispatcher,this,job,dispatcher,return,dispatcher,run,job,blocking,job
MiniCluster -> public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1509006142;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		MiniClusterJobDispatcher dispatcher__		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			dispatcher = this.jobDispatcher__		}__		return dispatcher.runJobBlocking(job)__	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,job,execution,result,run,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,mini,cluster,job,dispatcher,dispatcher,synchronized,lock,check,state,running,mini,cluster,is,not,running,dispatcher,this,job,dispatcher,return,dispatcher,run,job,blocking,job
MiniCluster -> public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1509547920;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		MiniClusterJobDispatcher dispatcher__		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			dispatcher = this.jobDispatcher__		}__		return dispatcher.runJobBlocking(job)__	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,job,execution,result,run,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,mini,cluster,job,dispatcher,dispatcher,synchronized,lock,check,state,running,mini,cluster,is,not,running,dispatcher,this,job,dispatcher,return,dispatcher,run,job,blocking,job
MiniCluster -> public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1509547921;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;public JobExecutionResult runJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		MiniClusterJobDispatcher dispatcher__		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			dispatcher = this.jobDispatcher__		}__		return dispatcher.runJobBlocking(job)__	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;public,job,execution,result,run,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,mini,cluster,job,dispatcher,dispatcher,synchronized,lock,check,state,running,mini,cluster,is,not,running,dispatcher,this,job,dispatcher,return,dispatcher,run,job,blocking,job
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1509006142;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1509547920;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1509547921;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1515583830;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1515600854;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1517915730;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1519121818;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1519249745;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1519406526;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1519406527;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1519406529;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1519510773;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1519512293;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1519977151;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1519977152;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1519977152;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1519977155;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1520032992;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1521379500;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1521385093;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1521385094;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1521537266;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1521537266;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1521537266;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1521804758;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1522132482;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1522681180;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1522759723;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1522825170;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1525420604;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1525452496;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1526334048;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1526336566;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1529682304;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1530181266;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1530644925;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1533555608;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1538042094;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1539169204;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1539176686;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1539176687;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1539176687;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1539582211;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1539787538;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1545326469;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1547675340;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1547675341;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1548249770;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1548326020;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1548846699;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1548866156;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1548966387;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1549360057;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1549360057;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1549360057;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1549360057;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")__		this.rpcServices = new ArrayList<>(1 + 2 + miniClusterConfiguration.getNumTaskManagers())_ _		this.dispatcherResourceManagerComponents = new ArrayList<>(1)___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,services,new,array,list,1,2,mini,cluster,configuration,get,num,task,managers,this,dispatcher,resource,manager,components,new,array,list,1,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1549360057;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")__		this.rpcServices = new ArrayList<>(1 + 2 + miniClusterConfiguration.getNumTaskManagers())_ _		this.dispatcherResourceManagerComponents = new ArrayList<>(1)___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,services,new,array,list,1,2,mini,cluster,configuration,get,num,task,managers,this,dispatcher,resource,manager,components,new,array,list,1,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1549360058;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")__		this.rpcServices = new ArrayList<>(1 + 2 + miniClusterConfiguration.getNumTaskManagers())_ _		this.dispatcherResourceManagerComponents = new ArrayList<>(1)___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,services,new,array,list,1,2,mini,cluster,configuration,get,num,task,managers,this,dispatcher,resource,manager,components,new,array,list,1,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1550005040;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")__		this.rpcServices = new ArrayList<>(1 + 2 + miniClusterConfiguration.getNumTaskManagers())_ _		this.dispatcherResourceManagerComponents = new ArrayList<>(1)___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,services,new,array,list,1,2,mini,cluster,configuration,get,num,task,managers,this,dispatcher,resource,manager,components,new,array,list,1,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1550069788;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")__		this.rpcServices = new ArrayList<>(1 + 2 + miniClusterConfiguration.getNumTaskManagers())_ _		this.dispatcherResourceManagerComponents = new ArrayList<>(1)___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false___		this.taskManagers = new ArrayList<>(miniClusterConfiguration.getNumTaskManagers())__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,services,new,array,list,1,2,mini,cluster,configuration,get,num,task,managers,this,dispatcher,resource,manager,components,new,array,list,1,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false,this,task,managers,new,array,list,mini,cluster,configuration,get,num,task,managers
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1550228244;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")__		this.rpcServices = new ArrayList<>(1 + 2 + miniClusterConfiguration.getNumTaskManagers())_ _		this.dispatcherResourceManagerComponents = new ArrayList<>(1)___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false___		this.taskManagers = new ArrayList<>(miniClusterConfiguration.getNumTaskManagers())__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,services,new,array,list,1,2,mini,cluster,configuration,get,num,task,managers,this,dispatcher,resource,manager,components,new,array,list,1,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false,this,task,managers,new,array,list,mini,cluster,configuration,get,num,task,managers
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1550483152;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")__		this.rpcServices = new ArrayList<>(1 + 2 + miniClusterConfiguration.getNumTaskManagers())_ _		this.dispatcherResourceManagerComponents = new ArrayList<>(1)___		this.rpcTimeout = Time.seconds(10L)__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false___		this.taskManagers = new ArrayList<>(miniClusterConfiguration.getNumTaskManagers())__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,services,new,array,list,1,2,mini,cluster,configuration,get,num,task,managers,this,dispatcher,resource,manager,components,new,array,list,1,this,rpc,timeout,time,seconds,10l,this,termination,future,completable,future,completed,future,null,running,false,this,task,managers,new,array,list,mini,cluster,configuration,get,num,task,managers
MiniCluster -> public MiniCluster(MiniClusterConfiguration miniClusterConfiguration);1550823915;Creates a new Flink mini cluster based on the given configuration.__@param miniClusterConfiguration The configuration for the mini cluster;public MiniCluster(MiniClusterConfiguration miniClusterConfiguration) {_		this.miniClusterConfiguration = checkNotNull(miniClusterConfiguration, "config may not be null")__		this.rpcServices = new ArrayList<>(1 + 2 + miniClusterConfiguration.getNumTaskManagers())_ _		this.dispatcherResourceManagerComponents = new ArrayList<>(1)___		this.rpcTimeout = miniClusterConfiguration.getRpcTimeout()__		this.terminationFuture = CompletableFuture.completedFuture(null)__		running = false___		this.taskManagers = new ArrayList<>(miniClusterConfiguration.getNumTaskManagers())__	};creates,a,new,flink,mini,cluster,based,on,the,given,configuration,param,mini,cluster,configuration,the,configuration,for,the,mini,cluster;public,mini,cluster,mini,cluster,configuration,mini,cluster,configuration,this,mini,cluster,configuration,check,not,null,mini,cluster,configuration,config,may,not,be,null,this,rpc,services,new,array,list,1,2,mini,cluster,configuration,get,num,task,managers,this,dispatcher,resource,manager,components,new,array,list,1,this,rpc,timeout,mini,cluster,configuration,get,rpc,timeout,this,termination,future,completable,future,completed,future,null,running,false,this,task,managers,new,array,list,mini,cluster,configuration,get,num,task,managers
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config);1482522863;Creates a mini cluster based on the given configuration.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config) {_		this(createConfig(config, true))__	};creates,a,mini,cluster,based,on,the,given,configuration,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,this,create,config,config,true
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config);1482522863;Creates a mini cluster based on the given configuration.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config) {_		this(createConfig(config, true))__	};creates,a,mini,cluster,based,on,the,given,configuration,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,this,create,config,config,true
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config);1482522864;Creates a mini cluster based on the given configuration.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config) {_		this(createConfig(config, true))__	};creates,a,mini,cluster,based,on,the,given,configuration,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,this,create,config,config,true
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config);1482522864;Creates a mini cluster based on the given configuration.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config) {_		this(createConfig(config, true))__	};creates,a,mini,cluster,based,on,the,given,configuration,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,this,create,config,config,true
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config);1482522864;Creates a mini cluster based on the given configuration.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config) {_		this(createConfig(config, true))__	};creates,a,mini,cluster,based,on,the,given,configuration,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,this,create,config,config,true
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config);1482522864;Creates a mini cluster based on the given configuration.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config) {_		this(createConfig(config, true))__	};creates,a,mini,cluster,based,on,the,given,configuration,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,this,create,config,config,true
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config);1482522866;Creates a mini cluster based on the given configuration.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config) {_		this(createConfig(config, true))__	};creates,a,mini,cluster,based,on,the,given,configuration,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,this,create,config,config,true
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config);1482522866;Creates a mini cluster based on the given configuration.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config) {_		this(createConfig(config, true))__	};creates,a,mini,cluster,based,on,the,given,configuration,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,this,create,config,config,true
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config);1482522866;Creates a mini cluster based on the given configuration.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config) {_		this(createConfig(config, true))__	};creates,a,mini,cluster,based,on,the,given,configuration,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,this,create,config,config,true
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config);1482522867;Creates a mini cluster based on the given configuration.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config) {_		this(createConfig(config, true))__	};creates,a,mini,cluster,based,on,the,given,configuration,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,this,create,config,config,true
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config);1489766405;Creates a mini cluster based on the given configuration.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config) {_		this(createConfig(config, true))__	};creates,a,mini,cluster,based,on,the,given,configuration,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,this,create,config,config,true
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config);1490273924;Creates a mini cluster based on the given configuration.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config) {_		this(createConfig(config, true))__	};creates,a,mini,cluster,based,on,the,given,configuration,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,this,create,config,config,true
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config);1490273924;Creates a mini cluster based on the given configuration.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config) {_		this(createConfig(config, true))__	};creates,a,mini,cluster,based,on,the,given,configuration,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,this,create,config,config,true
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config);1493146240;Creates a mini cluster based on the given configuration.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config) {_		this(createConfig(config, true))__	};creates,a,mini,cluster,based,on,the,given,configuration,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,this,create,config,config,true
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config);1493975155;Creates a mini cluster based on the given configuration.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config) {_		this(createConfig(config, true))__	};creates,a,mini,cluster,based,on,the,given,configuration,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,this,create,config,config,true
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config);1499254138;Creates a mini cluster based on the given configuration.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config) {_		this(createConfig(config, true))__	};creates,a,mini,cluster,based,on,the,given,configuration,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,this,create,config,config,true
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config);1499789965;Creates a mini cluster based on the given configuration.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config) {_		this(createConfig(config, true))__	};creates,a,mini,cluster,based,on,the,given,configuration,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,this,create,config,config,true
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config);1501437265;Creates a mini cluster based on the given configuration.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config) {_		this(createConfig(config, true))__	};creates,a,mini,cluster,based,on,the,given,configuration,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,this,create,config,config,true
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config);1501660818;Creates a mini cluster based on the given configuration.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config) {_		this(createConfig(config, true))__	};creates,a,mini,cluster,based,on,the,given,configuration,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,this,create,config,config,true
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config);1504477043;Creates a mini cluster based on the given configuration.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config) {_		this(createConfig(config, true))__	};creates,a,mini,cluster,based,on,the,given,configuration,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,this,create,config,config,true
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config);1504525441;Creates a mini cluster based on the given configuration.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config) {_		this(createConfig(config, true))__	};creates,a,mini,cluster,based,on,the,given,configuration,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,this,create,config,config,true
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config);1504607872;Creates a mini cluster based on the given configuration.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config) {_		this(createConfig(config, true))__	};creates,a,mini,cluster,based,on,the,given,configuration,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,this,create,config,config,true
MiniCluster -> @Deprecated 	public MiniCluster(Configuration config);1507212387;Creates a mini cluster based on the given configuration.__@deprecated Use {@link #MiniCluster(MiniClusterConfiguration)} instead._@see #MiniCluster(MiniClusterConfiguration);@Deprecated_	public MiniCluster(Configuration config) {_		this(createConfig(config, true))__	};creates,a,mini,cluster,based,on,the,given,configuration,deprecated,use,link,mini,cluster,mini,cluster,configuration,instead,see,mini,cluster,mini,cluster,configuration;deprecated,public,mini,cluster,configuration,config,this,create,config,config,true
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1482522863;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		ActorSystem actorSystem__		if (remoteEnabled) {_			actorSystem = AkkaUtils.createActorSystem(configuration, bindAddress, 0)__		} else {_			actorSystem = AkkaUtils.createLocalActorSystem(configuration)__		}__		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,actor,system,actor,system,if,remote,enabled,actor,system,akka,utils,create,actor,system,configuration,bind,address,0,else,actor,system,akka,utils,create,local,actor,system,configuration,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1482522864;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		ActorSystem actorSystem__		if (remoteEnabled) {_			actorSystem = AkkaUtils.createActorSystem(configuration, bindAddress, 0)__		} else {_			actorSystem = AkkaUtils.createLocalActorSystem(configuration)__		}__		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,actor,system,actor,system,if,remote,enabled,actor,system,akka,utils,create,actor,system,configuration,bind,address,0,else,actor,system,akka,utils,create,local,actor,system,configuration,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1482522864;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		ActorSystem actorSystem__		if (remoteEnabled) {_			actorSystem = AkkaUtils.createActorSystem(configuration, bindAddress, 0)__		} else {_			actorSystem = AkkaUtils.createLocalActorSystem(configuration)__		}__		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,actor,system,actor,system,if,remote,enabled,actor,system,akka,utils,create,actor,system,configuration,bind,address,0,else,actor,system,akka,utils,create,local,actor,system,configuration,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1482522864;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		ActorSystem actorSystem__		if (remoteEnabled) {_			actorSystem = AkkaUtils.createActorSystem(configuration, bindAddress, 0)__		} else {_			actorSystem = AkkaUtils.createLocalActorSystem(configuration)__		}__		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,actor,system,actor,system,if,remote,enabled,actor,system,akka,utils,create,actor,system,configuration,bind,address,0,else,actor,system,akka,utils,create,local,actor,system,configuration,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1482522864;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		ActorSystem actorSystem__		if (remoteEnabled) {_			actorSystem = AkkaUtils.createActorSystem(configuration, bindAddress, 0)__		} else {_			actorSystem = AkkaUtils.createLocalActorSystem(configuration)__		}__		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,actor,system,actor,system,if,remote,enabled,actor,system,akka,utils,create,actor,system,configuration,bind,address,0,else,actor,system,akka,utils,create,local,actor,system,configuration,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1482522866;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		ActorSystem actorSystem__		if (remoteEnabled) {_			actorSystem = AkkaUtils.createActorSystem(configuration, bindAddress, 0)__		} else {_			actorSystem = AkkaUtils.createLocalActorSystem(configuration)__		}__		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,actor,system,actor,system,if,remote,enabled,actor,system,akka,utils,create,actor,system,configuration,bind,address,0,else,actor,system,akka,utils,create,local,actor,system,configuration,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1482522866;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		ActorSystem actorSystem__		if (remoteEnabled) {_			actorSystem = AkkaUtils.createActorSystem(configuration, bindAddress, 0)__		} else {_			actorSystem = AkkaUtils.createLocalActorSystem(configuration)__		}__		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,actor,system,actor,system,if,remote,enabled,actor,system,akka,utils,create,actor,system,configuration,bind,address,0,else,actor,system,akka,utils,create,local,actor,system,configuration,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1482522866;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		ActorSystem actorSystem__		if (remoteEnabled) {_			actorSystem = AkkaUtils.createActorSystem(configuration, bindAddress, 0)__		} else {_			actorSystem = AkkaUtils.createLocalActorSystem(configuration)__		}__		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,actor,system,actor,system,if,remote,enabled,actor,system,akka,utils,create,actor,system,configuration,bind,address,0,else,actor,system,akka,utils,create,local,actor,system,configuration,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1482522867;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		ActorSystem actorSystem__		if (remoteEnabled) {_			actorSystem = AkkaUtils.createActorSystem(configuration, bindAddress, 0)__		} else {_			actorSystem = AkkaUtils.createLocalActorSystem(configuration)__		}__		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,actor,system,actor,system,if,remote,enabled,actor,system,akka,utils,create,actor,system,configuration,bind,address,0,else,actor,system,akka,utils,create,local,actor,system,configuration,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1489766405;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		ActorSystem actorSystem__		if (remoteEnabled) {_			actorSystem = AkkaUtils.createActorSystem(configuration, bindAddress, 0)__		} else {_			actorSystem = AkkaUtils.createLocalActorSystem(configuration)__		}__		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,actor,system,actor,system,if,remote,enabled,actor,system,akka,utils,create,actor,system,configuration,bind,address,0,else,actor,system,akka,utils,create,local,actor,system,configuration,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1490273924;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		ActorSystem actorSystem__		if (remoteEnabled) {_			actorSystem = AkkaUtils.createActorSystem(configuration, bindAddress, 0)__		} else {_			actorSystem = AkkaUtils.createLocalActorSystem(configuration)__		}__		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,actor,system,actor,system,if,remote,enabled,actor,system,akka,utils,create,actor,system,configuration,bind,address,0,else,actor,system,akka,utils,create,local,actor,system,configuration,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1490273924;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		ActorSystem actorSystem__		if (remoteEnabled) {_			actorSystem = AkkaUtils.createActorSystem(configuration, bindAddress, 0)__		} else {_			actorSystem = AkkaUtils.createLocalActorSystem(configuration)__		}__		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,actor,system,actor,system,if,remote,enabled,actor,system,akka,utils,create,actor,system,configuration,bind,address,0,else,actor,system,akka,utils,create,local,actor,system,configuration,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1493146240;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		ActorSystem actorSystem__		if (remoteEnabled) {_			actorSystem = AkkaUtils.createActorSystem(configuration, bindAddress, 0)__		} else {_			actorSystem = AkkaUtils.createLocalActorSystem(configuration)__		}__		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,actor,system,actor,system,if,remote,enabled,actor,system,akka,utils,create,actor,system,configuration,bind,address,0,else,actor,system,akka,utils,create,local,actor,system,configuration,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1493975155;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		ActorSystem actorSystem__		if (remoteEnabled) {_			actorSystem = AkkaUtils.createActorSystem(configuration, bindAddress, 0)__		} else {_			actorSystem = AkkaUtils.createLocalActorSystem(configuration)__		}__		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,actor,system,actor,system,if,remote,enabled,actor,system,akka,utils,create,actor,system,configuration,bind,address,0,else,actor,system,akka,utils,create,local,actor,system,configuration,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1499254138;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		ActorSystem actorSystem__		if (remoteEnabled) {_			actorSystem = AkkaUtils.createActorSystem(configuration, bindAddress, 0)__		} else {_			actorSystem = AkkaUtils.createLocalActorSystem(configuration)__		}__		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,actor,system,actor,system,if,remote,enabled,actor,system,akka,utils,create,actor,system,configuration,bind,address,0,else,actor,system,akka,utils,create,local,actor,system,configuration,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1499789965;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		ActorSystem actorSystem__		if (remoteEnabled) {_			actorSystem = AkkaUtils.createActorSystem(configuration, bindAddress, 0)__		} else {_			actorSystem = AkkaUtils.createLocalActorSystem(configuration)__		}__		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,actor,system,actor,system,if,remote,enabled,actor,system,akka,utils,create,actor,system,configuration,bind,address,0,else,actor,system,akka,utils,create,local,actor,system,configuration,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1501437265;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		ActorSystem actorSystem__		if (remoteEnabled) {_			actorSystem = AkkaUtils.createActorSystem(configuration, bindAddress, 0)__		} else {_			actorSystem = AkkaUtils.createLocalActorSystem(configuration)__		}__		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,actor,system,actor,system,if,remote,enabled,actor,system,akka,utils,create,actor,system,configuration,bind,address,0,else,actor,system,akka,utils,create,local,actor,system,configuration,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1501660818;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		ActorSystem actorSystem__		if (remoteEnabled) {_			actorSystem = AkkaUtils.createActorSystem(configuration, bindAddress, 0)__		} else {_			actorSystem = AkkaUtils.createLocalActorSystem(configuration)__		}__		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,actor,system,actor,system,if,remote,enabled,actor,system,akka,utils,create,actor,system,configuration,bind,address,0,else,actor,system,akka,utils,create,local,actor,system,configuration,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1504477043;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		ActorSystem actorSystem__		if (remoteEnabled) {_			actorSystem = AkkaUtils.createActorSystem(configuration, bindAddress, 0)__		} else {_			actorSystem = AkkaUtils.createLocalActorSystem(configuration)__		}__		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,actor,system,actor,system,if,remote,enabled,actor,system,akka,utils,create,actor,system,configuration,bind,address,0,else,actor,system,akka,utils,create,local,actor,system,configuration,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1504525441;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		ActorSystem actorSystem__		if (remoteEnabled) {_			actorSystem = AkkaUtils.createActorSystem(configuration, bindAddress, 0)__		} else {_			actorSystem = AkkaUtils.createLocalActorSystem(configuration)__		}__		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,actor,system,actor,system,if,remote,enabled,actor,system,akka,utils,create,actor,system,configuration,bind,address,0,else,actor,system,akka,utils,create,local,actor,system,configuration,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1504607872;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		ActorSystem actorSystem__		if (remoteEnabled) {_			actorSystem = AkkaUtils.createActorSystem(configuration, bindAddress, 0)__		} else {_			actorSystem = AkkaUtils.createLocalActorSystem(configuration)__		}__		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,actor,system,actor,system,if,remote,enabled,actor,system,akka,utils,create,actor,system,configuration,bind,address,0,else,actor,system,akka,utils,create,local,actor,system,configuration,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1507212387;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		ActorSystem actorSystem__		if (remoteEnabled) {_			actorSystem = AkkaUtils.createActorSystem(configuration, bindAddress, 0)__		} else {_			actorSystem = AkkaUtils.createLocalActorSystem(configuration)__		}__		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,actor,system,actor,system,if,remote,enabled,actor,system,akka,utils,create,actor,system,configuration,bind,address,0,else,actor,system,akka,utils,create,local,actor,system,configuration,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1509006142;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		ActorSystem actorSystem__		if (remoteEnabled) {_			actorSystem = AkkaUtils.createActorSystem(configuration, bindAddress, 0)__		} else {_			actorSystem = AkkaUtils.createLocalActorSystem(configuration)__		}__		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,actor,system,actor,system,if,remote,enabled,actor,system,akka,utils,create,actor,system,configuration,bind,address,0,else,actor,system,akka,utils,create,local,actor,system,configuration,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1509547920;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		ActorSystem actorSystem__		if (remoteEnabled) {_			actorSystem = AkkaUtils.createActorSystem(configuration, bindAddress, 0)__		} else {_			actorSystem = AkkaUtils.createLocalActorSystem(configuration)__		}__		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,actor,system,actor,system,if,remote,enabled,actor,system,akka,utils,create,actor,system,configuration,bind,address,0,else,actor,system,akka,utils,create,local,actor,system,configuration,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1509547921;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		ActorSystem actorSystem__		if (remoteEnabled) {_			actorSystem = AkkaUtils.createActorSystem(configuration, bindAddress, 0)__		} else {_			actorSystem = AkkaUtils.createLocalActorSystem(configuration)__		}__		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,actor,system,actor,system,if,remote,enabled,actor,system,akka,utils,create,actor,system,configuration,bind,address,0,else,actor,system,akka,utils,create,local,actor,system,configuration,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1515583830;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		ActorSystem actorSystem__		if (remoteEnabled) {_			actorSystem = AkkaUtils.createActorSystem(configuration, bindAddress, 0)__		} else {_			actorSystem = AkkaUtils.createLocalActorSystem(configuration)__		}__		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,actor,system,actor,system,if,remote,enabled,actor,system,akka,utils,create,actor,system,configuration,bind,address,0,else,actor,system,akka,utils,create,local,actor,system,configuration,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1515600854;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		ActorSystem actorSystem__		if (remoteEnabled) {_			actorSystem = AkkaUtils.createActorSystem(configuration, bindAddress, 0)__		} else {_			actorSystem = AkkaUtils.createLocalActorSystem(configuration)__		}__		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,actor,system,actor,system,if,remote,enabled,actor,system,akka,utils,create,actor,system,configuration,bind,address,0,else,actor,system,akka,utils,create,local,actor,system,configuration,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1517915730;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		ActorSystem actorSystem__		if (remoteEnabled) {_			actorSystem = AkkaUtils.createActorSystem(configuration, bindAddress, 0)__		} else {_			actorSystem = AkkaUtils.createLocalActorSystem(configuration)__		}__		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,actor,system,actor,system,if,remote,enabled,actor,system,akka,utils,create,actor,system,configuration,bind,address,0,else,actor,system,akka,utils,create,local,actor,system,configuration,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1519121818;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		ActorSystem actorSystem__		if (remoteEnabled) {_			actorSystem = AkkaUtils.createActorSystem(configuration, bindAddress, 0)__		} else {_			actorSystem = AkkaUtils.createLocalActorSystem(configuration)__		}__		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,actor,system,actor,system,if,remote,enabled,actor,system,akka,utils,create,actor,system,configuration,bind,address,0,else,actor,system,akka,utils,create,local,actor,system,configuration,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1519249745;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		ActorSystem actorSystem__		if (remoteEnabled) {_			actorSystem = AkkaUtils.createActorSystem(configuration, bindAddress, 0)__		} else {_			actorSystem = AkkaUtils.createLocalActorSystem(configuration)__		}__		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,actor,system,actor,system,if,remote,enabled,actor,system,akka,utils,create,actor,system,configuration,bind,address,0,else,actor,system,akka,utils,create,local,actor,system,configuration,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1519406526;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		ActorSystem actorSystem__		if (remoteEnabled) {_			actorSystem = AkkaUtils.createActorSystem(configuration, bindAddress, 0)__		} else {_			actorSystem = AkkaUtils.createLocalActorSystem(configuration)__		}__		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,actor,system,actor,system,if,remote,enabled,actor,system,akka,utils,create,actor,system,configuration,bind,address,0,else,actor,system,akka,utils,create,local,actor,system,configuration,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1519406527;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		ActorSystem actorSystem__		if (remoteEnabled) {_			actorSystem = AkkaUtils.createActorSystem(configuration, bindAddress, 0)__		} else {_			actorSystem = AkkaUtils.createLocalActorSystem(configuration)__		}__		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,actor,system,actor,system,if,remote,enabled,actor,system,akka,utils,create,actor,system,configuration,bind,address,0,else,actor,system,akka,utils,create,local,actor,system,configuration,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1519406529;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1519510773;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1519512293;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1519977151;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1519977152;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1519977152;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1519977155;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1520032992;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1521379500;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1521385093;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1521385094;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1521537266;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1521537266;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1521537266;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1521804758;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1522132482;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1522681180;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1522759723;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1522825170;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1525420604;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1525452496;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1526334048;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1526336566;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1529682304;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1530181266;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1530644925;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1533555608;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1538042094;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1539169204;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1539176686;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1539176687;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1539176687;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1539582211;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1539787538;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1545326469;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1547675340;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1547675341;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> protected RpcService createRpcService( 			Configuration configuration, 			Time askTimeout, 			boolean remoteEnabled, 			String bindAddress);1548249770;Factory method to instantiate the RPC service.__@param configuration_The configuration of the mini cluster_@param askTimeout_The default RPC timeout for asynchronous "ask" requests._@param remoteEnabled_True, if the RPC service should be reachable from other (remote) RPC services._@param bindAddress_The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.__@return The instantiated RPC service;protected RpcService createRpcService(_			Configuration configuration,_			Time askTimeout,_			boolean remoteEnabled,_			String bindAddress) {__		final Config akkaConfig___		if (remoteEnabled) {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration, bindAddress, 0)__		} else {_			akkaConfig = AkkaUtils.getAkkaConfig(configuration)__		}__		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig)___		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig)___		return new AkkaRpcService(actorSystem, askTimeout)__	};factory,method,to,instantiate,the,rpc,service,param,configuration,the,configuration,of,the,mini,cluster,param,ask,timeout,the,default,rpc,timeout,for,asynchronous,ask,requests,param,remote,enabled,true,if,the,rpc,service,should,be,reachable,from,other,remote,rpc,services,param,bind,address,the,address,to,bind,the,rpc,service,to,only,relevant,when,remote,enabled,is,true,return,the,instantiated,rpc,service;protected,rpc,service,create,rpc,service,configuration,configuration,time,ask,timeout,boolean,remote,enabled,string,bind,address,final,config,akka,config,if,remote,enabled,akka,config,akka,utils,get,akka,config,configuration,bind,address,0,else,akka,config,akka,utils,get,akka,config,configuration,final,config,effective,akka,config,akka,utils,test,dispatcher,config,with,fallback,akka,config,final,actor,system,actor,system,akka,utils,create,actor,system,effective,akka,config,return,new,akka,rpc,service,actor,system,ask,timeout
MiniCluster -> public void shutdown() throws Exception;1482522863;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@throws Exception Thrown, if the shutdown did not complete cleanly.;public void shutdown() throws Exception {_		synchronized (lock) {_			if (running) {_				try {_					shutdownInternally()__				} finally {_					running = false__				}_			}_		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,throws,exception,thrown,if,the,shutdown,did,not,complete,cleanly;public,void,shutdown,throws,exception,synchronized,lock,if,running,try,shutdown,internally,finally,running,false
MiniCluster -> public void shutdown() throws Exception;1482522863;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@throws Exception Thrown, if the shutdown did not complete cleanly.;public void shutdown() throws Exception {_		synchronized (lock) {_			if (running) {_				try {_					shutdownInternally()__				} finally {_					running = false__				}_			}_		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,throws,exception,thrown,if,the,shutdown,did,not,complete,cleanly;public,void,shutdown,throws,exception,synchronized,lock,if,running,try,shutdown,internally,finally,running,false
MiniCluster -> public void shutdown() throws Exception;1482522864;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@throws Exception Thrown, if the shutdown did not complete cleanly.;public void shutdown() throws Exception {_		synchronized (lock) {_			if (running) {_				try {_					shutdownInternally()__				} finally {_					running = false__				}_			}_		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,throws,exception,thrown,if,the,shutdown,did,not,complete,cleanly;public,void,shutdown,throws,exception,synchronized,lock,if,running,try,shutdown,internally,finally,running,false
MiniCluster -> public void shutdown() throws Exception;1482522864;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@throws Exception Thrown, if the shutdown did not complete cleanly.;public void shutdown() throws Exception {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					shutdownInternally()__				} finally {_					running = false__				}_				LOG.info("Flink Mini Cluster is shut down")__			}_		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,throws,exception,thrown,if,the,shutdown,did,not,complete,cleanly;public,void,shutdown,throws,exception,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,shutdown,internally,finally,running,false,log,info,flink,mini,cluster,is,shut,down
MiniCluster -> public void shutdown() throws Exception;1482522864;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@throws Exception Thrown, if the shutdown did not complete cleanly.;public void shutdown() throws Exception {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					shutdownInternally()__				} finally {_					running = false__				}_				LOG.info("Flink Mini Cluster is shut down")__			}_		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,throws,exception,thrown,if,the,shutdown,did,not,complete,cleanly;public,void,shutdown,throws,exception,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,shutdown,internally,finally,running,false,log,info,flink,mini,cluster,is,shut,down
MiniCluster -> public void shutdown() throws Exception;1482522864;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@throws Exception Thrown, if the shutdown did not complete cleanly.;public void shutdown() throws Exception {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					shutdownInternally()__				} finally {_					running = false__				}_				LOG.info("Flink Mini Cluster is shut down")__			}_		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,throws,exception,thrown,if,the,shutdown,did,not,complete,cleanly;public,void,shutdown,throws,exception,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,shutdown,internally,finally,running,false,log,info,flink,mini,cluster,is,shut,down
MiniCluster -> public void shutdown() throws Exception;1482522866;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@throws Exception Thrown, if the shutdown did not complete cleanly.;public void shutdown() throws Exception {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					shutdownInternally()__				} finally {_					running = false__				}_				LOG.info("Flink Mini Cluster is shut down")__			}_		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,throws,exception,thrown,if,the,shutdown,did,not,complete,cleanly;public,void,shutdown,throws,exception,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,shutdown,internally,finally,running,false,log,info,flink,mini,cluster,is,shut,down
MiniCluster -> public void shutdown() throws Exception;1482522866;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@throws Exception Thrown, if the shutdown did not complete cleanly.;public void shutdown() throws Exception {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					shutdownInternally()__				} finally {_					running = false__				}_				LOG.info("Flink Mini Cluster is shut down")__			}_		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,throws,exception,thrown,if,the,shutdown,did,not,complete,cleanly;public,void,shutdown,throws,exception,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,shutdown,internally,finally,running,false,log,info,flink,mini,cluster,is,shut,down
MiniCluster -> public void shutdown() throws Exception;1482522866;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@throws Exception Thrown, if the shutdown did not complete cleanly.;public void shutdown() throws Exception {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					shutdownInternally()__				} finally {_					running = false__				}_				LOG.info("Flink Mini Cluster is shut down")__			}_		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,throws,exception,thrown,if,the,shutdown,did,not,complete,cleanly;public,void,shutdown,throws,exception,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,shutdown,internally,finally,running,false,log,info,flink,mini,cluster,is,shut,down
MiniCluster -> public void shutdown() throws Exception;1482522867;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@throws Exception Thrown, if the shutdown did not complete cleanly.;public void shutdown() throws Exception {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					shutdownInternally()__				} finally {_					running = false__				}_				LOG.info("Flink Mini Cluster is shut down")__			}_		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,throws,exception,thrown,if,the,shutdown,did,not,complete,cleanly;public,void,shutdown,throws,exception,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,shutdown,internally,finally,running,false,log,info,flink,mini,cluster,is,shut,down
MiniCluster -> public void shutdown() throws Exception;1489766405;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@throws Exception Thrown, if the shutdown did not complete cleanly.;public void shutdown() throws Exception {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					shutdownInternally()__				} finally {_					running = false__				}_				LOG.info("Flink Mini Cluster is shut down")__			}_		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,throws,exception,thrown,if,the,shutdown,did,not,complete,cleanly;public,void,shutdown,throws,exception,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,shutdown,internally,finally,running,false,log,info,flink,mini,cluster,is,shut,down
MiniCluster -> public void shutdown() throws Exception;1490273924;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@throws Exception Thrown, if the shutdown did not complete cleanly.;public void shutdown() throws Exception {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					shutdownInternally()__				} finally {_					running = false__				}_				LOG.info("Flink Mini Cluster is shut down")__			}_		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,throws,exception,thrown,if,the,shutdown,did,not,complete,cleanly;public,void,shutdown,throws,exception,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,shutdown,internally,finally,running,false,log,info,flink,mini,cluster,is,shut,down
MiniCluster -> public void shutdown() throws Exception;1490273924;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@throws Exception Thrown, if the shutdown did not complete cleanly.;public void shutdown() throws Exception {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					shutdownInternally()__				} finally {_					running = false__				}_				LOG.info("Flink Mini Cluster is shut down")__			}_		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,throws,exception,thrown,if,the,shutdown,did,not,complete,cleanly;public,void,shutdown,throws,exception,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,shutdown,internally,finally,running,false,log,info,flink,mini,cluster,is,shut,down
MiniCluster -> public void shutdown() throws Exception;1493146240;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@throws Exception Thrown, if the shutdown did not complete cleanly.;public void shutdown() throws Exception {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					shutdownInternally()__				} finally {_					running = false__				}_				LOG.info("Flink Mini Cluster is shut down")__			}_		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,throws,exception,thrown,if,the,shutdown,did,not,complete,cleanly;public,void,shutdown,throws,exception,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,shutdown,internally,finally,running,false,log,info,flink,mini,cluster,is,shut,down
MiniCluster -> public void shutdown() throws Exception;1493975155;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@throws Exception Thrown, if the shutdown did not complete cleanly.;public void shutdown() throws Exception {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					shutdownInternally()__				} finally {_					running = false__				}_				LOG.info("Flink Mini Cluster is shut down")__			}_		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,throws,exception,thrown,if,the,shutdown,did,not,complete,cleanly;public,void,shutdown,throws,exception,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,shutdown,internally,finally,running,false,log,info,flink,mini,cluster,is,shut,down
MiniCluster -> public void shutdown() throws Exception;1499254138;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@throws Exception Thrown, if the shutdown did not complete cleanly.;public void shutdown() throws Exception {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					shutdownInternally()__				} finally {_					running = false__				}_				LOG.info("Flink Mini Cluster is shut down")__			}_		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,throws,exception,thrown,if,the,shutdown,did,not,complete,cleanly;public,void,shutdown,throws,exception,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,shutdown,internally,finally,running,false,log,info,flink,mini,cluster,is,shut,down
MiniCluster -> public void shutdown() throws Exception;1499789965;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@throws Exception Thrown, if the shutdown did not complete cleanly.;public void shutdown() throws Exception {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					shutdownInternally()__				} finally {_					running = false__				}_				LOG.info("Flink Mini Cluster is shut down")__			}_		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,throws,exception,thrown,if,the,shutdown,did,not,complete,cleanly;public,void,shutdown,throws,exception,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,shutdown,internally,finally,running,false,log,info,flink,mini,cluster,is,shut,down
MiniCluster -> public void shutdown() throws Exception;1501437265;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@throws Exception Thrown, if the shutdown did not complete cleanly.;public void shutdown() throws Exception {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					shutdownInternally()__				} finally {_					running = false__				}_				LOG.info("Flink Mini Cluster is shut down")__			}_		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,throws,exception,thrown,if,the,shutdown,did,not,complete,cleanly;public,void,shutdown,throws,exception,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,shutdown,internally,finally,running,false,log,info,flink,mini,cluster,is,shut,down
MiniCluster -> public void shutdown() throws Exception;1501660818;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@throws Exception Thrown, if the shutdown did not complete cleanly.;public void shutdown() throws Exception {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					shutdownInternally()__				} finally {_					running = false__				}_				LOG.info("Flink Mini Cluster is shut down")__			}_		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,throws,exception,thrown,if,the,shutdown,did,not,complete,cleanly;public,void,shutdown,throws,exception,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,shutdown,internally,finally,running,false,log,info,flink,mini,cluster,is,shut,down
MiniCluster -> public void shutdown() throws Exception;1504477043;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@throws Exception Thrown, if the shutdown did not complete cleanly.;public void shutdown() throws Exception {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					shutdownInternally()__				} finally {_					running = false__				}_				LOG.info("Flink Mini Cluster is shut down")__			}_		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,throws,exception,thrown,if,the,shutdown,did,not,complete,cleanly;public,void,shutdown,throws,exception,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,shutdown,internally,finally,running,false,log,info,flink,mini,cluster,is,shut,down
MiniCluster -> public void shutdown() throws Exception;1504525441;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@throws Exception Thrown, if the shutdown did not complete cleanly.;public void shutdown() throws Exception {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					shutdownInternally()__				} finally {_					running = false__				}_				LOG.info("Flink Mini Cluster is shut down")__			}_		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,throws,exception,thrown,if,the,shutdown,did,not,complete,cleanly;public,void,shutdown,throws,exception,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,shutdown,internally,finally,running,false,log,info,flink,mini,cluster,is,shut,down
MiniCluster -> public void shutdown() throws Exception;1504607872;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@throws Exception Thrown, if the shutdown did not complete cleanly.;public void shutdown() throws Exception {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					shutdownInternally()__				} finally {_					running = false__				}_				LOG.info("Flink Mini Cluster is shut down")__			}_		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,throws,exception,thrown,if,the,shutdown,did,not,complete,cleanly;public,void,shutdown,throws,exception,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,shutdown,internally,finally,running,false,log,info,flink,mini,cluster,is,shut,down
MiniCluster -> public void shutdown() throws Exception;1507212387;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@throws Exception Thrown, if the shutdown did not complete cleanly.;public void shutdown() throws Exception {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					shutdownInternally()__				} finally {_					running = false__				}_				LOG.info("Flink Mini Cluster is shut down")__			}_		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,throws,exception,thrown,if,the,shutdown,did,not,complete,cleanly;public,void,shutdown,throws,exception,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,shutdown,internally,finally,running,false,log,info,flink,mini,cluster,is,shut,down
MiniCluster -> public void shutdown() throws Exception;1509006142;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@throws Exception Thrown, if the shutdown did not complete cleanly.;public void shutdown() throws Exception {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					shutdownInternally()__				} finally {_					running = false__				}_				LOG.info("Flink Mini Cluster is shut down")__			}_		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,throws,exception,thrown,if,the,shutdown,did,not,complete,cleanly;public,void,shutdown,throws,exception,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,shutdown,internally,finally,running,false,log,info,flink,mini,cluster,is,shut,down
MiniCluster -> public void shutdown() throws Exception;1509547920;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@throws Exception Thrown, if the shutdown did not complete cleanly.;public void shutdown() throws Exception {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					shutdownInternally()__				} finally {_					running = false__				}_				LOG.info("Flink Mini Cluster is shut down")__			}_		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,throws,exception,thrown,if,the,shutdown,did,not,complete,cleanly;public,void,shutdown,throws,exception,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,shutdown,internally,finally,running,false,log,info,flink,mini,cluster,is,shut,down
MiniCluster -> public void shutdown() throws Exception;1509547921;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@throws Exception Thrown, if the shutdown did not complete cleanly.;public void shutdown() throws Exception {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					shutdownInternally()__				} finally {_					running = false__				}_				LOG.info("Flink Mini Cluster is shut down")__			}_		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,throws,exception,thrown,if,the,shutdown,did,not,complete,cleanly;public,void,shutdown,throws,exception,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,shutdown,internally,finally,running,false,log,info,flink,mini,cluster,is,shut,down
MiniCluster -> public void shutdown() throws Exception;1515583830;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@throws Exception Thrown, if the shutdown did not complete cleanly.;public void shutdown() throws Exception {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					shutdownInternally()__				} finally {_					running = false__				}_				LOG.info("Flink Mini Cluster is shut down")__			}_		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,throws,exception,thrown,if,the,shutdown,did,not,complete,cleanly;public,void,shutdown,throws,exception,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,shutdown,internally,finally,running,false,log,info,flink,mini,cluster,is,shut,down
MiniCluster -> public void shutdown() throws Exception;1515600854;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@throws Exception Thrown, if the shutdown did not complete cleanly.;public void shutdown() throws Exception {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					shutdownInternally()__				} finally {_					running = false__				}_				LOG.info("Flink Mini Cluster is shut down")__			}_		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,throws,exception,thrown,if,the,shutdown,did,not,complete,cleanly;public,void,shutdown,throws,exception,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,shutdown,internally,finally,running,false,log,info,flink,mini,cluster,is,shut,down
MiniCluster -> public void shutdown() throws Exception;1517915730;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@throws Exception Thrown, if the shutdown did not complete cleanly.;public void shutdown() throws Exception {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					shutdownInternally()__				} finally {_					running = false__				}_				LOG.info("Flink Mini Cluster is shut down")__			}_		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,throws,exception,thrown,if,the,shutdown,did,not,complete,cleanly;public,void,shutdown,throws,exception,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,shutdown,internally,finally,running,false,log,info,flink,mini,cluster,is,shut,down
MiniCluster -> public void shutdown() throws Exception;1519121818;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@throws Exception Thrown, if the shutdown did not complete cleanly.;public void shutdown() throws Exception {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					shutdownInternally()__				} finally {_					running = false__				}_				LOG.info("Flink Mini Cluster is shut down")__			}_		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,throws,exception,thrown,if,the,shutdown,did,not,complete,cleanly;public,void,shutdown,throws,exception,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,shutdown,internally,finally,running,false,log,info,flink,mini,cluster,is,shut,down
MiniCluster -> public void shutdown() throws Exception;1519249745;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@throws Exception Thrown, if the shutdown did not complete cleanly.;public void shutdown() throws Exception {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					shutdownInternally()__				} finally {_					running = false__				}_				LOG.info("Flink Mini Cluster is shut down")__			}_		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,throws,exception,thrown,if,the,shutdown,did,not,complete,cleanly;public,void,shutdown,throws,exception,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,shutdown,internally,finally,running,false,log,info,flink,mini,cluster,is,shut,down
MiniCluster -> public void shutdown() throws Exception;1519406526;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@throws Exception Thrown, if the shutdown did not complete cleanly.;public void shutdown() throws Exception {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					shutdownInternally()__				} finally {_					running = false__				}_				LOG.info("Flink Mini Cluster is shut down")__			}_		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,throws,exception,thrown,if,the,shutdown,did,not,complete,cleanly;public,void,shutdown,throws,exception,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,shutdown,internally,finally,running,false,log,info,flink,mini,cluster,is,shut,down
MiniCluster -> public void shutdown() throws Exception;1519406527;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@throws Exception Thrown, if the shutdown did not complete cleanly.;public void shutdown() throws Exception {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					shutdownInternally()__				} finally {_					running = false__				}_				LOG.info("Flink Mini Cluster is shut down")__			}_		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,throws,exception,thrown,if,the,shutdown,did,not,complete,cleanly;public,void,shutdown,throws,exception,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,shutdown,internally,finally,running,false,log,info,flink,mini,cluster,is,shut,down
MiniCluster -> public void shutdown() throws Exception;1519406529;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@throws Exception Thrown, if the shutdown did not complete cleanly.;public void shutdown() throws Exception {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					shutdownInternally()__				} finally {_					running = false__				}_				LOG.info("Flink Mini Cluster is shut down")__			}_		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,throws,exception,thrown,if,the,shutdown,did,not,complete,cleanly;public,void,shutdown,throws,exception,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,shutdown,internally,finally,running,false,log,info,flink,mini,cluster,is,shut,down
MiniCluster -> public void shutdown() throws Exception;1519510773;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@throws Exception Thrown, if the shutdown did not complete cleanly.;public void shutdown() throws Exception {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					shutdownInternally()__				} finally {_					running = false__				}_				LOG.info("Flink Mini Cluster is shut down")__			}_		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,throws,exception,thrown,if,the,shutdown,did,not,complete,cleanly;public,void,shutdown,throws,exception,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,shutdown,internally,finally,running,false,log,info,flink,mini,cluster,is,shut,down
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1515583830;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		MiniClusterJobDispatcher dispatcher__		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			dispatcher = this.jobDispatcher__		}__		return dispatcher.runJobBlocking(job)__	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,mini,cluster,job,dispatcher,dispatcher,synchronized,lock,check,state,running,mini,cluster,is,not,running,dispatcher,this,job,dispatcher,return,dispatcher,run,job,blocking,job
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1515600854;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		MiniClusterJobDispatcher dispatcher__		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			dispatcher = this.jobDispatcher__		}__		_		_		job.setAllowQueuedScheduling(true)___		return dispatcher.runJobBlocking(job)__	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,mini,cluster,job,dispatcher,dispatcher,synchronized,lock,check,state,running,mini,cluster,is,not,running,dispatcher,this,job,dispatcher,job,set,allow,queued,scheduling,true,return,dispatcher,run,job,blocking,job
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1517915730;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		MiniClusterJobDispatcher dispatcher__		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			dispatcher = this.jobDispatcher__		}__		_		_		job.setAllowQueuedScheduling(true)___		return dispatcher.runJobBlocking(job)__	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,mini,cluster,job,dispatcher,dispatcher,synchronized,lock,check,state,running,mini,cluster,is,not,running,dispatcher,this,job,dispatcher,job,set,allow,queued,scheduling,true,return,dispatcher,run,job,blocking,job
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1519121818;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		MiniClusterJobDispatcher dispatcher__		synchronized (lock) {_			checkState(running, "mini cluster is not running")__			dispatcher = this.jobDispatcher__		}__		_		_		job.setAllowQueuedScheduling(true)___		return dispatcher.runJobBlocking(job)__	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,mini,cluster,job,dispatcher,dispatcher,synchronized,lock,check,state,running,mini,cluster,is,not,running,dispatcher,this,job,dispatcher,job,set,allow,queued,scheduling,true,return,dispatcher,run,job,blocking,job
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1519249745;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(Acknowledge ack) -> currentDispatcherGateway.requestJobResult(job.getJobID(), RpcUtils.INF_TIMEOUT))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (JobResult.WrappedJobException e) {_			throw new JobExecutionException(job.getJobID(), e.getCause())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,final,completable,future,job,result,job,result,future,submission,future,then,compose,acknowledge,ack,current,dispatcher,gateway,request,job,result,job,get,job,id,rpc,utils,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,job,result,wrapped,job,exception,e,throw,new,job,execution,exception,job,get,job,id,e,get,cause,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1519406526;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(Acknowledge ack) -> currentDispatcherGateway.requestJobResult(job.getJobID(), RpcUtils.INF_TIMEOUT))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (JobResult.WrappedJobException e) {_			throw new JobExecutionException(job.getJobID(), e.getCause())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,final,completable,future,job,result,job,result,future,submission,future,then,compose,acknowledge,ack,current,dispatcher,gateway,request,job,result,job,get,job,id,rpc,utils,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,job,result,wrapped,job,exception,e,throw,new,job,execution,exception,job,get,job,id,e,get,cause,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1519406527;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(Acknowledge ack) -> currentDispatcherGateway.requestJobResult(job.getJobID(), RpcUtils.INF_TIMEOUT))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (JobResult.WrappedJobException e) {_			throw new JobExecutionException(job.getJobID(), e.getCause())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,final,completable,future,job,result,job,result,future,submission,future,then,compose,acknowledge,ack,current,dispatcher,gateway,request,job,result,job,get,job,id,rpc,utils,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,job,result,wrapped,job,exception,e,throw,new,job,execution,exception,job,get,job,id,e,get,cause,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1519406529;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(Acknowledge ack) -> currentDispatcherGateway.requestJobResult(job.getJobID(), RpcUtils.INF_TIMEOUT))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (JobResult.WrappedJobException e) {_			throw new JobExecutionException(job.getJobID(), e.getCause())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,final,completable,future,job,result,job,result,future,submission,future,then,compose,acknowledge,ack,current,dispatcher,gateway,request,job,result,job,get,job,id,rpc,utils,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,job,result,wrapped,job,exception,e,throw,new,job,execution,exception,job,get,job,id,e,get,cause,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1519510773;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(Acknowledge ack) -> currentDispatcherGateway.requestJobResult(job.getJobID(), RpcUtils.INF_TIMEOUT))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (JobResult.WrappedJobException e) {_			throw new JobExecutionException(job.getJobID(), e.getCause())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,final,completable,future,job,result,job,result,future,submission,future,then,compose,acknowledge,ack,current,dispatcher,gateway,request,job,result,job,get,job,id,rpc,utils,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,job,result,wrapped,job,exception,e,throw,new,job,execution,exception,job,get,job,id,e,get,cause,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1519512293;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(Acknowledge ack) -> currentDispatcherGateway.requestJobResult(job.getJobID(), RpcUtils.INF_TIMEOUT))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (JobResult.WrappedJobException e) {_			throw new JobExecutionException(job.getJobID(), e.getCause())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,final,completable,future,job,result,job,result,future,submission,future,then,compose,acknowledge,ack,current,dispatcher,gateway,request,job,result,job,get,job,id,rpc,utils,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,job,result,wrapped,job,exception,e,throw,new,job,execution,exception,job,get,job,id,e,get,cause,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1519977151;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(Acknowledge ack) -> currentDispatcherGateway.requestJobResult(job.getJobID(), RpcUtils.INF_TIMEOUT))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (JobResult.WrappedJobException e) {_			throw new JobExecutionException(job.getJobID(), e.getCause())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,final,completable,future,job,result,job,result,future,submission,future,then,compose,acknowledge,ack,current,dispatcher,gateway,request,job,result,job,get,job,id,rpc,utils,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,job,result,wrapped,job,exception,e,throw,new,job,execution,exception,job,get,job,id,e,get,cause,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1519977152;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(Acknowledge ack) -> currentDispatcherGateway.requestJobResult(job.getJobID(), RpcUtils.INF_TIMEOUT))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (JobResult.WrappedJobException e) {_			throw new JobExecutionException(job.getJobID(), e.getCause())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,final,completable,future,job,result,job,result,future,submission,future,then,compose,acknowledge,ack,current,dispatcher,gateway,request,job,result,job,get,job,id,rpc,utils,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,job,result,wrapped,job,exception,e,throw,new,job,execution,exception,job,get,job,id,e,get,cause,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1519977152;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(Acknowledge ack) -> currentDispatcherGateway.requestJobResult(job.getJobID(), RpcUtils.INF_TIMEOUT))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (JobResult.WrappedJobException e) {_			throw new JobExecutionException(job.getJobID(), e.getCause())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,final,completable,future,job,result,job,result,future,submission,future,then,compose,acknowledge,ack,current,dispatcher,gateway,request,job,result,job,get,job,id,rpc,utils,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,job,result,wrapped,job,exception,e,throw,new,job,execution,exception,job,get,job,id,e,get,cause,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1519977155;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(Acknowledge ack) -> currentDispatcherGateway.requestJobResult(job.getJobID(), RpcUtils.INF_TIMEOUT))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (JobResult.WrappedJobException e) {_			throw new JobExecutionException(job.getJobID(), e.getCause())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,final,completable,future,job,result,job,result,future,submission,future,then,compose,acknowledge,ack,current,dispatcher,gateway,request,job,result,job,get,job,id,rpc,utils,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,job,result,wrapped,job,exception,e,throw,new,job,execution,exception,job,get,job,id,e,get,cause,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1520032992;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(Acknowledge ack) -> currentDispatcherGateway.requestJobResult(job.getJobID(), RpcUtils.INF_TIMEOUT))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (JobResult.WrappedJobException e) {_			throw new JobExecutionException(job.getJobID(), e.getCause())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,final,completable,future,job,result,job,result,future,submission,future,then,compose,acknowledge,ack,current,dispatcher,gateway,request,job,result,job,get,job,id,rpc,utils,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,job,result,wrapped,job,exception,e,throw,new,job,execution,exception,job,get,job,id,e,get,cause,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1521379500;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(Acknowledge ack) -> currentDispatcherGateway.requestJobResult(job.getJobID(), RpcUtils.INF_TIMEOUT))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (JobResult.WrappedJobException e) {_			throw new JobExecutionException(job.getJobID(), e.getCause())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,final,completable,future,job,result,job,result,future,submission,future,then,compose,acknowledge,ack,current,dispatcher,gateway,request,job,result,job,get,job,id,rpc,utils,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,job,result,wrapped,job,exception,e,throw,new,job,execution,exception,job,get,job,id,e,get,cause,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1521385093;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(Acknowledge ack) -> currentDispatcherGateway.requestJobResult(job.getJobID(), RpcUtils.INF_TIMEOUT))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (JobResult.WrappedJobException e) {_			throw new JobExecutionException(job.getJobID(), e.getCause())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,final,completable,future,job,result,job,result,future,submission,future,then,compose,acknowledge,ack,current,dispatcher,gateway,request,job,result,job,get,job,id,rpc,utils,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,job,result,wrapped,job,exception,e,throw,new,job,execution,exception,job,get,job,id,e,get,cause,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1521385094;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(Acknowledge ack) -> currentDispatcherGateway.requestJobResult(job.getJobID(), RpcUtils.INF_TIMEOUT))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (JobResult.WrappedJobException e) {_			throw new JobExecutionException(job.getJobID(), e.getCause())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,final,completable,future,job,result,job,result,future,submission,future,then,compose,acknowledge,ack,current,dispatcher,gateway,request,job,result,job,get,job,id,rpc,utils,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,job,result,wrapped,job,exception,e,throw,new,job,execution,exception,job,get,job,id,e,get,cause,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1521537266;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(Acknowledge ack) -> currentDispatcherGateway.requestJobResult(job.getJobID(), RpcUtils.INF_TIMEOUT))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (JobResult.WrappedJobException e) {_			throw new JobExecutionException(job.getJobID(), e.getCause())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,final,completable,future,job,result,job,result,future,submission,future,then,compose,acknowledge,ack,current,dispatcher,gateway,request,job,result,job,get,job,id,rpc,utils,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,job,result,wrapped,job,exception,e,throw,new,job,execution,exception,job,get,job,id,e,get,cause,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1521537266;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(Acknowledge ack) -> currentDispatcherGateway.requestJobResult(job.getJobID(), RpcUtils.INF_TIMEOUT))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (JobResult.WrappedJobException e) {_			throw new JobExecutionException(job.getJobID(), e.getCause())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,final,completable,future,job,result,job,result,future,submission,future,then,compose,acknowledge,ack,current,dispatcher,gateway,request,job,result,job,get,job,id,rpc,utils,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,job,result,wrapped,job,exception,e,throw,new,job,execution,exception,job,get,job,id,e,get,cause,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1521537266;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(Acknowledge ack) -> currentDispatcherGateway.requestJobResult(job.getJobID(), RpcUtils.INF_TIMEOUT))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (JobResult.WrappedJobException e) {_			throw new JobExecutionException(job.getJobID(), e.getCause())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,final,completable,future,job,result,job,result,future,submission,future,then,compose,acknowledge,ack,current,dispatcher,gateway,request,job,result,job,get,job,id,rpc,utils,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,job,result,wrapped,job,exception,e,throw,new,job,execution,exception,job,get,job,id,e,get,cause,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1521804758;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(Acknowledge ack) -> currentDispatcherGateway.requestJobResult(job.getJobID(), RpcUtils.INF_TIMEOUT))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (JobResult.WrappedJobException e) {_			throw new JobExecutionException(job.getJobID(), e.getCause())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,final,completable,future,job,result,job,result,future,submission,future,then,compose,acknowledge,ack,current,dispatcher,gateway,request,job,result,job,get,job,id,rpc,utils,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,job,result,wrapped,job,exception,e,throw,new,job,execution,exception,job,get,job,id,e,get,cause,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1522132482;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(Acknowledge ack) -> currentDispatcherGateway.requestJobResult(job.getJobID(), RpcUtils.INF_TIMEOUT))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (JobResult.WrappedJobException e) {_			throw new JobExecutionException(job.getJobID(), e.getCause())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,final,completable,future,job,result,job,result,future,submission,future,then,compose,acknowledge,ack,current,dispatcher,gateway,request,job,result,job,get,job,id,rpc,utils,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,job,result,wrapped,job,exception,e,throw,new,job,execution,exception,job,get,job,id,e,get,cause,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1522681180;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final DispatcherGateway currentDispatcherGateway__		try {_			currentDispatcherGateway = getDispatcherGateway()__		} catch (LeaderRetrievalException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}__		_		_		job.setAllowQueuedScheduling(true)___		final CompletableFuture<Acknowledge> submissionFuture = currentDispatcherGateway.submitJob(job, rpcTimeout)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(Acknowledge ack) -> currentDispatcherGateway.requestJobResult(job.getJobID(), RpcUtils.INF_TIMEOUT))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (JobResult.WrappedJobException e) {_			throw new JobExecutionException(job.getJobID(), e.getCause())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,dispatcher,gateway,current,dispatcher,gateway,try,current,dispatcher,gateway,get,dispatcher,gateway,catch,leader,retrieval,exception,e,throw,new,job,execution,exception,job,get,job,id,e,job,set,allow,queued,scheduling,true,final,completable,future,acknowledge,submission,future,current,dispatcher,gateway,submit,job,job,rpc,timeout,final,completable,future,job,result,job,result,future,submission,future,then,compose,acknowledge,ack,current,dispatcher,gateway,request,job,result,job,get,job,id,rpc,utils,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,job,result,wrapped,job,exception,e,throw,new,job,execution,exception,job,get,job,id,e,get,cause,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1522759723;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (JobResult.WrappedJobException e) {_			throw new JobExecutionException(job.getJobID(), e.getCause())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,job,result,wrapped,job,exception,e,throw,new,job,execution,exception,job,get,job,id,e,get,cause,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1522825170;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (JobResult.WrappedJobException e) {_			throw new JobExecutionException(job.getJobID(), e.getCause())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,job,result,wrapped,job,exception,e,throw,new,job,execution,exception,job,get,job,id,e,get,cause,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1525420604;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		uploadUserArtifacts(job)__		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (JobResult.WrappedJobException e) {_			throw new JobExecutionException(job.getJobID(), e.getCause())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,upload,user,artifacts,job,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,job,result,wrapped,job,exception,e,throw,new,job,execution,exception,job,get,job,id,e,get,cause,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1525452496;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		uploadUserArtifacts(job)__		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (JobResult.WrappedJobException e) {_			throw new JobExecutionException(job.getJobID(), e.getCause())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,upload,user,artifacts,job,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,job,result,wrapped,job,exception,e,throw,new,job,execution,exception,job,get,job,id,e,get,cause,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1526334048;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		uploadUserArtifacts(job)__		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (JobResult.WrappedJobException e) {_			throw new JobExecutionException(job.getJobID(), e.getCause())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,upload,user,artifacts,job,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,job,result,wrapped,job,exception,e,throw,new,job,execution,exception,job,get,job,id,e,get,cause,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1526336566;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		uploadUserArtifacts(job)__		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (JobResult.WrappedJobException e) {_			throw new JobExecutionException(job.getJobID(), e.getCause())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,upload,user,artifacts,job,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,job,result,wrapped,job,exception,e,throw,new,job,execution,exception,job,get,job,id,e,get,cause,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1529682304;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		uploadUserArtifacts(job)__		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (JobResult.WrappedJobException e) {_			throw new JobExecutionException(job.getJobID(), e.getCause())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,upload,user,artifacts,job,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,job,result,wrapped,job,exception,e,throw,new,job,execution,exception,job,get,job,id,e,get,cause,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1530181266;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (JobResult.WrappedJobException e) {_			throw new JobExecutionException(job.getJobID(), e.getCause())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,job,result,wrapped,job,exception,e,throw,new,job,execution,exception,job,get,job,id,e,get,cause,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1530644925;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (JobResult.WrappedJobException e) {_			throw new JobExecutionException(job.getJobID(), e.getCause())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,job,result,wrapped,job,exception,e,throw,new,job,execution,exception,job,get,job,id,e,get,cause,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1533555608;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (JobResult.WrappedJobException e) {_			throw new JobExecutionException(job.getJobID(), e.getCause())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,job,result,wrapped,job,exception,e,throw,new,job,execution,exception,job,get,job,id,e,get,cause,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1538042094;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1539169204;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1539176686;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1539176687;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1539176687;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1539582211;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1539787538;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1545326469;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1547675340;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1547675341;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1548249770;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1548326020;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1548846699;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1548866156;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1548966387;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1549360057;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1549360057;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1549360057;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1549360057;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1549360057;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1549360058;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1550005040;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1550069788;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1550228244;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1550483152;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException;1550823915;This method runs a job in blocking mode. The method returns only after the job_completed successfully, or after it failed terminally.__@param job  The Flink job to execute_@return The result of the job execution__@throws JobExecutionException Thrown if anything went amiss during initial job launch,_or if the job terminally failed.;@Override_	public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {_		checkNotNull(job, "job is null")___		final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job)___		final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose(_			(JobSubmissionResult ignored) -> requestJobResult(job.getJobID()))___		final JobResult jobResult___		try {_			jobResult = jobResultFuture.get()__		} catch (ExecutionException e) {_			throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e))__		}__		try {_			return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader())__		} catch (IOException | ClassNotFoundException e) {_			throw new JobExecutionException(job.getJobID(), e)__		}_	};this,method,runs,a,job,in,blocking,mode,the,method,returns,only,after,the,job,completed,successfully,or,after,it,failed,terminally,param,job,the,flink,job,to,execute,return,the,result,of,the,job,execution,throws,job,execution,exception,thrown,if,anything,went,amiss,during,initial,job,launch,or,if,the,job,terminally,failed;override,public,job,execution,result,execute,job,blocking,job,graph,job,throws,job,execution,exception,interrupted,exception,check,not,null,job,job,is,null,final,completable,future,job,submission,result,submission,future,submit,job,job,final,completable,future,job,result,job,result,future,submission,future,then,compose,job,submission,result,ignored,request,job,result,job,get,job,id,final,job,result,job,result,try,job,result,job,result,future,get,catch,execution,exception,e,throw,new,job,execution,exception,job,get,job,id,could,not,retrieve,job,result,exception,utils,strip,execution,exception,e,try,return,job,result,to,job,execution,result,thread,current,thread,get,context,class,loader,catch,ioexception,class,not,found,exception,e,throw,new,job,execution,exception,job,get,job,id,e
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1519512293;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricRegistryTerminationFuture = FutureUtils.runAfterwards(_						componentsTerminationFuture,_						() -> {_							synchronized (lock) {_								_								if (metricRegistry != null) {_									metricRegistry.shutdown()__									metricRegistry = null__								}_							}_						})___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricRegistryTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,registry,termination,future,future,utils,run,afterwards,components,termination,future,synchronized,lock,if,metric,registry,null,metric,registry,shutdown,metric,registry,null,final,completable,future,void,rpc,services,termination,future,metric,registry,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1519977151;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricRegistryTerminationFuture = FutureUtils.runAfterwards(_						componentsTerminationFuture,_						() -> {_							synchronized (lock) {_								_								if (metricRegistry != null) {_									metricRegistry.shutdown()__									metricRegistry = null__								}_							}_						})___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricRegistryTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,registry,termination,future,future,utils,run,afterwards,components,termination,future,synchronized,lock,if,metric,registry,null,metric,registry,shutdown,metric,registry,null,final,completable,future,void,rpc,services,termination,future,metric,registry,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1519977152;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricRegistryTerminationFuture = FutureUtils.runAfterwards(_						componentsTerminationFuture,_						() -> {_							synchronized (lock) {_								_								if (metricRegistry != null) {_									metricRegistry.shutdown()__									metricRegistry = null__								}_							}_						})___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricRegistryTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,registry,termination,future,future,utils,run,afterwards,components,termination,future,synchronized,lock,if,metric,registry,null,metric,registry,shutdown,metric,registry,null,final,completable,future,void,rpc,services,termination,future,metric,registry,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1519977152;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricRegistryTerminationFuture = FutureUtils.runAfterwards(_						componentsTerminationFuture,_						() -> {_							synchronized (lock) {_								_								if (metricRegistry != null) {_									metricRegistry.shutdown()__									metricRegistry = null__								}_							}_						})___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricRegistryTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,registry,termination,future,future,utils,run,afterwards,components,termination,future,synchronized,lock,if,metric,registry,null,metric,registry,shutdown,metric,registry,null,final,completable,future,void,rpc,services,termination,future,metric,registry,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1519977155;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricRegistryTerminationFuture = FutureUtils.runAfterwards(_						componentsTerminationFuture,_						() -> {_							synchronized (lock) {_								_								if (metricRegistry != null) {_									metricRegistry.shutdown()__									metricRegistry = null__								}_							}_						})___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricRegistryTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,registry,termination,future,future,utils,run,afterwards,components,termination,future,synchronized,lock,if,metric,registry,null,metric,registry,shutdown,metric,registry,null,final,completable,future,void,rpc,services,termination,future,metric,registry,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1520032992;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricRegistryTerminationFuture = FutureUtils.runAfterwards(_						componentsTerminationFuture,_						() -> {_							synchronized (lock) {_								_								if (metricRegistry != null) {_									metricRegistry.shutdown()__									metricRegistry = null__								}_							}_						})___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricRegistryTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,registry,termination,future,future,utils,run,afterwards,components,termination,future,synchronized,lock,if,metric,registry,null,metric,registry,shutdown,metric,registry,null,final,completable,future,void,rpc,services,termination,future,metric,registry,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1521379500;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricRegistryTerminationFuture = FutureUtils.runAfterwards(_						componentsTerminationFuture,_						() -> {_							synchronized (lock) {_								if (jobManagerMetricGroup != null) {_									jobManagerMetricGroup.close()__									jobManagerMetricGroup = null__								}_								_								if (metricRegistry != null) {_									metricRegistry.shutdown()__									metricRegistry = null__								}_							}_						})___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricRegistryTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,registry,termination,future,future,utils,run,afterwards,components,termination,future,synchronized,lock,if,job,manager,metric,group,null,job,manager,metric,group,close,job,manager,metric,group,null,if,metric,registry,null,metric,registry,shutdown,metric,registry,null,final,completable,future,void,rpc,services,termination,future,metric,registry,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1521385093;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricRegistryTerminationFuture = FutureUtils.runAfterwards(_						componentsTerminationFuture,_						() -> {_							synchronized (lock) {_								if (jobManagerMetricGroup != null) {_									jobManagerMetricGroup.close()__									jobManagerMetricGroup = null__								}_								_								if (metricRegistry != null) {_									metricRegistry.shutdown()__									metricRegistry = null__								}_							}_						})___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricRegistryTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,registry,termination,future,future,utils,run,afterwards,components,termination,future,synchronized,lock,if,job,manager,metric,group,null,job,manager,metric,group,close,job,manager,metric,group,null,if,metric,registry,null,metric,registry,shutdown,metric,registry,null,final,completable,future,void,rpc,services,termination,future,metric,registry,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1521385094;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricRegistryTerminationFuture = FutureUtils.runAfterwards(_						componentsTerminationFuture,_						() -> {_							synchronized (lock) {_								if (jobManagerMetricGroup != null) {_									jobManagerMetricGroup.close()__									jobManagerMetricGroup = null__								}_								_								if (metricRegistry != null) {_									metricRegistry.shutdown()__									metricRegistry = null__								}_							}_						})___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricRegistryTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,registry,termination,future,future,utils,run,afterwards,components,termination,future,synchronized,lock,if,job,manager,metric,group,null,job,manager,metric,group,close,job,manager,metric,group,null,if,metric,registry,null,metric,registry,shutdown,metric,registry,null,final,completable,future,void,rpc,services,termination,future,metric,registry,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1521537266;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricRegistryTerminationFuture = FutureUtils.runAfterwards(_						componentsTerminationFuture,_						() -> {_							synchronized (lock) {_								if (jobManagerMetricGroup != null) {_									jobManagerMetricGroup.close()__									jobManagerMetricGroup = null__								}_								_								if (metricRegistry != null) {_									metricRegistry.shutdown()__									metricRegistry = null__								}_							}_						})___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricRegistryTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,registry,termination,future,future,utils,run,afterwards,components,termination,future,synchronized,lock,if,job,manager,metric,group,null,job,manager,metric,group,close,job,manager,metric,group,null,if,metric,registry,null,metric,registry,shutdown,metric,registry,null,final,completable,future,void,rpc,services,termination,future,metric,registry,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1521537266;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricRegistryTerminationFuture = FutureUtils.runAfterwards(_						componentsTerminationFuture,_						() -> {_							synchronized (lock) {_								if (jobManagerMetricGroup != null) {_									jobManagerMetricGroup.close()__									jobManagerMetricGroup = null__								}_								_								if (metricRegistry != null) {_									metricRegistry.shutdown()__									metricRegistry = null__								}_							}_						})___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricRegistryTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,registry,termination,future,future,utils,run,afterwards,components,termination,future,synchronized,lock,if,job,manager,metric,group,null,job,manager,metric,group,close,job,manager,metric,group,null,if,metric,registry,null,metric,registry,shutdown,metric,registry,null,final,completable,future,void,rpc,services,termination,future,metric,registry,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1521537266;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricRegistryTerminationFuture = FutureUtils.runAfterwards(_						componentsTerminationFuture,_						() -> {_							synchronized (lock) {_								if (jobManagerMetricGroup != null) {_									jobManagerMetricGroup.close()__									jobManagerMetricGroup = null__								}_								_								if (metricRegistry != null) {_									metricRegistry.shutdown()__									metricRegistry = null__								}_							}_						})___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricRegistryTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,registry,termination,future,future,utils,run,afterwards,components,termination,future,synchronized,lock,if,job,manager,metric,group,null,job,manager,metric,group,close,job,manager,metric,group,null,if,metric,registry,null,metric,registry,shutdown,metric,registry,null,final,completable,future,void,rpc,services,termination,future,metric,registry,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1521804758;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricRegistryTerminationFuture = FutureUtils.runAfterwards(_						componentsTerminationFuture,_						() -> {_							synchronized (lock) {_								if (jobManagerMetricGroup != null) {_									jobManagerMetricGroup.close()__									jobManagerMetricGroup = null__								}_								_								if (metricRegistry != null) {_									metricRegistry.shutdown()__									metricRegistry = null__								}_							}_						})___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricRegistryTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,registry,termination,future,future,utils,run,afterwards,components,termination,future,synchronized,lock,if,job,manager,metric,group,null,job,manager,metric,group,close,job,manager,metric,group,null,if,metric,registry,null,metric,registry,shutdown,metric,registry,null,final,completable,future,void,rpc,services,termination,future,metric,registry,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1522132482;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricRegistryTerminationFuture = FutureUtils.runAfterwards(_						componentsTerminationFuture,_						() -> {_							synchronized (lock) {_								if (jobManagerMetricGroup != null) {_									jobManagerMetricGroup.close()__									jobManagerMetricGroup = null__								}_								_								if (metricRegistry != null) {_									metricRegistry.shutdown()__									metricRegistry = null__								}_							}_						})___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricRegistryTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,registry,termination,future,future,utils,run,afterwards,components,termination,future,synchronized,lock,if,job,manager,metric,group,null,job,manager,metric,group,close,job,manager,metric,group,null,if,metric,registry,null,metric,registry,shutdown,metric,registry,null,final,completable,future,void,rpc,services,termination,future,metric,registry,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1522681180;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricRegistryTerminationFuture = FutureUtils.runAfterwards(_						componentsTerminationFuture,_						() -> {_							synchronized (lock) {_								if (jobManagerMetricGroup != null) {_									jobManagerMetricGroup.close()__									jobManagerMetricGroup = null__								}_								_								if (metricRegistry != null) {_									metricRegistry.shutdown()__									metricRegistry = null__								}_							}_						})___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricRegistryTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,registry,termination,future,future,utils,run,afterwards,components,termination,future,synchronized,lock,if,job,manager,metric,group,null,job,manager,metric,group,close,job,manager,metric,group,null,if,metric,registry,null,metric,registry,shutdown,metric,registry,null,final,completable,future,void,rpc,services,termination,future,metric,registry,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1522759723;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricRegistryTerminationFuture = FutureUtils.runAfterwards(_						componentsTerminationFuture,_						() -> {_							synchronized (lock) {_								if (jobManagerMetricGroup != null) {_									jobManagerMetricGroup.close()__									jobManagerMetricGroup = null__								}_								_								if (metricRegistry != null) {_									metricRegistry.shutdown()__									metricRegistry = null__								}_							}_						})___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricRegistryTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,registry,termination,future,future,utils,run,afterwards,components,termination,future,synchronized,lock,if,job,manager,metric,group,null,job,manager,metric,group,close,job,manager,metric,group,null,if,metric,registry,null,metric,registry,shutdown,metric,registry,null,final,completable,future,void,rpc,services,termination,future,metric,registry,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1522825170;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricRegistryTerminationFuture = FutureUtils.runAfterwards(_						componentsTerminationFuture,_						() -> {_							synchronized (lock) {_								if (jobManagerMetricGroup != null) {_									jobManagerMetricGroup.close()__									jobManagerMetricGroup = null__								}_								_								if (metricRegistry != null) {_									metricRegistry.shutdown()__									metricRegistry = null__								}_							}_						})___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricRegistryTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,registry,termination,future,future,utils,run,afterwards,components,termination,future,synchronized,lock,if,job,manager,metric,group,null,job,manager,metric,group,close,job,manager,metric,group,null,if,metric,registry,null,metric,registry,shutdown,metric,registry,null,final,completable,future,void,rpc,services,termination,future,metric,registry,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1525420604;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricRegistryTerminationFuture = FutureUtils.runAfterwards(_						componentsTerminationFuture,_						() -> {_							synchronized (lock) {_								if (jobManagerMetricGroup != null) {_									jobManagerMetricGroup.close()__									jobManagerMetricGroup = null__								}_								_								if (metricRegistry != null) {_									metricRegistry.shutdown()__									metricRegistry = null__								}_							}_						})___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricRegistryTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,registry,termination,future,future,utils,run,afterwards,components,termination,future,synchronized,lock,if,job,manager,metric,group,null,job,manager,metric,group,close,job,manager,metric,group,null,if,metric,registry,null,metric,registry,shutdown,metric,registry,null,final,completable,future,void,rpc,services,termination,future,metric,registry,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1525452496;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricRegistryTerminationFuture = FutureUtils.runAfterwards(_						componentsTerminationFuture,_						() -> {_							synchronized (lock) {_								if (jobManagerMetricGroup != null) {_									jobManagerMetricGroup.close()__									jobManagerMetricGroup = null__								}_								_								if (metricRegistry != null) {_									metricRegistry.shutdown()__									metricRegistry = null__								}_							}_						})___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricRegistryTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,registry,termination,future,future,utils,run,afterwards,components,termination,future,synchronized,lock,if,job,manager,metric,group,null,job,manager,metric,group,close,job,manager,metric,group,null,if,metric,registry,null,metric,registry,shutdown,metric,registry,null,final,completable,future,void,rpc,services,termination,future,metric,registry,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1526334048;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricRegistryTerminationFuture = FutureUtils.runAfterwards(_						componentsTerminationFuture,_						() -> {_							synchronized (lock) {_								if (jobManagerMetricGroup != null) {_									jobManagerMetricGroup.close()__									jobManagerMetricGroup = null__								}_								_								if (metricRegistry != null) {_									metricRegistry.shutdown()__									metricRegistry = null__								}_							}_						})___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricRegistryTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,registry,termination,future,future,utils,run,afterwards,components,termination,future,synchronized,lock,if,job,manager,metric,group,null,job,manager,metric,group,close,job,manager,metric,group,null,if,metric,registry,null,metric,registry,shutdown,metric,registry,null,final,completable,future,void,rpc,services,termination,future,metric,registry,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1526336566;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricRegistryTerminationFuture = FutureUtils.runAfterwards(_						componentsTerminationFuture,_						() -> {_							synchronized (lock) {_								if (jobManagerMetricGroup != null) {_									jobManagerMetricGroup.close()__									jobManagerMetricGroup = null__								}_								_								if (metricRegistry != null) {_									metricRegistry.shutdown()__									metricRegistry = null__								}_							}_						})___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricRegistryTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,registry,termination,future,future,utils,run,afterwards,components,termination,future,synchronized,lock,if,job,manager,metric,group,null,job,manager,metric,group,close,job,manager,metric,group,null,if,metric,registry,null,metric,registry,shutdown,metric,registry,null,final,completable,future,void,rpc,services,termination,future,metric,registry,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1529682304;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricRegistryTerminationFuture = FutureUtils.runAfterwards(_						componentsTerminationFuture,_						() -> {_							synchronized (lock) {_								if (jobManagerMetricGroup != null) {_									jobManagerMetricGroup.close()__									jobManagerMetricGroup = null__								}_								_								if (metricRegistry != null) {_									metricRegistry.shutdown()__									metricRegistry = null__								}_							}_						})___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricRegistryTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,registry,termination,future,future,utils,run,afterwards,components,termination,future,synchronized,lock,if,job,manager,metric,group,null,job,manager,metric,group,close,job,manager,metric,group,null,if,metric,registry,null,metric,registry,shutdown,metric,registry,null,final,completable,future,void,rpc,services,termination,future,metric,registry,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1530181266;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricRegistryTerminationFuture = FutureUtils.runAfterwards(_						componentsTerminationFuture,_						() -> {_							synchronized (lock) {_								if (jobManagerMetricGroup != null) {_									jobManagerMetricGroup.close()__									jobManagerMetricGroup = null__								}_								_								if (metricRegistry != null) {_									metricRegistry.shutdown()__									metricRegistry = null__								}_							}_						})___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricRegistryTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,registry,termination,future,future,utils,run,afterwards,components,termination,future,synchronized,lock,if,job,manager,metric,group,null,job,manager,metric,group,close,job,manager,metric,group,null,if,metric,registry,null,metric,registry,shutdown,metric,registry,null,final,completable,future,void,rpc,services,termination,future,metric,registry,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1530644925;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricRegistryTerminationFuture = FutureUtils.runAfterwards(_						componentsTerminationFuture,_						() -> {_							synchronized (lock) {_								if (jobManagerMetricGroup != null) {_									jobManagerMetricGroup.close()__									jobManagerMetricGroup = null__								}_								_								if (metricRegistry != null) {_									metricRegistry.shutdown()__									metricRegistry = null__								}_							}_						})___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricRegistryTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,registry,termination,future,future,utils,run,afterwards,components,termination,future,synchronized,lock,if,job,manager,metric,group,null,job,manager,metric,group,close,job,manager,metric,group,null,if,metric,registry,null,metric,registry,shutdown,metric,registry,null,final,completable,future,void,rpc,services,termination,future,metric,registry,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1533555608;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricRegistryTerminationFuture = FutureUtils.runAfterwards(_						componentsTerminationFuture,_						() -> {_							synchronized (lock) {_								if (jobManagerMetricGroup != null) {_									jobManagerMetricGroup.close()__									jobManagerMetricGroup = null__								}_								_								if (metricRegistry != null) {_									metricRegistry.shutdown()__									metricRegistry = null__								}_							}_						})___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricRegistryTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,registry,termination,future,future,utils,run,afterwards,components,termination,future,synchronized,lock,if,job,manager,metric,group,null,job,manager,metric,group,close,job,manager,metric,group,null,if,metric,registry,null,metric,registry,shutdown,metric,registry,null,final,completable,future,void,rpc,services,termination,future,metric,registry,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1538042094;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricRegistryTerminationFuture = FutureUtils.runAfterwards(_						componentsTerminationFuture,_						() -> {_							synchronized (lock) {_								if (jobManagerMetricGroup != null) {_									jobManagerMetricGroup.close()__									jobManagerMetricGroup = null__								}_								_								if (metricRegistry != null) {_									metricRegistry.shutdown()__									metricRegistry = null__								}_							}_						})___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricRegistryTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,registry,termination,future,future,utils,run,afterwards,components,termination,future,synchronized,lock,if,job,manager,metric,group,null,job,manager,metric,group,close,job,manager,metric,group,null,if,metric,registry,null,metric,registry,shutdown,metric,registry,null,final,completable,future,void,rpc,services,termination,future,metric,registry,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1539169204;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricRegistryTerminationFuture = FutureUtils.runAfterwards(_						componentsTerminationFuture,_						() -> {_							synchronized (lock) {_								if (jobManagerMetricGroup != null) {_									jobManagerMetricGroup.close()__									jobManagerMetricGroup = null__								}_								_								if (metricRegistry != null) {_									metricRegistry.shutdown()__									metricRegistry = null__								}_							}_						})___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricRegistryTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,registry,termination,future,future,utils,run,afterwards,components,termination,future,synchronized,lock,if,job,manager,metric,group,null,job,manager,metric,group,close,job,manager,metric,group,null,if,metric,registry,null,metric,registry,shutdown,metric,registry,null,final,completable,future,void,rpc,services,termination,future,metric,registry,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1539176686;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricSystemTerminationFuture = FutureUtils.composeAfterwards(_						componentsTerminationFuture,_						this::closeMetricSystem)___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricSystemTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,system,termination,future,future,utils,compose,afterwards,components,termination,future,this,close,metric,system,final,completable,future,void,rpc,services,termination,future,metric,system,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1539176687;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricSystemTerminationFuture = FutureUtils.composeAfterwards(_						componentsTerminationFuture,_						this::closeMetricSystem)___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricSystemTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,system,termination,future,future,utils,compose,afterwards,components,termination,future,this,close,metric,system,final,completable,future,void,rpc,services,termination,future,metric,system,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1539176687;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricSystemTerminationFuture = FutureUtils.composeAfterwards(_						componentsTerminationFuture,_						this::closeMetricSystem)___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricSystemTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,system,termination,future,future,utils,compose,afterwards,components,termination,future,this,close,metric,system,final,completable,future,void,rpc,services,termination,future,metric,system,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1539582211;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricSystemTerminationFuture = FutureUtils.composeAfterwards(_						componentsTerminationFuture,_						this::closeMetricSystem)___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricSystemTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,system,termination,future,future,utils,compose,afterwards,components,termination,future,this,close,metric,system,final,completable,future,void,rpc,services,termination,future,metric,system,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1539787538;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricSystemTerminationFuture = FutureUtils.composeAfterwards(_						componentsTerminationFuture,_						this::closeMetricSystem)___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricSystemTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,system,termination,future,future,utils,compose,afterwards,components,termination,future,this,close,metric,system,final,completable,future,void,rpc,services,termination,future,metric,system,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1545326469;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricSystemTerminationFuture = FutureUtils.composeAfterwards(_						componentsTerminationFuture,_						this::closeMetricSystem)___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricSystemTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,system,termination,future,future,utils,compose,afterwards,components,termination,future,this,close,metric,system,final,completable,future,void,rpc,services,termination,future,metric,system,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1547675340;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricSystemTerminationFuture = FutureUtils.composeAfterwards(_						componentsTerminationFuture,_						this::closeMetricSystem)___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricSystemTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,system,termination,future,future,utils,compose,afterwards,components,termination,future,this,close,metric,system,final,completable,future,void,rpc,services,termination,future,metric,system,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1547675341;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricSystemTerminationFuture = FutureUtils.composeAfterwards(_						componentsTerminationFuture,_						this::closeMetricSystem)___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricSystemTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,system,termination,future,future,utils,compose,afterwards,components,termination,future,this,close,metric,system,final,completable,future,void,rpc,services,termination,future,metric,system,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1548249770;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricSystemTerminationFuture = FutureUtils.composeAfterwards(_						componentsTerminationFuture,_						this::closeMetricSystem)___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricSystemTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,system,termination,future,future,utils,compose,afterwards,components,termination,future,this,close,metric,system,final,completable,future,void,rpc,services,termination,future,metric,system,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1548326020;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricSystemTerminationFuture = FutureUtils.composeAfterwards(_						componentsTerminationFuture,_						this::closeMetricSystem)___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricSystemTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,system,termination,future,future,utils,compose,afterwards,components,termination,future,this,close,metric,system,final,completable,future,void,rpc,services,termination,future,metric,system,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1548846699;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricSystemTerminationFuture = FutureUtils.composeAfterwards(_						componentsTerminationFuture,_						this::closeMetricSystem)___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricSystemTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,system,termination,future,future,utils,compose,afterwards,components,termination,future,this,close,metric,system,final,completable,future,void,rpc,services,termination,future,metric,system,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1548866156;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricSystemTerminationFuture = FutureUtils.composeAfterwards(_						componentsTerminationFuture,_						this::closeMetricSystem)___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricSystemTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,system,termination,future,future,utils,compose,afterwards,components,termination,future,this,close,metric,system,final,completable,future,void,rpc,services,termination,future,metric,system,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1548966387;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricSystemTerminationFuture = FutureUtils.composeAfterwards(_						componentsTerminationFuture,_						this::closeMetricSystem)___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricSystemTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,system,termination,future,future,utils,compose,afterwards,components,termination,future,this,close,metric,system,final,completable,future,void,rpc,services,termination,future,metric,system,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1549360057;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricSystemTerminationFuture = FutureUtils.composeAfterwards(_						componentsTerminationFuture,_						this::closeMetricSystem)___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricSystemTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,system,termination,future,future,utils,compose,afterwards,components,termination,future,this,close,metric,system,final,completable,future,void,rpc,services,termination,future,metric,system,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1549360057;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricSystemTerminationFuture = FutureUtils.composeAfterwards(_						componentsTerminationFuture,_						this::closeMetricSystem)___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricSystemTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,system,termination,future,future,utils,compose,afterwards,components,termination,future,this,close,metric,system,final,completable,future,void,rpc,services,termination,future,metric,system,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1549360057;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownDispatcher())___					if (resourceManagerRunner != null) {_						componentTerminationFutures.add(resourceManagerRunner.closeAsync())__						resourceManagerRunner = null__					}__					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricSystemTerminationFuture = FutureUtils.composeAfterwards(_						componentsTerminationFuture,_						this::closeMetricSystem)___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricSystemTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,dispatcher,if,resource,manager,runner,null,component,termination,futures,add,resource,manager,runner,close,async,resource,manager,runner,null,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,system,termination,future,future,utils,compose,afterwards,components,termination,future,this,close,metric,system,final,completable,future,void,rpc,services,termination,future,metric,system,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1549360057;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownResourceManagerComponents())___					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricSystemTerminationFuture = FutureUtils.composeAfterwards(_						componentsTerminationFuture,_						this::closeMetricSystem)___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricSystemTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,resource,manager,components,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,system,termination,future,future,utils,compose,afterwards,components,termination,future,this,close,metric,system,final,completable,future,void,rpc,services,termination,future,metric,system,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1549360057;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownResourceManagerComponents())___					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricSystemTerminationFuture = FutureUtils.composeAfterwards(_						componentsTerminationFuture,_						this::closeMetricSystem)___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricSystemTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,resource,manager,components,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,system,termination,future,future,utils,compose,afterwards,components,termination,future,this,close,metric,system,final,completable,future,void,rpc,services,termination,future,metric,system,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1549360058;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								tm.shutDown()__								componentTerminationFutures.add(tm.getTerminationFuture())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownResourceManagerComponents())___					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricSystemTerminationFuture = FutureUtils.composeAfterwards(_						componentsTerminationFuture,_						this::closeMetricSystem)___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricSystemTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,tm,shut,down,component,termination,futures,add,tm,get,termination,future,task,managers,null,component,termination,futures,add,shut,down,resource,manager,components,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,system,termination,future,future,utils,compose,afterwards,components,termination,future,this,close,metric,system,final,completable,future,void,rpc,services,termination,future,metric,system,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1550005040;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					if (taskManagers != null) {_						for (TaskExecutor tm : taskManagers) {_							if (tm != null) {_								componentTerminationFutures.add(tm.closeAsync())__							}_						}_						taskManagers = null__					}__					componentTerminationFutures.add(shutDownResourceManagerComponents())___					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricSystemTerminationFuture = FutureUtils.composeAfterwards(_						componentsTerminationFuture,_						this::closeMetricSystem)___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricSystemTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,if,task,managers,null,for,task,executor,tm,task,managers,if,tm,null,component,termination,futures,add,tm,close,async,task,managers,null,component,termination,futures,add,shut,down,resource,manager,components,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,system,termination,future,future,utils,compose,afterwards,components,termination,future,this,close,metric,system,final,completable,future,void,rpc,services,termination,future,metric,system,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1550069788;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					componentTerminationFutures.addAll(terminateTaskExecutors())___					componentTerminationFutures.add(shutDownResourceManagerComponents())___					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricSystemTerminationFuture = FutureUtils.composeAfterwards(_						componentsTerminationFuture,_						this::closeMetricSystem)___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricSystemTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,component,termination,futures,add,all,terminate,task,executors,component,termination,futures,add,shut,down,resource,manager,components,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,system,termination,future,future,utils,compose,afterwards,components,termination,future,this,close,metric,system,final,completable,future,void,rpc,services,termination,future,metric,system,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1550228244;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					componentTerminationFutures.addAll(terminateTaskExecutors())___					componentTerminationFutures.add(shutDownResourceManagerComponents())___					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricSystemTerminationFuture = FutureUtils.composeAfterwards(_						componentsTerminationFuture,_						this::closeMetricSystem)___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricSystemTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,component,termination,futures,add,all,terminate,task,executors,component,termination,futures,add,shut,down,resource,manager,components,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,system,termination,future,future,utils,compose,afterwards,components,termination,future,this,close,metric,system,final,completable,future,void,rpc,services,termination,future,metric,system,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1550483152;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					componentTerminationFutures.addAll(terminateTaskExecutors())___					componentTerminationFutures.add(shutDownResourceManagerComponents())___					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricSystemTerminationFuture = FutureUtils.composeAfterwards(_						componentsTerminationFuture,_						this::closeMetricSystem)___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricSystemTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,component,termination,futures,add,all,terminate,task,executors,component,termination,futures,add,shut,down,resource,manager,components,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,system,termination,future,future,utils,compose,afterwards,components,termination,future,this,close,metric,system,final,completable,future,void,rpc,services,termination,future,metric,system,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
MiniCluster -> @Override 	public CompletableFuture<Void> closeAsync();1550823915;Shuts down the mini cluster, failing all currently executing jobs._The mini cluster can be started again by calling the {@link #start()} method again.__<p>This method shuts down all started services and components,_even if an exception occurs in the process of shutting down some component.__@return Future which is completed once the MiniCluster has been completely shut down;@Override_	public CompletableFuture<Void> closeAsync() {_		synchronized (lock) {_			if (running) {_				LOG.info("Shutting down Flink Mini Cluster")__				try {_					final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers()__					final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents)___					componentTerminationFutures.addAll(terminateTaskExecutors())___					componentTerminationFutures.add(shutDownResourceManagerComponents())___					final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures)___					final CompletableFuture<Void> metricSystemTerminationFuture = FutureUtils.composeAfterwards(_						componentsTerminationFuture,_						this::closeMetricSystem)___					_					final CompletableFuture<Void> rpcServicesTerminationFuture = metricSystemTerminationFuture_						.thenCompose((Void ignored) -> terminateRpcServices())___					final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(_						rpcServicesTerminationFuture,_						this::terminateMiniClusterServices)___						remainingServicesTerminationFuture.whenComplete(_							(Void ignored, Throwable throwable) -> {_								if (throwable != null) {_									terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable))__								} else {_									terminationFuture.complete(null)__								}_							})__				} finally {_					running = false__				}_			}__			return terminationFuture__		}_	};shuts,down,the,mini,cluster,failing,all,currently,executing,jobs,the,mini,cluster,can,be,started,again,by,calling,the,link,start,method,again,p,this,method,shuts,down,all,started,services,and,components,even,if,an,exception,occurs,in,the,process,of,shutting,down,some,component,return,future,which,is,completed,once,the,mini,cluster,has,been,completely,shut,down;override,public,completable,future,void,close,async,synchronized,lock,if,running,log,info,shutting,down,flink,mini,cluster,try,final,int,num,components,2,mini,cluster,configuration,get,num,task,managers,final,collection,completable,future,void,component,termination,futures,new,array,list,num,components,component,termination,futures,add,all,terminate,task,executors,component,termination,futures,add,shut,down,resource,manager,components,final,future,utils,conjunct,future,void,components,termination,future,future,utils,complete,all,component,termination,futures,final,completable,future,void,metric,system,termination,future,future,utils,compose,afterwards,components,termination,future,this,close,metric,system,final,completable,future,void,rpc,services,termination,future,metric,system,termination,future,then,compose,void,ignored,terminate,rpc,services,final,completable,future,void,remaining,services,termination,future,future,utils,run,afterwards,rpc,services,termination,future,this,terminate,mini,cluster,services,remaining,services,termination,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,termination,future,complete,exceptionally,exception,utils,strip,completion,exception,throwable,else,termination,future,complete,null,finally,running,false,return,termination,future
