# id;timestamp;commentText;codeText;commentWords;codeWords
FsJobArchivist -> public static Path archiveJob(Path rootPath, JobID jobId, Collection<ArchivedJson> jsonToArchive) throws IOException;1524054784;Writes the given {@link AccessExecutionGraph} to the {@link FileSystem} pointed to by_{@link JobManagerOptions#ARCHIVE_DIR}.__@param rootPath directory to which the archive should be written to_@param jobId  job id_@param jsonToArchive collection of json-path pairs to that should be archived_@return path to where the archive was written, or null if no archive was created_@throws IOException;public static Path archiveJob(Path rootPath, JobID jobId, Collection<ArchivedJson> jsonToArchive) throws IOException {_		try {_			FileSystem fs = rootPath.getFileSystem()__			Path path = new Path(rootPath, jobId.toString())__			OutputStream out = fs.create(path, FileSystem.WriteMode.NO_OVERWRITE)___			try (JsonGenerator gen = jacksonFactory.createGenerator(out, JsonEncoding.UTF8)) {_				gen.writeStartObject()__				gen.writeArrayFieldStart(ARCHIVE)__				for (ArchivedJson archive : jsonToArchive) {_					gen.writeStartObject()__					gen.writeStringField(PATH, archive.getPath())__					gen.writeStringField(JSON, archive.getJson())__					gen.writeEndObject()__				}_				gen.writeEndArray()__				gen.writeEndObject()__			} catch (Exception e) {_				fs.delete(path, false)__				throw e__			}_			LOG.info("Job {} has been archived at {}.", jobId, path)__			return path__		} catch (IOException e) {_			LOG.error("Failed to archive job.", e)__			throw e__		}_	};writes,the,given,link,access,execution,graph,to,the,link,file,system,pointed,to,by,link,job,manager,options,param,root,path,directory,to,which,the,archive,should,be,written,to,param,job,id,job,id,param,json,to,archive,collection,of,json,path,pairs,to,that,should,be,archived,return,path,to,where,the,archive,was,written,or,null,if,no,archive,was,created,throws,ioexception;public,static,path,archive,job,path,root,path,job,id,job,id,collection,archived,json,json,to,archive,throws,ioexception,try,file,system,fs,root,path,get,file,system,path,path,new,path,root,path,job,id,to,string,output,stream,out,fs,create,path,file,system,write,mode,try,json,generator,gen,jackson,factory,create,generator,out,json,encoding,utf8,gen,write,start,object,gen,write,array,field,start,archive,for,archived,json,archive,json,to,archive,gen,write,start,object,gen,write,string,field,path,archive,get,path,gen,write,string,field,json,archive,get,json,gen,write,end,object,gen,write,end,array,gen,write,end,object,catch,exception,e,fs,delete,path,false,throw,e,log,info,job,has,been,archived,at,job,id,path,return,path,catch,ioexception,e,log,error,failed,to,archive,job,e,throw,e
FsJobArchivist -> public static Path archiveJob(Path rootPath, JobID jobId, Collection<ArchivedJson> jsonToArchive) throws IOException;1548942615;Writes the given {@link AccessExecutionGraph} to the {@link FileSystem} pointed to by_{@link JobManagerOptions#ARCHIVE_DIR}.__@param rootPath directory to which the archive should be written to_@param jobId  job id_@param jsonToArchive collection of json-path pairs to that should be archived_@return path to where the archive was written, or null if no archive was created_@throws IOException;public static Path archiveJob(Path rootPath, JobID jobId, Collection<ArchivedJson> jsonToArchive) throws IOException {_		try {_			FileSystem fs = rootPath.getFileSystem()__			Path path = new Path(rootPath, jobId.toString())__			OutputStream out = fs.create(path, FileSystem.WriteMode.NO_OVERWRITE)___			try (JsonGenerator gen = jacksonFactory.createGenerator(out, JsonEncoding.UTF8)) {_				gen.writeStartObject()__				gen.writeArrayFieldStart(ARCHIVE)__				for (ArchivedJson archive : jsonToArchive) {_					gen.writeStartObject()__					gen.writeStringField(PATH, archive.getPath())__					gen.writeStringField(JSON, archive.getJson())__					gen.writeEndObject()__				}_				gen.writeEndArray()__				gen.writeEndObject()__			} catch (Exception e) {_				fs.delete(path, false)__				throw e__			}_			LOG.info("Job {} has been archived at {}.", jobId, path)__			return path__		} catch (IOException e) {_			LOG.error("Failed to archive job.", e)__			throw e__		}_	};writes,the,given,link,access,execution,graph,to,the,link,file,system,pointed,to,by,link,job,manager,options,param,root,path,directory,to,which,the,archive,should,be,written,to,param,job,id,job,id,param,json,to,archive,collection,of,json,path,pairs,to,that,should,be,archived,return,path,to,where,the,archive,was,written,or,null,if,no,archive,was,created,throws,ioexception;public,static,path,archive,job,path,root,path,job,id,job,id,collection,archived,json,json,to,archive,throws,ioexception,try,file,system,fs,root,path,get,file,system,path,path,new,path,root,path,job,id,to,string,output,stream,out,fs,create,path,file,system,write,mode,try,json,generator,gen,jackson,factory,create,generator,out,json,encoding,utf8,gen,write,start,object,gen,write,array,field,start,archive,for,archived,json,archive,json,to,archive,gen,write,start,object,gen,write,string,field,path,archive,get,path,gen,write,string,field,json,archive,get,json,gen,write,end,object,gen,write,end,array,gen,write,end,object,catch,exception,e,fs,delete,path,false,throw,e,log,info,job,has,been,archived,at,job,id,path,return,path,catch,ioexception,e,log,error,failed,to,archive,job,e,throw,e
FsJobArchivist -> public static Path archiveJob(Path rootPath, AccessExecutionGraph graph) throws IOException;1490031714;Writes the given {@link AccessExecutionGraph} to the {@link FileSystem} pointed to by_{@link JobManagerOptions#ARCHIVE_DIR}.__@param rootPath directory to which the archive should be written to_@param graph  graph to archive_@return path to where the archive was written, or null if no archive was created_@throws IOException;public static Path archiveJob(Path rootPath, AccessExecutionGraph graph) throws IOException {_		try {_			FileSystem fs = rootPath.getFileSystem()__			Path path = new Path(rootPath, graph.getJobID().toString())__			OutputStream out = fs.create(path, FileSystem.WriteMode.NO_OVERWRITE)___			try (JsonGenerator gen = jacksonFactory.createGenerator(out, JsonEncoding.UTF8)) {_				gen.writeStartObject()__				gen.writeArrayFieldStart(ARCHIVE)__				for (JsonArchivist archiver : WebMonitorUtils.getJsonArchivists()) {_					for (ArchivedJson archive : archiver.archiveJsonWithPath(graph)) {_						gen.writeStartObject()__						gen.writeStringField(PATH, archive.getPath())__						gen.writeStringField(JSON, archive.getJson())__						gen.writeEndObject()__					}_				}_				gen.writeEndArray()__				gen.writeEndObject()__			} catch (Exception e) {_				fs.delete(path, false)__				throw e__			}_			LOG.info("Job {} has been archived at {}.", graph.getJobID(), path)__			return path__		} catch (IOException e) {_			LOG.error("Failed to archive job.", e)__			throw e__		}_	};writes,the,given,link,access,execution,graph,to,the,link,file,system,pointed,to,by,link,job,manager,options,param,root,path,directory,to,which,the,archive,should,be,written,to,param,graph,graph,to,archive,return,path,to,where,the,archive,was,written,or,null,if,no,archive,was,created,throws,ioexception;public,static,path,archive,job,path,root,path,access,execution,graph,graph,throws,ioexception,try,file,system,fs,root,path,get,file,system,path,path,new,path,root,path,graph,get,job,id,to,string,output,stream,out,fs,create,path,file,system,write,mode,try,json,generator,gen,jackson,factory,create,generator,out,json,encoding,utf8,gen,write,start,object,gen,write,array,field,start,archive,for,json,archivist,archiver,web,monitor,utils,get,json,archivists,for,archived,json,archive,archiver,archive,json,with,path,graph,gen,write,start,object,gen,write,string,field,path,archive,get,path,gen,write,string,field,json,archive,get,json,gen,write,end,object,gen,write,end,array,gen,write,end,object,catch,exception,e,fs,delete,path,false,throw,e,log,info,job,has,been,archived,at,graph,get,job,id,path,return,path,catch,ioexception,e,log,error,failed,to,archive,job,e,throw,e
FsJobArchivist -> public static Path archiveJob(Path rootPath, AccessExecutionGraph graph) throws IOException;1496242628;Writes the given {@link AccessExecutionGraph} to the {@link FileSystem} pointed to by_{@link JobManagerOptions#ARCHIVE_DIR}.__@param rootPath directory to which the archive should be written to_@param graph  graph to archive_@return path to where the archive was written, or null if no archive was created_@throws IOException;public static Path archiveJob(Path rootPath, AccessExecutionGraph graph) throws IOException {_		try {_			FileSystem fs = rootPath.getFileSystem()__			Path path = new Path(rootPath, graph.getJobID().toString())__			OutputStream out = fs.create(path, FileSystem.WriteMode.NO_OVERWRITE)___			try (JsonGenerator gen = jacksonFactory.createGenerator(out, JsonEncoding.UTF8)) {_				gen.writeStartObject()__				gen.writeArrayFieldStart(ARCHIVE)__				for (JsonArchivist archiver : WebMonitorUtils.getJsonArchivists()) {_					for (ArchivedJson archive : archiver.archiveJsonWithPath(graph)) {_						gen.writeStartObject()__						gen.writeStringField(PATH, archive.getPath())__						gen.writeStringField(JSON, archive.getJson())__						gen.writeEndObject()__					}_				}_				gen.writeEndArray()__				gen.writeEndObject()__			} catch (Exception e) {_				fs.delete(path, false)__				throw e__			}_			LOG.info("Job {} has been archived at {}.", graph.getJobID(), path)__			return path__		} catch (IOException e) {_			LOG.error("Failed to archive job.", e)__			throw e__		}_	};writes,the,given,link,access,execution,graph,to,the,link,file,system,pointed,to,by,link,job,manager,options,param,root,path,directory,to,which,the,archive,should,be,written,to,param,graph,graph,to,archive,return,path,to,where,the,archive,was,written,or,null,if,no,archive,was,created,throws,ioexception;public,static,path,archive,job,path,root,path,access,execution,graph,graph,throws,ioexception,try,file,system,fs,root,path,get,file,system,path,path,new,path,root,path,graph,get,job,id,to,string,output,stream,out,fs,create,path,file,system,write,mode,try,json,generator,gen,jackson,factory,create,generator,out,json,encoding,utf8,gen,write,start,object,gen,write,array,field,start,archive,for,json,archivist,archiver,web,monitor,utils,get,json,archivists,for,archived,json,archive,archiver,archive,json,with,path,graph,gen,write,start,object,gen,write,string,field,path,archive,get,path,gen,write,string,field,json,archive,get,json,gen,write,end,object,gen,write,end,array,gen,write,end,object,catch,exception,e,fs,delete,path,false,throw,e,log,info,job,has,been,archived,at,graph,get,job,id,path,return,path,catch,ioexception,e,log,error,failed,to,archive,job,e,throw,e
FsJobArchivist -> public static Path archiveJob(Path rootPath, AccessExecutionGraph graph) throws IOException;1508150892;Writes the given {@link AccessExecutionGraph} to the {@link FileSystem} pointed to by_{@link JobManagerOptions#ARCHIVE_DIR}.__@param rootPath directory to which the archive should be written to_@param graph  graph to archive_@return path to where the archive was written, or null if no archive was created_@throws IOException;public static Path archiveJob(Path rootPath, AccessExecutionGraph graph) throws IOException {_		try {_			FileSystem fs = rootPath.getFileSystem()__			Path path = new Path(rootPath, graph.getJobID().toString())__			OutputStream out = fs.create(path, FileSystem.WriteMode.NO_OVERWRITE)___			try (JsonGenerator gen = jacksonFactory.createGenerator(out, JsonEncoding.UTF8)) {_				gen.writeStartObject()__				gen.writeArrayFieldStart(ARCHIVE)__				for (JsonArchivist archiver : WebMonitorUtils.getJsonArchivists()) {_					for (ArchivedJson archive : archiver.archiveJsonWithPath(graph)) {_						gen.writeStartObject()__						gen.writeStringField(PATH, archive.getPath())__						gen.writeStringField(JSON, archive.getJson())__						gen.writeEndObject()__					}_				}_				gen.writeEndArray()__				gen.writeEndObject()__			} catch (Exception e) {_				fs.delete(path, false)__				throw e__			}_			LOG.info("Job {} has been archived at {}.", graph.getJobID(), path)__			return path__		} catch (IOException e) {_			LOG.error("Failed to archive job.", e)__			throw e__		}_	};writes,the,given,link,access,execution,graph,to,the,link,file,system,pointed,to,by,link,job,manager,options,param,root,path,directory,to,which,the,archive,should,be,written,to,param,graph,graph,to,archive,return,path,to,where,the,archive,was,written,or,null,if,no,archive,was,created,throws,ioexception;public,static,path,archive,job,path,root,path,access,execution,graph,graph,throws,ioexception,try,file,system,fs,root,path,get,file,system,path,path,new,path,root,path,graph,get,job,id,to,string,output,stream,out,fs,create,path,file,system,write,mode,try,json,generator,gen,jackson,factory,create,generator,out,json,encoding,utf8,gen,write,start,object,gen,write,array,field,start,archive,for,json,archivist,archiver,web,monitor,utils,get,json,archivists,for,archived,json,archive,archiver,archive,json,with,path,graph,gen,write,start,object,gen,write,string,field,path,archive,get,path,gen,write,string,field,json,archive,get,json,gen,write,end,object,gen,write,end,array,gen,write,end,object,catch,exception,e,fs,delete,path,false,throw,e,log,info,job,has,been,archived,at,graph,get,job,id,path,return,path,catch,ioexception,e,log,error,failed,to,archive,job,e,throw,e
FsJobArchivist -> public static Collection<ArchivedJson> getArchivedJsons(Path file) throws IOException;1490031714;Reads the given archive file and returns a {@link Collection} of contained {@link ArchivedJson}.__@param file archive to extract_@return collection of archived jsons_@throws IOException if the file can't be opened, read or doesn't contain valid json;public static Collection<ArchivedJson> getArchivedJsons(Path file) throws IOException {_		try (FSDataInputStream input = file.getFileSystem().open(file)__			ByteArrayOutputStream output = new ByteArrayOutputStream()) {_			IOUtils.copyBytes(input, output)___			JsonNode archive = mapper.readTree(output.toByteArray())___			Collection<ArchivedJson> archives = new ArrayList<>()__			for (JsonNode archivePart : archive.get(ARCHIVE)) {_				String path = archivePart.get(PATH).asText()__				String json = archivePart.get(JSON).asText()__				archives.add(new ArchivedJson(path, json))__			}_			return archives__		}_	};reads,the,given,archive,file,and,returns,a,link,collection,of,contained,link,archived,json,param,file,archive,to,extract,return,collection,of,archived,jsons,throws,ioexception,if,the,file,can,t,be,opened,read,or,doesn,t,contain,valid,json;public,static,collection,archived,json,get,archived,jsons,path,file,throws,ioexception,try,fsdata,input,stream,input,file,get,file,system,open,file,byte,array,output,stream,output,new,byte,array,output,stream,ioutils,copy,bytes,input,output,json,node,archive,mapper,read,tree,output,to,byte,array,collection,archived,json,archives,new,array,list,for,json,node,archive,part,archive,get,archive,string,path,archive,part,get,path,as,text,string,json,archive,part,get,json,as,text,archives,add,new,archived,json,path,json,return,archives
FsJobArchivist -> public static Collection<ArchivedJson> getArchivedJsons(Path file) throws IOException;1496242628;Reads the given archive file and returns a {@link Collection} of contained {@link ArchivedJson}.__@param file archive to extract_@return collection of archived jsons_@throws IOException if the file can't be opened, read or doesn't contain valid json;public static Collection<ArchivedJson> getArchivedJsons(Path file) throws IOException {_		try (FSDataInputStream input = file.getFileSystem().open(file)__			ByteArrayOutputStream output = new ByteArrayOutputStream()) {_			IOUtils.copyBytes(input, output)___			JsonNode archive = mapper.readTree(output.toByteArray())___			Collection<ArchivedJson> archives = new ArrayList<>()__			for (JsonNode archivePart : archive.get(ARCHIVE)) {_				String path = archivePart.get(PATH).asText()__				String json = archivePart.get(JSON).asText()__				archives.add(new ArchivedJson(path, json))__			}_			return archives__		}_	};reads,the,given,archive,file,and,returns,a,link,collection,of,contained,link,archived,json,param,file,archive,to,extract,return,collection,of,archived,jsons,throws,ioexception,if,the,file,can,t,be,opened,read,or,doesn,t,contain,valid,json;public,static,collection,archived,json,get,archived,jsons,path,file,throws,ioexception,try,fsdata,input,stream,input,file,get,file,system,open,file,byte,array,output,stream,output,new,byte,array,output,stream,ioutils,copy,bytes,input,output,json,node,archive,mapper,read,tree,output,to,byte,array,collection,archived,json,archives,new,array,list,for,json,node,archive,part,archive,get,archive,string,path,archive,part,get,path,as,text,string,json,archive,part,get,json,as,text,archives,add,new,archived,json,path,json,return,archives
FsJobArchivist -> public static Collection<ArchivedJson> getArchivedJsons(Path file) throws IOException;1508150892;Reads the given archive file and returns a {@link Collection} of contained {@link ArchivedJson}.__@param file archive to extract_@return collection of archived jsons_@throws IOException if the file can't be opened, read or doesn't contain valid json;public static Collection<ArchivedJson> getArchivedJsons(Path file) throws IOException {_		try (FSDataInputStream input = file.getFileSystem().open(file)__			ByteArrayOutputStream output = new ByteArrayOutputStream()) {_			IOUtils.copyBytes(input, output)___			JsonNode archive = mapper.readTree(output.toByteArray())___			Collection<ArchivedJson> archives = new ArrayList<>()__			for (JsonNode archivePart : archive.get(ARCHIVE)) {_				String path = archivePart.get(PATH).asText()__				String json = archivePart.get(JSON).asText()__				archives.add(new ArchivedJson(path, json))__			}_			return archives__		}_	};reads,the,given,archive,file,and,returns,a,link,collection,of,contained,link,archived,json,param,file,archive,to,extract,return,collection,of,archived,jsons,throws,ioexception,if,the,file,can,t,be,opened,read,or,doesn,t,contain,valid,json;public,static,collection,archived,json,get,archived,jsons,path,file,throws,ioexception,try,fsdata,input,stream,input,file,get,file,system,open,file,byte,array,output,stream,output,new,byte,array,output,stream,ioutils,copy,bytes,input,output,json,node,archive,mapper,read,tree,output,to,byte,array,collection,archived,json,archives,new,array,list,for,json,node,archive,part,archive,get,archive,string,path,archive,part,get,path,as,text,string,json,archive,part,get,json,as,text,archives,add,new,archived,json,path,json,return,archives
FsJobArchivist -> public static Collection<ArchivedJson> getArchivedJsons(Path file) throws IOException;1524054784;Reads the given archive file and returns a {@link Collection} of contained {@link ArchivedJson}.__@param file archive to extract_@return collection of archived jsons_@throws IOException if the file can't be opened, read or doesn't contain valid json;public static Collection<ArchivedJson> getArchivedJsons(Path file) throws IOException {_		try (FSDataInputStream input = file.getFileSystem().open(file)__			ByteArrayOutputStream output = new ByteArrayOutputStream()) {_			IOUtils.copyBytes(input, output)___			JsonNode archive = mapper.readTree(output.toByteArray())___			Collection<ArchivedJson> archives = new ArrayList<>()__			for (JsonNode archivePart : archive.get(ARCHIVE)) {_				String path = archivePart.get(PATH).asText()__				String json = archivePart.get(JSON).asText()__				archives.add(new ArchivedJson(path, json))__			}_			return archives__		}_	};reads,the,given,archive,file,and,returns,a,link,collection,of,contained,link,archived,json,param,file,archive,to,extract,return,collection,of,archived,jsons,throws,ioexception,if,the,file,can,t,be,opened,read,or,doesn,t,contain,valid,json;public,static,collection,archived,json,get,archived,jsons,path,file,throws,ioexception,try,fsdata,input,stream,input,file,get,file,system,open,file,byte,array,output,stream,output,new,byte,array,output,stream,ioutils,copy,bytes,input,output,json,node,archive,mapper,read,tree,output,to,byte,array,collection,archived,json,archives,new,array,list,for,json,node,archive,part,archive,get,archive,string,path,archive,part,get,path,as,text,string,json,archive,part,get,json,as,text,archives,add,new,archived,json,path,json,return,archives
FsJobArchivist -> public static Collection<ArchivedJson> getArchivedJsons(Path file) throws IOException;1548942615;Reads the given archive file and returns a {@link Collection} of contained {@link ArchivedJson}.__@param file archive to extract_@return collection of archived jsons_@throws IOException if the file can't be opened, read or doesn't contain valid json;public static Collection<ArchivedJson> getArchivedJsons(Path file) throws IOException {_		try (FSDataInputStream input = file.getFileSystem().open(file)__			ByteArrayOutputStream output = new ByteArrayOutputStream()) {_			IOUtils.copyBytes(input, output)___			JsonNode archive = mapper.readTree(output.toByteArray())___			Collection<ArchivedJson> archives = new ArrayList<>()__			for (JsonNode archivePart : archive.get(ARCHIVE)) {_				String path = archivePart.get(PATH).asText()__				String json = archivePart.get(JSON).asText()__				archives.add(new ArchivedJson(path, json))__			}_			return archives__		}_	};reads,the,given,archive,file,and,returns,a,link,collection,of,contained,link,archived,json,param,file,archive,to,extract,return,collection,of,archived,jsons,throws,ioexception,if,the,file,can,t,be,opened,read,or,doesn,t,contain,valid,json;public,static,collection,archived,json,get,archived,jsons,path,file,throws,ioexception,try,fsdata,input,stream,input,file,get,file,system,open,file,byte,array,output,stream,output,new,byte,array,output,stream,ioutils,copy,bytes,input,output,json,node,archive,mapper,read,tree,output,to,byte,array,collection,archived,json,archives,new,array,list,for,json,node,archive,part,archive,get,archive,string,path,archive,part,get,path,as,text,string,json,archive,part,get,json,as,text,archives,add,new,archived,json,path,json,return,archives
