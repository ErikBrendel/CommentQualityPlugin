# id;timestamp;commentText;codeText;commentWords;codeWords
RestartPipelinedRegionStrategy -> @VisibleForTesting 	public FailoverRegion getFailoverRegion(ExecutionVertex ev);1492496129;Finds the failover region that contains the given execution vertex.;@VisibleForTesting_	public FailoverRegion getFailoverRegion(ExecutionVertex ev) {_		return vertexToRegion.get(ev)__	};finds,the,failover,region,that,contains,the,given,execution,vertex;visible,for,testing,public,failover,region,get,failover,region,execution,vertex,ev,return,vertex,to,region,get,ev
RestartPipelinedRegionStrategy -> @VisibleForTesting 	public FailoverRegion getFailoverRegion(ExecutionVertex ev);1492725739;Finds the failover region that contains the given execution vertex.;@VisibleForTesting_	public FailoverRegion getFailoverRegion(ExecutionVertex ev) {_		return vertexToRegion.get(ev)__	};finds,the,failover,region,that,contains,the,given,execution,vertex;visible,for,testing,public,failover,region,get,failover,region,execution,vertex,ev,return,vertex,to,region,get,ev
RestartPipelinedRegionStrategy -> @VisibleForTesting 	public FailoverRegion getFailoverRegion(ExecutionVertex ev);1509034963;Finds the failover region that contains the given execution vertex.;@VisibleForTesting_	public FailoverRegion getFailoverRegion(ExecutionVertex ev) {_		return vertexToRegion.get(ev)__	};finds,the,failover,region,that,contains,the,given,execution,vertex;visible,for,testing,public,failover,region,get,failover,region,execution,vertex,ev,return,vertex,to,region,get,ev
RestartPipelinedRegionStrategy -> @VisibleForTesting 	public FailoverRegion getFailoverRegion(ExecutionVertex ev);1543229263;Finds the failover region that contains the given execution vertex.;@VisibleForTesting_	public FailoverRegion getFailoverRegion(ExecutionVertex ev) {_		return vertexToRegion.get(ev)__	};finds,the,failover,region,that,contains,the,given,execution,vertex;visible,for,testing,public,failover,region,get,failover,region,execution,vertex,ev,return,vertex,to,region,get,ev
RestartPipelinedRegionStrategy -> @VisibleForTesting 	public FailoverRegion getFailoverRegion(ExecutionVertex ev);1548717762;Finds the failover region that contains the given execution vertex.;@VisibleForTesting_	public FailoverRegion getFailoverRegion(ExecutionVertex ev) {_		return vertexToRegion.get(ev)__	};finds,the,failover,region,that,contains,the,given,execution,vertex;visible,for,testing,public,failover,region,get,failover,region,execution,vertex,ev,return,vertex,to,region,get,ev
RestartPipelinedRegionStrategy -> public RestartPipelinedRegionStrategy(ExecutionGraph executionGraph, Executor executor);1492496129;Creates a new failover strategy to restart pipelined regions that works on the given_execution graph and uses the given executor to call restart actions.__@param executionGraph The execution graph on which this FailoverStrategy will work_@param executor  The executor used for future actions;public RestartPipelinedRegionStrategy(ExecutionGraph executionGraph, Executor executor) {_		this.executionGraph = checkNotNull(executionGraph)__		this.executor = checkNotNull(executor)__		this.vertexToRegion = new HashMap<>()__	};creates,a,new,failover,strategy,to,restart,pipelined,regions,that,works,on,the,given,execution,graph,and,uses,the,given,executor,to,call,restart,actions,param,execution,graph,the,execution,graph,on,which,this,failover,strategy,will,work,param,executor,the,executor,used,for,future,actions;public,restart,pipelined,region,strategy,execution,graph,execution,graph,executor,executor,this,execution,graph,check,not,null,execution,graph,this,executor,check,not,null,executor,this,vertex,to,region,new,hash,map
RestartPipelinedRegionStrategy -> public RestartPipelinedRegionStrategy(ExecutionGraph executionGraph, Executor executor);1492725739;Creates a new failover strategy to restart pipelined regions that works on the given_execution graph and uses the given executor to call restart actions.__@param executionGraph The execution graph on which this FailoverStrategy will work_@param executor  The executor used for future actions;public RestartPipelinedRegionStrategy(ExecutionGraph executionGraph, Executor executor) {_		this.executionGraph = checkNotNull(executionGraph)__		this.executor = checkNotNull(executor)__		this.vertexToRegion = new HashMap<>()__	};creates,a,new,failover,strategy,to,restart,pipelined,regions,that,works,on,the,given,execution,graph,and,uses,the,given,executor,to,call,restart,actions,param,execution,graph,the,execution,graph,on,which,this,failover,strategy,will,work,param,executor,the,executor,used,for,future,actions;public,restart,pipelined,region,strategy,execution,graph,execution,graph,executor,executor,this,execution,graph,check,not,null,execution,graph,this,executor,check,not,null,executor,this,vertex,to,region,new,hash,map
RestartPipelinedRegionStrategy -> public RestartPipelinedRegionStrategy(ExecutionGraph executionGraph, Executor executor);1509034963;Creates a new failover strategy to restart pipelined regions that works on the given_execution graph and uses the given executor to call restart actions.__@param executionGraph The execution graph on which this FailoverStrategy will work_@param executor  The executor used for future actions;public RestartPipelinedRegionStrategy(ExecutionGraph executionGraph, Executor executor) {_		this.executionGraph = checkNotNull(executionGraph)__		this.executor = checkNotNull(executor)__		this.vertexToRegion = new HashMap<>()__	};creates,a,new,failover,strategy,to,restart,pipelined,regions,that,works,on,the,given,execution,graph,and,uses,the,given,executor,to,call,restart,actions,param,execution,graph,the,execution,graph,on,which,this,failover,strategy,will,work,param,executor,the,executor,used,for,future,actions;public,restart,pipelined,region,strategy,execution,graph,execution,graph,executor,executor,this,execution,graph,check,not,null,execution,graph,this,executor,check,not,null,executor,this,vertex,to,region,new,hash,map
RestartPipelinedRegionStrategy -> public RestartPipelinedRegionStrategy(ExecutionGraph executionGraph, Executor executor);1548717762;Creates a new failover strategy to restart pipelined regions that works on the given_execution graph and uses the given executor to call restart actions.__@param executionGraph The execution graph on which this FailoverStrategy will work_@param executor  The executor used for future actions;public RestartPipelinedRegionStrategy(ExecutionGraph executionGraph, Executor executor) {_		this.executionGraph = checkNotNull(executionGraph)__		this.executor = checkNotNull(executor)__		this.vertexToRegion = new HashMap<>()__	};creates,a,new,failover,strategy,to,restart,pipelined,regions,that,works,on,the,given,execution,graph,and,uses,the,given,executor,to,call,restart,actions,param,execution,graph,the,execution,graph,on,which,this,failover,strategy,will,work,param,executor,the,executor,used,for,future,actions;public,restart,pipelined,region,strategy,execution,graph,execution,graph,executor,executor,this,execution,graph,check,not,null,execution,graph,this,executor,check,not,null,executor,this,vertex,to,region,new,hash,map
RestartPipelinedRegionStrategy -> private void generateAllFailoverRegion(List<ExecutionJobVertex> newJobVerticesTopological);1492496129;Generate all the FailoverRegion from the new added job vertexes;private void generateAllFailoverRegion(List<ExecutionJobVertex> newJobVerticesTopological) {_		for (ExecutionJobVertex ejv : newJobVerticesTopological) {_			for (ExecutionVertex ev : ejv.getTaskVertices()) {_				if (getFailoverRegion(ev) != null) {_					continue__				}_				List<ExecutionVertex> pipelinedExecutions = new ArrayList<>()__				List<ExecutionVertex> orgExecutions = new ArrayList<>()__				orgExecutions.add(ev)__				pipelinedExecutions.add(ev)__				getAllPipelinedConnectedVertexes(orgExecutions, pipelinedExecutions)___				FailoverRegion region = new FailoverRegion(executionGraph, executor, pipelinedExecutions)__				for (ExecutionVertex vertex : pipelinedExecutions) {_					vertexToRegion.put(vertex, region)__				}_			}_		}_	};generate,all,the,failover,region,from,the,new,added,job,vertexes;private,void,generate,all,failover,region,list,execution,job,vertex,new,job,vertices,topological,for,execution,job,vertex,ejv,new,job,vertices,topological,for,execution,vertex,ev,ejv,get,task,vertices,if,get,failover,region,ev,null,continue,list,execution,vertex,pipelined,executions,new,array,list,list,execution,vertex,org,executions,new,array,list,org,executions,add,ev,pipelined,executions,add,ev,get,all,pipelined,connected,vertexes,org,executions,pipelined,executions,failover,region,region,new,failover,region,execution,graph,executor,pipelined,executions,for,execution,vertex,vertex,pipelined,executions,vertex,to,region,put,vertex,region
RestartPipelinedRegionStrategy -> private void generateAllFailoverRegion(List<ExecutionJobVertex> newJobVerticesTopological);1492725739;Generate all the FailoverRegion from the new added job vertexes;private void generateAllFailoverRegion(List<ExecutionJobVertex> newJobVerticesTopological) {_		final IdentityHashMap<ExecutionVertex, ArrayList<ExecutionVertex>> vertexToRegion = new IdentityHashMap<>()___		_		final IdentityHashMap<ArrayList<ExecutionVertex>, Object> distinctRegions = new IdentityHashMap<>()___		_		_		for (ExecutionJobVertex ejv : newJobVerticesTopological) {__			_			_			if (ejv.getCoLocationGroup() != null) {_				makeAllOneRegion(newJobVerticesTopological)__				return__			}__			_			final List<IntermediateResult> inputs = ejv.getInputs()__			final int numInputs = inputs.size()__			boolean hasPipelinedInputs = false___			for (IntermediateResult input : inputs) {_				if (input.getResultType().isPipelined()) {_					hasPipelinedInputs = true__					break__				}_			}__			if (hasPipelinedInputs) {_				_				for (ExecutionVertex ev : ejv.getTaskVertices()) {__					_					ArrayList<ExecutionVertex> thisRegion = null___					for (int inputNum = 0_ inputNum < numInputs_ inputNum++) {_						if (inputs.get(inputNum).getResultType().isPipelined()) {__							for (ExecutionEdge edge : ev.getInputEdges(inputNum)) {_								final ExecutionVertex predecessor = edge.getSource().getProducer()__								final ArrayList<ExecutionVertex> predecessorRegion = vertexToRegion.get(predecessor)___								if (thisRegion != null) {_									_									if (predecessorRegion != thisRegion) {__										_										thisRegion.addAll(predecessorRegion)__										distinctRegions.remove(predecessorRegion)___										_										for (ExecutionVertex inPredRegion: predecessorRegion) {_											vertexToRegion.put(inPredRegion, thisRegion)__										}_									}_								}_								else if (predecessor != null) {_									_									thisRegion = predecessorRegion__									thisRegion.add(ev)__									vertexToRegion.put(ev, thisRegion)__								}_								else {_									_									_									throw new FlinkRuntimeException(_											"bug in the logic to construct the pipelined failover regions")__								}_							}_						}_					}_				}_			}_			else {_				_				for (ExecutionVertex ev : ejv.getTaskVertices()) {_					ArrayList<ExecutionVertex> region = new ArrayList<>(1)__					region.add(ev)__					vertexToRegion.put(ev, region)__					distinctRegions.put(region, null)__				}_			}_		}__		_		LOG.info("Creating {} individual failover regions for job {} ({})",_				executionGraph.getJobName(), executionGraph.getJobID())___		for (List<ExecutionVertex> region : distinctRegions.keySet()) {_			final FailoverRegion failoverRegion = new FailoverRegion(executionGraph, executor, region)__			for (ExecutionVertex ev : region) {_				this.vertexToRegion.put(ev, failoverRegion)__			}_		}_	};generate,all,the,failover,region,from,the,new,added,job,vertexes;private,void,generate,all,failover,region,list,execution,job,vertex,new,job,vertices,topological,final,identity,hash,map,execution,vertex,array,list,execution,vertex,vertex,to,region,new,identity,hash,map,final,identity,hash,map,array,list,execution,vertex,object,distinct,regions,new,identity,hash,map,for,execution,job,vertex,ejv,new,job,vertices,topological,if,ejv,get,co,location,group,null,make,all,one,region,new,job,vertices,topological,return,final,list,intermediate,result,inputs,ejv,get,inputs,final,int,num,inputs,inputs,size,boolean,has,pipelined,inputs,false,for,intermediate,result,input,inputs,if,input,get,result,type,is,pipelined,has,pipelined,inputs,true,break,if,has,pipelined,inputs,for,execution,vertex,ev,ejv,get,task,vertices,array,list,execution,vertex,this,region,null,for,int,input,num,0,input,num,num,inputs,input,num,if,inputs,get,input,num,get,result,type,is,pipelined,for,execution,edge,edge,ev,get,input,edges,input,num,final,execution,vertex,predecessor,edge,get,source,get,producer,final,array,list,execution,vertex,predecessor,region,vertex,to,region,get,predecessor,if,this,region,null,if,predecessor,region,this,region,this,region,add,all,predecessor,region,distinct,regions,remove,predecessor,region,for,execution,vertex,in,pred,region,predecessor,region,vertex,to,region,put,in,pred,region,this,region,else,if,predecessor,null,this,region,predecessor,region,this,region,add,ev,vertex,to,region,put,ev,this,region,else,throw,new,flink,runtime,exception,bug,in,the,logic,to,construct,the,pipelined,failover,regions,else,for,execution,vertex,ev,ejv,get,task,vertices,array,list,execution,vertex,region,new,array,list,1,region,add,ev,vertex,to,region,put,ev,region,distinct,regions,put,region,null,log,info,creating,individual,failover,regions,for,job,execution,graph,get,job,name,execution,graph,get,job,id,for,list,execution,vertex,region,distinct,regions,key,set,final,failover,region,failover,region,new,failover,region,execution,graph,executor,region,for,execution,vertex,ev,region,this,vertex,to,region,put,ev,failover,region
RestartPipelinedRegionStrategy -> private void generateAllFailoverRegion(List<ExecutionJobVertex> newJobVerticesTopological);1509034963;Generate all the FailoverRegion from the new added job vertexes;private void generateAllFailoverRegion(List<ExecutionJobVertex> newJobVerticesTopological) {_		final IdentityHashMap<ExecutionVertex, ArrayList<ExecutionVertex>> vertexToRegion = new IdentityHashMap<>()___		_		final IdentityHashMap<ArrayList<ExecutionVertex>, Object> distinctRegions = new IdentityHashMap<>()___		_		_		for (ExecutionJobVertex ejv : newJobVerticesTopological) {__			_			_			if (ejv.getCoLocationGroup() != null) {_				makeAllOneRegion(newJobVerticesTopological)__				return__			}__			_			final List<IntermediateResult> inputs = ejv.getInputs()__			final int numInputs = inputs.size()__			boolean hasPipelinedInputs = false___			for (IntermediateResult input : inputs) {_				if (input.getResultType().isPipelined()) {_					hasPipelinedInputs = true__					break__				}_			}__			if (hasPipelinedInputs) {_				_				for (ExecutionVertex ev : ejv.getTaskVertices()) {__					_					ArrayList<ExecutionVertex> thisRegion = null___					for (int inputNum = 0_ inputNum < numInputs_ inputNum++) {_						if (inputs.get(inputNum).getResultType().isPipelined()) {__							for (ExecutionEdge edge : ev.getInputEdges(inputNum)) {_								final ExecutionVertex predecessor = edge.getSource().getProducer()__								final ArrayList<ExecutionVertex> predecessorRegion = vertexToRegion.get(predecessor)___								if (thisRegion != null) {_									_									if (predecessorRegion != thisRegion) {__										_										predecessorRegion.addAll(thisRegion)__										distinctRegions.remove(thisRegion)__										thisRegion = predecessorRegion___										_										for (ExecutionVertex inPredRegion: predecessorRegion) {_											vertexToRegion.put(inPredRegion, thisRegion)__										}_									}_								}_								else if (predecessor != null) {_									_									thisRegion = predecessorRegion__									thisRegion.add(ev)__									vertexToRegion.put(ev, thisRegion)__								}_								else {_									_									_									throw new FlinkRuntimeException(_											"bug in the logic to construct the pipelined failover regions")__								}_							}_						}_					}_				}_			}_			else {_				_				for (ExecutionVertex ev : ejv.getTaskVertices()) {_					ArrayList<ExecutionVertex> region = new ArrayList<>(1)__					region.add(ev)__					vertexToRegion.put(ev, region)__					distinctRegions.put(region, null)__				}_			}_		}__		_		LOG.info("Creating {} individual failover regions for job {} ({})",_				executionGraph.getJobName(), executionGraph.getJobID())___		for (List<ExecutionVertex> region : distinctRegions.keySet()) {_			final FailoverRegion failoverRegion = new FailoverRegion(executionGraph, executor, region)__			for (ExecutionVertex ev : region) {_				this.vertexToRegion.put(ev, failoverRegion)__			}_		}_	};generate,all,the,failover,region,from,the,new,added,job,vertexes;private,void,generate,all,failover,region,list,execution,job,vertex,new,job,vertices,topological,final,identity,hash,map,execution,vertex,array,list,execution,vertex,vertex,to,region,new,identity,hash,map,final,identity,hash,map,array,list,execution,vertex,object,distinct,regions,new,identity,hash,map,for,execution,job,vertex,ejv,new,job,vertices,topological,if,ejv,get,co,location,group,null,make,all,one,region,new,job,vertices,topological,return,final,list,intermediate,result,inputs,ejv,get,inputs,final,int,num,inputs,inputs,size,boolean,has,pipelined,inputs,false,for,intermediate,result,input,inputs,if,input,get,result,type,is,pipelined,has,pipelined,inputs,true,break,if,has,pipelined,inputs,for,execution,vertex,ev,ejv,get,task,vertices,array,list,execution,vertex,this,region,null,for,int,input,num,0,input,num,num,inputs,input,num,if,inputs,get,input,num,get,result,type,is,pipelined,for,execution,edge,edge,ev,get,input,edges,input,num,final,execution,vertex,predecessor,edge,get,source,get,producer,final,array,list,execution,vertex,predecessor,region,vertex,to,region,get,predecessor,if,this,region,null,if,predecessor,region,this,region,predecessor,region,add,all,this,region,distinct,regions,remove,this,region,this,region,predecessor,region,for,execution,vertex,in,pred,region,predecessor,region,vertex,to,region,put,in,pred,region,this,region,else,if,predecessor,null,this,region,predecessor,region,this,region,add,ev,vertex,to,region,put,ev,this,region,else,throw,new,flink,runtime,exception,bug,in,the,logic,to,construct,the,pipelined,failover,regions,else,for,execution,vertex,ev,ejv,get,task,vertices,array,list,execution,vertex,region,new,array,list,1,region,add,ev,vertex,to,region,put,ev,region,distinct,regions,put,region,null,log,info,creating,individual,failover,regions,for,job,execution,graph,get,job,name,execution,graph,get,job,id,for,list,execution,vertex,region,distinct,regions,key,set,final,failover,region,failover,region,new,failover,region,execution,graph,executor,region,for,execution,vertex,ev,region,this,vertex,to,region,put,ev,failover,region
RestartPipelinedRegionStrategy -> private void generateAllFailoverRegion(List<ExecutionJobVertex> newJobVerticesTopological);1543229263;Generate all the FailoverRegion from the new added job vertexes;private void generateAllFailoverRegion(List<ExecutionJobVertex> newJobVerticesTopological) {_		final IdentityHashMap<ExecutionVertex, ArrayList<ExecutionVertex>> vertexToRegion = new IdentityHashMap<>()___		_		final IdentityHashMap<ArrayList<ExecutionVertex>, Object> distinctRegions = new IdentityHashMap<>()___		_		_		for (ExecutionJobVertex ejv : newJobVerticesTopological) {__			_			_			if (ejv.getCoLocationGroup() != null) {_				makeAllOneRegion(newJobVerticesTopological)__				return__			}__			_			final List<IntermediateResult> inputs = ejv.getInputs()__			final int numInputs = inputs.size()__			boolean hasPipelinedInputs = false___			for (IntermediateResult input : inputs) {_				if (input.getResultType().isPipelined()) {_					hasPipelinedInputs = true__					break__				}_			}__			if (hasPipelinedInputs) {_				_				for (ExecutionVertex ev : ejv.getTaskVertices()) {__					_					ArrayList<ExecutionVertex> thisRegion = null___					for (int inputNum = 0_ inputNum < numInputs_ inputNum++) {_						if (inputs.get(inputNum).getResultType().isPipelined()) {__							for (ExecutionEdge edge : ev.getInputEdges(inputNum)) {_								final ExecutionVertex predecessor = edge.getSource().getProducer()__								final ArrayList<ExecutionVertex> predecessorRegion = vertexToRegion.get(predecessor)___								if (thisRegion != null) {_									_									if (predecessorRegion != thisRegion) {__										_										predecessorRegion.addAll(thisRegion)__										distinctRegions.remove(thisRegion)__										thisRegion = predecessorRegion___										_										for (ExecutionVertex inPredRegion: predecessorRegion) {_											vertexToRegion.put(inPredRegion, thisRegion)__										}_									}_								}_								else if (predecessor != null) {_									_									thisRegion = predecessorRegion__									thisRegion.add(ev)__									vertexToRegion.put(ev, thisRegion)__								}_								else {_									_									_									throw new FlinkRuntimeException(_											"bug in the logic to construct the pipelined failover regions")__								}_							}_						}_					}_				}_			}_			else {_				_				for (ExecutionVertex ev : ejv.getTaskVertices()) {_					ArrayList<ExecutionVertex> region = new ArrayList<>(1)__					region.add(ev)__					vertexToRegion.put(ev, region)__					distinctRegions.put(region, null)__				}_			}_		}__		_		LOG.info("Creating {} individual failover regions for job {} ({})",_				distinctRegions.size(), executionGraph.getJobName(), executionGraph.getJobID())___		for (List<ExecutionVertex> region : distinctRegions.keySet()) {_			final FailoverRegion failoverRegion = createFailoverRegion(executionGraph, region)__			for (ExecutionVertex ev : region) {_				this.vertexToRegion.put(ev, failoverRegion)__			}_		}_	};generate,all,the,failover,region,from,the,new,added,job,vertexes;private,void,generate,all,failover,region,list,execution,job,vertex,new,job,vertices,topological,final,identity,hash,map,execution,vertex,array,list,execution,vertex,vertex,to,region,new,identity,hash,map,final,identity,hash,map,array,list,execution,vertex,object,distinct,regions,new,identity,hash,map,for,execution,job,vertex,ejv,new,job,vertices,topological,if,ejv,get,co,location,group,null,make,all,one,region,new,job,vertices,topological,return,final,list,intermediate,result,inputs,ejv,get,inputs,final,int,num,inputs,inputs,size,boolean,has,pipelined,inputs,false,for,intermediate,result,input,inputs,if,input,get,result,type,is,pipelined,has,pipelined,inputs,true,break,if,has,pipelined,inputs,for,execution,vertex,ev,ejv,get,task,vertices,array,list,execution,vertex,this,region,null,for,int,input,num,0,input,num,num,inputs,input,num,if,inputs,get,input,num,get,result,type,is,pipelined,for,execution,edge,edge,ev,get,input,edges,input,num,final,execution,vertex,predecessor,edge,get,source,get,producer,final,array,list,execution,vertex,predecessor,region,vertex,to,region,get,predecessor,if,this,region,null,if,predecessor,region,this,region,predecessor,region,add,all,this,region,distinct,regions,remove,this,region,this,region,predecessor,region,for,execution,vertex,in,pred,region,predecessor,region,vertex,to,region,put,in,pred,region,this,region,else,if,predecessor,null,this,region,predecessor,region,this,region,add,ev,vertex,to,region,put,ev,this,region,else,throw,new,flink,runtime,exception,bug,in,the,logic,to,construct,the,pipelined,failover,regions,else,for,execution,vertex,ev,ejv,get,task,vertices,array,list,execution,vertex,region,new,array,list,1,region,add,ev,vertex,to,region,put,ev,region,distinct,regions,put,region,null,log,info,creating,individual,failover,regions,for,job,distinct,regions,size,execution,graph,get,job,name,execution,graph,get,job,id,for,list,execution,vertex,region,distinct,regions,key,set,final,failover,region,failover,region,create,failover,region,execution,graph,region,for,execution,vertex,ev,region,this,vertex,to,region,put,ev,failover,region
RestartPipelinedRegionStrategy -> private void generateAllFailoverRegion(List<ExecutionJobVertex> newJobVerticesTopological);1548717762;Generate all the FailoverRegion from the new added job vertexes;private void generateAllFailoverRegion(List<ExecutionJobVertex> newJobVerticesTopological) {_		final IdentityHashMap<ExecutionVertex, ArrayList<ExecutionVertex>> vertexToRegion = new IdentityHashMap<>()___		_		final IdentityHashMap<ArrayList<ExecutionVertex>, Object> distinctRegions = new IdentityHashMap<>()___		_		_		for (ExecutionJobVertex ejv : newJobVerticesTopological) {__			_			_			if (ejv.getCoLocationGroup() != null) {_				makeAllOneRegion(newJobVerticesTopological)__				return__			}__			_			final List<IntermediateResult> inputs = ejv.getInputs()__			final int numInputs = inputs.size()__			boolean hasPipelinedInputs = false___			for (IntermediateResult input : inputs) {_				if (input.getResultType().isPipelined()) {_					hasPipelinedInputs = true__					break__				}_			}__			if (hasPipelinedInputs) {_				_				for (ExecutionVertex ev : ejv.getTaskVertices()) {__					_					ArrayList<ExecutionVertex> thisRegion = null___					for (int inputNum = 0_ inputNum < numInputs_ inputNum++) {_						if (inputs.get(inputNum).getResultType().isPipelined()) {__							for (ExecutionEdge edge : ev.getInputEdges(inputNum)) {_								final ExecutionVertex predecessor = edge.getSource().getProducer()__								final ArrayList<ExecutionVertex> predecessorRegion = vertexToRegion.get(predecessor)___								if (thisRegion != null) {_									_									if (predecessorRegion != thisRegion) {__										_										predecessorRegion.addAll(thisRegion)__										distinctRegions.remove(thisRegion)__										thisRegion = predecessorRegion___										_										for (ExecutionVertex inPredRegion: predecessorRegion) {_											vertexToRegion.put(inPredRegion, thisRegion)__										}_									}_								}_								else if (predecessor != null) {_									_									thisRegion = predecessorRegion__									thisRegion.add(ev)__									vertexToRegion.put(ev, thisRegion)__								}_								else {_									_									_									throw new FlinkRuntimeException(_											"bug in the logic to construct the pipelined failover regions")__								}_							}_						}_					}_				}_			}_			else {_				_				for (ExecutionVertex ev : ejv.getTaskVertices()) {_					ArrayList<ExecutionVertex> region = new ArrayList<>(1)__					region.add(ev)__					vertexToRegion.put(ev, region)__					distinctRegions.put(region, null)__				}_			}_		}__		_		LOG.info("Creating {} individual failover regions for job {} ({})",_				distinctRegions.size(), executionGraph.getJobName(), executionGraph.getJobID())___		for (List<ExecutionVertex> region : distinctRegions.keySet()) {_			final FailoverRegion failoverRegion = new FailoverRegion(executionGraph, executor, region)__			for (ExecutionVertex ev : region) {_				this.vertexToRegion.put(ev, failoverRegion)__			}_		}_	};generate,all,the,failover,region,from,the,new,added,job,vertexes;private,void,generate,all,failover,region,list,execution,job,vertex,new,job,vertices,topological,final,identity,hash,map,execution,vertex,array,list,execution,vertex,vertex,to,region,new,identity,hash,map,final,identity,hash,map,array,list,execution,vertex,object,distinct,regions,new,identity,hash,map,for,execution,job,vertex,ejv,new,job,vertices,topological,if,ejv,get,co,location,group,null,make,all,one,region,new,job,vertices,topological,return,final,list,intermediate,result,inputs,ejv,get,inputs,final,int,num,inputs,inputs,size,boolean,has,pipelined,inputs,false,for,intermediate,result,input,inputs,if,input,get,result,type,is,pipelined,has,pipelined,inputs,true,break,if,has,pipelined,inputs,for,execution,vertex,ev,ejv,get,task,vertices,array,list,execution,vertex,this,region,null,for,int,input,num,0,input,num,num,inputs,input,num,if,inputs,get,input,num,get,result,type,is,pipelined,for,execution,edge,edge,ev,get,input,edges,input,num,final,execution,vertex,predecessor,edge,get,source,get,producer,final,array,list,execution,vertex,predecessor,region,vertex,to,region,get,predecessor,if,this,region,null,if,predecessor,region,this,region,predecessor,region,add,all,this,region,distinct,regions,remove,this,region,this,region,predecessor,region,for,execution,vertex,in,pred,region,predecessor,region,vertex,to,region,put,in,pred,region,this,region,else,if,predecessor,null,this,region,predecessor,region,this,region,add,ev,vertex,to,region,put,ev,this,region,else,throw,new,flink,runtime,exception,bug,in,the,logic,to,construct,the,pipelined,failover,regions,else,for,execution,vertex,ev,ejv,get,task,vertices,array,list,execution,vertex,region,new,array,list,1,region,add,ev,vertex,to,region,put,ev,region,distinct,regions,put,region,null,log,info,creating,individual,failover,regions,for,job,distinct,regions,size,execution,graph,get,job,name,execution,graph,get,job,id,for,list,execution,vertex,region,distinct,regions,key,set,final,failover,region,failover,region,new,failover,region,execution,graph,executor,region,for,execution,vertex,ev,region,this,vertex,to,region,put,ev,failover,region
RestartPipelinedRegionStrategy -> public RestartPipelinedRegionStrategy(ExecutionGraph executionGraph);1492496129;Creates a new failover strategy to restart pipelined regions that works on the given_execution graph and uses the execution graph's future executor to call restart actions.__@param executionGraph The execution graph on which this FailoverStrategy will work;public RestartPipelinedRegionStrategy(ExecutionGraph executionGraph) {_		this(executionGraph, executionGraph.getFutureExecutor())__	};creates,a,new,failover,strategy,to,restart,pipelined,regions,that,works,on,the,given,execution,graph,and,uses,the,execution,graph,s,future,executor,to,call,restart,actions,param,execution,graph,the,execution,graph,on,which,this,failover,strategy,will,work;public,restart,pipelined,region,strategy,execution,graph,execution,graph,this,execution,graph,execution,graph,get,future,executor
RestartPipelinedRegionStrategy -> public RestartPipelinedRegionStrategy(ExecutionGraph executionGraph);1492725739;Creates a new failover strategy to restart pipelined regions that works on the given_execution graph and uses the execution graph's future executor to call restart actions.__@param executionGraph The execution graph on which this FailoverStrategy will work;public RestartPipelinedRegionStrategy(ExecutionGraph executionGraph) {_		this(executionGraph, executionGraph.getFutureExecutor())__	};creates,a,new,failover,strategy,to,restart,pipelined,regions,that,works,on,the,given,execution,graph,and,uses,the,execution,graph,s,future,executor,to,call,restart,actions,param,execution,graph,the,execution,graph,on,which,this,failover,strategy,will,work;public,restart,pipelined,region,strategy,execution,graph,execution,graph,this,execution,graph,execution,graph,get,future,executor
RestartPipelinedRegionStrategy -> public RestartPipelinedRegionStrategy(ExecutionGraph executionGraph);1509034963;Creates a new failover strategy to restart pipelined regions that works on the given_execution graph and uses the execution graph's future executor to call restart actions.__@param executionGraph The execution graph on which this FailoverStrategy will work;public RestartPipelinedRegionStrategy(ExecutionGraph executionGraph) {_		this(executionGraph, executionGraph.getFutureExecutor())__	};creates,a,new,failover,strategy,to,restart,pipelined,regions,that,works,on,the,given,execution,graph,and,uses,the,execution,graph,s,future,executor,to,call,restart,actions,param,execution,graph,the,execution,graph,on,which,this,failover,strategy,will,work;public,restart,pipelined,region,strategy,execution,graph,execution,graph,this,execution,graph,execution,graph,get,future,executor
RestartPipelinedRegionStrategy -> public RestartPipelinedRegionStrategy(ExecutionGraph executionGraph);1543229263;Creates a new failover strategy to restart pipelined regions that works on the given_execution graph.__@param executionGraph The execution graph on which this FailoverStrategy will work;public RestartPipelinedRegionStrategy(ExecutionGraph executionGraph) {_		this.executionGraph = checkNotNull(executionGraph)__		this.vertexToRegion = new HashMap<>()__	};creates,a,new,failover,strategy,to,restart,pipelined,regions,that,works,on,the,given,execution,graph,param,execution,graph,the,execution,graph,on,which,this,failover,strategy,will,work;public,restart,pipelined,region,strategy,execution,graph,execution,graph,this,execution,graph,check,not,null,execution,graph,this,vertex,to,region,new,hash,map
RestartPipelinedRegionStrategy -> public RestartPipelinedRegionStrategy(ExecutionGraph executionGraph);1548717762;Creates a new failover strategy to restart pipelined regions that works on the given_execution graph and uses the execution graph's future executor to call restart actions.__@param executionGraph The execution graph on which this FailoverStrategy will work;public RestartPipelinedRegionStrategy(ExecutionGraph executionGraph) {_		this(executionGraph, executionGraph.getFutureExecutor())__	};creates,a,new,failover,strategy,to,restart,pipelined,regions,that,works,on,the,given,execution,graph,and,uses,the,execution,graph,s,future,executor,to,call,restart,actions,param,execution,graph,the,execution,graph,on,which,this,failover,strategy,will,work;public,restart,pipelined,region,strategy,execution,graph,execution,graph,this,execution,graph,execution,graph,get,future,executor
