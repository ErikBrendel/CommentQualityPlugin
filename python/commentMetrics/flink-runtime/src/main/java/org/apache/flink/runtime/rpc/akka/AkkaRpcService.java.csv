# id;timestamp;commentText;codeText;commentWords;codeWords
AkkaRpcService -> @Override 	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz);1470854565;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz) {_		checkState(!stopped, "RpcService is stopped")___		LOG.debug("Try to connect to remote RPC endpoint with address {}. Returning a {} gateway.",_				address, clazz.getName())___		final ActorSelection actorSel = actorSystem.actorSelection(address)__		final AskableActorSelection asker = new AskableActorSelection(actorSel)___		final Future<Object> identify = asker.ask(new Identify(42), timeout)__		return identify.map(new Mapper<Object, C>(){_			@Override_			public C apply(Object obj) {_				ActorRef actorRef = ((ActorIdentity) obj).getRef()___				InvocationHandler akkaInvocationHandler = new AkkaInvocationHandler(actorRef, timeout, maximumFramesize)___				@SuppressWarnings("unchecked")_				C proxy = (C) Proxy.newProxyInstance(_					ClassLoader.getSystemClassLoader(),_					new Class<?>[] {clazz},_					akkaInvocationHandler)___				return proxy__			}_		}, actorSystem.dispatcher())__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,future,c,connect,final,string,address,final,class,c,clazz,check,state,stopped,rpc,service,is,stopped,log,debug,try,to,connect,to,remote,rpc,endpoint,with,address,returning,a,gateway,address,clazz,get,name,final,actor,selection,actor,sel,actor,system,actor,selection,address,final,askable,actor,selection,asker,new,askable,actor,selection,actor,sel,final,future,object,identify,asker,ask,new,identify,42,timeout,return,identify,map,new,mapper,object,c,override,public,c,apply,object,obj,actor,ref,actor,ref,actor,identity,obj,get,ref,invocation,handler,akka,invocation,handler,new,akka,invocation,handler,actor,ref,timeout,maximum,framesize,suppress,warnings,unchecked,c,proxy,c,proxy,new,proxy,instance,class,loader,get,system,class,loader,new,class,clazz,akka,invocation,handler,return,proxy,actor,system,dispatcher
AkkaRpcService -> @Override 	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz);1470932005;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz) {_		checkState(!stopped, "RpcService is stopped")___		LOG.debug("Try to connect to remote RPC endpoint with address {}. Returning a {} gateway.",_				address, clazz.getName())___		final ActorSelection actorSel = actorSystem.actorSelection(address)__		final AskableActorSelection asker = new AskableActorSelection(actorSel)___		final Future<Object> identify = asker.ask(new Identify(42), timeout)__		return identify.map(new Mapper<Object, C>(){_			@Override_			public C apply(Object obj) {_				ActorRef actorRef = ((ActorIdentity) obj).getRef()___				InvocationHandler akkaInvocationHandler = new AkkaInvocationHandler(actorRef, timeout, maximumFramesize)___				@SuppressWarnings("unchecked")_				C proxy = (C) Proxy.newProxyInstance(_					ClassLoader.getSystemClassLoader(),_					new Class<?>[] {clazz},_					akkaInvocationHandler)___				return proxy__			}_		}, actorSystem.dispatcher())__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,future,c,connect,final,string,address,final,class,c,clazz,check,state,stopped,rpc,service,is,stopped,log,debug,try,to,connect,to,remote,rpc,endpoint,with,address,returning,a,gateway,address,clazz,get,name,final,actor,selection,actor,sel,actor,system,actor,selection,address,final,askable,actor,selection,asker,new,askable,actor,selection,actor,sel,final,future,object,identify,asker,ask,new,identify,42,timeout,return,identify,map,new,mapper,object,c,override,public,c,apply,object,obj,actor,ref,actor,ref,actor,identity,obj,get,ref,invocation,handler,akka,invocation,handler,new,akka,invocation,handler,actor,ref,timeout,maximum,framesize,suppress,warnings,unchecked,c,proxy,c,proxy,new,proxy,instance,class,loader,get,system,class,loader,new,class,clazz,akka,invocation,handler,return,proxy,actor,system,dispatcher
AkkaRpcService -> @Override 	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz);1470940254;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz) {_		checkState(!stopped, "RpcService is stopped")___		LOG.debug("Try to connect to remote RPC endpoint with address {}. Returning a {} gateway.",_				address, clazz.getName())___		final ActorSelection actorSel = actorSystem.actorSelection(address)__		final AskableActorSelection asker = new AskableActorSelection(actorSel)___		final Future<Object> identify = asker.ask(new Identify(42), timeout)__		return identify.map(new Mapper<Object, C>(){_			@Override_			public C apply(Object obj) {_				ActorRef actorRef = ((ActorIdentity) obj).getRef()___				InvocationHandler akkaInvocationHandler = new AkkaInvocationHandler(actorRef, timeout)___				@SuppressWarnings("unchecked")_				C proxy = (C) Proxy.newProxyInstance(_					ClassLoader.getSystemClassLoader(),_					new Class<?>[] {clazz},_					akkaInvocationHandler)___				return proxy__			}_		}, actorSystem.dispatcher())__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,future,c,connect,final,string,address,final,class,c,clazz,check,state,stopped,rpc,service,is,stopped,log,debug,try,to,connect,to,remote,rpc,endpoint,with,address,returning,a,gateway,address,clazz,get,name,final,actor,selection,actor,sel,actor,system,actor,selection,address,final,askable,actor,selection,asker,new,askable,actor,selection,actor,sel,final,future,object,identify,asker,ask,new,identify,42,timeout,return,identify,map,new,mapper,object,c,override,public,c,apply,object,obj,actor,ref,actor,ref,actor,identity,obj,get,ref,invocation,handler,akka,invocation,handler,new,akka,invocation,handler,actor,ref,timeout,suppress,warnings,unchecked,c,proxy,c,proxy,new,proxy,instance,class,loader,get,system,class,loader,new,class,clazz,akka,invocation,handler,return,proxy,actor,system,dispatcher
AkkaRpcService -> @Override 	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz);1470990750;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz) {_		checkState(!stopped, "RpcService is stopped")___		LOG.debug("Try to connect to remote RPC endpoint with address {}. Returning a {} gateway.",_				address, clazz.getName())___		final ActorSelection actorSel = actorSystem.actorSelection(address)__		final AskableActorSelection asker = new AskableActorSelection(actorSel)___		final Future<Object> identify = asker.ask(new Identify(42), timeout)__		return identify.map(new Mapper<Object, C>(){_			@Override_			public C apply(Object obj) {_				ActorRef actorRef = ((ActorIdentity) obj).getRef()___				InvocationHandler akkaInvocationHandler = new AkkaInvocationHandler(actorRef, timeout, maximumFramesize)___				@SuppressWarnings("unchecked")_				C proxy = (C) Proxy.newProxyInstance(_					ClassLoader.getSystemClassLoader(),_					new Class<?>[] {clazz},_					akkaInvocationHandler)___				return proxy__			}_		}, actorSystem.dispatcher())__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,future,c,connect,final,string,address,final,class,c,clazz,check,state,stopped,rpc,service,is,stopped,log,debug,try,to,connect,to,remote,rpc,endpoint,with,address,returning,a,gateway,address,clazz,get,name,final,actor,selection,actor,sel,actor,system,actor,selection,address,final,askable,actor,selection,asker,new,askable,actor,selection,actor,sel,final,future,object,identify,asker,ask,new,identify,42,timeout,return,identify,map,new,mapper,object,c,override,public,c,apply,object,obj,actor,ref,actor,ref,actor,identity,obj,get,ref,invocation,handler,akka,invocation,handler,new,akka,invocation,handler,actor,ref,timeout,maximum,framesize,suppress,warnings,unchecked,c,proxy,c,proxy,new,proxy,instance,class,loader,get,system,class,loader,new,class,clazz,akka,invocation,handler,return,proxy,actor,system,dispatcher
AkkaRpcService -> @Override 	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz);1471108307;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz) {_		checkState(!stopped, "RpcService is stopped")___		LOG.debug("Try to connect to remote RPC endpoint with address {}. Returning a {} gateway.",_				address, clazz.getName())___		final ActorSelection actorSel = actorSystem.actorSelection(address)__		final AskableActorSelection asker = new AskableActorSelection(actorSel)___		final Future<Object> identify = asker.ask(new Identify(42), timeout)__		return identify.map(new Mapper<Object, C>(){_			@Override_			public C apply(Object obj) {_				ActorRef actorRef = ((ActorIdentity) obj).getRef()___				InvocationHandler akkaInvocationHandler = new AkkaInvocationHandler(actorRef, timeout)___				@SuppressWarnings("unchecked")_				C proxy = (C) Proxy.newProxyInstance(_					ClassLoader.getSystemClassLoader(),_					new Class<?>[] {clazz},_					akkaInvocationHandler)___				return proxy__			}_		}, actorSystem.dispatcher())__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,future,c,connect,final,string,address,final,class,c,clazz,check,state,stopped,rpc,service,is,stopped,log,debug,try,to,connect,to,remote,rpc,endpoint,with,address,returning,a,gateway,address,clazz,get,name,final,actor,selection,actor,sel,actor,system,actor,selection,address,final,askable,actor,selection,asker,new,askable,actor,selection,actor,sel,final,future,object,identify,asker,ask,new,identify,42,timeout,return,identify,map,new,mapper,object,c,override,public,c,apply,object,obj,actor,ref,actor,ref,actor,identity,obj,get,ref,invocation,handler,akka,invocation,handler,new,akka,invocation,handler,actor,ref,timeout,suppress,warnings,unchecked,c,proxy,c,proxy,new,proxy,instance,class,loader,get,system,class,loader,new,class,clazz,akka,invocation,handler,return,proxy,actor,system,dispatcher
AkkaRpcService -> @Override 	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz);1471374661;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz) {_		checkState(!stopped, "RpcService is stopped")___		LOG.debug("Try to connect to remote RPC endpoint with address {}. Returning a {} gateway.",_				address, clazz.getName())___		final ActorSelection actorSel = actorSystem.actorSelection(address)__		final AskableActorSelection asker = new AskableActorSelection(actorSel)___		final Future<Object> identify = asker.ask(new Identify(42), timeout)__		return identify.map(new Mapper<Object, C>(){_			@Override_			public C apply(Object obj) {_				ActorRef actorRef = ((ActorIdentity) obj).getRef()___				InvocationHandler akkaInvocationHandler = new AkkaInvocationHandler(actorRef, timeout, maximumFramesize)___				_				_				_				ClassLoader classLoader = AkkaRpcService.this.getClass().getClassLoader()__				_				@SuppressWarnings("unchecked")_				C proxy = (C) Proxy.newProxyInstance(_					classLoader,_					new Class<?>[] {clazz},_					akkaInvocationHandler)___				return proxy__			}_		}, actorSystem.dispatcher())__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,future,c,connect,final,string,address,final,class,c,clazz,check,state,stopped,rpc,service,is,stopped,log,debug,try,to,connect,to,remote,rpc,endpoint,with,address,returning,a,gateway,address,clazz,get,name,final,actor,selection,actor,sel,actor,system,actor,selection,address,final,askable,actor,selection,asker,new,askable,actor,selection,actor,sel,final,future,object,identify,asker,ask,new,identify,42,timeout,return,identify,map,new,mapper,object,c,override,public,c,apply,object,obj,actor,ref,actor,ref,actor,identity,obj,get,ref,invocation,handler,akka,invocation,handler,new,akka,invocation,handler,actor,ref,timeout,maximum,framesize,class,loader,class,loader,akka,rpc,service,this,get,class,get,class,loader,suppress,warnings,unchecked,c,proxy,c,proxy,new,proxy,instance,class,loader,new,class,clazz,akka,invocation,handler,return,proxy,actor,system,dispatcher
AkkaRpcService -> @Override 	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz);1471530887;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz) {_		checkState(!stopped, "RpcService is stopped")___		LOG.debug("Try to connect to remote RPC endpoint with address {}. Returning a {} gateway.",_				address, clazz.getName())___		final ActorSelection actorSel = actorSystem.actorSelection(address)__		final AskableActorSelection asker = new AskableActorSelection(actorSel)___		final Future<Object> identify = asker.ask(new Identify(42), timeout)__		return identify.map(new Mapper<Object, C>(){_			@Override_			public C apply(Object obj) {_				ActorRef actorRef = ((ActorIdentity) obj).getRef()___				final String address = AkkaUtils.getAkkaURL(actorSystem, actorRef)___				InvocationHandler akkaInvocationHandler = new AkkaInvocationHandler(address, actorRef, timeout, maximumFramesize)___				_				_				_				ClassLoader classLoader = AkkaRpcService.this.getClass().getClassLoader()__				_				@SuppressWarnings("unchecked")_				C proxy = (C) Proxy.newProxyInstance(_					classLoader,_					new Class<?>[] {clazz},_					akkaInvocationHandler)___				return proxy__			}_		}, actorSystem.dispatcher())__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,future,c,connect,final,string,address,final,class,c,clazz,check,state,stopped,rpc,service,is,stopped,log,debug,try,to,connect,to,remote,rpc,endpoint,with,address,returning,a,gateway,address,clazz,get,name,final,actor,selection,actor,sel,actor,system,actor,selection,address,final,askable,actor,selection,asker,new,askable,actor,selection,actor,sel,final,future,object,identify,asker,ask,new,identify,42,timeout,return,identify,map,new,mapper,object,c,override,public,c,apply,object,obj,actor,ref,actor,ref,actor,identity,obj,get,ref,final,string,address,akka,utils,get,akka,url,actor,system,actor,ref,invocation,handler,akka,invocation,handler,new,akka,invocation,handler,address,actor,ref,timeout,maximum,framesize,class,loader,class,loader,akka,rpc,service,this,get,class,get,class,loader,suppress,warnings,unchecked,c,proxy,c,proxy,new,proxy,instance,class,loader,new,class,clazz,akka,invocation,handler,return,proxy,actor,system,dispatcher
AkkaRpcService -> @Override 	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz);1471967994;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz) {_		checkState(!stopped, "RpcService is stopped")___		LOG.debug("Try to connect to remote RPC endpoint with address {}. Returning a {} gateway.",_				address, clazz.getName())___		final ActorSelection actorSel = actorSystem.actorSelection(address)__		final AskableActorSelection asker = new AskableActorSelection(actorSel)___		final Future<Object> identify = asker.ask(new Identify(42), timeout)__		return identify.map(new Mapper<Object, C>(){_			@Override_			public C checkedApply(Object obj) throws Exception {__				ActorIdentity actorIdentity = (ActorIdentity) obj___				if (actorIdentity.getRef() == null) {_					throw new RpcConnectionException("Could not connect to rpc endpoint under address " + address + '.')__				} else {_					ActorRef actorRef = actorIdentity.getRef()___					final String address = AkkaUtils.getAkkaURL(actorSystem, actorRef)___					InvocationHandler akkaInvocationHandler = new AkkaInvocationHandler(address, actorRef, timeout, maximumFramesize)___					_					_					_					ClassLoader classLoader = AkkaRpcService.this.getClass().getClassLoader()___					@SuppressWarnings("unchecked")_					C proxy = (C) Proxy.newProxyInstance(_						classLoader,_						new Class<?>[]{clazz},_						akkaInvocationHandler)___					return proxy__				}_			}_		}, actorSystem.dispatcher())__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,future,c,connect,final,string,address,final,class,c,clazz,check,state,stopped,rpc,service,is,stopped,log,debug,try,to,connect,to,remote,rpc,endpoint,with,address,returning,a,gateway,address,clazz,get,name,final,actor,selection,actor,sel,actor,system,actor,selection,address,final,askable,actor,selection,asker,new,askable,actor,selection,actor,sel,final,future,object,identify,asker,ask,new,identify,42,timeout,return,identify,map,new,mapper,object,c,override,public,c,checked,apply,object,obj,throws,exception,actor,identity,actor,identity,actor,identity,obj,if,actor,identity,get,ref,null,throw,new,rpc,connection,exception,could,not,connect,to,rpc,endpoint,under,address,address,else,actor,ref,actor,ref,actor,identity,get,ref,final,string,address,akka,utils,get,akka,url,actor,system,actor,ref,invocation,handler,akka,invocation,handler,new,akka,invocation,handler,address,actor,ref,timeout,maximum,framesize,class,loader,class,loader,akka,rpc,service,this,get,class,get,class,loader,suppress,warnings,unchecked,c,proxy,c,proxy,new,proxy,instance,class,loader,new,class,clazz,akka,invocation,handler,return,proxy,actor,system,dispatcher
AkkaRpcService -> @Override 	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz);1474453995;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz) {_		checkState(!stopped, "RpcService is stopped")___		LOG.debug("Try to connect to remote RPC endpoint with address {}. Returning a {} gateway.",_				address, clazz.getName())___		final ActorSelection actorSel = actorSystem.actorSelection(address)___		final scala.concurrent.Future<Object> identify = Patterns.ask(actorSel, new Identify(42), timeout.toMilliseconds())__		final scala.concurrent.Future<C> resultFuture = identify.map(new Mapper<Object, C>(){_			@Override_			public C checkedApply(Object obj) throws Exception {__				ActorIdentity actorIdentity = (ActorIdentity) obj___				if (actorIdentity.getRef() == null) {_					throw new RpcConnectionException("Could not connect to rpc endpoint under address " + address + '.')__				} else {_					ActorRef actorRef = actorIdentity.getRef()___					final String address = AkkaUtils.getAkkaURL(actorSystem, actorRef)___					InvocationHandler akkaInvocationHandler = new AkkaInvocationHandler(address, actorRef, timeout, maximumFramesize)___					_					_					_					ClassLoader classLoader = AkkaRpcService.this.getClass().getClassLoader()___					@SuppressWarnings("unchecked")_					C proxy = (C) Proxy.newProxyInstance(_						classLoader,_						new Class<?>[]{clazz},_						akkaInvocationHandler)___					return proxy__				}_			}_		}, actorSystem.dispatcher())___		return new FlinkFuture<>(resultFuture)__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,future,c,connect,final,string,address,final,class,c,clazz,check,state,stopped,rpc,service,is,stopped,log,debug,try,to,connect,to,remote,rpc,endpoint,with,address,returning,a,gateway,address,clazz,get,name,final,actor,selection,actor,sel,actor,system,actor,selection,address,final,scala,concurrent,future,object,identify,patterns,ask,actor,sel,new,identify,42,timeout,to,milliseconds,final,scala,concurrent,future,c,result,future,identify,map,new,mapper,object,c,override,public,c,checked,apply,object,obj,throws,exception,actor,identity,actor,identity,actor,identity,obj,if,actor,identity,get,ref,null,throw,new,rpc,connection,exception,could,not,connect,to,rpc,endpoint,under,address,address,else,actor,ref,actor,ref,actor,identity,get,ref,final,string,address,akka,utils,get,akka,url,actor,system,actor,ref,invocation,handler,akka,invocation,handler,new,akka,invocation,handler,address,actor,ref,timeout,maximum,framesize,class,loader,class,loader,akka,rpc,service,this,get,class,get,class,loader,suppress,warnings,unchecked,c,proxy,c,proxy,new,proxy,instance,class,loader,new,class,clazz,akka,invocation,handler,return,proxy,actor,system,dispatcher,return,new,flink,future,result,future
AkkaRpcService -> @Override 	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz);1474471581;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz) {_		checkState(!stopped, "RpcService is stopped")___		LOG.debug("Try to connect to remote RPC endpoint with address {}. Returning a {} gateway.",_				address, clazz.getName())___		final ActorSelection actorSel = actorSystem.actorSelection(address)___		final scala.concurrent.Future<Object> identify = Patterns.ask(actorSel, new Identify(42), timeout.toMilliseconds())__		final scala.concurrent.Future<C> resultFuture = identify.map(new Mapper<Object, C>(){_			@Override_			public C checkedApply(Object obj) throws Exception {__				ActorIdentity actorIdentity = (ActorIdentity) obj___				if (actorIdentity.getRef() == null) {_					throw new RpcConnectionException("Could not connect to rpc endpoint under address " + address + '.')__				} else {_					ActorRef actorRef = actorIdentity.getRef()___					final String address = AkkaUtils.getAkkaURL(actorSystem, actorRef)___					InvocationHandler akkaInvocationHandler = new AkkaInvocationHandler(address, actorRef, timeout, maximumFramesize)___					_					_					_					ClassLoader classLoader = AkkaRpcService.this.getClass().getClassLoader()___					@SuppressWarnings("unchecked")_					C proxy = (C) Proxy.newProxyInstance(_						classLoader,_						new Class<?>[]{clazz},_						akkaInvocationHandler)___					return proxy__				}_			}_		}, actorSystem.dispatcher())___		return new FlinkFuture<>(resultFuture)__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,future,c,connect,final,string,address,final,class,c,clazz,check,state,stopped,rpc,service,is,stopped,log,debug,try,to,connect,to,remote,rpc,endpoint,with,address,returning,a,gateway,address,clazz,get,name,final,actor,selection,actor,sel,actor,system,actor,selection,address,final,scala,concurrent,future,object,identify,patterns,ask,actor,sel,new,identify,42,timeout,to,milliseconds,final,scala,concurrent,future,c,result,future,identify,map,new,mapper,object,c,override,public,c,checked,apply,object,obj,throws,exception,actor,identity,actor,identity,actor,identity,obj,if,actor,identity,get,ref,null,throw,new,rpc,connection,exception,could,not,connect,to,rpc,endpoint,under,address,address,else,actor,ref,actor,ref,actor,identity,get,ref,final,string,address,akka,utils,get,akka,url,actor,system,actor,ref,invocation,handler,akka,invocation,handler,new,akka,invocation,handler,address,actor,ref,timeout,maximum,framesize,class,loader,class,loader,akka,rpc,service,this,get,class,get,class,loader,suppress,warnings,unchecked,c,proxy,c,proxy,new,proxy,instance,class,loader,new,class,clazz,akka,invocation,handler,return,proxy,actor,system,dispatcher,return,new,flink,future,result,future
AkkaRpcService -> @Override 	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz);1474474587;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz) {_		checkState(!stopped, "RpcService is stopped")___		LOG.debug("Try to connect to remote RPC endpoint with address {}. Returning a {} gateway.",_				address, clazz.getName())___		final ActorSelection actorSel = actorSystem.actorSelection(address)___		final scala.concurrent.Future<Object> identify = Patterns.ask(actorSel, new Identify(42), timeout.toMilliseconds())__		final scala.concurrent.Future<C> resultFuture = identify.map(new Mapper<Object, C>(){_			@Override_			public C checkedApply(Object obj) throws Exception {__				ActorIdentity actorIdentity = (ActorIdentity) obj___				if (actorIdentity.getRef() == null) {_					throw new RpcConnectionException("Could not connect to rpc endpoint under address " + address + '.')__				} else {_					ActorRef actorRef = actorIdentity.getRef()___					final String address = AkkaUtils.getAkkaURL(actorSystem, actorRef)___					InvocationHandler akkaInvocationHandler = new AkkaInvocationHandler(address, actorRef, timeout, maximumFramesize)___					_					_					_					ClassLoader classLoader = AkkaRpcService.this.getClass().getClassLoader()___					@SuppressWarnings("unchecked")_					C proxy = (C) Proxy.newProxyInstance(_						classLoader,_						new Class<?>[]{clazz},_						akkaInvocationHandler)___					return proxy__				}_			}_		}, actorSystem.dispatcher())___		return new FlinkFuture<>(resultFuture)__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,future,c,connect,final,string,address,final,class,c,clazz,check,state,stopped,rpc,service,is,stopped,log,debug,try,to,connect,to,remote,rpc,endpoint,with,address,returning,a,gateway,address,clazz,get,name,final,actor,selection,actor,sel,actor,system,actor,selection,address,final,scala,concurrent,future,object,identify,patterns,ask,actor,sel,new,identify,42,timeout,to,milliseconds,final,scala,concurrent,future,c,result,future,identify,map,new,mapper,object,c,override,public,c,checked,apply,object,obj,throws,exception,actor,identity,actor,identity,actor,identity,obj,if,actor,identity,get,ref,null,throw,new,rpc,connection,exception,could,not,connect,to,rpc,endpoint,under,address,address,else,actor,ref,actor,ref,actor,identity,get,ref,final,string,address,akka,utils,get,akka,url,actor,system,actor,ref,invocation,handler,akka,invocation,handler,new,akka,invocation,handler,address,actor,ref,timeout,maximum,framesize,class,loader,class,loader,akka,rpc,service,this,get,class,get,class,loader,suppress,warnings,unchecked,c,proxy,c,proxy,new,proxy,instance,class,loader,new,class,clazz,akka,invocation,handler,return,proxy,actor,system,dispatcher,return,new,flink,future,result,future
AkkaRpcService -> @Override 	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz);1474905707;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz) {_		checkState(!stopped, "RpcService is stopped")___		LOG.debug("Try to connect to remote RPC endpoint with address {}. Returning a {} gateway.",_				address, clazz.getName())___		final ActorSelection actorSel = actorSystem.actorSelection(address)___		final scala.concurrent.Future<Object> identify = Patterns.ask(actorSel, new Identify(42), timeout.toMilliseconds())__		final scala.concurrent.Future<C> resultFuture = identify.map(new Mapper<Object, C>(){_			@Override_			public C checkedApply(Object obj) throws Exception {__				ActorIdentity actorIdentity = (ActorIdentity) obj___				if (actorIdentity.getRef() == null) {_					throw new RpcConnectionException("Could not connect to rpc endpoint under address " + address + '.')__				} else {_					ActorRef actorRef = actorIdentity.getRef()___					final String address = AkkaUtils.getAkkaURL(actorSystem, actorRef)___					InvocationHandler akkaInvocationHandler = new AkkaInvocationHandler(address, actorRef, timeout, maximumFramesize)___					_					_					_					ClassLoader classLoader = AkkaRpcService.this.getClass().getClassLoader()___					@SuppressWarnings("unchecked")_					C proxy = (C) Proxy.newProxyInstance(_						classLoader,_						new Class<?>[]{clazz},_						akkaInvocationHandler)___					return proxy__				}_			}_		}, actorSystem.dispatcher())___		return new FlinkFuture<>(resultFuture)__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,future,c,connect,final,string,address,final,class,c,clazz,check,state,stopped,rpc,service,is,stopped,log,debug,try,to,connect,to,remote,rpc,endpoint,with,address,returning,a,gateway,address,clazz,get,name,final,actor,selection,actor,sel,actor,system,actor,selection,address,final,scala,concurrent,future,object,identify,patterns,ask,actor,sel,new,identify,42,timeout,to,milliseconds,final,scala,concurrent,future,c,result,future,identify,map,new,mapper,object,c,override,public,c,checked,apply,object,obj,throws,exception,actor,identity,actor,identity,actor,identity,obj,if,actor,identity,get,ref,null,throw,new,rpc,connection,exception,could,not,connect,to,rpc,endpoint,under,address,address,else,actor,ref,actor,ref,actor,identity,get,ref,final,string,address,akka,utils,get,akka,url,actor,system,actor,ref,invocation,handler,akka,invocation,handler,new,akka,invocation,handler,address,actor,ref,timeout,maximum,framesize,class,loader,class,loader,akka,rpc,service,this,get,class,get,class,loader,suppress,warnings,unchecked,c,proxy,c,proxy,new,proxy,instance,class,loader,new,class,clazz,akka,invocation,handler,return,proxy,actor,system,dispatcher,return,new,flink,future,result,future
AkkaRpcService -> @Override 	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz);1474993062;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz) {_		checkState(!stopped, "RpcService is stopped")___		LOG.debug("Try to connect to remote RPC endpoint with address {}. Returning a {} gateway.",_				address, clazz.getName())___		final ActorSelection actorSel = actorSystem.actorSelection(address)___		final scala.concurrent.Future<Object> identify = Patterns.ask(actorSel, new Identify(42), timeout.toMilliseconds())__		final scala.concurrent.Future<C> resultFuture = identify.map(new Mapper<Object, C>(){_			@Override_			public C checkedApply(Object obj) throws Exception {__				ActorIdentity actorIdentity = (ActorIdentity) obj___				if (actorIdentity.getRef() == null) {_					throw new RpcConnectionException("Could not connect to rpc endpoint under address " + address + '.')__				} else {_					ActorRef actorRef = actorIdentity.getRef()___					final String address = AkkaUtils.getAkkaURL(actorSystem, actorRef)___					InvocationHandler akkaInvocationHandler = new AkkaInvocationHandler(_						address,_						actorRef,_						timeout,_						maximumFramesize,_						null)___					_					_					_					ClassLoader classLoader = AkkaRpcService.this.getClass().getClassLoader()___					@SuppressWarnings("unchecked")_					C proxy = (C) Proxy.newProxyInstance(_						classLoader,_						new Class<?>[]{clazz},_						akkaInvocationHandler)___					return proxy__				}_			}_		}, actorSystem.dispatcher())___		return new FlinkFuture<>(resultFuture)__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,future,c,connect,final,string,address,final,class,c,clazz,check,state,stopped,rpc,service,is,stopped,log,debug,try,to,connect,to,remote,rpc,endpoint,with,address,returning,a,gateway,address,clazz,get,name,final,actor,selection,actor,sel,actor,system,actor,selection,address,final,scala,concurrent,future,object,identify,patterns,ask,actor,sel,new,identify,42,timeout,to,milliseconds,final,scala,concurrent,future,c,result,future,identify,map,new,mapper,object,c,override,public,c,checked,apply,object,obj,throws,exception,actor,identity,actor,identity,actor,identity,obj,if,actor,identity,get,ref,null,throw,new,rpc,connection,exception,could,not,connect,to,rpc,endpoint,under,address,address,else,actor,ref,actor,ref,actor,identity,get,ref,final,string,address,akka,utils,get,akka,url,actor,system,actor,ref,invocation,handler,akka,invocation,handler,new,akka,invocation,handler,address,actor,ref,timeout,maximum,framesize,null,class,loader,class,loader,akka,rpc,service,this,get,class,get,class,loader,suppress,warnings,unchecked,c,proxy,c,proxy,new,proxy,instance,class,loader,new,class,clazz,akka,invocation,handler,return,proxy,actor,system,dispatcher,return,new,flink,future,result,future
AkkaRpcService -> @Override 	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz);1476806580;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz) {_		checkState(!stopped, "RpcService is stopped")___		LOG.debug("Try to connect to remote RPC endpoint with address {}. Returning a {} gateway.",_				address, clazz.getName())___		final ActorSelection actorSel = actorSystem.actorSelection(address)___		final scala.concurrent.Future<Object> identify = Patterns.ask(actorSel, new Identify(42), timeout.toMilliseconds())__		final scala.concurrent.Future<C> resultFuture = identify.map(new Mapper<Object, C>(){_			@Override_			public C checkedApply(Object obj) throws Exception {__				ActorIdentity actorIdentity = (ActorIdentity) obj___				if (actorIdentity.getRef() == null) {_					throw new RpcConnectionException("Could not connect to rpc endpoint under address " + address + '.')__				} else {_					ActorRef actorRef = actorIdentity.getRef()___					final String address = AkkaUtils.getAkkaURL(actorSystem, actorRef)___					InvocationHandler akkaInvocationHandler = new AkkaInvocationHandler(_						address,_						actorRef,_						timeout,_						maximumFramesize,_						null)___					_					_					_					ClassLoader classLoader = AkkaRpcService.this.getClass().getClassLoader()___					@SuppressWarnings("unchecked")_					C proxy = (C) Proxy.newProxyInstance(_						classLoader,_						new Class<?>[]{clazz},_						akkaInvocationHandler)___					return proxy__				}_			}_		}, actorSystem.dispatcher())___		return new FlinkFuture<>(resultFuture)__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,future,c,connect,final,string,address,final,class,c,clazz,check,state,stopped,rpc,service,is,stopped,log,debug,try,to,connect,to,remote,rpc,endpoint,with,address,returning,a,gateway,address,clazz,get,name,final,actor,selection,actor,sel,actor,system,actor,selection,address,final,scala,concurrent,future,object,identify,patterns,ask,actor,sel,new,identify,42,timeout,to,milliseconds,final,scala,concurrent,future,c,result,future,identify,map,new,mapper,object,c,override,public,c,checked,apply,object,obj,throws,exception,actor,identity,actor,identity,actor,identity,obj,if,actor,identity,get,ref,null,throw,new,rpc,connection,exception,could,not,connect,to,rpc,endpoint,under,address,address,else,actor,ref,actor,ref,actor,identity,get,ref,final,string,address,akka,utils,get,akka,url,actor,system,actor,ref,invocation,handler,akka,invocation,handler,new,akka,invocation,handler,address,actor,ref,timeout,maximum,framesize,null,class,loader,class,loader,akka,rpc,service,this,get,class,get,class,loader,suppress,warnings,unchecked,c,proxy,c,proxy,new,proxy,instance,class,loader,new,class,clazz,akka,invocation,handler,return,proxy,actor,system,dispatcher,return,new,flink,future,result,future
AkkaRpcService -> @Override 	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz);1487087443;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz) {_		checkState(!stopped, "RpcService is stopped")___		LOG.debug("Try to connect to remote RPC endpoint with address {}. Returning a {} gateway.",_				address, clazz.getName())___		final ActorSelection actorSel = actorSystem.actorSelection(address)___		final scala.concurrent.Future<Object> identify = Patterns.ask(actorSel, new Identify(42), timeout.toMilliseconds())__		final scala.concurrent.Future<C> resultFuture = identify.map(new Mapper<Object, C>(){_			@Override_			public C checkedApply(Object obj) throws Exception {__				ActorIdentity actorIdentity = (ActorIdentity) obj___				if (actorIdentity.getRef() == null) {_					throw new RpcConnectionException("Could not connect to rpc endpoint under address " + address + '.')__				} else {_					ActorRef actorRef = actorIdentity.getRef()___					final String address = AkkaUtils.getAkkaURL(actorSystem, actorRef)___					InvocationHandler akkaInvocationHandler = new AkkaInvocationHandler(_						address,_						actorRef,_						timeout,_						maximumFramesize,_						null)___					_					_					_					ClassLoader classLoader = AkkaRpcService.this.getClass().getClassLoader()___					@SuppressWarnings("unchecked")_					C proxy = (C) Proxy.newProxyInstance(_						classLoader,_						new Class<?>[]{clazz},_						akkaInvocationHandler)___					return proxy__				}_			}_		}, actorSystem.dispatcher())___		return new FlinkFuture<>(resultFuture)__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,future,c,connect,final,string,address,final,class,c,clazz,check,state,stopped,rpc,service,is,stopped,log,debug,try,to,connect,to,remote,rpc,endpoint,with,address,returning,a,gateway,address,clazz,get,name,final,actor,selection,actor,sel,actor,system,actor,selection,address,final,scala,concurrent,future,object,identify,patterns,ask,actor,sel,new,identify,42,timeout,to,milliseconds,final,scala,concurrent,future,c,result,future,identify,map,new,mapper,object,c,override,public,c,checked,apply,object,obj,throws,exception,actor,identity,actor,identity,actor,identity,obj,if,actor,identity,get,ref,null,throw,new,rpc,connection,exception,could,not,connect,to,rpc,endpoint,under,address,address,else,actor,ref,actor,ref,actor,identity,get,ref,final,string,address,akka,utils,get,akka,url,actor,system,actor,ref,invocation,handler,akka,invocation,handler,new,akka,invocation,handler,address,actor,ref,timeout,maximum,framesize,null,class,loader,class,loader,akka,rpc,service,this,get,class,get,class,loader,suppress,warnings,unchecked,c,proxy,c,proxy,new,proxy,instance,class,loader,new,class,clazz,akka,invocation,handler,return,proxy,actor,system,dispatcher,return,new,flink,future,result,future
AkkaRpcService -> @Override 	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz);1487101230;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz) {_		checkState(!stopped, "RpcService is stopped")___		LOG.debug("Try to connect to remote RPC endpoint with address {}. Returning a {} gateway.",_				address, clazz.getName())___		final ActorSelection actorSel = actorSystem.actorSelection(address)___		final scala.concurrent.Future<Object> identify = Patterns.ask(actorSel, new Identify(42), timeout.toMilliseconds())__		final scala.concurrent.Future<C> resultFuture = identify.map(new Mapper<Object, C>(){_			@Override_			public C checkedApply(Object obj) throws Exception {__				ActorIdentity actorIdentity = (ActorIdentity) obj___				if (actorIdentity.getRef() == null) {_					throw new RpcConnectionException("Could not connect to rpc endpoint under address " + address + '.')__				} else {_					ActorRef actorRef = actorIdentity.getRef()___					final String address = AkkaUtils.getAkkaURL(actorSystem, actorRef)___					InvocationHandler akkaInvocationHandler = new AkkaInvocationHandler(_						address,_						actorRef,_						timeout,_						maximumFramesize,_						null)___					_					_					_					ClassLoader classLoader = AkkaRpcService.this.getClass().getClassLoader()___					@SuppressWarnings("unchecked")_					C proxy = (C) Proxy.newProxyInstance(_						classLoader,_						new Class<?>[]{clazz},_						akkaInvocationHandler)___					return proxy__				}_			}_		}, actorSystem.dispatcher())___		return new FlinkFuture<>(resultFuture)__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,future,c,connect,final,string,address,final,class,c,clazz,check,state,stopped,rpc,service,is,stopped,log,debug,try,to,connect,to,remote,rpc,endpoint,with,address,returning,a,gateway,address,clazz,get,name,final,actor,selection,actor,sel,actor,system,actor,selection,address,final,scala,concurrent,future,object,identify,patterns,ask,actor,sel,new,identify,42,timeout,to,milliseconds,final,scala,concurrent,future,c,result,future,identify,map,new,mapper,object,c,override,public,c,checked,apply,object,obj,throws,exception,actor,identity,actor,identity,actor,identity,obj,if,actor,identity,get,ref,null,throw,new,rpc,connection,exception,could,not,connect,to,rpc,endpoint,under,address,address,else,actor,ref,actor,ref,actor,identity,get,ref,final,string,address,akka,utils,get,akka,url,actor,system,actor,ref,invocation,handler,akka,invocation,handler,new,akka,invocation,handler,address,actor,ref,timeout,maximum,framesize,null,class,loader,class,loader,akka,rpc,service,this,get,class,get,class,loader,suppress,warnings,unchecked,c,proxy,c,proxy,new,proxy,instance,class,loader,new,class,clazz,akka,invocation,handler,return,proxy,actor,system,dispatcher,return,new,flink,future,result,future
AkkaRpcService -> @Override 	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz);1489590578;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz) {_		checkState(!stopped, "RpcService is stopped")___		LOG.debug("Try to connect to remote RPC endpoint with address {}. Returning a {} gateway.",_				address, clazz.getName())___		final ActorSelection actorSel = actorSystem.actorSelection(address)___		final scala.concurrent.Future<Object> identify = Patterns.ask(actorSel, new Identify(42), timeout.toMilliseconds())__		final scala.concurrent.Future<C> resultFuture = identify.map(new Mapper<Object, C>(){_			@Override_			public C checkedApply(Object obj) throws Exception {__				ActorIdentity actorIdentity = (ActorIdentity) obj___				if (actorIdentity.getRef() == null) {_					throw new RpcConnectionException("Could not connect to rpc endpoint under address " + address + '.')__				} else {_					ActorRef actorRef = actorIdentity.getRef()___					final String address = AkkaUtils.getAkkaURL(actorSystem, actorRef)__					final String hostname__					Option<String> host = actorRef.path().address().host()__					if (host.isEmpty()) {_						hostname = "localhost"__					} else {_						hostname = host.get()__					}__					InvocationHandler akkaInvocationHandler = new AkkaInvocationHandler(_						address,_						hostname,_						actorRef,_						timeout,_						maximumFramesize,_						null)___					_					_					_					ClassLoader classLoader = AkkaRpcService.this.getClass().getClassLoader()___					@SuppressWarnings("unchecked")_					C proxy = (C) Proxy.newProxyInstance(_						classLoader,_						new Class<?>[]{clazz},_						akkaInvocationHandler)___					return proxy__				}_			}_		}, actorSystem.dispatcher())___		return new FlinkFuture<>(resultFuture)__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,future,c,connect,final,string,address,final,class,c,clazz,check,state,stopped,rpc,service,is,stopped,log,debug,try,to,connect,to,remote,rpc,endpoint,with,address,returning,a,gateway,address,clazz,get,name,final,actor,selection,actor,sel,actor,system,actor,selection,address,final,scala,concurrent,future,object,identify,patterns,ask,actor,sel,new,identify,42,timeout,to,milliseconds,final,scala,concurrent,future,c,result,future,identify,map,new,mapper,object,c,override,public,c,checked,apply,object,obj,throws,exception,actor,identity,actor,identity,actor,identity,obj,if,actor,identity,get,ref,null,throw,new,rpc,connection,exception,could,not,connect,to,rpc,endpoint,under,address,address,else,actor,ref,actor,ref,actor,identity,get,ref,final,string,address,akka,utils,get,akka,url,actor,system,actor,ref,final,string,hostname,option,string,host,actor,ref,path,address,host,if,host,is,empty,hostname,localhost,else,hostname,host,get,invocation,handler,akka,invocation,handler,new,akka,invocation,handler,address,hostname,actor,ref,timeout,maximum,framesize,null,class,loader,class,loader,akka,rpc,service,this,get,class,get,class,loader,suppress,warnings,unchecked,c,proxy,c,proxy,new,proxy,instance,class,loader,new,class,clazz,akka,invocation,handler,return,proxy,actor,system,dispatcher,return,new,flink,future,result,future
AkkaRpcService -> @Override 	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz);1490170142;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz) {_		checkState(!stopped, "RpcService is stopped")___		LOG.debug("Try to connect to remote RPC endpoint with address {}. Returning a {} gateway.",_				address, clazz.getName())___		final ActorSelection actorSel = actorSystem.actorSelection(address)___		final scala.concurrent.Future<Object> identify = Patterns.ask(actorSel, new Identify(42), timeout.toMilliseconds())__		final scala.concurrent.Future<C> resultFuture = identify.map(new Mapper<Object, C>(){_			@Override_			public C checkedApply(Object obj) throws Exception {__				ActorIdentity actorIdentity = (ActorIdentity) obj___				if (actorIdentity.getRef() == null) {_					throw new RpcConnectionException("Could not connect to rpc endpoint under address " + address + '.')__				} else {_					ActorRef actorRef = actorIdentity.getRef()___					final String address = AkkaUtils.getAkkaURL(actorSystem, actorRef)__					final String hostname__					Option<String> host = actorRef.path().address().host()__					if (host.isEmpty()) {_						hostname = "localhost"__					} else {_						hostname = host.get()__					}__					InvocationHandler akkaInvocationHandler = new AkkaInvocationHandler(_						address,_						hostname,_						actorRef,_						timeout,_						maximumFramesize,_						null)___					_					_					_					ClassLoader classLoader = AkkaRpcService.this.getClass().getClassLoader()___					@SuppressWarnings("unchecked")_					C proxy = (C) Proxy.newProxyInstance(_						classLoader,_						new Class<?>[]{clazz},_						akkaInvocationHandler)___					return proxy__				}_			}_		}, actorSystem.dispatcher())___		return new FlinkFuture<>(resultFuture)__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,future,c,connect,final,string,address,final,class,c,clazz,check,state,stopped,rpc,service,is,stopped,log,debug,try,to,connect,to,remote,rpc,endpoint,with,address,returning,a,gateway,address,clazz,get,name,final,actor,selection,actor,sel,actor,system,actor,selection,address,final,scala,concurrent,future,object,identify,patterns,ask,actor,sel,new,identify,42,timeout,to,milliseconds,final,scala,concurrent,future,c,result,future,identify,map,new,mapper,object,c,override,public,c,checked,apply,object,obj,throws,exception,actor,identity,actor,identity,actor,identity,obj,if,actor,identity,get,ref,null,throw,new,rpc,connection,exception,could,not,connect,to,rpc,endpoint,under,address,address,else,actor,ref,actor,ref,actor,identity,get,ref,final,string,address,akka,utils,get,akka,url,actor,system,actor,ref,final,string,hostname,option,string,host,actor,ref,path,address,host,if,host,is,empty,hostname,localhost,else,hostname,host,get,invocation,handler,akka,invocation,handler,new,akka,invocation,handler,address,hostname,actor,ref,timeout,maximum,framesize,null,class,loader,class,loader,akka,rpc,service,this,get,class,get,class,loader,suppress,warnings,unchecked,c,proxy,c,proxy,new,proxy,instance,class,loader,new,class,clazz,akka,invocation,handler,return,proxy,actor,system,dispatcher,return,new,flink,future,result,future
AkkaRpcService -> @Override 	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz);1499377396;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz) {_		checkState(!stopped, "RpcService is stopped")___		LOG.debug("Try to connect to remote RPC endpoint with address {}. Returning a {} gateway.",_				address, clazz.getName())___		final ActorSelection actorSel = actorSystem.actorSelection(address)___		final scala.concurrent.Future<Object> identify = Patterns.ask(actorSel, new Identify(42), timeout.toMilliseconds())__		final scala.concurrent.Future<C> resultFuture = identify.map(new Mapper<Object, C>(){_			@Override_			public C checkedApply(Object obj) throws Exception {__				ActorIdentity actorIdentity = (ActorIdentity) obj___				if (actorIdentity.getRef() == null) {_					throw new RpcConnectionException("Could not connect to rpc endpoint under address " + address + '.')__				} else {_					ActorRef actorRef = actorIdentity.getRef()___					final String address = AkkaUtils.getAkkaURL(actorSystem, actorRef)__					final String hostname__					Option<String> host = actorRef.path().address().host()__					if (host.isEmpty()) {_						hostname = "localhost"__					} else {_						hostname = host.get()__					}__					InvocationHandler akkaInvocationHandler = new AkkaInvocationHandler(_						address,_						hostname,_						actorRef,_						timeout,_						maximumFramesize,_						null)___					_					_					_					ClassLoader classLoader = AkkaRpcService.this.getClass().getClassLoader()___					@SuppressWarnings("unchecked")_					C proxy = (C) Proxy.newProxyInstance(_						classLoader,_						new Class<?>[]{clazz},_						akkaInvocationHandler)___					return proxy__				}_			}_		}, actorSystem.dispatcher())___		return new FlinkFuture<>(resultFuture)__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,future,c,connect,final,string,address,final,class,c,clazz,check,state,stopped,rpc,service,is,stopped,log,debug,try,to,connect,to,remote,rpc,endpoint,with,address,returning,a,gateway,address,clazz,get,name,final,actor,selection,actor,sel,actor,system,actor,selection,address,final,scala,concurrent,future,object,identify,patterns,ask,actor,sel,new,identify,42,timeout,to,milliseconds,final,scala,concurrent,future,c,result,future,identify,map,new,mapper,object,c,override,public,c,checked,apply,object,obj,throws,exception,actor,identity,actor,identity,actor,identity,obj,if,actor,identity,get,ref,null,throw,new,rpc,connection,exception,could,not,connect,to,rpc,endpoint,under,address,address,else,actor,ref,actor,ref,actor,identity,get,ref,final,string,address,akka,utils,get,akka,url,actor,system,actor,ref,final,string,hostname,option,string,host,actor,ref,path,address,host,if,host,is,empty,hostname,localhost,else,hostname,host,get,invocation,handler,akka,invocation,handler,new,akka,invocation,handler,address,hostname,actor,ref,timeout,maximum,framesize,null,class,loader,class,loader,akka,rpc,service,this,get,class,get,class,loader,suppress,warnings,unchecked,c,proxy,c,proxy,new,proxy,instance,class,loader,new,class,clazz,akka,invocation,handler,return,proxy,actor,system,dispatcher,return,new,flink,future,result,future
AkkaRpcService -> @Override 	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz);1501251235;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> Future<C> connect(final String address, final Class<C> clazz) {_		checkState(!stopped, "RpcService is stopped")___		LOG.debug("Try to connect to remote RPC endpoint with address {}. Returning a {} gateway.",_				address, clazz.getName())___		final ActorSelection actorSel = actorSystem.actorSelection(address)___		final scala.concurrent.Future<Object> identify = Patterns.ask(actorSel, new Identify(42), timeout.toMilliseconds())__		final scala.concurrent.Future<C> resultFuture = identify.map(new Mapper<Object, C>(){_			@Override_			public C checkedApply(Object obj) throws Exception {__				ActorIdentity actorIdentity = (ActorIdentity) obj___				if (actorIdentity.getRef() == null) {_					throw new RpcConnectionException("Could not connect to rpc endpoint under address " + address + '.')__				} else {_					ActorRef actorRef = actorIdentity.getRef()___					final String address = AkkaUtils.getAkkaURL(actorSystem, actorRef)__					final String hostname__					Option<String> host = actorRef.path().address().host()__					if (host.isEmpty()) {_						hostname = "localhost"__					} else {_						hostname = host.get()__					}__					InvocationHandler akkaInvocationHandler = new AkkaInvocationHandler(_						address,_						hostname,_						actorRef,_						timeout,_						maximumFramesize,_						null)___					_					_					_					ClassLoader classLoader = AkkaRpcService.this.getClass().getClassLoader()___					@SuppressWarnings("unchecked")_					C proxy = (C) Proxy.newProxyInstance(_						classLoader,_						new Class<?>[]{clazz},_						akkaInvocationHandler)___					return proxy__				}_			}_		}, actorSystem.dispatcher())___		return new FlinkFuture<>(resultFuture)__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,future,c,connect,final,string,address,final,class,c,clazz,check,state,stopped,rpc,service,is,stopped,log,debug,try,to,connect,to,remote,rpc,endpoint,with,address,returning,a,gateway,address,clazz,get,name,final,actor,selection,actor,sel,actor,system,actor,selection,address,final,scala,concurrent,future,object,identify,patterns,ask,actor,sel,new,identify,42,timeout,to,milliseconds,final,scala,concurrent,future,c,result,future,identify,map,new,mapper,object,c,override,public,c,checked,apply,object,obj,throws,exception,actor,identity,actor,identity,actor,identity,obj,if,actor,identity,get,ref,null,throw,new,rpc,connection,exception,could,not,connect,to,rpc,endpoint,under,address,address,else,actor,ref,actor,ref,actor,identity,get,ref,final,string,address,akka,utils,get,akka,url,actor,system,actor,ref,final,string,hostname,option,string,host,actor,ref,path,address,host,if,host,is,empty,hostname,localhost,else,hostname,host,get,invocation,handler,akka,invocation,handler,new,akka,invocation,handler,address,hostname,actor,ref,timeout,maximum,framesize,null,class,loader,class,loader,akka,rpc,service,this,get,class,get,class,loader,suppress,warnings,unchecked,c,proxy,c,proxy,new,proxy,instance,class,loader,new,class,clazz,akka,invocation,handler,return,proxy,actor,system,dispatcher,return,new,flink,future,result,future
AkkaRpcService -> @Override 	public <C extends RpcGateway> CompletableFuture<C> connect(final String address, final Class<C> clazz);1501580028;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> CompletableFuture<C> connect(final String address, final Class<C> clazz) {_		checkState(!stopped, "RpcService is stopped")___		LOG.debug("Try to connect to remote RPC endpoint with address {}. Returning a {} gateway.",_				address, clazz.getName())___		final ActorSelection actorSel = actorSystem.actorSelection(address)___		final scala.concurrent.Future<Object> identify = Patterns.ask(actorSel, new Identify(42), timeout.toMilliseconds())__		final scala.concurrent.Future<C> resultFuture = identify.map(new Mapper<Object, C>(){_			@Override_			public C checkedApply(Object obj) throws Exception {__				ActorIdentity actorIdentity = (ActorIdentity) obj___				if (actorIdentity.getRef() == null) {_					throw new RpcConnectionException("Could not connect to rpc endpoint under address " + address + '.')__				} else {_					ActorRef actorRef = actorIdentity.getRef()___					final String address = AkkaUtils.getAkkaURL(actorSystem, actorRef)__					final String hostname__					Option<String> host = actorRef.path().address().host()__					if (host.isEmpty()) {_						hostname = "localhost"__					} else {_						hostname = host.get()__					}__					InvocationHandler akkaInvocationHandler = new AkkaInvocationHandler(_						address,_						hostname,_						actorRef,_						timeout,_						maximumFramesize,_						null)___					_					_					_					ClassLoader classLoader = AkkaRpcService.this.getClass().getClassLoader()___					@SuppressWarnings("unchecked")_					C proxy = (C) Proxy.newProxyInstance(_						classLoader,_						new Class<?>[]{clazz},_						akkaInvocationHandler)___					return proxy__				}_			}_		}, actorSystem.dispatcher())___		return FutureUtils.toJava(resultFuture)__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,completable,future,c,connect,final,string,address,final,class,c,clazz,check,state,stopped,rpc,service,is,stopped,log,debug,try,to,connect,to,remote,rpc,endpoint,with,address,returning,a,gateway,address,clazz,get,name,final,actor,selection,actor,sel,actor,system,actor,selection,address,final,scala,concurrent,future,object,identify,patterns,ask,actor,sel,new,identify,42,timeout,to,milliseconds,final,scala,concurrent,future,c,result,future,identify,map,new,mapper,object,c,override,public,c,checked,apply,object,obj,throws,exception,actor,identity,actor,identity,actor,identity,obj,if,actor,identity,get,ref,null,throw,new,rpc,connection,exception,could,not,connect,to,rpc,endpoint,under,address,address,else,actor,ref,actor,ref,actor,identity,get,ref,final,string,address,akka,utils,get,akka,url,actor,system,actor,ref,final,string,hostname,option,string,host,actor,ref,path,address,host,if,host,is,empty,hostname,localhost,else,hostname,host,get,invocation,handler,akka,invocation,handler,new,akka,invocation,handler,address,hostname,actor,ref,timeout,maximum,framesize,null,class,loader,class,loader,akka,rpc,service,this,get,class,get,class,loader,suppress,warnings,unchecked,c,proxy,c,proxy,new,proxy,instance,class,loader,new,class,clazz,akka,invocation,handler,return,proxy,actor,system,dispatcher,return,future,utils,to,java,result,future
AkkaRpcService -> @Override 	public <C extends RpcGateway> CompletableFuture<C> connect(final String address, final Class<C> clazz);1502196227;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> CompletableFuture<C> connect(final String address, final Class<C> clazz) {_		checkState(!stopped, "RpcService is stopped")___		LOG.debug("Try to connect to remote RPC endpoint with address {}. Returning a {} gateway.",_				address, clazz.getName())___		final ActorSelection actorSel = actorSystem.actorSelection(address)___		final scala.concurrent.Future<Object> identify = Patterns.ask(actorSel, new Identify(42), timeout.toMilliseconds())__		final scala.concurrent.Future<C> resultFuture = identify.map(new Mapper<Object, C>(){_			@Override_			public C checkedApply(Object obj) throws Exception {__				ActorIdentity actorIdentity = (ActorIdentity) obj___				if (actorIdentity.getRef() == null) {_					throw new RpcConnectionException("Could not connect to rpc endpoint under address " + address + '.')__				} else {_					ActorRef actorRef = actorIdentity.getRef()___					final String address = AkkaUtils.getAkkaURL(actorSystem, actorRef)__					final String hostname__					Option<String> host = actorRef.path().address().host()__					if (host.isEmpty()) {_						hostname = "localhost"__					} else {_						hostname = host.get()__					}__					InvocationHandler akkaInvocationHandler = new AkkaInvocationHandler(_						address,_						hostname,_						actorRef,_						timeout,_						maximumFramesize,_						null)___					_					_					_					ClassLoader classLoader = AkkaRpcService.this.getClass().getClassLoader()___					@SuppressWarnings("unchecked")_					C proxy = (C) Proxy.newProxyInstance(_						classLoader,_						new Class<?>[]{clazz},_						akkaInvocationHandler)___					return proxy__				}_			}_		}, actorSystem.dispatcher())___		return FutureUtils.toJava(resultFuture)__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,completable,future,c,connect,final,string,address,final,class,c,clazz,check,state,stopped,rpc,service,is,stopped,log,debug,try,to,connect,to,remote,rpc,endpoint,with,address,returning,a,gateway,address,clazz,get,name,final,actor,selection,actor,sel,actor,system,actor,selection,address,final,scala,concurrent,future,object,identify,patterns,ask,actor,sel,new,identify,42,timeout,to,milliseconds,final,scala,concurrent,future,c,result,future,identify,map,new,mapper,object,c,override,public,c,checked,apply,object,obj,throws,exception,actor,identity,actor,identity,actor,identity,obj,if,actor,identity,get,ref,null,throw,new,rpc,connection,exception,could,not,connect,to,rpc,endpoint,under,address,address,else,actor,ref,actor,ref,actor,identity,get,ref,final,string,address,akka,utils,get,akka,url,actor,system,actor,ref,final,string,hostname,option,string,host,actor,ref,path,address,host,if,host,is,empty,hostname,localhost,else,hostname,host,get,invocation,handler,akka,invocation,handler,new,akka,invocation,handler,address,hostname,actor,ref,timeout,maximum,framesize,null,class,loader,class,loader,akka,rpc,service,this,get,class,get,class,loader,suppress,warnings,unchecked,c,proxy,c,proxy,new,proxy,instance,class,loader,new,class,clazz,akka,invocation,handler,return,proxy,actor,system,dispatcher,return,future,utils,to,java,result,future
AkkaRpcService -> @Override 	public <F extends Serializable, C extends FencedRpcGateway<F>> CompletableFuture<C> connect(String address, F fencingToken, Class<C> clazz);1503500935;this method does not mutate state and is thus thread-safe;@Override_	public <F extends Serializable, C extends FencedRpcGateway<F>> CompletableFuture<C> connect(String address, F fencingToken, Class<C> clazz) {_		return connectInternal(_			address,_			clazz,_			(ActorRef actorRef) -> {_				Tuple2<String, String> addressHostname = extractAddressHostname(actorRef)___				return new FencedAkkaInvocationHandler<>(_					addressHostname.f0,_					addressHostname.f1,_					actorRef,_					timeout,_					maximumFramesize,_					null,_					() -> fencingToken)__			})__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,f,extends,serializable,c,extends,fenced,rpc,gateway,f,completable,future,c,connect,string,address,f,fencing,token,class,c,clazz,return,connect,internal,address,clazz,actor,ref,actor,ref,tuple2,string,string,address,hostname,extract,address,hostname,actor,ref,return,new,fenced,akka,invocation,handler,address,hostname,f0,address,hostname,f1,actor,ref,timeout,maximum,framesize,null,fencing,token
AkkaRpcService -> @Override 	public <F extends Serializable, C extends FencedRpcGateway<F>> CompletableFuture<C> connect(String address, F fencingToken, Class<C> clazz);1503740736;this method does not mutate state and is thus thread-safe;@Override_	public <F extends Serializable, C extends FencedRpcGateway<F>> CompletableFuture<C> connect(String address, F fencingToken, Class<C> clazz) {_		return connectInternal(_			address,_			clazz,_			(ActorRef actorRef) -> {_				Tuple2<String, String> addressHostname = extractAddressHostname(actorRef)___				return new FencedAkkaInvocationHandler<>(_					addressHostname.f0,_					addressHostname.f1,_					actorRef,_					timeout,_					maximumFramesize,_					null,_					() -> fencingToken)__			})__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,f,extends,serializable,c,extends,fenced,rpc,gateway,f,completable,future,c,connect,string,address,f,fencing,token,class,c,clazz,return,connect,internal,address,clazz,actor,ref,actor,ref,tuple2,string,string,address,hostname,extract,address,hostname,actor,ref,return,new,fenced,akka,invocation,handler,address,hostname,f0,address,hostname,f1,actor,ref,timeout,maximum,framesize,null,fencing,token
AkkaRpcService -> @Override 	public <F extends Serializable, C extends FencedRpcGateway<F>> CompletableFuture<C> connect(String address, F fencingToken, Class<C> clazz);1504540628;this method does not mutate state and is thus thread-safe;@Override_	public <F extends Serializable, C extends FencedRpcGateway<F>> CompletableFuture<C> connect(String address, F fencingToken, Class<C> clazz) {_		return connectInternal(_			address,_			clazz,_			(ActorRef actorRef) -> {_				Tuple2<String, String> addressHostname = extractAddressHostname(actorRef)___				return new FencedAkkaInvocationHandler<>(_					addressHostname.f0,_					addressHostname.f1,_					actorRef,_					timeout,_					maximumFramesize,_					null,_					() -> fencingToken)__			})__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,f,extends,serializable,c,extends,fenced,rpc,gateway,f,completable,future,c,connect,string,address,f,fencing,token,class,c,clazz,return,connect,internal,address,clazz,actor,ref,actor,ref,tuple2,string,string,address,hostname,extract,address,hostname,actor,ref,return,new,fenced,akka,invocation,handler,address,hostname,f0,address,hostname,f1,actor,ref,timeout,maximum,framesize,null,fencing,token
AkkaRpcService -> @Override 	public <F extends Serializable, C extends FencedRpcGateway<F>> CompletableFuture<C> connect(String address, F fencingToken, Class<C> clazz);1506976152;this method does not mutate state and is thus thread-safe;@Override_	public <F extends Serializable, C extends FencedRpcGateway<F>> CompletableFuture<C> connect(String address, F fencingToken, Class<C> clazz) {_		return connectInternal(_			address,_			clazz,_			(ActorRef actorRef) -> {_				Tuple2<String, String> addressHostname = extractAddressHostname(actorRef)___				return new FencedAkkaInvocationHandler<>(_					addressHostname.f0,_					addressHostname.f1,_					actorRef,_					timeout,_					maximumFramesize,_					null,_					null,_					() -> fencingToken)__			})__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,f,extends,serializable,c,extends,fenced,rpc,gateway,f,completable,future,c,connect,string,address,f,fencing,token,class,c,clazz,return,connect,internal,address,clazz,actor,ref,actor,ref,tuple2,string,string,address,hostname,extract,address,hostname,actor,ref,return,new,fenced,akka,invocation,handler,address,hostname,f0,address,hostname,f1,actor,ref,timeout,maximum,framesize,null,null,fencing,token
AkkaRpcService -> @Override 	public <F extends Serializable, C extends FencedRpcGateway<F>> CompletableFuture<C> connect(String address, F fencingToken, Class<C> clazz);1507724922;this method does not mutate state and is thus thread-safe;@Override_	public <F extends Serializable, C extends FencedRpcGateway<F>> CompletableFuture<C> connect(String address, F fencingToken, Class<C> clazz) {_		return connectInternal(_			address,_			clazz,_			(ActorRef actorRef) -> {_				Tuple2<String, String> addressHostname = extractAddressHostname(actorRef)___				return new FencedAkkaInvocationHandler<>(_					addressHostname.f0,_					addressHostname.f1,_					actorRef,_					timeout,_					maximumFramesize,_					null,_					null,_					() -> fencingToken)__			})__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,f,extends,serializable,c,extends,fenced,rpc,gateway,f,completable,future,c,connect,string,address,f,fencing,token,class,c,clazz,return,connect,internal,address,clazz,actor,ref,actor,ref,tuple2,string,string,address,hostname,extract,address,hostname,actor,ref,return,new,fenced,akka,invocation,handler,address,hostname,f0,address,hostname,f1,actor,ref,timeout,maximum,framesize,null,null,fencing,token
AkkaRpcService -> @Override 	public <F extends Serializable, C extends FencedRpcGateway<F>> CompletableFuture<C> connect(String address, F fencingToken, Class<C> clazz);1508327406;this method does not mutate state and is thus thread-safe;@Override_	public <F extends Serializable, C extends FencedRpcGateway<F>> CompletableFuture<C> connect(String address, F fencingToken, Class<C> clazz) {_		return connectInternal(_			address,_			clazz,_			(ActorRef actorRef) -> {_				Tuple2<String, String> addressHostname = extractAddressHostname(actorRef)___				return new FencedAkkaInvocationHandler<>(_					addressHostname.f0,_					addressHostname.f1,_					actorRef,_					timeout,_					maximumFramesize,_					null,_					null,_					() -> fencingToken)__			})__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,f,extends,serializable,c,extends,fenced,rpc,gateway,f,completable,future,c,connect,string,address,f,fencing,token,class,c,clazz,return,connect,internal,address,clazz,actor,ref,actor,ref,tuple2,string,string,address,hostname,extract,address,hostname,actor,ref,return,new,fenced,akka,invocation,handler,address,hostname,f0,address,hostname,f1,actor,ref,timeout,maximum,framesize,null,null,fencing,token
AkkaRpcService -> @Override 	public <F extends Serializable, C extends FencedRpcGateway<F>> CompletableFuture<C> connect(String address, F fencingToken, Class<C> clazz);1515516637;this method does not mutate state and is thus thread-safe;@Override_	public <F extends Serializable, C extends FencedRpcGateway<F>> CompletableFuture<C> connect(String address, F fencingToken, Class<C> clazz) {_		return connectInternal(_			address,_			clazz,_			(ActorRef actorRef) -> {_				Tuple2<String, String> addressHostname = extractAddressHostname(actorRef)___				return new FencedAkkaInvocationHandler<>(_					addressHostname.f0,_					addressHostname.f1,_					actorRef,_					timeout,_					maximumFramesize,_					null,_					() -> fencingToken)__			})__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,f,extends,serializable,c,extends,fenced,rpc,gateway,f,completable,future,c,connect,string,address,f,fencing,token,class,c,clazz,return,connect,internal,address,clazz,actor,ref,actor,ref,tuple2,string,string,address,hostname,extract,address,hostname,actor,ref,return,new,fenced,akka,invocation,handler,address,hostname,f0,address,hostname,f1,actor,ref,timeout,maximum,framesize,null,fencing,token
AkkaRpcService -> @Override 	public <F extends Serializable, C extends FencedRpcGateway<F>> CompletableFuture<C> connect(String address, F fencingToken, Class<C> clazz);1518528451;this method does not mutate state and is thus thread-safe;@Override_	public <F extends Serializable, C extends FencedRpcGateway<F>> CompletableFuture<C> connect(String address, F fencingToken, Class<C> clazz) {_		return connectInternal(_			address,_			clazz,_			(ActorRef actorRef) -> {_				Tuple2<String, String> addressHostname = extractAddressHostname(actorRef)___				return new FencedAkkaInvocationHandler<>(_					addressHostname.f0,_					addressHostname.f1,_					actorRef,_					timeout,_					maximumFramesize,_					null,_					() -> fencingToken)__			})__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,f,extends,serializable,c,extends,fenced,rpc,gateway,f,completable,future,c,connect,string,address,f,fencing,token,class,c,clazz,return,connect,internal,address,clazz,actor,ref,actor,ref,tuple2,string,string,address,hostname,extract,address,hostname,actor,ref,return,new,fenced,akka,invocation,handler,address,hostname,f0,address,hostname,f1,actor,ref,timeout,maximum,framesize,null,fencing,token
AkkaRpcService -> @Override 	public <F extends Serializable, C extends FencedRpcGateway<F>> CompletableFuture<C> connect(String address, F fencingToken, Class<C> clazz);1518716619;this method does not mutate state and is thus thread-safe;@Override_	public <F extends Serializable, C extends FencedRpcGateway<F>> CompletableFuture<C> connect(String address, F fencingToken, Class<C> clazz) {_		return connectInternal(_			address,_			clazz,_			(ActorRef actorRef) -> {_				Tuple2<String, String> addressHostname = extractAddressHostname(actorRef)___				return new FencedAkkaInvocationHandler<>(_					addressHostname.f0,_					addressHostname.f1,_					actorRef,_					timeout,_					maximumFramesize,_					null,_					() -> fencingToken)__			})__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,f,extends,serializable,c,extends,fenced,rpc,gateway,f,completable,future,c,connect,string,address,f,fencing,token,class,c,clazz,return,connect,internal,address,clazz,actor,ref,actor,ref,tuple2,string,string,address,hostname,extract,address,hostname,actor,ref,return,new,fenced,akka,invocation,handler,address,hostname,f0,address,hostname,f1,actor,ref,timeout,maximum,framesize,null,fencing,token
AkkaRpcService -> @Override 	public <F extends Serializable, C extends FencedRpcGateway<F>> CompletableFuture<C> connect(String address, F fencingToken, Class<C> clazz);1518803202;this method does not mutate state and is thus thread-safe;@Override_	public <F extends Serializable, C extends FencedRpcGateway<F>> CompletableFuture<C> connect(String address, F fencingToken, Class<C> clazz) {_		return connectInternal(_			address,_			clazz,_			(ActorRef actorRef) -> {_				Tuple2<String, String> addressHostname = extractAddressHostname(actorRef)___				return new FencedAkkaInvocationHandler<>(_					addressHostname.f0,_					addressHostname.f1,_					actorRef,_					timeout,_					maximumFramesize,_					null,_					() -> fencingToken)__			})__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,f,extends,serializable,c,extends,fenced,rpc,gateway,f,completable,future,c,connect,string,address,f,fencing,token,class,c,clazz,return,connect,internal,address,clazz,actor,ref,actor,ref,tuple2,string,string,address,hostname,extract,address,hostname,actor,ref,return,new,fenced,akka,invocation,handler,address,hostname,f0,address,hostname,f1,actor,ref,timeout,maximum,framesize,null,fencing,token
AkkaRpcService -> @Override 	public <F extends Serializable, C extends FencedRpcGateway<F>> CompletableFuture<C> connect(String address, F fencingToken, Class<C> clazz);1526373675;this method does not mutate state and is thus thread-safe;@Override_	public <F extends Serializable, C extends FencedRpcGateway<F>> CompletableFuture<C> connect(String address, F fencingToken, Class<C> clazz) {_		return connectInternal(_			address,_			clazz,_			(ActorRef actorRef) -> {_				Tuple2<String, String> addressHostname = extractAddressHostname(actorRef)___				return new FencedAkkaInvocationHandler<>(_					addressHostname.f0,_					addressHostname.f1,_					actorRef,_					timeout,_					maximumFramesize,_					null,_					() -> fencingToken)__			})__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,f,extends,serializable,c,extends,fenced,rpc,gateway,f,completable,future,c,connect,string,address,f,fencing,token,class,c,clazz,return,connect,internal,address,clazz,actor,ref,actor,ref,tuple2,string,string,address,hostname,extract,address,hostname,actor,ref,return,new,fenced,akka,invocation,handler,address,hostname,f0,address,hostname,f1,actor,ref,timeout,maximum,framesize,null,fencing,token
AkkaRpcService -> @Override 	public <F extends Serializable, C extends FencedRpcGateway<F>> CompletableFuture<C> connect(String address, F fencingToken, Class<C> clazz);1526374504;this method does not mutate state and is thus thread-safe;@Override_	public <F extends Serializable, C extends FencedRpcGateway<F>> CompletableFuture<C> connect(String address, F fencingToken, Class<C> clazz) {_		return connectInternal(_			address,_			clazz,_			(ActorRef actorRef) -> {_				Tuple2<String, String> addressHostname = extractAddressHostname(actorRef)___				return new FencedAkkaInvocationHandler<>(_					addressHostname.f0,_					addressHostname.f1,_					actorRef,_					timeout,_					maximumFramesize,_					null,_					() -> fencingToken)__			})__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,f,extends,serializable,c,extends,fenced,rpc,gateway,f,completable,future,c,connect,string,address,f,fencing,token,class,c,clazz,return,connect,internal,address,clazz,actor,ref,actor,ref,tuple2,string,string,address,hostname,extract,address,hostname,actor,ref,return,new,fenced,akka,invocation,handler,address,hostname,f0,address,hostname,f1,actor,ref,timeout,maximum,framesize,null,fencing,token
AkkaRpcService -> @Override 	public <F extends Serializable, C extends FencedRpcGateway<F>> CompletableFuture<C> connect(String address, F fencingToken, Class<C> clazz);1531679956;this method does not mutate state and is thus thread-safe;@Override_	public <F extends Serializable, C extends FencedRpcGateway<F>> CompletableFuture<C> connect(String address, F fencingToken, Class<C> clazz) {_		return connectInternal(_			address,_			clazz,_			(ActorRef actorRef) -> {_				Tuple2<String, String> addressHostname = extractAddressHostname(actorRef)___				return new FencedAkkaInvocationHandler<>(_					addressHostname.f0,_					addressHostname.f1,_					actorRef,_					timeout,_					maximumFramesize,_					null,_					() -> fencingToken)__			})__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,f,extends,serializable,c,extends,fenced,rpc,gateway,f,completable,future,c,connect,string,address,f,fencing,token,class,c,clazz,return,connect,internal,address,clazz,actor,ref,actor,ref,tuple2,string,string,address,hostname,extract,address,hostname,actor,ref,return,new,fenced,akka,invocation,handler,address,hostname,f0,address,hostname,f1,actor,ref,timeout,maximum,framesize,null,fencing,token
AkkaRpcService -> @Override 	public <F extends Serializable, C extends FencedRpcGateway<F>> CompletableFuture<C> connect(String address, F fencingToken, Class<C> clazz);1539833178;this method does not mutate state and is thus thread-safe;@Override_	public <F extends Serializable, C extends FencedRpcGateway<F>> CompletableFuture<C> connect(String address, F fencingToken, Class<C> clazz) {_		return connectInternal(_			address,_			clazz,_			(ActorRef actorRef) -> {_				Tuple2<String, String> addressHostname = extractAddressHostname(actorRef)___				return new FencedAkkaInvocationHandler<>(_					addressHostname.f0,_					addressHostname.f1,_					actorRef,_					configuration.getTimeout(),_					configuration.getMaximumFramesize(),_					null,_					() -> fencingToken)__			})__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,f,extends,serializable,c,extends,fenced,rpc,gateway,f,completable,future,c,connect,string,address,f,fencing,token,class,c,clazz,return,connect,internal,address,clazz,actor,ref,actor,ref,tuple2,string,string,address,hostname,extract,address,hostname,actor,ref,return,new,fenced,akka,invocation,handler,address,hostname,f0,address,hostname,f1,actor,ref,configuration,get,timeout,configuration,get,maximum,framesize,null,fencing,token
AkkaRpcService -> @Override 	public <F extends Serializable, C extends FencedRpcGateway<F>> CompletableFuture<C> connect(String address, F fencingToken, Class<C> clazz);1548316130;this method does not mutate state and is thus thread-safe;@Override_	public <F extends Serializable, C extends FencedRpcGateway<F>> CompletableFuture<C> connect(String address, F fencingToken, Class<C> clazz) {_		return connectInternal(_			address,_			clazz,_			(ActorRef actorRef) -> {_				Tuple2<String, String> addressHostname = extractAddressHostname(actorRef)___				return new FencedAkkaInvocationHandler<>(_					addressHostname.f0,_					addressHostname.f1,_					actorRef,_					configuration.getTimeout(),_					configuration.getMaximumFramesize(),_					null,_					() -> fencingToken)__			})__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,f,extends,serializable,c,extends,fenced,rpc,gateway,f,completable,future,c,connect,string,address,f,fencing,token,class,c,clazz,return,connect,internal,address,clazz,actor,ref,actor,ref,tuple2,string,string,address,hostname,extract,address,hostname,actor,ref,return,new,fenced,akka,invocation,handler,address,hostname,f0,address,hostname,f1,actor,ref,configuration,get,timeout,configuration,get,maximum,framesize,null,fencing,token
AkkaRpcService -> @Override 	public <F extends Serializable, C extends FencedRpcGateway<F>> CompletableFuture<C> connect(String address, F fencingToken, Class<C> clazz);1549533702;this method does not mutate state and is thus thread-safe;@Override_	public <F extends Serializable, C extends FencedRpcGateway<F>> CompletableFuture<C> connect(String address, F fencingToken, Class<C> clazz) {_		return connectInternal(_			address,_			clazz,_			(ActorRef actorRef) -> {_				Tuple2<String, String> addressHostname = extractAddressHostname(actorRef)___				return new FencedAkkaInvocationHandler<>(_					addressHostname.f0,_					addressHostname.f1,_					actorRef,_					configuration.getTimeout(),_					configuration.getMaximumFramesize(),_					null,_					() -> fencingToken)__			})__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,f,extends,serializable,c,extends,fenced,rpc,gateway,f,completable,future,c,connect,string,address,f,fencing,token,class,c,clazz,return,connect,internal,address,clazz,actor,ref,actor,ref,tuple2,string,string,address,hostname,extract,address,hostname,actor,ref,return,new,fenced,akka,invocation,handler,address,hostname,f0,address,hostname,f1,actor,ref,configuration,get,timeout,configuration,get,maximum,framesize,null,fencing,token
AkkaRpcService -> @Override 	public <C extends RpcGateway> CompletableFuture<C> connect( 			final String address, 			final Class<C> clazz);1503500935;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> CompletableFuture<C> connect(_			final String address,_			final Class<C> clazz) {__		return connectInternal(_			address,_			clazz,_			(ActorRef actorRef) -> {_				Tuple2<String, String> addressHostname = extractAddressHostname(actorRef)___				return new AkkaInvocationHandler(_					addressHostname.f0,_					addressHostname.f1,_					actorRef,_					timeout,_					maximumFramesize,_					null)__			})__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,completable,future,c,connect,final,string,address,final,class,c,clazz,return,connect,internal,address,clazz,actor,ref,actor,ref,tuple2,string,string,address,hostname,extract,address,hostname,actor,ref,return,new,akka,invocation,handler,address,hostname,f0,address,hostname,f1,actor,ref,timeout,maximum,framesize,null
AkkaRpcService -> @Override 	public <C extends RpcGateway> CompletableFuture<C> connect( 			final String address, 			final Class<C> clazz);1503740736;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> CompletableFuture<C> connect(_			final String address,_			final Class<C> clazz) {__		return connectInternal(_			address,_			clazz,_			(ActorRef actorRef) -> {_				Tuple2<String, String> addressHostname = extractAddressHostname(actorRef)___				return new AkkaInvocationHandler(_					addressHostname.f0,_					addressHostname.f1,_					actorRef,_					timeout,_					maximumFramesize,_					null)__			})__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,completable,future,c,connect,final,string,address,final,class,c,clazz,return,connect,internal,address,clazz,actor,ref,actor,ref,tuple2,string,string,address,hostname,extract,address,hostname,actor,ref,return,new,akka,invocation,handler,address,hostname,f0,address,hostname,f1,actor,ref,timeout,maximum,framesize,null
AkkaRpcService -> @Override 	public <C extends RpcGateway> CompletableFuture<C> connect( 			final String address, 			final Class<C> clazz);1504540628;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> CompletableFuture<C> connect(_			final String address,_			final Class<C> clazz) {__		return connectInternal(_			address,_			clazz,_			(ActorRef actorRef) -> {_				Tuple2<String, String> addressHostname = extractAddressHostname(actorRef)___				return new AkkaInvocationHandler(_					addressHostname.f0,_					addressHostname.f1,_					actorRef,_					timeout,_					maximumFramesize,_					null)__			})__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,completable,future,c,connect,final,string,address,final,class,c,clazz,return,connect,internal,address,clazz,actor,ref,actor,ref,tuple2,string,string,address,hostname,extract,address,hostname,actor,ref,return,new,akka,invocation,handler,address,hostname,f0,address,hostname,f1,actor,ref,timeout,maximum,framesize,null
AkkaRpcService -> @Override 	public <C extends RpcGateway> CompletableFuture<C> connect( 			final String address, 			final Class<C> clazz);1506976152;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> CompletableFuture<C> connect(_			final String address,_			final Class<C> clazz) {__		return connectInternal(_			address,_			clazz,_			(ActorRef actorRef) -> {_				Tuple2<String, String> addressHostname = extractAddressHostname(actorRef)___				return new AkkaInvocationHandler(_					addressHostname.f0,_					addressHostname.f1,_					actorRef,_					timeout,_					maximumFramesize,_					null,_					null)__			})__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,completable,future,c,connect,final,string,address,final,class,c,clazz,return,connect,internal,address,clazz,actor,ref,actor,ref,tuple2,string,string,address,hostname,extract,address,hostname,actor,ref,return,new,akka,invocation,handler,address,hostname,f0,address,hostname,f1,actor,ref,timeout,maximum,framesize,null,null
AkkaRpcService -> @Override 	public <C extends RpcGateway> CompletableFuture<C> connect( 			final String address, 			final Class<C> clazz);1507724922;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> CompletableFuture<C> connect(_			final String address,_			final Class<C> clazz) {__		return connectInternal(_			address,_			clazz,_			(ActorRef actorRef) -> {_				Tuple2<String, String> addressHostname = extractAddressHostname(actorRef)___				return new AkkaInvocationHandler(_					addressHostname.f0,_					addressHostname.f1,_					actorRef,_					timeout,_					maximumFramesize,_					null,_					null)__			})__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,completable,future,c,connect,final,string,address,final,class,c,clazz,return,connect,internal,address,clazz,actor,ref,actor,ref,tuple2,string,string,address,hostname,extract,address,hostname,actor,ref,return,new,akka,invocation,handler,address,hostname,f0,address,hostname,f1,actor,ref,timeout,maximum,framesize,null,null
AkkaRpcService -> @Override 	public <C extends RpcGateway> CompletableFuture<C> connect( 			final String address, 			final Class<C> clazz);1508327406;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> CompletableFuture<C> connect(_			final String address,_			final Class<C> clazz) {__		return connectInternal(_			address,_			clazz,_			(ActorRef actorRef) -> {_				Tuple2<String, String> addressHostname = extractAddressHostname(actorRef)___				return new AkkaInvocationHandler(_					addressHostname.f0,_					addressHostname.f1,_					actorRef,_					timeout,_					maximumFramesize,_					null,_					null)__			})__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,completable,future,c,connect,final,string,address,final,class,c,clazz,return,connect,internal,address,clazz,actor,ref,actor,ref,tuple2,string,string,address,hostname,extract,address,hostname,actor,ref,return,new,akka,invocation,handler,address,hostname,f0,address,hostname,f1,actor,ref,timeout,maximum,framesize,null,null
AkkaRpcService -> @Override 	public <C extends RpcGateway> CompletableFuture<C> connect( 			final String address, 			final Class<C> clazz);1515516637;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> CompletableFuture<C> connect(_			final String address,_			final Class<C> clazz) {__		return connectInternal(_			address,_			clazz,_			(ActorRef actorRef) -> {_				Tuple2<String, String> addressHostname = extractAddressHostname(actorRef)___				return new AkkaInvocationHandler(_					addressHostname.f0,_					addressHostname.f1,_					actorRef,_					timeout,_					maximumFramesize,_					null)__			})__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,completable,future,c,connect,final,string,address,final,class,c,clazz,return,connect,internal,address,clazz,actor,ref,actor,ref,tuple2,string,string,address,hostname,extract,address,hostname,actor,ref,return,new,akka,invocation,handler,address,hostname,f0,address,hostname,f1,actor,ref,timeout,maximum,framesize,null
AkkaRpcService -> @Override 	public <C extends RpcGateway> CompletableFuture<C> connect( 			final String address, 			final Class<C> clazz);1518528451;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> CompletableFuture<C> connect(_			final String address,_			final Class<C> clazz) {__		return connectInternal(_			address,_			clazz,_			(ActorRef actorRef) -> {_				Tuple2<String, String> addressHostname = extractAddressHostname(actorRef)___				return new AkkaInvocationHandler(_					addressHostname.f0,_					addressHostname.f1,_					actorRef,_					timeout,_					maximumFramesize,_					null)__			})__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,completable,future,c,connect,final,string,address,final,class,c,clazz,return,connect,internal,address,clazz,actor,ref,actor,ref,tuple2,string,string,address,hostname,extract,address,hostname,actor,ref,return,new,akka,invocation,handler,address,hostname,f0,address,hostname,f1,actor,ref,timeout,maximum,framesize,null
AkkaRpcService -> @Override 	public <C extends RpcGateway> CompletableFuture<C> connect( 			final String address, 			final Class<C> clazz);1518716619;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> CompletableFuture<C> connect(_			final String address,_			final Class<C> clazz) {__		return connectInternal(_			address,_			clazz,_			(ActorRef actorRef) -> {_				Tuple2<String, String> addressHostname = extractAddressHostname(actorRef)___				return new AkkaInvocationHandler(_					addressHostname.f0,_					addressHostname.f1,_					actorRef,_					timeout,_					maximumFramesize,_					null)__			})__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,completable,future,c,connect,final,string,address,final,class,c,clazz,return,connect,internal,address,clazz,actor,ref,actor,ref,tuple2,string,string,address,hostname,extract,address,hostname,actor,ref,return,new,akka,invocation,handler,address,hostname,f0,address,hostname,f1,actor,ref,timeout,maximum,framesize,null
AkkaRpcService -> @Override 	public <C extends RpcGateway> CompletableFuture<C> connect( 			final String address, 			final Class<C> clazz);1518803202;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> CompletableFuture<C> connect(_			final String address,_			final Class<C> clazz) {__		return connectInternal(_			address,_			clazz,_			(ActorRef actorRef) -> {_				Tuple2<String, String> addressHostname = extractAddressHostname(actorRef)___				return new AkkaInvocationHandler(_					addressHostname.f0,_					addressHostname.f1,_					actorRef,_					timeout,_					maximumFramesize,_					null)__			})__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,completable,future,c,connect,final,string,address,final,class,c,clazz,return,connect,internal,address,clazz,actor,ref,actor,ref,tuple2,string,string,address,hostname,extract,address,hostname,actor,ref,return,new,akka,invocation,handler,address,hostname,f0,address,hostname,f1,actor,ref,timeout,maximum,framesize,null
AkkaRpcService -> @Override 	public <C extends RpcGateway> CompletableFuture<C> connect( 			final String address, 			final Class<C> clazz);1526373675;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> CompletableFuture<C> connect(_			final String address,_			final Class<C> clazz) {__		return connectInternal(_			address,_			clazz,_			(ActorRef actorRef) -> {_				Tuple2<String, String> addressHostname = extractAddressHostname(actorRef)___				return new AkkaInvocationHandler(_					addressHostname.f0,_					addressHostname.f1,_					actorRef,_					timeout,_					maximumFramesize,_					null)__			})__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,completable,future,c,connect,final,string,address,final,class,c,clazz,return,connect,internal,address,clazz,actor,ref,actor,ref,tuple2,string,string,address,hostname,extract,address,hostname,actor,ref,return,new,akka,invocation,handler,address,hostname,f0,address,hostname,f1,actor,ref,timeout,maximum,framesize,null
AkkaRpcService -> @Override 	public <C extends RpcGateway> CompletableFuture<C> connect( 			final String address, 			final Class<C> clazz);1526374504;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> CompletableFuture<C> connect(_			final String address,_			final Class<C> clazz) {__		return connectInternal(_			address,_			clazz,_			(ActorRef actorRef) -> {_				Tuple2<String, String> addressHostname = extractAddressHostname(actorRef)___				return new AkkaInvocationHandler(_					addressHostname.f0,_					addressHostname.f1,_					actorRef,_					timeout,_					maximumFramesize,_					null)__			})__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,completable,future,c,connect,final,string,address,final,class,c,clazz,return,connect,internal,address,clazz,actor,ref,actor,ref,tuple2,string,string,address,hostname,extract,address,hostname,actor,ref,return,new,akka,invocation,handler,address,hostname,f0,address,hostname,f1,actor,ref,timeout,maximum,framesize,null
AkkaRpcService -> @Override 	public <C extends RpcGateway> CompletableFuture<C> connect( 			final String address, 			final Class<C> clazz);1531679956;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> CompletableFuture<C> connect(_			final String address,_			final Class<C> clazz) {__		return connectInternal(_			address,_			clazz,_			(ActorRef actorRef) -> {_				Tuple2<String, String> addressHostname = extractAddressHostname(actorRef)___				return new AkkaInvocationHandler(_					addressHostname.f0,_					addressHostname.f1,_					actorRef,_					timeout,_					maximumFramesize,_					null)__			})__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,completable,future,c,connect,final,string,address,final,class,c,clazz,return,connect,internal,address,clazz,actor,ref,actor,ref,tuple2,string,string,address,hostname,extract,address,hostname,actor,ref,return,new,akka,invocation,handler,address,hostname,f0,address,hostname,f1,actor,ref,timeout,maximum,framesize,null
AkkaRpcService -> @Override 	public <C extends RpcGateway> CompletableFuture<C> connect( 			final String address, 			final Class<C> clazz);1539833178;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> CompletableFuture<C> connect(_			final String address,_			final Class<C> clazz) {__		return connectInternal(_			address,_			clazz,_			(ActorRef actorRef) -> {_				Tuple2<String, String> addressHostname = extractAddressHostname(actorRef)___				return new AkkaInvocationHandler(_					addressHostname.f0,_					addressHostname.f1,_					actorRef,_					configuration.getTimeout(),_					configuration.getMaximumFramesize(),_					null)__			})__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,completable,future,c,connect,final,string,address,final,class,c,clazz,return,connect,internal,address,clazz,actor,ref,actor,ref,tuple2,string,string,address,hostname,extract,address,hostname,actor,ref,return,new,akka,invocation,handler,address,hostname,f0,address,hostname,f1,actor,ref,configuration,get,timeout,configuration,get,maximum,framesize,null
AkkaRpcService -> @Override 	public <C extends RpcGateway> CompletableFuture<C> connect( 			final String address, 			final Class<C> clazz);1548316130;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> CompletableFuture<C> connect(_			final String address,_			final Class<C> clazz) {__		return connectInternal(_			address,_			clazz,_			(ActorRef actorRef) -> {_				Tuple2<String, String> addressHostname = extractAddressHostname(actorRef)___				return new AkkaInvocationHandler(_					addressHostname.f0,_					addressHostname.f1,_					actorRef,_					configuration.getTimeout(),_					configuration.getMaximumFramesize(),_					null)__			})__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,completable,future,c,connect,final,string,address,final,class,c,clazz,return,connect,internal,address,clazz,actor,ref,actor,ref,tuple2,string,string,address,hostname,extract,address,hostname,actor,ref,return,new,akka,invocation,handler,address,hostname,f0,address,hostname,f1,actor,ref,configuration,get,timeout,configuration,get,maximum,framesize,null
AkkaRpcService -> @Override 	public <C extends RpcGateway> CompletableFuture<C> connect( 			final String address, 			final Class<C> clazz);1549533702;this method does not mutate state and is thus thread-safe;@Override_	public <C extends RpcGateway> CompletableFuture<C> connect(_			final String address,_			final Class<C> clazz) {__		return connectInternal(_			address,_			clazz,_			(ActorRef actorRef) -> {_				Tuple2<String, String> addressHostname = extractAddressHostname(actorRef)___				return new AkkaInvocationHandler(_					addressHostname.f0,_					addressHostname.f1,_					actorRef,_					configuration.getTimeout(),_					configuration.getMaximumFramesize(),_					null)__			})__	};this,method,does,not,mutate,state,and,is,thus,thread,safe;override,public,c,extends,rpc,gateway,completable,future,c,connect,final,string,address,final,class,c,clazz,return,connect,internal,address,clazz,actor,ref,actor,ref,tuple2,string,string,address,hostname,extract,address,hostname,actor,ref,return,new,akka,invocation,handler,address,hostname,f0,address,hostname,f1,actor,ref,configuration,get,timeout,configuration,get,maximum,framesize,null
