# id;timestamp;commentText;codeText;commentWords;codeWords
CopyOnWriteStateTable -> boolean containsKey(K key, N namespace);1489685642;Returns whether this table contains the specified key/namespace composite key.__@param key       the key in the composite key to search for. Not null._@param namespace the namespace in the composite key to search for. Not null._@return {@code true} if this map contains the specified key/namespace composite key,_{@code false} otherwise.;boolean containsKey(K key, N namespace) {__		final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace)__		final StateTableEntry<K, N, S>[] tab = selectActiveTable(hash)__		int index = hash & (tab.length - 1)___		for (StateTableEntry<K, N, S> e = tab[index]_ e != null_ e = e.next) {_			final K eKey = e.key__			final N eNamespace = e.namespace___			if ((e.hash == hash && key.equals(eKey) && namespace.equals(eNamespace))) {_				return true__			}_		}_		return false__	};returns,whether,this,table,contains,the,specified,key,namespace,composite,key,param,key,the,key,in,the,composite,key,to,search,for,not,null,param,namespace,the,namespace,in,the,composite,key,to,search,for,not,null,return,code,true,if,this,map,contains,the,specified,key,namespace,composite,key,code,false,otherwise;boolean,contains,key,k,key,n,namespace,final,int,hash,compute,hash,for,operation,and,do,incremental,rehash,key,namespace,final,state,table,entry,k,n,s,tab,select,active,table,hash,int,index,hash,tab,length,1,for,state,table,entry,k,n,s,e,tab,index,e,null,e,e,next,final,k,e,key,e,key,final,n,e,namespace,e,namespace,if,e,hash,hash,key,equals,e,key,namespace,equals,e,namespace,return,true,return,false
CopyOnWriteStateTable -> boolean containsKey(K key, N namespace);1494180263;Returns whether this table contains the specified key/namespace composite key.__@param key       the key in the composite key to search for. Not null._@param namespace the namespace in the composite key to search for. Not null._@return {@code true} if this map contains the specified key/namespace composite key,_{@code false} otherwise.;boolean containsKey(K key, N namespace) {__		final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace)__		final StateTableEntry<K, N, S>[] tab = selectActiveTable(hash)__		int index = hash & (tab.length - 1)___		for (StateTableEntry<K, N, S> e = tab[index]_ e != null_ e = e.next) {_			final K eKey = e.key__			final N eNamespace = e.namespace___			if ((e.hash == hash && key.equals(eKey) && namespace.equals(eNamespace))) {_				return true__			}_		}_		return false__	};returns,whether,this,table,contains,the,specified,key,namespace,composite,key,param,key,the,key,in,the,composite,key,to,search,for,not,null,param,namespace,the,namespace,in,the,composite,key,to,search,for,not,null,return,code,true,if,this,map,contains,the,specified,key,namespace,composite,key,code,false,otherwise;boolean,contains,key,k,key,n,namespace,final,int,hash,compute,hash,for,operation,and,do,incremental,rehash,key,namespace,final,state,table,entry,k,n,s,tab,select,active,table,hash,int,index,hash,tab,length,1,for,state,table,entry,k,n,s,e,tab,index,e,null,e,e,next,final,k,e,key,e,key,final,n,e,namespace,e,namespace,if,e,hash,hash,key,equals,e,key,namespace,equals,e,namespace,return,true,return,false
CopyOnWriteStateTable -> boolean containsKey(K key, N namespace);1506609393;Returns whether this table contains the specified key/namespace composite key.__@param key       the key in the composite key to search for. Not null._@param namespace the namespace in the composite key to search for. Not null._@return {@code true} if this map contains the specified key/namespace composite key,_{@code false} otherwise.;boolean containsKey(K key, N namespace) {__		final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace)__		final StateTableEntry<K, N, S>[] tab = selectActiveTable(hash)__		int index = hash & (tab.length - 1)___		for (StateTableEntry<K, N, S> e = tab[index]_ e != null_ e = e.next) {_			final K eKey = e.key__			final N eNamespace = e.namespace___			if ((e.hash == hash && key.equals(eKey) && namespace.equals(eNamespace))) {_				return true__			}_		}_		return false__	};returns,whether,this,table,contains,the,specified,key,namespace,composite,key,param,key,the,key,in,the,composite,key,to,search,for,not,null,param,namespace,the,namespace,in,the,composite,key,to,search,for,not,null,return,code,true,if,this,map,contains,the,specified,key,namespace,composite,key,code,false,otherwise;boolean,contains,key,k,key,n,namespace,final,int,hash,compute,hash,for,operation,and,do,incremental,rehash,key,namespace,final,state,table,entry,k,n,s,tab,select,active,table,hash,int,index,hash,tab,length,1,for,state,table,entry,k,n,s,e,tab,index,e,null,e,e,next,final,k,e,key,e,key,final,n,e,namespace,e,namespace,if,e,hash,hash,key,equals,e,key,namespace,equals,e,namespace,return,true,return,false
CopyOnWriteStateTable -> boolean containsKey(K key, N namespace);1519379856;Returns whether this table contains the specified key/namespace composite key.__@param key       the key in the composite key to search for. Not null._@param namespace the namespace in the composite key to search for. Not null._@return {@code true} if this map contains the specified key/namespace composite key,_{@code false} otherwise.;boolean containsKey(K key, N namespace) {__		final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace)__		final StateTableEntry<K, N, S>[] tab = selectActiveTable(hash)__		int index = hash & (tab.length - 1)___		for (StateTableEntry<K, N, S> e = tab[index]_ e != null_ e = e.next) {_			final K eKey = e.key__			final N eNamespace = e.namespace___			if ((e.hash == hash && key.equals(eKey) && namespace.equals(eNamespace))) {_				return true__			}_		}_		return false__	};returns,whether,this,table,contains,the,specified,key,namespace,composite,key,param,key,the,key,in,the,composite,key,to,search,for,not,null,param,namespace,the,namespace,in,the,composite,key,to,search,for,not,null,return,code,true,if,this,map,contains,the,specified,key,namespace,composite,key,code,false,otherwise;boolean,contains,key,k,key,n,namespace,final,int,hash,compute,hash,for,operation,and,do,incremental,rehash,key,namespace,final,state,table,entry,k,n,s,tab,select,active,table,hash,int,index,hash,tab,length,1,for,state,table,entry,k,n,s,e,tab,index,e,null,e,e,next,final,k,e,key,e,key,final,n,e,namespace,e,namespace,if,e,hash,hash,key,equals,e,key,namespace,equals,e,namespace,return,true,return,false
CopyOnWriteStateTable -> boolean containsKey(K key, N namespace);1529089579;Returns whether this table contains the specified key/namespace composite key.__@param key       the key in the composite key to search for. Not null._@param namespace the namespace in the composite key to search for. Not null._@return {@code true} if this map contains the specified key/namespace composite key,_{@code false} otherwise.;boolean containsKey(K key, N namespace) {__		final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace)__		final StateTableEntry<K, N, S>[] tab = selectActiveTable(hash)__		int index = hash & (tab.length - 1)___		for (StateTableEntry<K, N, S> e = tab[index]_ e != null_ e = e.next) {_			final K eKey = e.key__			final N eNamespace = e.namespace___			if ((e.hash == hash && key.equals(eKey) && namespace.equals(eNamespace))) {_				return true__			}_		}_		return false__	};returns,whether,this,table,contains,the,specified,key,namespace,composite,key,param,key,the,key,in,the,composite,key,to,search,for,not,null,param,namespace,the,namespace,in,the,composite,key,to,search,for,not,null,return,code,true,if,this,map,contains,the,specified,key,namespace,composite,key,code,false,otherwise;boolean,contains,key,k,key,n,namespace,final,int,hash,compute,hash,for,operation,and,do,incremental,rehash,key,namespace,final,state,table,entry,k,n,s,tab,select,active,table,hash,int,index,hash,tab,length,1,for,state,table,entry,k,n,s,e,tab,index,e,null,e,e,next,final,k,e,key,e,key,final,n,e,namespace,e,namespace,if,e,hash,hash,key,equals,e,key,namespace,equals,e,namespace,return,true,return,false
CopyOnWriteStateTable -> boolean containsKey(K key, N namespace);1529089584;Returns whether this table contains the specified key/namespace composite key.__@param key       the key in the composite key to search for. Not null._@param namespace the namespace in the composite key to search for. Not null._@return {@code true} if this map contains the specified key/namespace composite key,_{@code false} otherwise.;boolean containsKey(K key, N namespace) {__		final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace)__		final StateTableEntry<K, N, S>[] tab = selectActiveTable(hash)__		int index = hash & (tab.length - 1)___		for (StateTableEntry<K, N, S> e = tab[index]_ e != null_ e = e.next) {_			final K eKey = e.key__			final N eNamespace = e.namespace___			if ((e.hash == hash && key.equals(eKey) && namespace.equals(eNamespace))) {_				return true__			}_		}_		return false__	};returns,whether,this,table,contains,the,specified,key,namespace,composite,key,param,key,the,key,in,the,composite,key,to,search,for,not,null,param,namespace,the,namespace,in,the,composite,key,to,search,for,not,null,return,code,true,if,this,map,contains,the,specified,key,namespace,composite,key,code,false,otherwise;boolean,contains,key,k,key,n,namespace,final,int,hash,compute,hash,for,operation,and,do,incremental,rehash,key,namespace,final,state,table,entry,k,n,s,tab,select,active,table,hash,int,index,hash,tab,length,1,for,state,table,entry,k,n,s,e,tab,index,e,null,e,e,next,final,k,e,key,e,key,final,n,e,namespace,e,namespace,if,e,hash,hash,key,equals,e,key,namespace,equals,e,namespace,return,true,return,false
CopyOnWriteStateTable -> boolean containsKey(K key, N namespace);1529307900;Returns whether this table contains the specified key/namespace composite key.__@param key       the key in the composite key to search for. Not null._@param namespace the namespace in the composite key to search for. Not null._@return {@code true} if this map contains the specified key/namespace composite key,_{@code false} otherwise.;boolean containsKey(K key, N namespace) {__		final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace)__		final StateTableEntry<K, N, S>[] tab = selectActiveTable(hash)__		int index = hash & (tab.length - 1)___		for (StateTableEntry<K, N, S> e = tab[index]_ e != null_ e = e.next) {_			final K eKey = e.key__			final N eNamespace = e.namespace___			if ((e.hash == hash && key.equals(eKey) && namespace.equals(eNamespace))) {_				return true__			}_		}_		return false__	};returns,whether,this,table,contains,the,specified,key,namespace,composite,key,param,key,the,key,in,the,composite,key,to,search,for,not,null,param,namespace,the,namespace,in,the,composite,key,to,search,for,not,null,return,code,true,if,this,map,contains,the,specified,key,namespace,composite,key,code,false,otherwise;boolean,contains,key,k,key,n,namespace,final,int,hash,compute,hash,for,operation,and,do,incremental,rehash,key,namespace,final,state,table,entry,k,n,s,tab,select,active,table,hash,int,index,hash,tab,length,1,for,state,table,entry,k,n,s,e,tab,index,e,null,e,e,next,final,k,e,key,e,key,final,n,e,namespace,e,namespace,if,e,hash,hash,key,equals,e,key,namespace,equals,e,namespace,return,true,return,false
CopyOnWriteStateTable -> boolean containsKey(K key, N namespace);1530639128;Returns whether this table contains the specified key/namespace composite key.__@param key       the key in the composite key to search for. Not null._@param namespace the namespace in the composite key to search for. Not null._@return {@code true} if this map contains the specified key/namespace composite key,_{@code false} otherwise.;boolean containsKey(K key, N namespace) {__		final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace)__		final StateTableEntry<K, N, S>[] tab = selectActiveTable(hash)__		int index = hash & (tab.length - 1)___		for (StateTableEntry<K, N, S> e = tab[index]_ e != null_ e = e.next) {_			final K eKey = e.key__			final N eNamespace = e.namespace___			if ((e.hash == hash && key.equals(eKey) && namespace.equals(eNamespace))) {_				return true__			}_		}_		return false__	};returns,whether,this,table,contains,the,specified,key,namespace,composite,key,param,key,the,key,in,the,composite,key,to,search,for,not,null,param,namespace,the,namespace,in,the,composite,key,to,search,for,not,null,return,code,true,if,this,map,contains,the,specified,key,namespace,composite,key,code,false,otherwise;boolean,contains,key,k,key,n,namespace,final,int,hash,compute,hash,for,operation,and,do,incremental,rehash,key,namespace,final,state,table,entry,k,n,s,tab,select,active,table,hash,int,index,hash,tab,length,1,for,state,table,entry,k,n,s,e,tab,index,e,null,e,e,next,final,k,e,key,e,key,final,n,e,namespace,e,namespace,if,e,hash,hash,key,equals,e,key,namespace,equals,e,namespace,return,true,return,false
CopyOnWriteStateTable -> boolean containsKey(K key, N namespace);1531771917;Returns whether this table contains the specified key/namespace composite key.__@param key       the key in the composite key to search for. Not null._@param namespace the namespace in the composite key to search for. Not null._@return {@code true} if this map contains the specified key/namespace composite key,_{@code false} otherwise.;boolean containsKey(K key, N namespace) {__		final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace)__		final StateTableEntry<K, N, S>[] tab = selectActiveTable(hash)__		int index = hash & (tab.length - 1)___		for (StateTableEntry<K, N, S> e = tab[index]_ e != null_ e = e.next) {_			final K eKey = e.key__			final N eNamespace = e.namespace___			if ((e.hash == hash && key.equals(eKey) && namespace.equals(eNamespace))) {_				return true__			}_		}_		return false__	};returns,whether,this,table,contains,the,specified,key,namespace,composite,key,param,key,the,key,in,the,composite,key,to,search,for,not,null,param,namespace,the,namespace,in,the,composite,key,to,search,for,not,null,return,code,true,if,this,map,contains,the,specified,key,namespace,composite,key,code,false,otherwise;boolean,contains,key,k,key,n,namespace,final,int,hash,compute,hash,for,operation,and,do,incremental,rehash,key,namespace,final,state,table,entry,k,n,s,tab,select,active,table,hash,int,index,hash,tab,length,1,for,state,table,entry,k,n,s,e,tab,index,e,null,e,e,next,final,k,e,key,e,key,final,n,e,namespace,e,namespace,if,e,hash,hash,key,equals,e,key,namespace,equals,e,namespace,return,true,return,false
CopyOnWriteStateTable -> boolean containsKey(K key, N namespace);1548755874;Returns whether this table contains the specified key/namespace composite key.__@param key       the key in the composite key to search for. Not null._@param namespace the namespace in the composite key to search for. Not null._@return {@code true} if this map contains the specified key/namespace composite key,_{@code false} otherwise.;boolean containsKey(K key, N namespace) {__		final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace)__		final StateTableEntry<K, N, S>[] tab = selectActiveTable(hash)__		int index = hash & (tab.length - 1)___		for (StateTableEntry<K, N, S> e = tab[index]_ e != null_ e = e.next) {_			final K eKey = e.key__			final N eNamespace = e.namespace___			if ((e.hash == hash && key.equals(eKey) && namespace.equals(eNamespace))) {_				return true__			}_		}_		return false__	};returns,whether,this,table,contains,the,specified,key,namespace,composite,key,param,key,the,key,in,the,composite,key,to,search,for,not,null,param,namespace,the,namespace,in,the,composite,key,to,search,for,not,null,return,code,true,if,this,map,contains,the,specified,key,namespace,composite,key,code,false,otherwise;boolean,contains,key,k,key,n,namespace,final,int,hash,compute,hash,for,operation,and,do,incremental,rehash,key,namespace,final,state,table,entry,k,n,s,tab,select,active,table,hash,int,index,hash,tab,length,1,for,state,table,entry,k,n,s,e,tab,index,e,null,e,e,next,final,k,e,key,e,key,final,n,e,namespace,e,namespace,if,e,hash,hash,key,equals,e,key,namespace,equals,e,namespace,return,true,return,false
CopyOnWriteStateTable -> private StateTableEntry<K, N, S>[] makeTable(int newCapacity);1489685642;Allocate a table of the given capacity and set the threshold accordingly.__@param newCapacity must be a power of two;private StateTableEntry<K, N, S>[] makeTable(int newCapacity) {__		if (MAXIMUM_CAPACITY == newCapacity) {_			LOG.warn("Maximum capacity of 2^30 in StateTable reached. Cannot increase hash table size. This can lead " +_					"to more collisions and lower performance. Please consider scaling-out your job or using a " +_					"different keyed state backend implementation!")__		}__		threshold = (newCapacity >> 1) + (newCapacity >> 2)_ _		@SuppressWarnings("unchecked") StateTableEntry<K, N, S>[] newTable_				= (StateTableEntry<K, N, S>[]) new StateTableEntry[newCapacity]__		return newTable__	};allocate,a,table,of,the,given,capacity,and,set,the,threshold,accordingly,param,new,capacity,must,be,a,power,of,two;private,state,table,entry,k,n,s,make,table,int,new,capacity,if,new,capacity,log,warn,maximum,capacity,of,2,30,in,state,table,reached,cannot,increase,hash,table,size,this,can,lead,to,more,collisions,and,lower,performance,please,consider,scaling,out,your,job,or,using,a,different,keyed,state,backend,implementation,threshold,new,capacity,1,new,capacity,2,suppress,warnings,unchecked,state,table,entry,k,n,s,new,table,state,table,entry,k,n,s,new,state,table,entry,new,capacity,return,new,table
CopyOnWriteStateTable -> private StateTableEntry<K, N, S>[] makeTable(int newCapacity);1494180263;Allocate a table of the given capacity and set the threshold accordingly.__@param newCapacity must be a power of two;private StateTableEntry<K, N, S>[] makeTable(int newCapacity) {__		if (MAXIMUM_CAPACITY == newCapacity) {_			LOG.warn("Maximum capacity of 2^30 in StateTable reached. Cannot increase hash table size. This can lead " +_					"to more collisions and lower performance. Please consider scaling-out your job or using a " +_					"different keyed state backend implementation!")__		}__		threshold = (newCapacity >> 1) + (newCapacity >> 2)_ _		@SuppressWarnings("unchecked") StateTableEntry<K, N, S>[] newTable_				= (StateTableEntry<K, N, S>[]) new StateTableEntry[newCapacity]__		return newTable__	};allocate,a,table,of,the,given,capacity,and,set,the,threshold,accordingly,param,new,capacity,must,be,a,power,of,two;private,state,table,entry,k,n,s,make,table,int,new,capacity,if,new,capacity,log,warn,maximum,capacity,of,2,30,in,state,table,reached,cannot,increase,hash,table,size,this,can,lead,to,more,collisions,and,lower,performance,please,consider,scaling,out,your,job,or,using,a,different,keyed,state,backend,implementation,threshold,new,capacity,1,new,capacity,2,suppress,warnings,unchecked,state,table,entry,k,n,s,new,table,state,table,entry,k,n,s,new,state,table,entry,new,capacity,return,new,table
CopyOnWriteStateTable -> private StateTableEntry<K, N, S>[] makeTable(int newCapacity);1506609393;Allocate a table of the given capacity and set the threshold accordingly.__@param newCapacity must be a power of two;private StateTableEntry<K, N, S>[] makeTable(int newCapacity) {__		if (MAXIMUM_CAPACITY == newCapacity) {_			LOG.warn("Maximum capacity of 2^30 in StateTable reached. Cannot increase hash table size. This can lead " +_					"to more collisions and lower performance. Please consider scaling-out your job or using a " +_					"different keyed state backend implementation!")__		}__		threshold = (newCapacity >> 1) + (newCapacity >> 2)_ _		@SuppressWarnings("unchecked") StateTableEntry<K, N, S>[] newTable_				= (StateTableEntry<K, N, S>[]) new StateTableEntry[newCapacity]__		return newTable__	};allocate,a,table,of,the,given,capacity,and,set,the,threshold,accordingly,param,new,capacity,must,be,a,power,of,two;private,state,table,entry,k,n,s,make,table,int,new,capacity,if,new,capacity,log,warn,maximum,capacity,of,2,30,in,state,table,reached,cannot,increase,hash,table,size,this,can,lead,to,more,collisions,and,lower,performance,please,consider,scaling,out,your,job,or,using,a,different,keyed,state,backend,implementation,threshold,new,capacity,1,new,capacity,2,suppress,warnings,unchecked,state,table,entry,k,n,s,new,table,state,table,entry,k,n,s,new,state,table,entry,new,capacity,return,new,table
CopyOnWriteStateTable -> private StateTableEntry<K, N, S>[] makeTable(int newCapacity);1519379856;Allocate a table of the given capacity and set the threshold accordingly.__@param newCapacity must be a power of two;private StateTableEntry<K, N, S>[] makeTable(int newCapacity) {__		if (MAXIMUM_CAPACITY == newCapacity) {_			LOG.warn("Maximum capacity of 2^30 in StateTable reached. Cannot increase hash table size. This can lead " +_					"to more collisions and lower performance. Please consider scaling-out your job or using a " +_					"different keyed state backend implementation!")__		}__		threshold = (newCapacity >> 1) + (newCapacity >> 2)_ _		@SuppressWarnings("unchecked") StateTableEntry<K, N, S>[] newTable_				= (StateTableEntry<K, N, S>[]) new StateTableEntry[newCapacity]__		return newTable__	};allocate,a,table,of,the,given,capacity,and,set,the,threshold,accordingly,param,new,capacity,must,be,a,power,of,two;private,state,table,entry,k,n,s,make,table,int,new,capacity,if,new,capacity,log,warn,maximum,capacity,of,2,30,in,state,table,reached,cannot,increase,hash,table,size,this,can,lead,to,more,collisions,and,lower,performance,please,consider,scaling,out,your,job,or,using,a,different,keyed,state,backend,implementation,threshold,new,capacity,1,new,capacity,2,suppress,warnings,unchecked,state,table,entry,k,n,s,new,table,state,table,entry,k,n,s,new,state,table,entry,new,capacity,return,new,table
CopyOnWriteStateTable -> private StateTableEntry<K, N, S>[] makeTable(int newCapacity);1529089579;Allocate a table of the given capacity and set the threshold accordingly.__@param newCapacity must be a power of two;private StateTableEntry<K, N, S>[] makeTable(int newCapacity) {__		if (MAXIMUM_CAPACITY == newCapacity) {_			LOG.warn("Maximum capacity of 2^30 in StateTable reached. Cannot increase hash table size. This can lead " +_					"to more collisions and lower performance. Please consider scaling-out your job or using a " +_					"different keyed state backend implementation!")__		}__		threshold = (newCapacity >> 1) + (newCapacity >> 2)_ _		@SuppressWarnings("unchecked") StateTableEntry<K, N, S>[] newTable_				= (StateTableEntry<K, N, S>[]) new StateTableEntry[newCapacity]__		return newTable__	};allocate,a,table,of,the,given,capacity,and,set,the,threshold,accordingly,param,new,capacity,must,be,a,power,of,two;private,state,table,entry,k,n,s,make,table,int,new,capacity,if,new,capacity,log,warn,maximum,capacity,of,2,30,in,state,table,reached,cannot,increase,hash,table,size,this,can,lead,to,more,collisions,and,lower,performance,please,consider,scaling,out,your,job,or,using,a,different,keyed,state,backend,implementation,threshold,new,capacity,1,new,capacity,2,suppress,warnings,unchecked,state,table,entry,k,n,s,new,table,state,table,entry,k,n,s,new,state,table,entry,new,capacity,return,new,table
CopyOnWriteStateTable -> private StateTableEntry<K, N, S>[] makeTable(int newCapacity);1529089584;Allocate a table of the given capacity and set the threshold accordingly.__@param newCapacity must be a power of two;private StateTableEntry<K, N, S>[] makeTable(int newCapacity) {__		if (newCapacity < MAXIMUM_CAPACITY) {_			threshold = (newCapacity >> 1) + (newCapacity >> 2)_ _		} else {_			if (size() > MAX_ARRAY_SIZE) {__				throw new IllegalStateException("Maximum capacity of CopyOnWriteStateTable is reached and the job " +_					"cannot continue. Please consider scaling-out your job or using a different keyed state backend " +_					"implementation!")__			} else {__				LOG.warn("Maximum capacity of 2^30 in StateTable reached. Cannot increase hash table size. This can " +_					"lead to more collisions and lower performance. Please consider scaling-out your job or using a " +_					"different keyed state backend implementation!")__				threshold = MAX_ARRAY_SIZE__			}_		}__		@SuppressWarnings("unchecked") StateTableEntry<K, N, S>[] newTable_				= (StateTableEntry<K, N, S>[]) new StateTableEntry[newCapacity]__		return newTable__	};allocate,a,table,of,the,given,capacity,and,set,the,threshold,accordingly,param,new,capacity,must,be,a,power,of,two;private,state,table,entry,k,n,s,make,table,int,new,capacity,if,new,capacity,threshold,new,capacity,1,new,capacity,2,else,if,size,throw,new,illegal,state,exception,maximum,capacity,of,copy,on,write,state,table,is,reached,and,the,job,cannot,continue,please,consider,scaling,out,your,job,or,using,a,different,keyed,state,backend,implementation,else,log,warn,maximum,capacity,of,2,30,in,state,table,reached,cannot,increase,hash,table,size,this,can,lead,to,more,collisions,and,lower,performance,please,consider,scaling,out,your,job,or,using,a,different,keyed,state,backend,implementation,threshold,suppress,warnings,unchecked,state,table,entry,k,n,s,new,table,state,table,entry,k,n,s,new,state,table,entry,new,capacity,return,new,table
CopyOnWriteStateTable -> private StateTableEntry<K, N, S>[] makeTable(int newCapacity);1529307900;Allocate a table of the given capacity and set the threshold accordingly.__@param newCapacity must be a power of two;private StateTableEntry<K, N, S>[] makeTable(int newCapacity) {__		if (newCapacity < MAXIMUM_CAPACITY) {_			threshold = (newCapacity >> 1) + (newCapacity >> 2)_ _		} else {_			if (size() > MAX_ARRAY_SIZE) {__				throw new IllegalStateException("Maximum capacity of CopyOnWriteStateTable is reached and the job " +_					"cannot continue. Please consider scaling-out your job or using a different keyed state backend " +_					"implementation!")__			} else {__				LOG.warn("Maximum capacity of 2^30 in StateTable reached. Cannot increase hash table size. This can " +_					"lead to more collisions and lower performance. Please consider scaling-out your job or using a " +_					"different keyed state backend implementation!")__				threshold = MAX_ARRAY_SIZE__			}_		}__		@SuppressWarnings("unchecked") StateTableEntry<K, N, S>[] newTable_				= (StateTableEntry<K, N, S>[]) new StateTableEntry[newCapacity]__		return newTable__	};allocate,a,table,of,the,given,capacity,and,set,the,threshold,accordingly,param,new,capacity,must,be,a,power,of,two;private,state,table,entry,k,n,s,make,table,int,new,capacity,if,new,capacity,threshold,new,capacity,1,new,capacity,2,else,if,size,throw,new,illegal,state,exception,maximum,capacity,of,copy,on,write,state,table,is,reached,and,the,job,cannot,continue,please,consider,scaling,out,your,job,or,using,a,different,keyed,state,backend,implementation,else,log,warn,maximum,capacity,of,2,30,in,state,table,reached,cannot,increase,hash,table,size,this,can,lead,to,more,collisions,and,lower,performance,please,consider,scaling,out,your,job,or,using,a,different,keyed,state,backend,implementation,threshold,suppress,warnings,unchecked,state,table,entry,k,n,s,new,table,state,table,entry,k,n,s,new,state,table,entry,new,capacity,return,new,table
CopyOnWriteStateTable -> private StateTableEntry<K, N, S>[] makeTable(int newCapacity);1530639128;Allocate a table of the given capacity and set the threshold accordingly.__@param newCapacity must be a power of two;private StateTableEntry<K, N, S>[] makeTable(int newCapacity) {__		if (newCapacity < MAXIMUM_CAPACITY) {_			threshold = (newCapacity >> 1) + (newCapacity >> 2)_ _		} else {_			if (size() > MAX_ARRAY_SIZE) {__				throw new IllegalStateException("Maximum capacity of CopyOnWriteStateTable is reached and the job " +_					"cannot continue. Please consider scaling-out your job or using a different keyed state backend " +_					"implementation!")__			} else {__				LOG.warn("Maximum capacity of 2^30 in StateTable reached. Cannot increase hash table size. This can " +_					"lead to more collisions and lower performance. Please consider scaling-out your job or using a " +_					"different keyed state backend implementation!")__				threshold = MAX_ARRAY_SIZE__			}_		}__		@SuppressWarnings("unchecked") StateTableEntry<K, N, S>[] newTable_				= (StateTableEntry<K, N, S>[]) new StateTableEntry[newCapacity]__		return newTable__	};allocate,a,table,of,the,given,capacity,and,set,the,threshold,accordingly,param,new,capacity,must,be,a,power,of,two;private,state,table,entry,k,n,s,make,table,int,new,capacity,if,new,capacity,threshold,new,capacity,1,new,capacity,2,else,if,size,throw,new,illegal,state,exception,maximum,capacity,of,copy,on,write,state,table,is,reached,and,the,job,cannot,continue,please,consider,scaling,out,your,job,or,using,a,different,keyed,state,backend,implementation,else,log,warn,maximum,capacity,of,2,30,in,state,table,reached,cannot,increase,hash,table,size,this,can,lead,to,more,collisions,and,lower,performance,please,consider,scaling,out,your,job,or,using,a,different,keyed,state,backend,implementation,threshold,suppress,warnings,unchecked,state,table,entry,k,n,s,new,table,state,table,entry,k,n,s,new,state,table,entry,new,capacity,return,new,table
CopyOnWriteStateTable -> private StateTableEntry<K, N, S>[] makeTable(int newCapacity);1531771917;Allocate a table of the given capacity and set the threshold accordingly.__@param newCapacity must be a power of two;private StateTableEntry<K, N, S>[] makeTable(int newCapacity) {__		if (newCapacity < MAXIMUM_CAPACITY) {_			threshold = (newCapacity >> 1) + (newCapacity >> 2)_ _		} else {_			if (size() > MAX_ARRAY_SIZE) {__				throw new IllegalStateException("Maximum capacity of CopyOnWriteStateTable is reached and the job " +_					"cannot continue. Please consider scaling-out your job or using a different keyed state backend " +_					"implementation!")__			} else {__				LOG.warn("Maximum capacity of 2^30 in StateTable reached. Cannot increase hash table size. This can " +_					"lead to more collisions and lower performance. Please consider scaling-out your job or using a " +_					"different keyed state backend implementation!")__				threshold = MAX_ARRAY_SIZE__			}_		}__		@SuppressWarnings("unchecked") StateTableEntry<K, N, S>[] newTable_				= (StateTableEntry<K, N, S>[]) new StateTableEntry[newCapacity]__		return newTable__	};allocate,a,table,of,the,given,capacity,and,set,the,threshold,accordingly,param,new,capacity,must,be,a,power,of,two;private,state,table,entry,k,n,s,make,table,int,new,capacity,if,new,capacity,threshold,new,capacity,1,new,capacity,2,else,if,size,throw,new,illegal,state,exception,maximum,capacity,of,copy,on,write,state,table,is,reached,and,the,job,cannot,continue,please,consider,scaling,out,your,job,or,using,a,different,keyed,state,backend,implementation,else,log,warn,maximum,capacity,of,2,30,in,state,table,reached,cannot,increase,hash,table,size,this,can,lead,to,more,collisions,and,lower,performance,please,consider,scaling,out,your,job,or,using,a,different,keyed,state,backend,implementation,threshold,suppress,warnings,unchecked,state,table,entry,k,n,s,new,table,state,table,entry,k,n,s,new,state,table,entry,new,capacity,return,new,table
CopyOnWriteStateTable -> private StateTableEntry<K, N, S>[] makeTable(int newCapacity);1548755874;Allocate a table of the given capacity and set the threshold accordingly.__@param newCapacity must be a power of two;private StateTableEntry<K, N, S>[] makeTable(int newCapacity) {__		if (newCapacity < MAXIMUM_CAPACITY) {_			threshold = (newCapacity >> 1) + (newCapacity >> 2)_ _		} else {_			if (size() > MAX_ARRAY_SIZE) {__				throw new IllegalStateException("Maximum capacity of CopyOnWriteStateTable is reached and the job " +_					"cannot continue. Please consider scaling-out your job or using a different keyed state backend " +_					"implementation!")__			} else {__				LOG.warn("Maximum capacity of 2^30 in StateTable reached. Cannot increase hash table size. This can " +_					"lead to more collisions and lower performance. Please consider scaling-out your job or using a " +_					"different keyed state backend implementation!")__				threshold = MAX_ARRAY_SIZE__			}_		}__		@SuppressWarnings("unchecked") StateTableEntry<K, N, S>[] newTable_				= (StateTableEntry<K, N, S>[]) new StateTableEntry[newCapacity]__		return newTable__	};allocate,a,table,of,the,given,capacity,and,set,the,threshold,accordingly,param,new,capacity,must,be,a,power,of,two;private,state,table,entry,k,n,s,make,table,int,new,capacity,if,new,capacity,threshold,new,capacity,1,new,capacity,2,else,if,size,throw,new,illegal,state,exception,maximum,capacity,of,copy,on,write,state,table,is,reached,and,the,job,cannot,continue,please,consider,scaling,out,your,job,or,using,a,different,keyed,state,backend,implementation,else,log,warn,maximum,capacity,of,2,30,in,state,table,reached,cannot,increase,hash,table,size,this,can,lead,to,more,collisions,and,lower,performance,please,consider,scaling,out,your,job,or,using,a,different,keyed,state,backend,implementation,threshold,suppress,warnings,unchecked,state,table,entry,k,n,s,new,table,state,table,entry,k,n,s,new,state,table,entry,new,capacity,return,new,table
CopyOnWriteStateTable -> CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo);1494180263;Constructs a new {@code StateTable} with default capacity of 1024.__@param keyContext the key context._@param metaInfo   the meta information, including the type serializer for state copy-on-write.;CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo) {_		this(keyContext, metaInfo, 1024)__	};constructs,a,new,code,state,table,with,default,capacity,of,1024,param,key,context,the,key,context,param,meta,info,the,meta,information,including,the,type,serializer,for,state,copy,on,write;copy,on,write,state,table,internal,key,context,k,key,context,registered,keyed,backend,state,meta,info,n,s,meta,info,this,key,context,meta,info,1024
CopyOnWriteStateTable -> CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo);1506609393;Constructs a new {@code StateTable} with default capacity of 1024.__@param keyContext the key context._@param metaInfo   the meta information, including the type serializer for state copy-on-write.;CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo) {_		this(keyContext, metaInfo, 1024)__	};constructs,a,new,code,state,table,with,default,capacity,of,1024,param,key,context,the,key,context,param,meta,info,the,meta,information,including,the,type,serializer,for,state,copy,on,write;copy,on,write,state,table,internal,key,context,k,key,context,registered,keyed,backend,state,meta,info,n,s,meta,info,this,key,context,meta,info,1024
CopyOnWriteStateTable -> CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo);1519379856;Constructs a new {@code StateTable} with default capacity of 1024.__@param keyContext the key context._@param metaInfo   the meta information, including the type serializer for state copy-on-write.;CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo) {_		this(keyContext, metaInfo, 1024)__	};constructs,a,new,code,state,table,with,default,capacity,of,1024,param,key,context,the,key,context,param,meta,info,the,meta,information,including,the,type,serializer,for,state,copy,on,write;copy,on,write,state,table,internal,key,context,k,key,context,registered,keyed,backend,state,meta,info,n,s,meta,info,this,key,context,meta,info,1024
CopyOnWriteStateTable -> CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo);1529089579;Constructs a new {@code StateTable} with default capacity of 1024.__@param keyContext the key context._@param metaInfo   the meta information, including the type serializer for state copy-on-write.;CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo) {_		this(keyContext, metaInfo, 1024)__	};constructs,a,new,code,state,table,with,default,capacity,of,1024,param,key,context,the,key,context,param,meta,info,the,meta,information,including,the,type,serializer,for,state,copy,on,write;copy,on,write,state,table,internal,key,context,k,key,context,registered,keyed,backend,state,meta,info,n,s,meta,info,this,key,context,meta,info,1024
CopyOnWriteStateTable -> CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo);1529089584;Constructs a new {@code StateTable} with default capacity of 1024.__@param keyContext the key context._@param metaInfo   the meta information, including the type serializer for state copy-on-write.;CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo) {_		this(keyContext, metaInfo, 1024)__	};constructs,a,new,code,state,table,with,default,capacity,of,1024,param,key,context,the,key,context,param,meta,info,the,meta,information,including,the,type,serializer,for,state,copy,on,write;copy,on,write,state,table,internal,key,context,k,key,context,registered,keyed,backend,state,meta,info,n,s,meta,info,this,key,context,meta,info,1024
CopyOnWriteStateTable -> CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo);1529307900;Constructs a new {@code StateTable} with default capacity of 1024.__@param keyContext the key context._@param metaInfo   the meta information, including the type serializer for state copy-on-write.;CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo) {_		this(keyContext, metaInfo, 1024)__	};constructs,a,new,code,state,table,with,default,capacity,of,1024,param,key,context,the,key,context,param,meta,info,the,meta,information,including,the,type,serializer,for,state,copy,on,write;copy,on,write,state,table,internal,key,context,k,key,context,registered,keyed,backend,state,meta,info,n,s,meta,info,this,key,context,meta,info,1024
CopyOnWriteStateTable -> CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo);1530639128;Constructs a new {@code StateTable} with default capacity of 1024.__@param keyContext the key context._@param metaInfo   the meta information, including the type serializer for state copy-on-write.;CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo) {_		this(keyContext, metaInfo, 1024)__	};constructs,a,new,code,state,table,with,default,capacity,of,1024,param,key,context,the,key,context,param,meta,info,the,meta,information,including,the,type,serializer,for,state,copy,on,write;copy,on,write,state,table,internal,key,context,k,key,context,registered,keyed,backend,state,meta,info,n,s,meta,info,this,key,context,meta,info,1024
CopyOnWriteStateTable -> <T> void transform( 			K key, 			N namespace, 			T value, 			StateTransformationFunction<S, T> transformation) throws Exception;1489685642;@param key            the key of the mapping to remove. Not null._@param namespace      the namespace of the mapping to remove. Not null._@param value          the value that is the second input for the transformation._@param transformation the transformation function to apply on the old state and the given value._@param <T>            type of the value that is the second input to the {@link StateTransformationFunction}._@throws Exception exception that happen on applying the function._@see #transform(Object, Object, StateTransformationFunction).;<T> void transform(_			K key,_			N namespace,_			T value,_			StateTransformationFunction<S, T> transformation) throws Exception {__		final StateTableEntry<K, N, S> entry = putEntry(key, namespace)___		_		entry.state = transformation.apply(_				(entry.stateVersion < highestRequiredSnapshotVersion) ?_						getStateSerializer().copy(entry.state) :_						entry.state,_				value)__		entry.stateVersion = stateTableVersion__	};param,key,the,key,of,the,mapping,to,remove,not,null,param,namespace,the,namespace,of,the,mapping,to,remove,not,null,param,value,the,value,that,is,the,second,input,for,the,transformation,param,transformation,the,transformation,function,to,apply,on,the,old,state,and,the,given,value,param,t,type,of,the,value,that,is,the,second,input,to,the,link,state,transformation,function,throws,exception,exception,that,happen,on,applying,the,function,see,transform,object,object,state,transformation,function;t,void,transform,k,key,n,namespace,t,value,state,transformation,function,s,t,transformation,throws,exception,final,state,table,entry,k,n,s,entry,put,entry,key,namespace,entry,state,transformation,apply,entry,state,version,highest,required,snapshot,version,get,state,serializer,copy,entry,state,entry,state,value,entry,state,version,state,table,version
CopyOnWriteStateTable -> <T> void transform( 			K key, 			N namespace, 			T value, 			StateTransformationFunction<S, T> transformation) throws Exception;1494180263;@param key            the key of the mapping to remove. Not null._@param namespace      the namespace of the mapping to remove. Not null._@param value          the value that is the second input for the transformation._@param transformation the transformation function to apply on the old state and the given value._@param <T>            type of the value that is the second input to the {@link StateTransformationFunction}._@throws Exception exception that happen on applying the function._@see #transform(Object, Object, StateTransformationFunction).;<T> void transform(_			K key,_			N namespace,_			T value,_			StateTransformationFunction<S, T> transformation) throws Exception {__		final StateTableEntry<K, N, S> entry = putEntry(key, namespace)___		_		entry.state = transformation.apply(_				(entry.stateVersion < highestRequiredSnapshotVersion) ?_						getStateSerializer().copy(entry.state) :_						entry.state,_				value)__		entry.stateVersion = stateTableVersion__	};param,key,the,key,of,the,mapping,to,remove,not,null,param,namespace,the,namespace,of,the,mapping,to,remove,not,null,param,value,the,value,that,is,the,second,input,for,the,transformation,param,transformation,the,transformation,function,to,apply,on,the,old,state,and,the,given,value,param,t,type,of,the,value,that,is,the,second,input,to,the,link,state,transformation,function,throws,exception,exception,that,happen,on,applying,the,function,see,transform,object,object,state,transformation,function;t,void,transform,k,key,n,namespace,t,value,state,transformation,function,s,t,transformation,throws,exception,final,state,table,entry,k,n,s,entry,put,entry,key,namespace,entry,state,transformation,apply,entry,state,version,highest,required,snapshot,version,get,state,serializer,copy,entry,state,entry,state,value,entry,state,version,state,table,version
CopyOnWriteStateTable -> <T> void transform( 			K key, 			N namespace, 			T value, 			StateTransformationFunction<S, T> transformation) throws Exception;1506609393;@param key            the key of the mapping to remove. Not null._@param namespace      the namespace of the mapping to remove. Not null._@param value          the value that is the second input for the transformation._@param transformation the transformation function to apply on the old state and the given value._@param <T>            type of the value that is the second input to the {@link StateTransformationFunction}._@throws Exception exception that happen on applying the function._@see #transform(Object, Object, StateTransformationFunction).;<T> void transform(_			K key,_			N namespace,_			T value,_			StateTransformationFunction<S, T> transformation) throws Exception {__		final StateTableEntry<K, N, S> entry = putEntry(key, namespace)___		_		entry.state = transformation.apply(_				(entry.stateVersion < highestRequiredSnapshotVersion) ?_						getStateSerializer().copy(entry.state) :_						entry.state,_				value)__		entry.stateVersion = stateTableVersion__	};param,key,the,key,of,the,mapping,to,remove,not,null,param,namespace,the,namespace,of,the,mapping,to,remove,not,null,param,value,the,value,that,is,the,second,input,for,the,transformation,param,transformation,the,transformation,function,to,apply,on,the,old,state,and,the,given,value,param,t,type,of,the,value,that,is,the,second,input,to,the,link,state,transformation,function,throws,exception,exception,that,happen,on,applying,the,function,see,transform,object,object,state,transformation,function;t,void,transform,k,key,n,namespace,t,value,state,transformation,function,s,t,transformation,throws,exception,final,state,table,entry,k,n,s,entry,put,entry,key,namespace,entry,state,transformation,apply,entry,state,version,highest,required,snapshot,version,get,state,serializer,copy,entry,state,entry,state,value,entry,state,version,state,table,version
CopyOnWriteStateTable -> <T> void transform( 			K key, 			N namespace, 			T value, 			StateTransformationFunction<S, T> transformation) throws Exception;1519379856;@param key            the key of the mapping to remove. Not null._@param namespace      the namespace of the mapping to remove. Not null._@param value          the value that is the second input for the transformation._@param transformation the transformation function to apply on the old state and the given value._@param <T>            type of the value that is the second input to the {@link StateTransformationFunction}._@throws Exception exception that happen on applying the function._@see #transform(Object, Object, StateTransformationFunction).;<T> void transform(_			K key,_			N namespace,_			T value,_			StateTransformationFunction<S, T> transformation) throws Exception {__		final StateTableEntry<K, N, S> entry = putEntry(key, namespace)___		_		entry.state = transformation.apply(_				(entry.stateVersion < highestRequiredSnapshotVersion) ?_						getStateSerializer().copy(entry.state) :_						entry.state,_				value)__		entry.stateVersion = stateTableVersion__	};param,key,the,key,of,the,mapping,to,remove,not,null,param,namespace,the,namespace,of,the,mapping,to,remove,not,null,param,value,the,value,that,is,the,second,input,for,the,transformation,param,transformation,the,transformation,function,to,apply,on,the,old,state,and,the,given,value,param,t,type,of,the,value,that,is,the,second,input,to,the,link,state,transformation,function,throws,exception,exception,that,happen,on,applying,the,function,see,transform,object,object,state,transformation,function;t,void,transform,k,key,n,namespace,t,value,state,transformation,function,s,t,transformation,throws,exception,final,state,table,entry,k,n,s,entry,put,entry,key,namespace,entry,state,transformation,apply,entry,state,version,highest,required,snapshot,version,get,state,serializer,copy,entry,state,entry,state,value,entry,state,version,state,table,version
CopyOnWriteStateTable -> <T> void transform( 			K key, 			N namespace, 			T value, 			StateTransformationFunction<S, T> transformation) throws Exception;1529089579;@param key            the key of the mapping to remove. Not null._@param namespace      the namespace of the mapping to remove. Not null._@param value          the value that is the second input for the transformation._@param transformation the transformation function to apply on the old state and the given value._@param <T>            type of the value that is the second input to the {@link StateTransformationFunction}._@throws Exception exception that happen on applying the function._@see #transform(Object, Object, StateTransformationFunction).;<T> void transform(_			K key,_			N namespace,_			T value,_			StateTransformationFunction<S, T> transformation) throws Exception {__		final StateTableEntry<K, N, S> entry = putEntry(key, namespace)___		_		entry.state = transformation.apply(_				(entry.stateVersion < highestRequiredSnapshotVersion) ?_						getStateSerializer().copy(entry.state) :_						entry.state,_				value)__		entry.stateVersion = stateTableVersion__	};param,key,the,key,of,the,mapping,to,remove,not,null,param,namespace,the,namespace,of,the,mapping,to,remove,not,null,param,value,the,value,that,is,the,second,input,for,the,transformation,param,transformation,the,transformation,function,to,apply,on,the,old,state,and,the,given,value,param,t,type,of,the,value,that,is,the,second,input,to,the,link,state,transformation,function,throws,exception,exception,that,happen,on,applying,the,function,see,transform,object,object,state,transformation,function;t,void,transform,k,key,n,namespace,t,value,state,transformation,function,s,t,transformation,throws,exception,final,state,table,entry,k,n,s,entry,put,entry,key,namespace,entry,state,transformation,apply,entry,state,version,highest,required,snapshot,version,get,state,serializer,copy,entry,state,entry,state,value,entry,state,version,state,table,version
CopyOnWriteStateTable -> <T> void transform( 			K key, 			N namespace, 			T value, 			StateTransformationFunction<S, T> transformation) throws Exception;1529089584;@param key            the key of the mapping to remove. Not null._@param namespace      the namespace of the mapping to remove. Not null._@param value          the value that is the second input for the transformation._@param transformation the transformation function to apply on the old state and the given value._@param <T>            type of the value that is the second input to the {@link StateTransformationFunction}._@throws Exception exception that happen on applying the function._@see #transform(Object, Object, StateTransformationFunction).;<T> void transform(_			K key,_			N namespace,_			T value,_			StateTransformationFunction<S, T> transformation) throws Exception {__		final StateTableEntry<K, N, S> entry = putEntry(key, namespace)___		_		entry.state = transformation.apply(_				(entry.stateVersion < highestRequiredSnapshotVersion) ?_						getStateSerializer().copy(entry.state) :_						entry.state,_				value)__		entry.stateVersion = stateTableVersion__	};param,key,the,key,of,the,mapping,to,remove,not,null,param,namespace,the,namespace,of,the,mapping,to,remove,not,null,param,value,the,value,that,is,the,second,input,for,the,transformation,param,transformation,the,transformation,function,to,apply,on,the,old,state,and,the,given,value,param,t,type,of,the,value,that,is,the,second,input,to,the,link,state,transformation,function,throws,exception,exception,that,happen,on,applying,the,function,see,transform,object,object,state,transformation,function;t,void,transform,k,key,n,namespace,t,value,state,transformation,function,s,t,transformation,throws,exception,final,state,table,entry,k,n,s,entry,put,entry,key,namespace,entry,state,transformation,apply,entry,state,version,highest,required,snapshot,version,get,state,serializer,copy,entry,state,entry,state,value,entry,state,version,state,table,version
CopyOnWriteStateTable -> <T> void transform( 			K key, 			N namespace, 			T value, 			StateTransformationFunction<S, T> transformation) throws Exception;1529307900;@param key            the key of the mapping to remove. Not null._@param namespace      the namespace of the mapping to remove. Not null._@param value          the value that is the second input for the transformation._@param transformation the transformation function to apply on the old state and the given value._@param <T>            type of the value that is the second input to the {@link StateTransformationFunction}._@throws Exception exception that happen on applying the function._@see #transform(Object, Object, StateTransformationFunction).;<T> void transform(_			K key,_			N namespace,_			T value,_			StateTransformationFunction<S, T> transformation) throws Exception {__		final StateTableEntry<K, N, S> entry = putEntry(key, namespace)___		_		entry.state = transformation.apply(_				(entry.stateVersion < highestRequiredSnapshotVersion) ?_						getStateSerializer().copy(entry.state) :_						entry.state,_				value)__		entry.stateVersion = stateTableVersion__	};param,key,the,key,of,the,mapping,to,remove,not,null,param,namespace,the,namespace,of,the,mapping,to,remove,not,null,param,value,the,value,that,is,the,second,input,for,the,transformation,param,transformation,the,transformation,function,to,apply,on,the,old,state,and,the,given,value,param,t,type,of,the,value,that,is,the,second,input,to,the,link,state,transformation,function,throws,exception,exception,that,happen,on,applying,the,function,see,transform,object,object,state,transformation,function;t,void,transform,k,key,n,namespace,t,value,state,transformation,function,s,t,transformation,throws,exception,final,state,table,entry,k,n,s,entry,put,entry,key,namespace,entry,state,transformation,apply,entry,state,version,highest,required,snapshot,version,get,state,serializer,copy,entry,state,entry,state,value,entry,state,version,state,table,version
CopyOnWriteStateTable -> <T> void transform( 			K key, 			N namespace, 			T value, 			StateTransformationFunction<S, T> transformation) throws Exception;1530639128;@param key            the key of the mapping to remove. Not null._@param namespace      the namespace of the mapping to remove. Not null._@param value          the value that is the second input for the transformation._@param transformation the transformation function to apply on the old state and the given value._@param <T>            type of the value that is the second input to the {@link StateTransformationFunction}._@throws Exception exception that happen on applying the function._@see #transform(Object, Object, StateTransformationFunction).;<T> void transform(_			K key,_			N namespace,_			T value,_			StateTransformationFunction<S, T> transformation) throws Exception {__		final StateTableEntry<K, N, S> entry = putEntry(key, namespace)___		_		entry.state = transformation.apply(_				(entry.stateVersion < highestRequiredSnapshotVersion) ?_						getStateSerializer().copy(entry.state) :_						entry.state,_				value)__		entry.stateVersion = stateTableVersion__	};param,key,the,key,of,the,mapping,to,remove,not,null,param,namespace,the,namespace,of,the,mapping,to,remove,not,null,param,value,the,value,that,is,the,second,input,for,the,transformation,param,transformation,the,transformation,function,to,apply,on,the,old,state,and,the,given,value,param,t,type,of,the,value,that,is,the,second,input,to,the,link,state,transformation,function,throws,exception,exception,that,happen,on,applying,the,function,see,transform,object,object,state,transformation,function;t,void,transform,k,key,n,namespace,t,value,state,transformation,function,s,t,transformation,throws,exception,final,state,table,entry,k,n,s,entry,put,entry,key,namespace,entry,state,transformation,apply,entry,state,version,highest,required,snapshot,version,get,state,serializer,copy,entry,state,entry,state,value,entry,state,version,state,table,version
CopyOnWriteStateTable -> <T> void transform( 			K key, 			N namespace, 			T value, 			StateTransformationFunction<S, T> transformation) throws Exception;1531771917;@param key            the key of the mapping to remove. Not null._@param namespace      the namespace of the mapping to remove. Not null._@param value          the value that is the second input for the transformation._@param transformation the transformation function to apply on the old state and the given value._@param <T>            type of the value that is the second input to the {@link StateTransformationFunction}._@throws Exception exception that happen on applying the function._@see #transform(Object, Object, StateTransformationFunction).;<T> void transform(_			K key,_			N namespace,_			T value,_			StateTransformationFunction<S, T> transformation) throws Exception {__		final StateTableEntry<K, N, S> entry = putEntry(key, namespace)___		_		entry.state = transformation.apply(_				(entry.stateVersion < highestRequiredSnapshotVersion) ?_						getStateSerializer().copy(entry.state) :_						entry.state,_				value)__		entry.stateVersion = stateTableVersion__	};param,key,the,key,of,the,mapping,to,remove,not,null,param,namespace,the,namespace,of,the,mapping,to,remove,not,null,param,value,the,value,that,is,the,second,input,for,the,transformation,param,transformation,the,transformation,function,to,apply,on,the,old,state,and,the,given,value,param,t,type,of,the,value,that,is,the,second,input,to,the,link,state,transformation,function,throws,exception,exception,that,happen,on,applying,the,function,see,transform,object,object,state,transformation,function;t,void,transform,k,key,n,namespace,t,value,state,transformation,function,s,t,transformation,throws,exception,final,state,table,entry,k,n,s,entry,put,entry,key,namespace,entry,state,transformation,apply,entry,state,version,highest,required,snapshot,version,get,state,serializer,copy,entry,state,entry,state,value,entry,state,version,state,table,version
CopyOnWriteStateTable -> <T> void transform( 			K key, 			N namespace, 			T value, 			StateTransformationFunction<S, T> transformation) throws Exception;1548755874;@param key            the key of the mapping to remove. Not null._@param namespace      the namespace of the mapping to remove. Not null._@param value          the value that is the second input for the transformation._@param transformation the transformation function to apply on the old state and the given value._@param <T>            type of the value that is the second input to the {@link StateTransformationFunction}._@throws Exception exception that happen on applying the function._@see #transform(Object, Object, StateTransformationFunction).;<T> void transform(_			K key,_			N namespace,_			T value,_			StateTransformationFunction<S, T> transformation) throws Exception {__		final StateTableEntry<K, N, S> entry = putEntry(key, namespace)___		_		entry.state = transformation.apply(_				(entry.stateVersion < highestRequiredSnapshotVersion) ?_						getStateSerializer().copy(entry.state) :_						entry.state,_				value)__		entry.stateVersion = stateTableVersion__	};param,key,the,key,of,the,mapping,to,remove,not,null,param,namespace,the,namespace,of,the,mapping,to,remove,not,null,param,value,the,value,that,is,the,second,input,for,the,transformation,param,transformation,the,transformation,function,to,apply,on,the,old,state,and,the,given,value,param,t,type,of,the,value,that,is,the,second,input,to,the,link,state,transformation,function,throws,exception,exception,that,happen,on,applying,the,function,see,transform,object,object,state,transformation,function;t,void,transform,k,key,n,namespace,t,value,state,transformation,function,s,t,transformation,throws,exception,final,state,table,entry,k,n,s,entry,put,entry,key,namespace,entry,state,transformation,apply,entry,state,version,highest,required,snapshot,version,get,state,serializer,copy,entry,state,entry,state,value,entry,state,version,state,table,version
CopyOnWriteStateTable -> @SuppressWarnings("unchecked") 	private void incrementalRehash();1489685642;Runs a number of steps for incremental rehashing.;@SuppressWarnings("unchecked")_	private void incrementalRehash() {__		StateTableEntry<K, N, S>[] oldTable = primaryTable__		StateTableEntry<K, N, S>[] newTable = incrementalRehashTable___		int oldCapacity = oldTable.length__		int newMask = newTable.length - 1__		int requiredVersion = highestRequiredSnapshotVersion__		int rhIdx = rehashIndex__		int transferred = 0___		_		while (transferred < MIN_TRANSFERRED_PER_INCREMENTAL_REHASH) {__			StateTableEntry<K, N, S> e = oldTable[rhIdx]___			while (e != null) {_				_				if (e.entryVersion < requiredVersion) {_					e = new StateTableEntry<>(e, stateTableVersion)__				}_				StateTableEntry<K, N, S> n = e.next__				int pos = e.hash & newMask__				e.next = newTable[pos]__				newTable[pos] = e__				e = n__				++transferred__			}__			oldTable[rhIdx] = null__			if (++rhIdx == oldCapacity) {_				_				primaryTable = newTable__				incrementalRehashTable = (StateTableEntry<K, N, S>[]) EMPTY_TABLE__				primaryTableSize += incrementalRehashTableSize__				incrementalRehashTableSize = 0__				rehashIndex = 0__				return__			}_		}__		_		primaryTableSize -= transferred__		incrementalRehashTableSize += transferred__		rehashIndex = rhIdx__	};runs,a,number,of,steps,for,incremental,rehashing;suppress,warnings,unchecked,private,void,incremental,rehash,state,table,entry,k,n,s,old,table,primary,table,state,table,entry,k,n,s,new,table,incremental,rehash,table,int,old,capacity,old,table,length,int,new,mask,new,table,length,1,int,required,version,highest,required,snapshot,version,int,rh,idx,rehash,index,int,transferred,0,while,transferred,state,table,entry,k,n,s,e,old,table,rh,idx,while,e,null,if,e,entry,version,required,version,e,new,state,table,entry,e,state,table,version,state,table,entry,k,n,s,n,e,next,int,pos,e,hash,new,mask,e,next,new,table,pos,new,table,pos,e,e,n,transferred,old,table,rh,idx,null,if,rh,idx,old,capacity,primary,table,new,table,incremental,rehash,table,state,table,entry,k,n,s,primary,table,size,incremental,rehash,table,size,incremental,rehash,table,size,0,rehash,index,0,return,primary,table,size,transferred,incremental,rehash,table,size,transferred,rehash,index,rh,idx
CopyOnWriteStateTable -> @SuppressWarnings("unchecked") 	private void incrementalRehash();1494180263;Runs a number of steps for incremental rehashing.;@SuppressWarnings("unchecked")_	private void incrementalRehash() {__		StateTableEntry<K, N, S>[] oldTable = primaryTable__		StateTableEntry<K, N, S>[] newTable = incrementalRehashTable___		int oldCapacity = oldTable.length__		int newMask = newTable.length - 1__		int requiredVersion = highestRequiredSnapshotVersion__		int rhIdx = rehashIndex__		int transferred = 0___		_		while (transferred < MIN_TRANSFERRED_PER_INCREMENTAL_REHASH) {__			StateTableEntry<K, N, S> e = oldTable[rhIdx]___			while (e != null) {_				_				if (e.entryVersion < requiredVersion) {_					e = new StateTableEntry<>(e, stateTableVersion)__				}_				StateTableEntry<K, N, S> n = e.next__				int pos = e.hash & newMask__				e.next = newTable[pos]__				newTable[pos] = e__				e = n__				++transferred__			}__			oldTable[rhIdx] = null__			if (++rhIdx == oldCapacity) {_				_				primaryTable = newTable__				incrementalRehashTable = (StateTableEntry<K, N, S>[]) EMPTY_TABLE__				primaryTableSize += incrementalRehashTableSize__				incrementalRehashTableSize = 0__				rehashIndex = 0__				return__			}_		}__		_		primaryTableSize -= transferred__		incrementalRehashTableSize += transferred__		rehashIndex = rhIdx__	};runs,a,number,of,steps,for,incremental,rehashing;suppress,warnings,unchecked,private,void,incremental,rehash,state,table,entry,k,n,s,old,table,primary,table,state,table,entry,k,n,s,new,table,incremental,rehash,table,int,old,capacity,old,table,length,int,new,mask,new,table,length,1,int,required,version,highest,required,snapshot,version,int,rh,idx,rehash,index,int,transferred,0,while,transferred,state,table,entry,k,n,s,e,old,table,rh,idx,while,e,null,if,e,entry,version,required,version,e,new,state,table,entry,e,state,table,version,state,table,entry,k,n,s,n,e,next,int,pos,e,hash,new,mask,e,next,new,table,pos,new,table,pos,e,e,n,transferred,old,table,rh,idx,null,if,rh,idx,old,capacity,primary,table,new,table,incremental,rehash,table,state,table,entry,k,n,s,primary,table,size,incremental,rehash,table,size,incremental,rehash,table,size,0,rehash,index,0,return,primary,table,size,transferred,incremental,rehash,table,size,transferred,rehash,index,rh,idx
CopyOnWriteStateTable -> @SuppressWarnings("unchecked") 	private void incrementalRehash();1506609393;Runs a number of steps for incremental rehashing.;@SuppressWarnings("unchecked")_	private void incrementalRehash() {__		StateTableEntry<K, N, S>[] oldTable = primaryTable__		StateTableEntry<K, N, S>[] newTable = incrementalRehashTable___		int oldCapacity = oldTable.length__		int newMask = newTable.length - 1__		int requiredVersion = highestRequiredSnapshotVersion__		int rhIdx = rehashIndex__		int transferred = 0___		_		while (transferred < MIN_TRANSFERRED_PER_INCREMENTAL_REHASH) {__			StateTableEntry<K, N, S> e = oldTable[rhIdx]___			while (e != null) {_				_				if (e.entryVersion < requiredVersion) {_					e = new StateTableEntry<>(e, stateTableVersion)__				}_				StateTableEntry<K, N, S> n = e.next__				int pos = e.hash & newMask__				e.next = newTable[pos]__				newTable[pos] = e__				e = n__				++transferred__			}__			oldTable[rhIdx] = null__			if (++rhIdx == oldCapacity) {_				_				primaryTable = newTable__				incrementalRehashTable = (StateTableEntry<K, N, S>[]) EMPTY_TABLE__				primaryTableSize += incrementalRehashTableSize__				incrementalRehashTableSize = 0__				rehashIndex = 0__				return__			}_		}__		_		primaryTableSize -= transferred__		incrementalRehashTableSize += transferred__		rehashIndex = rhIdx__	};runs,a,number,of,steps,for,incremental,rehashing;suppress,warnings,unchecked,private,void,incremental,rehash,state,table,entry,k,n,s,old,table,primary,table,state,table,entry,k,n,s,new,table,incremental,rehash,table,int,old,capacity,old,table,length,int,new,mask,new,table,length,1,int,required,version,highest,required,snapshot,version,int,rh,idx,rehash,index,int,transferred,0,while,transferred,state,table,entry,k,n,s,e,old,table,rh,idx,while,e,null,if,e,entry,version,required,version,e,new,state,table,entry,e,state,table,version,state,table,entry,k,n,s,n,e,next,int,pos,e,hash,new,mask,e,next,new,table,pos,new,table,pos,e,e,n,transferred,old,table,rh,idx,null,if,rh,idx,old,capacity,primary,table,new,table,incremental,rehash,table,state,table,entry,k,n,s,primary,table,size,incremental,rehash,table,size,incremental,rehash,table,size,0,rehash,index,0,return,primary,table,size,transferred,incremental,rehash,table,size,transferred,rehash,index,rh,idx
CopyOnWriteStateTable -> @SuppressWarnings("unchecked") 	private void incrementalRehash();1519379856;Runs a number of steps for incremental rehashing.;@SuppressWarnings("unchecked")_	private void incrementalRehash() {__		StateTableEntry<K, N, S>[] oldTable = primaryTable__		StateTableEntry<K, N, S>[] newTable = incrementalRehashTable___		int oldCapacity = oldTable.length__		int newMask = newTable.length - 1__		int requiredVersion = highestRequiredSnapshotVersion__		int rhIdx = rehashIndex__		int transferred = 0___		_		while (transferred < MIN_TRANSFERRED_PER_INCREMENTAL_REHASH) {__			StateTableEntry<K, N, S> e = oldTable[rhIdx]___			while (e != null) {_				_				if (e.entryVersion < requiredVersion) {_					e = new StateTableEntry<>(e, stateTableVersion)__				}_				StateTableEntry<K, N, S> n = e.next__				int pos = e.hash & newMask__				e.next = newTable[pos]__				newTable[pos] = e__				e = n__				++transferred__			}__			oldTable[rhIdx] = null__			if (++rhIdx == oldCapacity) {_				_				primaryTable = newTable__				incrementalRehashTable = (StateTableEntry<K, N, S>[]) EMPTY_TABLE__				primaryTableSize += incrementalRehashTableSize__				incrementalRehashTableSize = 0__				rehashIndex = 0__				return__			}_		}__		_		primaryTableSize -= transferred__		incrementalRehashTableSize += transferred__		rehashIndex = rhIdx__	};runs,a,number,of,steps,for,incremental,rehashing;suppress,warnings,unchecked,private,void,incremental,rehash,state,table,entry,k,n,s,old,table,primary,table,state,table,entry,k,n,s,new,table,incremental,rehash,table,int,old,capacity,old,table,length,int,new,mask,new,table,length,1,int,required,version,highest,required,snapshot,version,int,rh,idx,rehash,index,int,transferred,0,while,transferred,state,table,entry,k,n,s,e,old,table,rh,idx,while,e,null,if,e,entry,version,required,version,e,new,state,table,entry,e,state,table,version,state,table,entry,k,n,s,n,e,next,int,pos,e,hash,new,mask,e,next,new,table,pos,new,table,pos,e,e,n,transferred,old,table,rh,idx,null,if,rh,idx,old,capacity,primary,table,new,table,incremental,rehash,table,state,table,entry,k,n,s,primary,table,size,incremental,rehash,table,size,incremental,rehash,table,size,0,rehash,index,0,return,primary,table,size,transferred,incremental,rehash,table,size,transferred,rehash,index,rh,idx
CopyOnWriteStateTable -> @SuppressWarnings("unchecked") 	private void incrementalRehash();1529089579;Runs a number of steps for incremental rehashing.;@SuppressWarnings("unchecked")_	private void incrementalRehash() {__		StateTableEntry<K, N, S>[] oldTable = primaryTable__		StateTableEntry<K, N, S>[] newTable = incrementalRehashTable___		int oldCapacity = oldTable.length__		int newMask = newTable.length - 1__		int requiredVersion = highestRequiredSnapshotVersion__		int rhIdx = rehashIndex__		int transferred = 0___		_		while (transferred < MIN_TRANSFERRED_PER_INCREMENTAL_REHASH) {__			StateTableEntry<K, N, S> e = oldTable[rhIdx]___			while (e != null) {_				_				if (e.entryVersion < requiredVersion) {_					e = new StateTableEntry<>(e, stateTableVersion)__				}_				StateTableEntry<K, N, S> n = e.next__				int pos = e.hash & newMask__				e.next = newTable[pos]__				newTable[pos] = e__				e = n__				++transferred__			}__			oldTable[rhIdx] = null__			if (++rhIdx == oldCapacity) {_				_				primaryTable = newTable__				incrementalRehashTable = (StateTableEntry<K, N, S>[]) EMPTY_TABLE__				primaryTableSize += incrementalRehashTableSize__				incrementalRehashTableSize = 0__				rehashIndex = 0__				return__			}_		}__		_		primaryTableSize -= transferred__		incrementalRehashTableSize += transferred__		rehashIndex = rhIdx__	};runs,a,number,of,steps,for,incremental,rehashing;suppress,warnings,unchecked,private,void,incremental,rehash,state,table,entry,k,n,s,old,table,primary,table,state,table,entry,k,n,s,new,table,incremental,rehash,table,int,old,capacity,old,table,length,int,new,mask,new,table,length,1,int,required,version,highest,required,snapshot,version,int,rh,idx,rehash,index,int,transferred,0,while,transferred,state,table,entry,k,n,s,e,old,table,rh,idx,while,e,null,if,e,entry,version,required,version,e,new,state,table,entry,e,state,table,version,state,table,entry,k,n,s,n,e,next,int,pos,e,hash,new,mask,e,next,new,table,pos,new,table,pos,e,e,n,transferred,old,table,rh,idx,null,if,rh,idx,old,capacity,primary,table,new,table,incremental,rehash,table,state,table,entry,k,n,s,primary,table,size,incremental,rehash,table,size,incremental,rehash,table,size,0,rehash,index,0,return,primary,table,size,transferred,incremental,rehash,table,size,transferred,rehash,index,rh,idx
CopyOnWriteStateTable -> @SuppressWarnings("unchecked") 	private void incrementalRehash();1529089584;Runs a number of steps for incremental rehashing.;@SuppressWarnings("unchecked")_	private void incrementalRehash() {__		StateTableEntry<K, N, S>[] oldTable = primaryTable__		StateTableEntry<K, N, S>[] newTable = incrementalRehashTable___		int oldCapacity = oldTable.length__		int newMask = newTable.length - 1__		int requiredVersion = highestRequiredSnapshotVersion__		int rhIdx = rehashIndex__		int transferred = 0___		_		while (transferred < MIN_TRANSFERRED_PER_INCREMENTAL_REHASH) {__			StateTableEntry<K, N, S> e = oldTable[rhIdx]___			while (e != null) {_				_				if (e.entryVersion < requiredVersion) {_					e = new StateTableEntry<>(e, stateTableVersion)__				}_				StateTableEntry<K, N, S> n = e.next__				int pos = e.hash & newMask__				e.next = newTable[pos]__				newTable[pos] = e__				e = n__				++transferred__			}__			oldTable[rhIdx] = null__			if (++rhIdx == oldCapacity) {_				_				primaryTable = newTable__				incrementalRehashTable = (StateTableEntry<K, N, S>[]) EMPTY_TABLE__				primaryTableSize += incrementalRehashTableSize__				incrementalRehashTableSize = 0__				rehashIndex = 0__				return__			}_		}__		_		primaryTableSize -= transferred__		incrementalRehashTableSize += transferred__		rehashIndex = rhIdx__	};runs,a,number,of,steps,for,incremental,rehashing;suppress,warnings,unchecked,private,void,incremental,rehash,state,table,entry,k,n,s,old,table,primary,table,state,table,entry,k,n,s,new,table,incremental,rehash,table,int,old,capacity,old,table,length,int,new,mask,new,table,length,1,int,required,version,highest,required,snapshot,version,int,rh,idx,rehash,index,int,transferred,0,while,transferred,state,table,entry,k,n,s,e,old,table,rh,idx,while,e,null,if,e,entry,version,required,version,e,new,state,table,entry,e,state,table,version,state,table,entry,k,n,s,n,e,next,int,pos,e,hash,new,mask,e,next,new,table,pos,new,table,pos,e,e,n,transferred,old,table,rh,idx,null,if,rh,idx,old,capacity,primary,table,new,table,incremental,rehash,table,state,table,entry,k,n,s,primary,table,size,incremental,rehash,table,size,incremental,rehash,table,size,0,rehash,index,0,return,primary,table,size,transferred,incremental,rehash,table,size,transferred,rehash,index,rh,idx
CopyOnWriteStateTable -> @SuppressWarnings("unchecked") 	private void incrementalRehash();1529307900;Runs a number of steps for incremental rehashing.;@SuppressWarnings("unchecked")_	private void incrementalRehash() {__		StateTableEntry<K, N, S>[] oldTable = primaryTable__		StateTableEntry<K, N, S>[] newTable = incrementalRehashTable___		int oldCapacity = oldTable.length__		int newMask = newTable.length - 1__		int requiredVersion = highestRequiredSnapshotVersion__		int rhIdx = rehashIndex__		int transferred = 0___		_		while (transferred < MIN_TRANSFERRED_PER_INCREMENTAL_REHASH) {__			StateTableEntry<K, N, S> e = oldTable[rhIdx]___			while (e != null) {_				_				if (e.entryVersion < requiredVersion) {_					e = new StateTableEntry<>(e, stateTableVersion)__				}_				StateTableEntry<K, N, S> n = e.next__				int pos = e.hash & newMask__				e.next = newTable[pos]__				newTable[pos] = e__				e = n__				++transferred__			}__			oldTable[rhIdx] = null__			if (++rhIdx == oldCapacity) {_				_				primaryTable = newTable__				incrementalRehashTable = (StateTableEntry<K, N, S>[]) EMPTY_TABLE__				primaryTableSize += incrementalRehashTableSize__				incrementalRehashTableSize = 0__				rehashIndex = 0__				return__			}_		}__		_		primaryTableSize -= transferred__		incrementalRehashTableSize += transferred__		rehashIndex = rhIdx__	};runs,a,number,of,steps,for,incremental,rehashing;suppress,warnings,unchecked,private,void,incremental,rehash,state,table,entry,k,n,s,old,table,primary,table,state,table,entry,k,n,s,new,table,incremental,rehash,table,int,old,capacity,old,table,length,int,new,mask,new,table,length,1,int,required,version,highest,required,snapshot,version,int,rh,idx,rehash,index,int,transferred,0,while,transferred,state,table,entry,k,n,s,e,old,table,rh,idx,while,e,null,if,e,entry,version,required,version,e,new,state,table,entry,e,state,table,version,state,table,entry,k,n,s,n,e,next,int,pos,e,hash,new,mask,e,next,new,table,pos,new,table,pos,e,e,n,transferred,old,table,rh,idx,null,if,rh,idx,old,capacity,primary,table,new,table,incremental,rehash,table,state,table,entry,k,n,s,primary,table,size,incremental,rehash,table,size,incremental,rehash,table,size,0,rehash,index,0,return,primary,table,size,transferred,incremental,rehash,table,size,transferred,rehash,index,rh,idx
CopyOnWriteStateTable -> @SuppressWarnings("unchecked") 	private void incrementalRehash();1530639128;Runs a number of steps for incremental rehashing.;@SuppressWarnings("unchecked")_	private void incrementalRehash() {__		StateTableEntry<K, N, S>[] oldTable = primaryTable__		StateTableEntry<K, N, S>[] newTable = incrementalRehashTable___		int oldCapacity = oldTable.length__		int newMask = newTable.length - 1__		int requiredVersion = highestRequiredSnapshotVersion__		int rhIdx = rehashIndex__		int transferred = 0___		_		while (transferred < MIN_TRANSFERRED_PER_INCREMENTAL_REHASH) {__			StateTableEntry<K, N, S> e = oldTable[rhIdx]___			while (e != null) {_				_				if (e.entryVersion < requiredVersion) {_					e = new StateTableEntry<>(e, stateTableVersion)__				}_				StateTableEntry<K, N, S> n = e.next__				int pos = e.hash & newMask__				e.next = newTable[pos]__				newTable[pos] = e__				e = n__				++transferred__			}__			oldTable[rhIdx] = null__			if (++rhIdx == oldCapacity) {_				_				primaryTable = newTable__				incrementalRehashTable = (StateTableEntry<K, N, S>[]) EMPTY_TABLE__				primaryTableSize += incrementalRehashTableSize__				incrementalRehashTableSize = 0__				rehashIndex = 0__				return__			}_		}__		_		primaryTableSize -= transferred__		incrementalRehashTableSize += transferred__		rehashIndex = rhIdx__	};runs,a,number,of,steps,for,incremental,rehashing;suppress,warnings,unchecked,private,void,incremental,rehash,state,table,entry,k,n,s,old,table,primary,table,state,table,entry,k,n,s,new,table,incremental,rehash,table,int,old,capacity,old,table,length,int,new,mask,new,table,length,1,int,required,version,highest,required,snapshot,version,int,rh,idx,rehash,index,int,transferred,0,while,transferred,state,table,entry,k,n,s,e,old,table,rh,idx,while,e,null,if,e,entry,version,required,version,e,new,state,table,entry,e,state,table,version,state,table,entry,k,n,s,n,e,next,int,pos,e,hash,new,mask,e,next,new,table,pos,new,table,pos,e,e,n,transferred,old,table,rh,idx,null,if,rh,idx,old,capacity,primary,table,new,table,incremental,rehash,table,state,table,entry,k,n,s,primary,table,size,incremental,rehash,table,size,incremental,rehash,table,size,0,rehash,index,0,return,primary,table,size,transferred,incremental,rehash,table,size,transferred,rehash,index,rh,idx
CopyOnWriteStateTable -> @SuppressWarnings("unchecked") 	private void incrementalRehash();1531771917;Runs a number of steps for incremental rehashing.;@SuppressWarnings("unchecked")_	private void incrementalRehash() {__		StateTableEntry<K, N, S>[] oldTable = primaryTable__		StateTableEntry<K, N, S>[] newTable = incrementalRehashTable___		int oldCapacity = oldTable.length__		int newMask = newTable.length - 1__		int requiredVersion = highestRequiredSnapshotVersion__		int rhIdx = rehashIndex__		int transferred = 0___		_		while (transferred < MIN_TRANSFERRED_PER_INCREMENTAL_REHASH) {__			StateTableEntry<K, N, S> e = oldTable[rhIdx]___			while (e != null) {_				_				if (e.entryVersion < requiredVersion) {_					e = new StateTableEntry<>(e, stateTableVersion)__				}_				StateTableEntry<K, N, S> n = e.next__				int pos = e.hash & newMask__				e.next = newTable[pos]__				newTable[pos] = e__				e = n__				++transferred__			}__			oldTable[rhIdx] = null__			if (++rhIdx == oldCapacity) {_				_				primaryTable = newTable__				incrementalRehashTable = (StateTableEntry<K, N, S>[]) EMPTY_TABLE__				primaryTableSize += incrementalRehashTableSize__				incrementalRehashTableSize = 0__				rehashIndex = 0__				return__			}_		}__		_		primaryTableSize -= transferred__		incrementalRehashTableSize += transferred__		rehashIndex = rhIdx__	};runs,a,number,of,steps,for,incremental,rehashing;suppress,warnings,unchecked,private,void,incremental,rehash,state,table,entry,k,n,s,old,table,primary,table,state,table,entry,k,n,s,new,table,incremental,rehash,table,int,old,capacity,old,table,length,int,new,mask,new,table,length,1,int,required,version,highest,required,snapshot,version,int,rh,idx,rehash,index,int,transferred,0,while,transferred,state,table,entry,k,n,s,e,old,table,rh,idx,while,e,null,if,e,entry,version,required,version,e,new,state,table,entry,e,state,table,version,state,table,entry,k,n,s,n,e,next,int,pos,e,hash,new,mask,e,next,new,table,pos,new,table,pos,e,e,n,transferred,old,table,rh,idx,null,if,rh,idx,old,capacity,primary,table,new,table,incremental,rehash,table,state,table,entry,k,n,s,primary,table,size,incremental,rehash,table,size,incremental,rehash,table,size,0,rehash,index,0,return,primary,table,size,transferred,incremental,rehash,table,size,transferred,rehash,index,rh,idx
CopyOnWriteStateTable -> @SuppressWarnings("unchecked") 	private void incrementalRehash();1548755874;Runs a number of steps for incremental rehashing.;@SuppressWarnings("unchecked")_	private void incrementalRehash() {__		StateTableEntry<K, N, S>[] oldTable = primaryTable__		StateTableEntry<K, N, S>[] newTable = incrementalRehashTable___		int oldCapacity = oldTable.length__		int newMask = newTable.length - 1__		int requiredVersion = highestRequiredSnapshotVersion__		int rhIdx = rehashIndex__		int transferred = 0___		_		while (transferred < MIN_TRANSFERRED_PER_INCREMENTAL_REHASH) {__			StateTableEntry<K, N, S> e = oldTable[rhIdx]___			while (e != null) {_				_				if (e.entryVersion < requiredVersion) {_					e = new StateTableEntry<>(e, stateTableVersion)__				}_				StateTableEntry<K, N, S> n = e.next__				int pos = e.hash & newMask__				e.next = newTable[pos]__				newTable[pos] = e__				e = n__				++transferred__			}__			oldTable[rhIdx] = null__			if (++rhIdx == oldCapacity) {_				_				primaryTable = newTable__				incrementalRehashTable = (StateTableEntry<K, N, S>[]) EMPTY_TABLE__				primaryTableSize += incrementalRehashTableSize__				incrementalRehashTableSize = 0__				rehashIndex = 0__				return__			}_		}__		_		primaryTableSize -= transferred__		incrementalRehashTableSize += transferred__		rehashIndex = rhIdx__	};runs,a,number,of,steps,for,incremental,rehashing;suppress,warnings,unchecked,private,void,incremental,rehash,state,table,entry,k,n,s,old,table,primary,table,state,table,entry,k,n,s,new,table,incremental,rehash,table,int,old,capacity,old,table,length,int,new,mask,new,table,length,1,int,required,version,highest,required,snapshot,version,int,rh,idx,rehash,index,int,transferred,0,while,transferred,state,table,entry,k,n,s,e,old,table,rh,idx,while,e,null,if,e,entry,version,required,version,e,new,state,table,entry,e,state,table,version,state,table,entry,k,n,s,n,e,next,int,pos,e,hash,new,mask,e,next,new,table,pos,new,table,pos,e,e,n,transferred,old,table,rh,idx,null,if,rh,idx,old,capacity,primary,table,new,table,incremental,rehash,table,state,table,entry,k,n,s,primary,table,size,incremental,rehash,table,size,incremental,rehash,table,size,0,rehash,index,0,return,primary,table,size,transferred,incremental,rehash,table,size,transferred,rehash,index,rh,idx
CopyOnWriteStateTable -> S removeAndGetOld(K key, N namespace);1489685642;Removes the mapping with the specified key/namespace composite key from this map, returning the state that was_found under the entry.__@param key       the key of the mapping to remove. Not null._@param namespace the namespace of the mapping to remove. Not null._@return the value of the removed mapping or {@code null} if no mapping_for the specified key was found.;S removeAndGetOld(K key, N namespace) {__		final StateTableEntry<K, N, S> e = removeEntry(key, namespace)___		return e != null ?_				_				(e.stateVersion < highestRequiredSnapshotVersion ?_						getStateSerializer().copy(e.state) :_						e.state) :_				null__	};removes,the,mapping,with,the,specified,key,namespace,composite,key,from,this,map,returning,the,state,that,was,found,under,the,entry,param,key,the,key,of,the,mapping,to,remove,not,null,param,namespace,the,namespace,of,the,mapping,to,remove,not,null,return,the,value,of,the,removed,mapping,or,code,null,if,no,mapping,for,the,specified,key,was,found;s,remove,and,get,old,k,key,n,namespace,final,state,table,entry,k,n,s,e,remove,entry,key,namespace,return,e,null,e,state,version,highest,required,snapshot,version,get,state,serializer,copy,e,state,e,state,null
CopyOnWriteStateTable -> S removeAndGetOld(K key, N namespace);1494180263;Removes the mapping with the specified key/namespace composite key from this map, returning the state that was_found under the entry.__@param key       the key of the mapping to remove. Not null._@param namespace the namespace of the mapping to remove. Not null._@return the value of the removed mapping or {@code null} if no mapping_for the specified key was found.;S removeAndGetOld(K key, N namespace) {__		final StateTableEntry<K, N, S> e = removeEntry(key, namespace)___		return e != null ?_				_				(e.stateVersion < highestRequiredSnapshotVersion ?_						getStateSerializer().copy(e.state) :_						e.state) :_				null__	};removes,the,mapping,with,the,specified,key,namespace,composite,key,from,this,map,returning,the,state,that,was,found,under,the,entry,param,key,the,key,of,the,mapping,to,remove,not,null,param,namespace,the,namespace,of,the,mapping,to,remove,not,null,return,the,value,of,the,removed,mapping,or,code,null,if,no,mapping,for,the,specified,key,was,found;s,remove,and,get,old,k,key,n,namespace,final,state,table,entry,k,n,s,e,remove,entry,key,namespace,return,e,null,e,state,version,highest,required,snapshot,version,get,state,serializer,copy,e,state,e,state,null
CopyOnWriteStateTable -> S removeAndGetOld(K key, N namespace);1506609393;Removes the mapping with the specified key/namespace composite key from this map, returning the state that was_found under the entry.__@param key       the key of the mapping to remove. Not null._@param namespace the namespace of the mapping to remove. Not null._@return the value of the removed mapping or {@code null} if no mapping_for the specified key was found.;S removeAndGetOld(K key, N namespace) {__		final StateTableEntry<K, N, S> e = removeEntry(key, namespace)___		return e != null ?_				_				(e.stateVersion < highestRequiredSnapshotVersion ?_						getStateSerializer().copy(e.state) :_						e.state) :_				null__	};removes,the,mapping,with,the,specified,key,namespace,composite,key,from,this,map,returning,the,state,that,was,found,under,the,entry,param,key,the,key,of,the,mapping,to,remove,not,null,param,namespace,the,namespace,of,the,mapping,to,remove,not,null,return,the,value,of,the,removed,mapping,or,code,null,if,no,mapping,for,the,specified,key,was,found;s,remove,and,get,old,k,key,n,namespace,final,state,table,entry,k,n,s,e,remove,entry,key,namespace,return,e,null,e,state,version,highest,required,snapshot,version,get,state,serializer,copy,e,state,e,state,null
CopyOnWriteStateTable -> S removeAndGetOld(K key, N namespace);1519379856;Removes the mapping with the specified key/namespace composite key from this map, returning the state that was_found under the entry.__@param key       the key of the mapping to remove. Not null._@param namespace the namespace of the mapping to remove. Not null._@return the value of the removed mapping or {@code null} if no mapping_for the specified key was found.;S removeAndGetOld(K key, N namespace) {__		final StateTableEntry<K, N, S> e = removeEntry(key, namespace)___		return e != null ?_				_				(e.stateVersion < highestRequiredSnapshotVersion ?_						getStateSerializer().copy(e.state) :_						e.state) :_				null__	};removes,the,mapping,with,the,specified,key,namespace,composite,key,from,this,map,returning,the,state,that,was,found,under,the,entry,param,key,the,key,of,the,mapping,to,remove,not,null,param,namespace,the,namespace,of,the,mapping,to,remove,not,null,return,the,value,of,the,removed,mapping,or,code,null,if,no,mapping,for,the,specified,key,was,found;s,remove,and,get,old,k,key,n,namespace,final,state,table,entry,k,n,s,e,remove,entry,key,namespace,return,e,null,e,state,version,highest,required,snapshot,version,get,state,serializer,copy,e,state,e,state,null
CopyOnWriteStateTable -> S removeAndGetOld(K key, N namespace);1529089579;Removes the mapping with the specified key/namespace composite key from this map, returning the state that was_found under the entry.__@param key       the key of the mapping to remove. Not null._@param namespace the namespace of the mapping to remove. Not null._@return the value of the removed mapping or {@code null} if no mapping_for the specified key was found.;S removeAndGetOld(K key, N namespace) {__		final StateTableEntry<K, N, S> e = removeEntry(key, namespace)___		return e != null ?_				_				(e.stateVersion < highestRequiredSnapshotVersion ?_						getStateSerializer().copy(e.state) :_						e.state) :_				null__	};removes,the,mapping,with,the,specified,key,namespace,composite,key,from,this,map,returning,the,state,that,was,found,under,the,entry,param,key,the,key,of,the,mapping,to,remove,not,null,param,namespace,the,namespace,of,the,mapping,to,remove,not,null,return,the,value,of,the,removed,mapping,or,code,null,if,no,mapping,for,the,specified,key,was,found;s,remove,and,get,old,k,key,n,namespace,final,state,table,entry,k,n,s,e,remove,entry,key,namespace,return,e,null,e,state,version,highest,required,snapshot,version,get,state,serializer,copy,e,state,e,state,null
CopyOnWriteStateTable -> S removeAndGetOld(K key, N namespace);1529089584;Removes the mapping with the specified key/namespace composite key from this map, returning the state that was_found under the entry.__@param key       the key of the mapping to remove. Not null._@param namespace the namespace of the mapping to remove. Not null._@return the value of the removed mapping or {@code null} if no mapping_for the specified key was found.;S removeAndGetOld(K key, N namespace) {__		final StateTableEntry<K, N, S> e = removeEntry(key, namespace)___		return e != null ?_				_				(e.stateVersion < highestRequiredSnapshotVersion ?_						getStateSerializer().copy(e.state) :_						e.state) :_				null__	};removes,the,mapping,with,the,specified,key,namespace,composite,key,from,this,map,returning,the,state,that,was,found,under,the,entry,param,key,the,key,of,the,mapping,to,remove,not,null,param,namespace,the,namespace,of,the,mapping,to,remove,not,null,return,the,value,of,the,removed,mapping,or,code,null,if,no,mapping,for,the,specified,key,was,found;s,remove,and,get,old,k,key,n,namespace,final,state,table,entry,k,n,s,e,remove,entry,key,namespace,return,e,null,e,state,version,highest,required,snapshot,version,get,state,serializer,copy,e,state,e,state,null
CopyOnWriteStateTable -> S removeAndGetOld(K key, N namespace);1529307900;Removes the mapping with the specified key/namespace composite key from this map, returning the state that was_found under the entry.__@param key       the key of the mapping to remove. Not null._@param namespace the namespace of the mapping to remove. Not null._@return the value of the removed mapping or {@code null} if no mapping_for the specified key was found.;S removeAndGetOld(K key, N namespace) {__		final StateTableEntry<K, N, S> e = removeEntry(key, namespace)___		return e != null ?_				_				(e.stateVersion < highestRequiredSnapshotVersion ?_						getStateSerializer().copy(e.state) :_						e.state) :_				null__	};removes,the,mapping,with,the,specified,key,namespace,composite,key,from,this,map,returning,the,state,that,was,found,under,the,entry,param,key,the,key,of,the,mapping,to,remove,not,null,param,namespace,the,namespace,of,the,mapping,to,remove,not,null,return,the,value,of,the,removed,mapping,or,code,null,if,no,mapping,for,the,specified,key,was,found;s,remove,and,get,old,k,key,n,namespace,final,state,table,entry,k,n,s,e,remove,entry,key,namespace,return,e,null,e,state,version,highest,required,snapshot,version,get,state,serializer,copy,e,state,e,state,null
CopyOnWriteStateTable -> S removeAndGetOld(K key, N namespace);1530639128;Removes the mapping with the specified key/namespace composite key from this map, returning the state that was_found under the entry.__@param key       the key of the mapping to remove. Not null._@param namespace the namespace of the mapping to remove. Not null._@return the value of the removed mapping or {@code null} if no mapping_for the specified key was found.;S removeAndGetOld(K key, N namespace) {__		final StateTableEntry<K, N, S> e = removeEntry(key, namespace)___		return e != null ?_				_				(e.stateVersion < highestRequiredSnapshotVersion ?_						getStateSerializer().copy(e.state) :_						e.state) :_				null__	};removes,the,mapping,with,the,specified,key,namespace,composite,key,from,this,map,returning,the,state,that,was,found,under,the,entry,param,key,the,key,of,the,mapping,to,remove,not,null,param,namespace,the,namespace,of,the,mapping,to,remove,not,null,return,the,value,of,the,removed,mapping,or,code,null,if,no,mapping,for,the,specified,key,was,found;s,remove,and,get,old,k,key,n,namespace,final,state,table,entry,k,n,s,e,remove,entry,key,namespace,return,e,null,e,state,version,highest,required,snapshot,version,get,state,serializer,copy,e,state,e,state,null
CopyOnWriteStateTable -> S removeAndGetOld(K key, N namespace);1531771917;Removes the mapping with the specified key/namespace composite key from this map, returning the state that was_found under the entry.__@param key       the key of the mapping to remove. Not null._@param namespace the namespace of the mapping to remove. Not null._@return the value of the removed mapping or {@code null} if no mapping_for the specified key was found.;S removeAndGetOld(K key, N namespace) {__		final StateTableEntry<K, N, S> e = removeEntry(key, namespace)___		return e != null ?_				_				(e.stateVersion < highestRequiredSnapshotVersion ?_						getStateSerializer().copy(e.state) :_						e.state) :_				null__	};removes,the,mapping,with,the,specified,key,namespace,composite,key,from,this,map,returning,the,state,that,was,found,under,the,entry,param,key,the,key,of,the,mapping,to,remove,not,null,param,namespace,the,namespace,of,the,mapping,to,remove,not,null,return,the,value,of,the,removed,mapping,or,code,null,if,no,mapping,for,the,specified,key,was,found;s,remove,and,get,old,k,key,n,namespace,final,state,table,entry,k,n,s,e,remove,entry,key,namespace,return,e,null,e,state,version,highest,required,snapshot,version,get,state,serializer,copy,e,state,e,state,null
CopyOnWriteStateTable -> S removeAndGetOld(K key, N namespace);1548755874;Removes the mapping with the specified key/namespace composite key from this map, returning the state that was_found under the entry.__@param key       the key of the mapping to remove. Not null._@param namespace the namespace of the mapping to remove. Not null._@return the value of the removed mapping or {@code null} if no mapping_for the specified key was found.;S removeAndGetOld(K key, N namespace) {__		final StateTableEntry<K, N, S> e = removeEntry(key, namespace)___		return e != null ?_				_				(e.stateVersion < highestRequiredSnapshotVersion ?_						getStateSerializer().copy(e.state) :_						e.state) :_				null__	};removes,the,mapping,with,the,specified,key,namespace,composite,key,from,this,map,returning,the,state,that,was,found,under,the,entry,param,key,the,key,of,the,mapping,to,remove,not,null,param,namespace,the,namespace,of,the,mapping,to,remove,not,null,return,the,value,of,the,removed,mapping,or,code,null,if,no,mapping,for,the,specified,key,was,found;s,remove,and,get,old,k,key,n,namespace,final,state,table,entry,k,n,s,e,remove,entry,key,namespace,return,e,null,e,state,version,highest,required,snapshot,version,get,state,serializer,copy,e,state,e,state,null
CopyOnWriteStateTable -> void put(K key, N namespace, S value);1489685642;Maps the specified key/namespace composite key to the specified value. This method should be preferred_over {@link #putAndGetOld(Object, Object, Object)} (Object, Object)} when the caller is not interested_in the old value, because this can potentially reduce copy-on-write activity.__@param key       the key. Not null._@param namespace the namespace. Not null._@param value     the value. Can be null.;void put(K key, N namespace, S value) {_		final StateTableEntry<K, N, S> e = putEntry(key, namespace)___		e.state = value__		e.stateVersion = stateTableVersion__	};maps,the,specified,key,namespace,composite,key,to,the,specified,value,this,method,should,be,preferred,over,link,put,and,get,old,object,object,object,object,object,when,the,caller,is,not,interested,in,the,old,value,because,this,can,potentially,reduce,copy,on,write,activity,param,key,the,key,not,null,param,namespace,the,namespace,not,null,param,value,the,value,can,be,null;void,put,k,key,n,namespace,s,value,final,state,table,entry,k,n,s,e,put,entry,key,namespace,e,state,value,e,state,version,state,table,version
CopyOnWriteStateTable -> void put(K key, N namespace, S value);1494180263;Maps the specified key/namespace composite key to the specified value. This method should be preferred_over {@link #putAndGetOld(Object, Object, Object)} (Object, Object)} when the caller is not interested_in the old value, because this can potentially reduce copy-on-write activity.__@param key       the key. Not null._@param namespace the namespace. Not null._@param value     the value. Can be null.;void put(K key, N namespace, S value) {_		final StateTableEntry<K, N, S> e = putEntry(key, namespace)___		e.state = value__		e.stateVersion = stateTableVersion__	};maps,the,specified,key,namespace,composite,key,to,the,specified,value,this,method,should,be,preferred,over,link,put,and,get,old,object,object,object,object,object,when,the,caller,is,not,interested,in,the,old,value,because,this,can,potentially,reduce,copy,on,write,activity,param,key,the,key,not,null,param,namespace,the,namespace,not,null,param,value,the,value,can,be,null;void,put,k,key,n,namespace,s,value,final,state,table,entry,k,n,s,e,put,entry,key,namespace,e,state,value,e,state,version,state,table,version
CopyOnWriteStateTable -> void put(K key, N namespace, S value);1506609393;Maps the specified key/namespace composite key to the specified value. This method should be preferred_over {@link #putAndGetOld(Object, Object, Object)} (Object, Object)} when the caller is not interested_in the old value, because this can potentially reduce copy-on-write activity.__@param key       the key. Not null._@param namespace the namespace. Not null._@param value     the value. Can be null.;void put(K key, N namespace, S value) {_		final StateTableEntry<K, N, S> e = putEntry(key, namespace)___		e.state = value__		e.stateVersion = stateTableVersion__	};maps,the,specified,key,namespace,composite,key,to,the,specified,value,this,method,should,be,preferred,over,link,put,and,get,old,object,object,object,object,object,when,the,caller,is,not,interested,in,the,old,value,because,this,can,potentially,reduce,copy,on,write,activity,param,key,the,key,not,null,param,namespace,the,namespace,not,null,param,value,the,value,can,be,null;void,put,k,key,n,namespace,s,value,final,state,table,entry,k,n,s,e,put,entry,key,namespace,e,state,value,e,state,version,state,table,version
CopyOnWriteStateTable -> void put(K key, N namespace, S value);1519379856;Maps the specified key/namespace composite key to the specified value. This method should be preferred_over {@link #putAndGetOld(Object, Object, Object)} (Object, Object)} when the caller is not interested_in the old value, because this can potentially reduce copy-on-write activity.__@param key       the key. Not null._@param namespace the namespace. Not null._@param value     the value. Can be null.;void put(K key, N namespace, S value) {_		final StateTableEntry<K, N, S> e = putEntry(key, namespace)___		e.state = value__		e.stateVersion = stateTableVersion__	};maps,the,specified,key,namespace,composite,key,to,the,specified,value,this,method,should,be,preferred,over,link,put,and,get,old,object,object,object,object,object,when,the,caller,is,not,interested,in,the,old,value,because,this,can,potentially,reduce,copy,on,write,activity,param,key,the,key,not,null,param,namespace,the,namespace,not,null,param,value,the,value,can,be,null;void,put,k,key,n,namespace,s,value,final,state,table,entry,k,n,s,e,put,entry,key,namespace,e,state,value,e,state,version,state,table,version
CopyOnWriteStateTable -> void put(K key, N namespace, S value);1529089579;Maps the specified key/namespace composite key to the specified value. This method should be preferred_over {@link #putAndGetOld(Object, Object, Object)} (Object, Object)} when the caller is not interested_in the old value, because this can potentially reduce copy-on-write activity.__@param key       the key. Not null._@param namespace the namespace. Not null._@param value     the value. Can be null.;void put(K key, N namespace, S value) {_		final StateTableEntry<K, N, S> e = putEntry(key, namespace)___		e.state = value__		e.stateVersion = stateTableVersion__	};maps,the,specified,key,namespace,composite,key,to,the,specified,value,this,method,should,be,preferred,over,link,put,and,get,old,object,object,object,object,object,when,the,caller,is,not,interested,in,the,old,value,because,this,can,potentially,reduce,copy,on,write,activity,param,key,the,key,not,null,param,namespace,the,namespace,not,null,param,value,the,value,can,be,null;void,put,k,key,n,namespace,s,value,final,state,table,entry,k,n,s,e,put,entry,key,namespace,e,state,value,e,state,version,state,table,version
CopyOnWriteStateTable -> void put(K key, N namespace, S value);1529089584;Maps the specified key/namespace composite key to the specified value. This method should be preferred_over {@link #putAndGetOld(Object, Object, Object)} (Object, Object)} when the caller is not interested_in the old value, because this can potentially reduce copy-on-write activity.__@param key       the key. Not null._@param namespace the namespace. Not null._@param value     the value. Can be null.;void put(K key, N namespace, S value) {_		final StateTableEntry<K, N, S> e = putEntry(key, namespace)___		e.state = value__		e.stateVersion = stateTableVersion__	};maps,the,specified,key,namespace,composite,key,to,the,specified,value,this,method,should,be,preferred,over,link,put,and,get,old,object,object,object,object,object,when,the,caller,is,not,interested,in,the,old,value,because,this,can,potentially,reduce,copy,on,write,activity,param,key,the,key,not,null,param,namespace,the,namespace,not,null,param,value,the,value,can,be,null;void,put,k,key,n,namespace,s,value,final,state,table,entry,k,n,s,e,put,entry,key,namespace,e,state,value,e,state,version,state,table,version
CopyOnWriteStateTable -> void put(K key, N namespace, S value);1529307900;Maps the specified key/namespace composite key to the specified value. This method should be preferred_over {@link #putAndGetOld(Object, Object, Object)} (Object, Object)} when the caller is not interested_in the old value, because this can potentially reduce copy-on-write activity.__@param key       the key. Not null._@param namespace the namespace. Not null._@param value     the value. Can be null.;void put(K key, N namespace, S value) {_		final StateTableEntry<K, N, S> e = putEntry(key, namespace)___		e.state = value__		e.stateVersion = stateTableVersion__	};maps,the,specified,key,namespace,composite,key,to,the,specified,value,this,method,should,be,preferred,over,link,put,and,get,old,object,object,object,object,object,when,the,caller,is,not,interested,in,the,old,value,because,this,can,potentially,reduce,copy,on,write,activity,param,key,the,key,not,null,param,namespace,the,namespace,not,null,param,value,the,value,can,be,null;void,put,k,key,n,namespace,s,value,final,state,table,entry,k,n,s,e,put,entry,key,namespace,e,state,value,e,state,version,state,table,version
CopyOnWriteStateTable -> void put(K key, N namespace, S value);1530639128;Maps the specified key/namespace composite key to the specified value. This method should be preferred_over {@link #putAndGetOld(Object, Object, Object)} (Object, Object)} when the caller is not interested_in the old value, because this can potentially reduce copy-on-write activity.__@param key       the key. Not null._@param namespace the namespace. Not null._@param value     the value. Can be null.;void put(K key, N namespace, S value) {_		final StateTableEntry<K, N, S> e = putEntry(key, namespace)___		e.state = value__		e.stateVersion = stateTableVersion__	};maps,the,specified,key,namespace,composite,key,to,the,specified,value,this,method,should,be,preferred,over,link,put,and,get,old,object,object,object,object,object,when,the,caller,is,not,interested,in,the,old,value,because,this,can,potentially,reduce,copy,on,write,activity,param,key,the,key,not,null,param,namespace,the,namespace,not,null,param,value,the,value,can,be,null;void,put,k,key,n,namespace,s,value,final,state,table,entry,k,n,s,e,put,entry,key,namespace,e,state,value,e,state,version,state,table,version
CopyOnWriteStateTable -> void put(K key, N namespace, S value);1531771917;Maps the specified key/namespace composite key to the specified value. This method should be preferred_over {@link #putAndGetOld(Object, Object, Object)} (Object, Object)} when the caller is not interested_in the old value, because this can potentially reduce copy-on-write activity.__@param key       the key. Not null._@param namespace the namespace. Not null._@param value     the value. Can be null.;void put(K key, N namespace, S value) {_		final StateTableEntry<K, N, S> e = putEntry(key, namespace)___		e.state = value__		e.stateVersion = stateTableVersion__	};maps,the,specified,key,namespace,composite,key,to,the,specified,value,this,method,should,be,preferred,over,link,put,and,get,old,object,object,object,object,object,when,the,caller,is,not,interested,in,the,old,value,because,this,can,potentially,reduce,copy,on,write,activity,param,key,the,key,not,null,param,namespace,the,namespace,not,null,param,value,the,value,can,be,null;void,put,k,key,n,namespace,s,value,final,state,table,entry,k,n,s,e,put,entry,key,namespace,e,state,value,e,state,version,state,table,version
CopyOnWriteStateTable -> void put(K key, N namespace, S value);1548755874;Maps the specified key/namespace composite key to the specified value. This method should be preferred_over {@link #putAndGetOld(Object, Object, Object)} (Object, Object)} when the caller is not interested_in the old value, because this can potentially reduce copy-on-write activity.__@param key       the key. Not null._@param namespace the namespace. Not null._@param value     the value. Can be null.;void put(K key, N namespace, S value) {_		final StateTableEntry<K, N, S> e = putEntry(key, namespace)___		e.state = value__		e.stateVersion = stateTableVersion__	};maps,the,specified,key,namespace,composite,key,to,the,specified,value,this,method,should,be,preferred,over,link,put,and,get,old,object,object,object,object,object,when,the,caller,is,not,interested,in,the,old,value,because,this,can,potentially,reduce,copy,on,write,activity,param,key,the,key,not,null,param,namespace,the,namespace,not,null,param,value,the,value,can,be,null;void,put,k,key,n,namespace,s,value,final,state,table,entry,k,n,s,e,put,entry,key,namespace,e,state,value,e,state,version,state,table,version
CopyOnWriteStateTable -> @VisibleForTesting 	void releaseSnapshot(int snapshotVersion);1489685642;@see #releaseSnapshot(CopyOnWriteStateTableSnapshot);@VisibleForTesting_	void releaseSnapshot(int snapshotVersion) {_		_		_		synchronized (snapshotVersions) {_			Preconditions.checkState(snapshotVersions.remove(snapshotVersion), "Attempt to release unknown snapshot version")__			highestRequiredSnapshotVersion = snapshotVersions.isEmpty() ? 0 : snapshotVersions.last()__		}_	};see,release,snapshot,copy,on,write,state,table,snapshot;visible,for,testing,void,release,snapshot,int,snapshot,version,synchronized,snapshot,versions,preconditions,check,state,snapshot,versions,remove,snapshot,version,attempt,to,release,unknown,snapshot,version,highest,required,snapshot,version,snapshot,versions,is,empty,0,snapshot,versions,last
CopyOnWriteStateTable -> @VisibleForTesting 	void releaseSnapshot(int snapshotVersion);1494180263;@see #releaseSnapshot(CopyOnWriteStateTableSnapshot);@VisibleForTesting_	void releaseSnapshot(int snapshotVersion) {_		_		_		synchronized (snapshotVersions) {_			Preconditions.checkState(snapshotVersions.remove(snapshotVersion), "Attempt to release unknown snapshot version")__			highestRequiredSnapshotVersion = snapshotVersions.isEmpty() ? 0 : snapshotVersions.last()__		}_	};see,release,snapshot,copy,on,write,state,table,snapshot;visible,for,testing,void,release,snapshot,int,snapshot,version,synchronized,snapshot,versions,preconditions,check,state,snapshot,versions,remove,snapshot,version,attempt,to,release,unknown,snapshot,version,highest,required,snapshot,version,snapshot,versions,is,empty,0,snapshot,versions,last
CopyOnWriteStateTable -> @VisibleForTesting 	void releaseSnapshot(int snapshotVersion);1506609393;@see #releaseSnapshot(CopyOnWriteStateTableSnapshot);@VisibleForTesting_	void releaseSnapshot(int snapshotVersion) {_		_		_		synchronized (snapshotVersions) {_			Preconditions.checkState(snapshotVersions.remove(snapshotVersion), "Attempt to release unknown snapshot version")__			highestRequiredSnapshotVersion = snapshotVersions.isEmpty() ? 0 : snapshotVersions.last()__		}_	};see,release,snapshot,copy,on,write,state,table,snapshot;visible,for,testing,void,release,snapshot,int,snapshot,version,synchronized,snapshot,versions,preconditions,check,state,snapshot,versions,remove,snapshot,version,attempt,to,release,unknown,snapshot,version,highest,required,snapshot,version,snapshot,versions,is,empty,0,snapshot,versions,last
CopyOnWriteStateTable -> @VisibleForTesting 	void releaseSnapshot(int snapshotVersion);1519379856;@see #releaseSnapshot(CopyOnWriteStateTableSnapshot);@VisibleForTesting_	void releaseSnapshot(int snapshotVersion) {_		_		_		synchronized (snapshotVersions) {_			Preconditions.checkState(snapshotVersions.remove(snapshotVersion), "Attempt to release unknown snapshot version")__			highestRequiredSnapshotVersion = snapshotVersions.isEmpty() ? 0 : snapshotVersions.last()__		}_	};see,release,snapshot,copy,on,write,state,table,snapshot;visible,for,testing,void,release,snapshot,int,snapshot,version,synchronized,snapshot,versions,preconditions,check,state,snapshot,versions,remove,snapshot,version,attempt,to,release,unknown,snapshot,version,highest,required,snapshot,version,snapshot,versions,is,empty,0,snapshot,versions,last
CopyOnWriteStateTable -> @VisibleForTesting 	void releaseSnapshot(int snapshotVersion);1529089579;@see #releaseSnapshot(CopyOnWriteStateTableSnapshot);@VisibleForTesting_	void releaseSnapshot(int snapshotVersion) {_		_		_		synchronized (snapshotVersions) {_			Preconditions.checkState(snapshotVersions.remove(snapshotVersion), "Attempt to release unknown snapshot version")__			highestRequiredSnapshotVersion = snapshotVersions.isEmpty() ? 0 : snapshotVersions.last()__		}_	};see,release,snapshot,copy,on,write,state,table,snapshot;visible,for,testing,void,release,snapshot,int,snapshot,version,synchronized,snapshot,versions,preconditions,check,state,snapshot,versions,remove,snapshot,version,attempt,to,release,unknown,snapshot,version,highest,required,snapshot,version,snapshot,versions,is,empty,0,snapshot,versions,last
CopyOnWriteStateTable -> @VisibleForTesting 	void releaseSnapshot(int snapshotVersion);1529089584;@see #releaseSnapshot(CopyOnWriteStateTableSnapshot);@VisibleForTesting_	void releaseSnapshot(int snapshotVersion) {_		_		_		synchronized (snapshotVersions) {_			Preconditions.checkState(snapshotVersions.remove(snapshotVersion), "Attempt to release unknown snapshot version")__			highestRequiredSnapshotVersion = snapshotVersions.isEmpty() ? 0 : snapshotVersions.last()__		}_	};see,release,snapshot,copy,on,write,state,table,snapshot;visible,for,testing,void,release,snapshot,int,snapshot,version,synchronized,snapshot,versions,preconditions,check,state,snapshot,versions,remove,snapshot,version,attempt,to,release,unknown,snapshot,version,highest,required,snapshot,version,snapshot,versions,is,empty,0,snapshot,versions,last
CopyOnWriteStateTable -> @VisibleForTesting 	void releaseSnapshot(int snapshotVersion);1529307900;@see #releaseSnapshot(CopyOnWriteStateTableSnapshot);@VisibleForTesting_	void releaseSnapshot(int snapshotVersion) {_		_		_		synchronized (snapshotVersions) {_			Preconditions.checkState(snapshotVersions.remove(snapshotVersion), "Attempt to release unknown snapshot version")__			highestRequiredSnapshotVersion = snapshotVersions.isEmpty() ? 0 : snapshotVersions.last()__		}_	};see,release,snapshot,copy,on,write,state,table,snapshot;visible,for,testing,void,release,snapshot,int,snapshot,version,synchronized,snapshot,versions,preconditions,check,state,snapshot,versions,remove,snapshot,version,attempt,to,release,unknown,snapshot,version,highest,required,snapshot,version,snapshot,versions,is,empty,0,snapshot,versions,last
CopyOnWriteStateTable -> @VisibleForTesting 	void releaseSnapshot(int snapshotVersion);1530639128;@see #releaseSnapshot(CopyOnWriteStateTableSnapshot);@VisibleForTesting_	void releaseSnapshot(int snapshotVersion) {_		_		_		synchronized (snapshotVersions) {_			Preconditions.checkState(snapshotVersions.remove(snapshotVersion), "Attempt to release unknown snapshot version")__			highestRequiredSnapshotVersion = snapshotVersions.isEmpty() ? 0 : snapshotVersions.last()__		}_	};see,release,snapshot,copy,on,write,state,table,snapshot;visible,for,testing,void,release,snapshot,int,snapshot,version,synchronized,snapshot,versions,preconditions,check,state,snapshot,versions,remove,snapshot,version,attempt,to,release,unknown,snapshot,version,highest,required,snapshot,version,snapshot,versions,is,empty,0,snapshot,versions,last
CopyOnWriteStateTable -> @VisibleForTesting 	void releaseSnapshot(int snapshotVersion);1531771917;@see #releaseSnapshot(CopyOnWriteStateTableSnapshot);@VisibleForTesting_	void releaseSnapshot(int snapshotVersion) {_		_		_		synchronized (snapshotVersions) {_			Preconditions.checkState(snapshotVersions.remove(snapshotVersion), "Attempt to release unknown snapshot version")__			highestRequiredSnapshotVersion = snapshotVersions.isEmpty() ? 0 : snapshotVersions.last()__		}_	};see,release,snapshot,copy,on,write,state,table,snapshot;visible,for,testing,void,release,snapshot,int,snapshot,version,synchronized,snapshot,versions,preconditions,check,state,snapshot,versions,remove,snapshot,version,attempt,to,release,unknown,snapshot,version,highest,required,snapshot,version,snapshot,versions,is,empty,0,snapshot,versions,last
CopyOnWriteStateTable -> @VisibleForTesting 	void releaseSnapshot(int snapshotVersion);1548755874;@see #releaseSnapshot(CopyOnWriteStateTableSnapshot);@VisibleForTesting_	void releaseSnapshot(int snapshotVersion) {_		_		_		synchronized (snapshotVersions) {_			Preconditions.checkState(snapshotVersions.remove(snapshotVersion), "Attempt to release unknown snapshot version")__			highestRequiredSnapshotVersion = snapshotVersions.isEmpty() ? 0 : snapshotVersions.last()__		}_	};see,release,snapshot,copy,on,write,state,table,snapshot;visible,for,testing,void,release,snapshot,int,snapshot,version,synchronized,snapshot,versions,preconditions,check,state,snapshot,versions,remove,snapshot,version,attempt,to,release,unknown,snapshot,version,highest,required,snapshot,version,snapshot,versions,is,empty,0,snapshot,versions,last
CopyOnWriteStateTable -> S putAndGetOld(K key, N namespace, S value);1489685642;Maps the specified key/namespace composite key to the specified value. Returns the previous state that was_registered under the composite key.__@param key       the key. Not null._@param namespace the namespace. Not null._@param value     the value. Can be null._@return the value of any previous mapping with the specified key or_{@code null} if there was no such mapping.;S putAndGetOld(K key, N namespace, S value) {__		final StateTableEntry<K, N, S> e = putEntry(key, namespace)___		_		S oldState = (e.stateVersion < highestRequiredSnapshotVersion) ?_				getStateSerializer().copy(e.state) :_				e.state___		e.state = value__		e.stateVersion = stateTableVersion___		return oldState__	};maps,the,specified,key,namespace,composite,key,to,the,specified,value,returns,the,previous,state,that,was,registered,under,the,composite,key,param,key,the,key,not,null,param,namespace,the,namespace,not,null,param,value,the,value,can,be,null,return,the,value,of,any,previous,mapping,with,the,specified,key,or,code,null,if,there,was,no,such,mapping;s,put,and,get,old,k,key,n,namespace,s,value,final,state,table,entry,k,n,s,e,put,entry,key,namespace,s,old,state,e,state,version,highest,required,snapshot,version,get,state,serializer,copy,e,state,e,state,e,state,value,e,state,version,state,table,version,return,old,state
CopyOnWriteStateTable -> S putAndGetOld(K key, N namespace, S value);1494180263;Maps the specified key/namespace composite key to the specified value. Returns the previous state that was_registered under the composite key.__@param key       the key. Not null._@param namespace the namespace. Not null._@param value     the value. Can be null._@return the value of any previous mapping with the specified key or_{@code null} if there was no such mapping.;S putAndGetOld(K key, N namespace, S value) {__		final StateTableEntry<K, N, S> e = putEntry(key, namespace)___		_		S oldState = (e.stateVersion < highestRequiredSnapshotVersion) ?_				getStateSerializer().copy(e.state) :_				e.state___		e.state = value__		e.stateVersion = stateTableVersion___		return oldState__	};maps,the,specified,key,namespace,composite,key,to,the,specified,value,returns,the,previous,state,that,was,registered,under,the,composite,key,param,key,the,key,not,null,param,namespace,the,namespace,not,null,param,value,the,value,can,be,null,return,the,value,of,any,previous,mapping,with,the,specified,key,or,code,null,if,there,was,no,such,mapping;s,put,and,get,old,k,key,n,namespace,s,value,final,state,table,entry,k,n,s,e,put,entry,key,namespace,s,old,state,e,state,version,highest,required,snapshot,version,get,state,serializer,copy,e,state,e,state,e,state,value,e,state,version,state,table,version,return,old,state
CopyOnWriteStateTable -> S putAndGetOld(K key, N namespace, S value);1506609393;Maps the specified key/namespace composite key to the specified value. Returns the previous state that was_registered under the composite key.__@param key       the key. Not null._@param namespace the namespace. Not null._@param value     the value. Can be null._@return the value of any previous mapping with the specified key or_{@code null} if there was no such mapping.;S putAndGetOld(K key, N namespace, S value) {__		final StateTableEntry<K, N, S> e = putEntry(key, namespace)___		_		S oldState = (e.stateVersion < highestRequiredSnapshotVersion) ?_				getStateSerializer().copy(e.state) :_				e.state___		e.state = value__		e.stateVersion = stateTableVersion___		return oldState__	};maps,the,specified,key,namespace,composite,key,to,the,specified,value,returns,the,previous,state,that,was,registered,under,the,composite,key,param,key,the,key,not,null,param,namespace,the,namespace,not,null,param,value,the,value,can,be,null,return,the,value,of,any,previous,mapping,with,the,specified,key,or,code,null,if,there,was,no,such,mapping;s,put,and,get,old,k,key,n,namespace,s,value,final,state,table,entry,k,n,s,e,put,entry,key,namespace,s,old,state,e,state,version,highest,required,snapshot,version,get,state,serializer,copy,e,state,e,state,e,state,value,e,state,version,state,table,version,return,old,state
CopyOnWriteStateTable -> S putAndGetOld(K key, N namespace, S value);1519379856;Maps the specified key/namespace composite key to the specified value. Returns the previous state that was_registered under the composite key.__@param key       the key. Not null._@param namespace the namespace. Not null._@param value     the value. Can be null._@return the value of any previous mapping with the specified key or_{@code null} if there was no such mapping.;S putAndGetOld(K key, N namespace, S value) {__		final StateTableEntry<K, N, S> e = putEntry(key, namespace)___		_		S oldState = (e.stateVersion < highestRequiredSnapshotVersion) ?_				getStateSerializer().copy(e.state) :_				e.state___		e.state = value__		e.stateVersion = stateTableVersion___		return oldState__	};maps,the,specified,key,namespace,composite,key,to,the,specified,value,returns,the,previous,state,that,was,registered,under,the,composite,key,param,key,the,key,not,null,param,namespace,the,namespace,not,null,param,value,the,value,can,be,null,return,the,value,of,any,previous,mapping,with,the,specified,key,or,code,null,if,there,was,no,such,mapping;s,put,and,get,old,k,key,n,namespace,s,value,final,state,table,entry,k,n,s,e,put,entry,key,namespace,s,old,state,e,state,version,highest,required,snapshot,version,get,state,serializer,copy,e,state,e,state,e,state,value,e,state,version,state,table,version,return,old,state
CopyOnWriteStateTable -> S putAndGetOld(K key, N namespace, S value);1529089579;Maps the specified key/namespace composite key to the specified value. Returns the previous state that was_registered under the composite key.__@param key       the key. Not null._@param namespace the namespace. Not null._@param value     the value. Can be null._@return the value of any previous mapping with the specified key or_{@code null} if there was no such mapping.;S putAndGetOld(K key, N namespace, S value) {__		final StateTableEntry<K, N, S> e = putEntry(key, namespace)___		_		S oldState = (e.stateVersion < highestRequiredSnapshotVersion) ?_				getStateSerializer().copy(e.state) :_				e.state___		e.state = value__		e.stateVersion = stateTableVersion___		return oldState__	};maps,the,specified,key,namespace,composite,key,to,the,specified,value,returns,the,previous,state,that,was,registered,under,the,composite,key,param,key,the,key,not,null,param,namespace,the,namespace,not,null,param,value,the,value,can,be,null,return,the,value,of,any,previous,mapping,with,the,specified,key,or,code,null,if,there,was,no,such,mapping;s,put,and,get,old,k,key,n,namespace,s,value,final,state,table,entry,k,n,s,e,put,entry,key,namespace,s,old,state,e,state,version,highest,required,snapshot,version,get,state,serializer,copy,e,state,e,state,e,state,value,e,state,version,state,table,version,return,old,state
CopyOnWriteStateTable -> S putAndGetOld(K key, N namespace, S value);1529089584;Maps the specified key/namespace composite key to the specified value. Returns the previous state that was_registered under the composite key.__@param key       the key. Not null._@param namespace the namespace. Not null._@param value     the value. Can be null._@return the value of any previous mapping with the specified key or_{@code null} if there was no such mapping.;S putAndGetOld(K key, N namespace, S value) {__		final StateTableEntry<K, N, S> e = putEntry(key, namespace)___		_		S oldState = (e.stateVersion < highestRequiredSnapshotVersion) ?_				getStateSerializer().copy(e.state) :_				e.state___		e.state = value__		e.stateVersion = stateTableVersion___		return oldState__	};maps,the,specified,key,namespace,composite,key,to,the,specified,value,returns,the,previous,state,that,was,registered,under,the,composite,key,param,key,the,key,not,null,param,namespace,the,namespace,not,null,param,value,the,value,can,be,null,return,the,value,of,any,previous,mapping,with,the,specified,key,or,code,null,if,there,was,no,such,mapping;s,put,and,get,old,k,key,n,namespace,s,value,final,state,table,entry,k,n,s,e,put,entry,key,namespace,s,old,state,e,state,version,highest,required,snapshot,version,get,state,serializer,copy,e,state,e,state,e,state,value,e,state,version,state,table,version,return,old,state
CopyOnWriteStateTable -> S putAndGetOld(K key, N namespace, S value);1529307900;Maps the specified key/namespace composite key to the specified value. Returns the previous state that was_registered under the composite key.__@param key       the key. Not null._@param namespace the namespace. Not null._@param value     the value. Can be null._@return the value of any previous mapping with the specified key or_{@code null} if there was no such mapping.;S putAndGetOld(K key, N namespace, S value) {__		final StateTableEntry<K, N, S> e = putEntry(key, namespace)___		_		S oldState = (e.stateVersion < highestRequiredSnapshotVersion) ?_				getStateSerializer().copy(e.state) :_				e.state___		e.state = value__		e.stateVersion = stateTableVersion___		return oldState__	};maps,the,specified,key,namespace,composite,key,to,the,specified,value,returns,the,previous,state,that,was,registered,under,the,composite,key,param,key,the,key,not,null,param,namespace,the,namespace,not,null,param,value,the,value,can,be,null,return,the,value,of,any,previous,mapping,with,the,specified,key,or,code,null,if,there,was,no,such,mapping;s,put,and,get,old,k,key,n,namespace,s,value,final,state,table,entry,k,n,s,e,put,entry,key,namespace,s,old,state,e,state,version,highest,required,snapshot,version,get,state,serializer,copy,e,state,e,state,e,state,value,e,state,version,state,table,version,return,old,state
CopyOnWriteStateTable -> S putAndGetOld(K key, N namespace, S value);1530639128;Maps the specified key/namespace composite key to the specified value. Returns the previous state that was_registered under the composite key.__@param key       the key. Not null._@param namespace the namespace. Not null._@param value     the value. Can be null._@return the value of any previous mapping with the specified key or_{@code null} if there was no such mapping.;S putAndGetOld(K key, N namespace, S value) {__		final StateTableEntry<K, N, S> e = putEntry(key, namespace)___		_		S oldState = (e.stateVersion < highestRequiredSnapshotVersion) ?_				getStateSerializer().copy(e.state) :_				e.state___		e.state = value__		e.stateVersion = stateTableVersion___		return oldState__	};maps,the,specified,key,namespace,composite,key,to,the,specified,value,returns,the,previous,state,that,was,registered,under,the,composite,key,param,key,the,key,not,null,param,namespace,the,namespace,not,null,param,value,the,value,can,be,null,return,the,value,of,any,previous,mapping,with,the,specified,key,or,code,null,if,there,was,no,such,mapping;s,put,and,get,old,k,key,n,namespace,s,value,final,state,table,entry,k,n,s,e,put,entry,key,namespace,s,old,state,e,state,version,highest,required,snapshot,version,get,state,serializer,copy,e,state,e,state,e,state,value,e,state,version,state,table,version,return,old,state
CopyOnWriteStateTable -> S putAndGetOld(K key, N namespace, S value);1531771917;Maps the specified key/namespace composite key to the specified value. Returns the previous state that was_registered under the composite key.__@param key       the key. Not null._@param namespace the namespace. Not null._@param value     the value. Can be null._@return the value of any previous mapping with the specified key or_{@code null} if there was no such mapping.;S putAndGetOld(K key, N namespace, S value) {__		final StateTableEntry<K, N, S> e = putEntry(key, namespace)___		_		S oldState = (e.stateVersion < highestRequiredSnapshotVersion) ?_				getStateSerializer().copy(e.state) :_				e.state___		e.state = value__		e.stateVersion = stateTableVersion___		return oldState__	};maps,the,specified,key,namespace,composite,key,to,the,specified,value,returns,the,previous,state,that,was,registered,under,the,composite,key,param,key,the,key,not,null,param,namespace,the,namespace,not,null,param,value,the,value,can,be,null,return,the,value,of,any,previous,mapping,with,the,specified,key,or,code,null,if,there,was,no,such,mapping;s,put,and,get,old,k,key,n,namespace,s,value,final,state,table,entry,k,n,s,e,put,entry,key,namespace,s,old,state,e,state,version,highest,required,snapshot,version,get,state,serializer,copy,e,state,e,state,e,state,value,e,state,version,state,table,version,return,old,state
CopyOnWriteStateTable -> S putAndGetOld(K key, N namespace, S value);1548755874;Maps the specified key/namespace composite key to the specified value. Returns the previous state that was_registered under the composite key.__@param key       the key. Not null._@param namespace the namespace. Not null._@param value     the value. Can be null._@return the value of any previous mapping with the specified key or_{@code null} if there was no such mapping.;S putAndGetOld(K key, N namespace, S value) {__		final StateTableEntry<K, N, S> e = putEntry(key, namespace)___		_		S oldState = (e.stateVersion < highestRequiredSnapshotVersion) ?_				getStateSerializer().copy(e.state) :_				e.state___		e.state = value__		e.stateVersion = stateTableVersion___		return oldState__	};maps,the,specified,key,namespace,composite,key,to,the,specified,value,returns,the,previous,state,that,was,registered,under,the,composite,key,param,key,the,key,not,null,param,namespace,the,namespace,not,null,param,value,the,value,can,be,null,return,the,value,of,any,previous,mapping,with,the,specified,key,or,code,null,if,there,was,no,such,mapping;s,put,and,get,old,k,key,n,namespace,s,value,final,state,table,entry,k,n,s,e,put,entry,key,namespace,s,old,state,e,state,version,highest,required,snapshot,version,get,state,serializer,copy,e,state,e,state,e,state,value,e,state,version,state,table,version,return,old,state
CopyOnWriteStateTable -> CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyValueStateBackendMetaInfo<N, S> metaInfo);1531771917;Constructs a new {@code StateTable} with default capacity of 1024.__@param keyContext the key context._@param metaInfo   the meta information, including the type serializer for state copy-on-write.;CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyValueStateBackendMetaInfo<N, S> metaInfo) {_		this(keyContext, metaInfo, 1024)__	};constructs,a,new,code,state,table,with,default,capacity,of,1024,param,key,context,the,key,context,param,meta,info,the,meta,information,including,the,type,serializer,for,state,copy,on,write;copy,on,write,state,table,internal,key,context,k,key,context,registered,key,value,state,backend,meta,info,n,s,meta,info,this,key,context,meta,info,1024
CopyOnWriteStateTable -> CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyValueStateBackendMetaInfo<N, S> metaInfo);1548755874;Constructs a new {@code StateTable} with default capacity of {@code DEFAULT_CAPACITY}.__@param keyContext the key context._@param metaInfo   the meta information, including the type serializer for state copy-on-write.;CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyValueStateBackendMetaInfo<N, S> metaInfo) {_		this(keyContext, metaInfo, DEFAULT_CAPACITY)__	};constructs,a,new,code,state,table,with,default,capacity,of,code,param,key,context,the,key,context,param,meta,info,the,meta,information,including,the,type,serializer,for,state,copy,on,write;copy,on,write,state,table,internal,key,context,k,key,context,registered,key,value,state,backend,meta,info,n,s,meta,info,this,key,context,meta,info
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> handleChainedEntryCopyOnWrite( 			StateTableEntry<K, N, S>[] tab, 			int tableIdx, 			StateTableEntry<K, N, S> untilEntry);1489685642;Perform copy-on-write for entry chains. We iterate the (hopefully and probably) still cached chain, replace_all links up to the 'untilEntry', which we actually wanted to modify.;private StateTableEntry<K, N, S> handleChainedEntryCopyOnWrite(_			StateTableEntry<K, N, S>[] tab,_			int tableIdx,_			StateTableEntry<K, N, S> untilEntry) {__		final int required = highestRequiredSnapshotVersion___		StateTableEntry<K, N, S> current = tab[tableIdx]__		StateTableEntry<K, N, S> copy___		if (current.entryVersion < required) {_			copy = new StateTableEntry<>(current, stateTableVersion)__			tab[tableIdx] = copy__		} else {_			_			copy = current__		}__		_		while (current != untilEntry) {__			_			current = current.next___			if (current.entryVersion < required) {_				_				copy.next = new StateTableEntry<>(current, stateTableVersion)__				copy = copy.next__			} else {_				_				copy = current__			}_		}__		return copy__	};perform,copy,on,write,for,entry,chains,we,iterate,the,hopefully,and,probably,still,cached,chain,replace,all,links,up,to,the,until,entry,which,we,actually,wanted,to,modify;private,state,table,entry,k,n,s,handle,chained,entry,copy,on,write,state,table,entry,k,n,s,tab,int,table,idx,state,table,entry,k,n,s,until,entry,final,int,required,highest,required,snapshot,version,state,table,entry,k,n,s,current,tab,table,idx,state,table,entry,k,n,s,copy,if,current,entry,version,required,copy,new,state,table,entry,current,state,table,version,tab,table,idx,copy,else,copy,current,while,current,until,entry,current,current,next,if,current,entry,version,required,copy,next,new,state,table,entry,current,state,table,version,copy,copy,next,else,copy,current,return,copy
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> handleChainedEntryCopyOnWrite( 			StateTableEntry<K, N, S>[] tab, 			int tableIdx, 			StateTableEntry<K, N, S> untilEntry);1494180263;Perform copy-on-write for entry chains. We iterate the (hopefully and probably) still cached chain, replace_all links up to the 'untilEntry', which we actually wanted to modify.;private StateTableEntry<K, N, S> handleChainedEntryCopyOnWrite(_			StateTableEntry<K, N, S>[] tab,_			int tableIdx,_			StateTableEntry<K, N, S> untilEntry) {__		final int required = highestRequiredSnapshotVersion___		StateTableEntry<K, N, S> current = tab[tableIdx]__		StateTableEntry<K, N, S> copy___		if (current.entryVersion < required) {_			copy = new StateTableEntry<>(current, stateTableVersion)__			tab[tableIdx] = copy__		} else {_			_			copy = current__		}__		_		while (current != untilEntry) {__			_			current = current.next___			if (current.entryVersion < required) {_				_				copy.next = new StateTableEntry<>(current, stateTableVersion)__				copy = copy.next__			} else {_				_				copy = current__			}_		}__		return copy__	};perform,copy,on,write,for,entry,chains,we,iterate,the,hopefully,and,probably,still,cached,chain,replace,all,links,up,to,the,until,entry,which,we,actually,wanted,to,modify;private,state,table,entry,k,n,s,handle,chained,entry,copy,on,write,state,table,entry,k,n,s,tab,int,table,idx,state,table,entry,k,n,s,until,entry,final,int,required,highest,required,snapshot,version,state,table,entry,k,n,s,current,tab,table,idx,state,table,entry,k,n,s,copy,if,current,entry,version,required,copy,new,state,table,entry,current,state,table,version,tab,table,idx,copy,else,copy,current,while,current,until,entry,current,current,next,if,current,entry,version,required,copy,next,new,state,table,entry,current,state,table,version,copy,copy,next,else,copy,current,return,copy
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> handleChainedEntryCopyOnWrite( 			StateTableEntry<K, N, S>[] tab, 			int tableIdx, 			StateTableEntry<K, N, S> untilEntry);1506609393;Perform copy-on-write for entry chains. We iterate the (hopefully and probably) still cached chain, replace_all links up to the 'untilEntry', which we actually wanted to modify.;private StateTableEntry<K, N, S> handleChainedEntryCopyOnWrite(_			StateTableEntry<K, N, S>[] tab,_			int tableIdx,_			StateTableEntry<K, N, S> untilEntry) {__		final int required = highestRequiredSnapshotVersion___		StateTableEntry<K, N, S> current = tab[tableIdx]__		StateTableEntry<K, N, S> copy___		if (current.entryVersion < required) {_			copy = new StateTableEntry<>(current, stateTableVersion)__			tab[tableIdx] = copy__		} else {_			_			copy = current__		}__		_		while (current != untilEntry) {__			_			current = current.next___			if (current.entryVersion < required) {_				_				copy.next = new StateTableEntry<>(current, stateTableVersion)__				copy = copy.next__			} else {_				_				copy = current__			}_		}__		return copy__	};perform,copy,on,write,for,entry,chains,we,iterate,the,hopefully,and,probably,still,cached,chain,replace,all,links,up,to,the,until,entry,which,we,actually,wanted,to,modify;private,state,table,entry,k,n,s,handle,chained,entry,copy,on,write,state,table,entry,k,n,s,tab,int,table,idx,state,table,entry,k,n,s,until,entry,final,int,required,highest,required,snapshot,version,state,table,entry,k,n,s,current,tab,table,idx,state,table,entry,k,n,s,copy,if,current,entry,version,required,copy,new,state,table,entry,current,state,table,version,tab,table,idx,copy,else,copy,current,while,current,until,entry,current,current,next,if,current,entry,version,required,copy,next,new,state,table,entry,current,state,table,version,copy,copy,next,else,copy,current,return,copy
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> handleChainedEntryCopyOnWrite( 			StateTableEntry<K, N, S>[] tab, 			int tableIdx, 			StateTableEntry<K, N, S> untilEntry);1519379856;Perform copy-on-write for entry chains. We iterate the (hopefully and probably) still cached chain, replace_all links up to the 'untilEntry', which we actually wanted to modify.;private StateTableEntry<K, N, S> handleChainedEntryCopyOnWrite(_			StateTableEntry<K, N, S>[] tab,_			int tableIdx,_			StateTableEntry<K, N, S> untilEntry) {__		final int required = highestRequiredSnapshotVersion___		StateTableEntry<K, N, S> current = tab[tableIdx]__		StateTableEntry<K, N, S> copy___		if (current.entryVersion < required) {_			copy = new StateTableEntry<>(current, stateTableVersion)__			tab[tableIdx] = copy__		} else {_			_			copy = current__		}__		_		while (current != untilEntry) {__			_			current = current.next___			if (current.entryVersion < required) {_				_				copy.next = new StateTableEntry<>(current, stateTableVersion)__				copy = copy.next__			} else {_				_				copy = current__			}_		}__		return copy__	};perform,copy,on,write,for,entry,chains,we,iterate,the,hopefully,and,probably,still,cached,chain,replace,all,links,up,to,the,until,entry,which,we,actually,wanted,to,modify;private,state,table,entry,k,n,s,handle,chained,entry,copy,on,write,state,table,entry,k,n,s,tab,int,table,idx,state,table,entry,k,n,s,until,entry,final,int,required,highest,required,snapshot,version,state,table,entry,k,n,s,current,tab,table,idx,state,table,entry,k,n,s,copy,if,current,entry,version,required,copy,new,state,table,entry,current,state,table,version,tab,table,idx,copy,else,copy,current,while,current,until,entry,current,current,next,if,current,entry,version,required,copy,next,new,state,table,entry,current,state,table,version,copy,copy,next,else,copy,current,return,copy
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> handleChainedEntryCopyOnWrite( 			StateTableEntry<K, N, S>[] tab, 			int tableIdx, 			StateTableEntry<K, N, S> untilEntry);1529089579;Perform copy-on-write for entry chains. We iterate the (hopefully and probably) still cached chain, replace_all links up to the 'untilEntry', which we actually wanted to modify.;private StateTableEntry<K, N, S> handleChainedEntryCopyOnWrite(_			StateTableEntry<K, N, S>[] tab,_			int tableIdx,_			StateTableEntry<K, N, S> untilEntry) {__		final int required = highestRequiredSnapshotVersion___		StateTableEntry<K, N, S> current = tab[tableIdx]__		StateTableEntry<K, N, S> copy___		if (current.entryVersion < required) {_			copy = new StateTableEntry<>(current, stateTableVersion)__			tab[tableIdx] = copy__		} else {_			_			copy = current__		}__		_		while (current != untilEntry) {__			_			current = current.next___			if (current.entryVersion < required) {_				_				copy.next = new StateTableEntry<>(current, stateTableVersion)__				copy = copy.next__			} else {_				_				copy = current__			}_		}__		return copy__	};perform,copy,on,write,for,entry,chains,we,iterate,the,hopefully,and,probably,still,cached,chain,replace,all,links,up,to,the,until,entry,which,we,actually,wanted,to,modify;private,state,table,entry,k,n,s,handle,chained,entry,copy,on,write,state,table,entry,k,n,s,tab,int,table,idx,state,table,entry,k,n,s,until,entry,final,int,required,highest,required,snapshot,version,state,table,entry,k,n,s,current,tab,table,idx,state,table,entry,k,n,s,copy,if,current,entry,version,required,copy,new,state,table,entry,current,state,table,version,tab,table,idx,copy,else,copy,current,while,current,until,entry,current,current,next,if,current,entry,version,required,copy,next,new,state,table,entry,current,state,table,version,copy,copy,next,else,copy,current,return,copy
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> handleChainedEntryCopyOnWrite( 			StateTableEntry<K, N, S>[] tab, 			int tableIdx, 			StateTableEntry<K, N, S> untilEntry);1529089584;Perform copy-on-write for entry chains. We iterate the (hopefully and probably) still cached chain, replace_all links up to the 'untilEntry', which we actually wanted to modify.;private StateTableEntry<K, N, S> handleChainedEntryCopyOnWrite(_			StateTableEntry<K, N, S>[] tab,_			int tableIdx,_			StateTableEntry<K, N, S> untilEntry) {__		final int required = highestRequiredSnapshotVersion___		StateTableEntry<K, N, S> current = tab[tableIdx]__		StateTableEntry<K, N, S> copy___		if (current.entryVersion < required) {_			copy = new StateTableEntry<>(current, stateTableVersion)__			tab[tableIdx] = copy__		} else {_			_			copy = current__		}__		_		while (current != untilEntry) {__			_			current = current.next___			if (current.entryVersion < required) {_				_				copy.next = new StateTableEntry<>(current, stateTableVersion)__				copy = copy.next__			} else {_				_				copy = current__			}_		}__		return copy__	};perform,copy,on,write,for,entry,chains,we,iterate,the,hopefully,and,probably,still,cached,chain,replace,all,links,up,to,the,until,entry,which,we,actually,wanted,to,modify;private,state,table,entry,k,n,s,handle,chained,entry,copy,on,write,state,table,entry,k,n,s,tab,int,table,idx,state,table,entry,k,n,s,until,entry,final,int,required,highest,required,snapshot,version,state,table,entry,k,n,s,current,tab,table,idx,state,table,entry,k,n,s,copy,if,current,entry,version,required,copy,new,state,table,entry,current,state,table,version,tab,table,idx,copy,else,copy,current,while,current,until,entry,current,current,next,if,current,entry,version,required,copy,next,new,state,table,entry,current,state,table,version,copy,copy,next,else,copy,current,return,copy
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> handleChainedEntryCopyOnWrite( 			StateTableEntry<K, N, S>[] tab, 			int tableIdx, 			StateTableEntry<K, N, S> untilEntry);1529307900;Perform copy-on-write for entry chains. We iterate the (hopefully and probably) still cached chain, replace_all links up to the 'untilEntry', which we actually wanted to modify.;private StateTableEntry<K, N, S> handleChainedEntryCopyOnWrite(_			StateTableEntry<K, N, S>[] tab,_			int tableIdx,_			StateTableEntry<K, N, S> untilEntry) {__		final int required = highestRequiredSnapshotVersion___		StateTableEntry<K, N, S> current = tab[tableIdx]__		StateTableEntry<K, N, S> copy___		if (current.entryVersion < required) {_			copy = new StateTableEntry<>(current, stateTableVersion)__			tab[tableIdx] = copy__		} else {_			_			copy = current__		}__		_		while (current != untilEntry) {__			_			current = current.next___			if (current.entryVersion < required) {_				_				copy.next = new StateTableEntry<>(current, stateTableVersion)__				copy = copy.next__			} else {_				_				copy = current__			}_		}__		return copy__	};perform,copy,on,write,for,entry,chains,we,iterate,the,hopefully,and,probably,still,cached,chain,replace,all,links,up,to,the,until,entry,which,we,actually,wanted,to,modify;private,state,table,entry,k,n,s,handle,chained,entry,copy,on,write,state,table,entry,k,n,s,tab,int,table,idx,state,table,entry,k,n,s,until,entry,final,int,required,highest,required,snapshot,version,state,table,entry,k,n,s,current,tab,table,idx,state,table,entry,k,n,s,copy,if,current,entry,version,required,copy,new,state,table,entry,current,state,table,version,tab,table,idx,copy,else,copy,current,while,current,until,entry,current,current,next,if,current,entry,version,required,copy,next,new,state,table,entry,current,state,table,version,copy,copy,next,else,copy,current,return,copy
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> handleChainedEntryCopyOnWrite( 			StateTableEntry<K, N, S>[] tab, 			int tableIdx, 			StateTableEntry<K, N, S> untilEntry);1530639128;Perform copy-on-write for entry chains. We iterate the (hopefully and probably) still cached chain, replace_all links up to the 'untilEntry', which we actually wanted to modify.;private StateTableEntry<K, N, S> handleChainedEntryCopyOnWrite(_			StateTableEntry<K, N, S>[] tab,_			int tableIdx,_			StateTableEntry<K, N, S> untilEntry) {__		final int required = highestRequiredSnapshotVersion___		StateTableEntry<K, N, S> current = tab[tableIdx]__		StateTableEntry<K, N, S> copy___		if (current.entryVersion < required) {_			copy = new StateTableEntry<>(current, stateTableVersion)__			tab[tableIdx] = copy__		} else {_			_			copy = current__		}__		_		while (current != untilEntry) {__			_			current = current.next___			if (current.entryVersion < required) {_				_				copy.next = new StateTableEntry<>(current, stateTableVersion)__				copy = copy.next__			} else {_				_				copy = current__			}_		}__		return copy__	};perform,copy,on,write,for,entry,chains,we,iterate,the,hopefully,and,probably,still,cached,chain,replace,all,links,up,to,the,until,entry,which,we,actually,wanted,to,modify;private,state,table,entry,k,n,s,handle,chained,entry,copy,on,write,state,table,entry,k,n,s,tab,int,table,idx,state,table,entry,k,n,s,until,entry,final,int,required,highest,required,snapshot,version,state,table,entry,k,n,s,current,tab,table,idx,state,table,entry,k,n,s,copy,if,current,entry,version,required,copy,new,state,table,entry,current,state,table,version,tab,table,idx,copy,else,copy,current,while,current,until,entry,current,current,next,if,current,entry,version,required,copy,next,new,state,table,entry,current,state,table,version,copy,copy,next,else,copy,current,return,copy
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> handleChainedEntryCopyOnWrite( 			StateTableEntry<K, N, S>[] tab, 			int tableIdx, 			StateTableEntry<K, N, S> untilEntry);1531771917;Perform copy-on-write for entry chains. We iterate the (hopefully and probably) still cached chain, replace_all links up to the 'untilEntry', which we actually wanted to modify.;private StateTableEntry<K, N, S> handleChainedEntryCopyOnWrite(_			StateTableEntry<K, N, S>[] tab,_			int tableIdx,_			StateTableEntry<K, N, S> untilEntry) {__		final int required = highestRequiredSnapshotVersion___		StateTableEntry<K, N, S> current = tab[tableIdx]__		StateTableEntry<K, N, S> copy___		if (current.entryVersion < required) {_			copy = new StateTableEntry<>(current, stateTableVersion)__			tab[tableIdx] = copy__		} else {_			_			copy = current__		}__		_		while (current != untilEntry) {__			_			current = current.next___			if (current.entryVersion < required) {_				_				copy.next = new StateTableEntry<>(current, stateTableVersion)__				copy = copy.next__			} else {_				_				copy = current__			}_		}__		return copy__	};perform,copy,on,write,for,entry,chains,we,iterate,the,hopefully,and,probably,still,cached,chain,replace,all,links,up,to,the,until,entry,which,we,actually,wanted,to,modify;private,state,table,entry,k,n,s,handle,chained,entry,copy,on,write,state,table,entry,k,n,s,tab,int,table,idx,state,table,entry,k,n,s,until,entry,final,int,required,highest,required,snapshot,version,state,table,entry,k,n,s,current,tab,table,idx,state,table,entry,k,n,s,copy,if,current,entry,version,required,copy,new,state,table,entry,current,state,table,version,tab,table,idx,copy,else,copy,current,while,current,until,entry,current,current,next,if,current,entry,version,required,copy,next,new,state,table,entry,current,state,table,version,copy,copy,next,else,copy,current,return,copy
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> handleChainedEntryCopyOnWrite( 			StateTableEntry<K, N, S>[] tab, 			int tableIdx, 			StateTableEntry<K, N, S> untilEntry);1548755874;Perform copy-on-write for entry chains. We iterate the (hopefully and probably) still cached chain, replace_all links up to the 'untilEntry', which we actually wanted to modify.;private StateTableEntry<K, N, S> handleChainedEntryCopyOnWrite(_			StateTableEntry<K, N, S>[] tab,_			int tableIdx,_			StateTableEntry<K, N, S> untilEntry) {__		final int required = highestRequiredSnapshotVersion___		StateTableEntry<K, N, S> current = tab[tableIdx]__		StateTableEntry<K, N, S> copy___		if (current.entryVersion < required) {_			copy = new StateTableEntry<>(current, stateTableVersion)__			tab[tableIdx] = copy__		} else {_			_			copy = current__		}__		_		while (current != untilEntry) {__			_			current = current.next___			if (current.entryVersion < required) {_				_				copy.next = new StateTableEntry<>(current, stateTableVersion)__				copy = copy.next__			} else {_				_				copy = current__			}_		}__		return copy__	};perform,copy,on,write,for,entry,chains,we,iterate,the,hopefully,and,probably,still,cached,chain,replace,all,links,up,to,the,until,entry,which,we,actually,wanted,to,modify;private,state,table,entry,k,n,s,handle,chained,entry,copy,on,write,state,table,entry,k,n,s,tab,int,table,idx,state,table,entry,k,n,s,until,entry,final,int,required,highest,required,snapshot,version,state,table,entry,k,n,s,current,tab,table,idx,state,table,entry,k,n,s,copy,if,current,entry,version,required,copy,new,state,table,entry,current,state,table,version,tab,table,idx,copy,else,copy,current,while,current,until,entry,current,current,next,if,current,entry,version,required,copy,next,new,state,table,entry,current,state,table,version,copy,copy,next,else,copy,current,return,copy
CopyOnWriteStateTable -> @VisibleForTesting 	@SuppressWarnings("unchecked") 	StateTableEntry<K, N, S>[] snapshotTableArrays();1489685642;Creates (combined) copy of the table arrays for a snapshot. This method must be called by the same Thread that_does modifications to the {@link CopyOnWriteStateTable}.;@VisibleForTesting_	@SuppressWarnings("unchecked")_	StateTableEntry<K, N, S>[] snapshotTableArrays() {__		_		_		_		synchronized (snapshotVersions) {__			_			if (++stateTableVersion < 0) {_				_				throw new IllegalStateException("Version count overflow in CopyOnWriteStateTable. Enforcing restart.")__			}__			highestRequiredSnapshotVersion = stateTableVersion__			snapshotVersions.add(highestRequiredSnapshotVersion)__		}__		StateTableEntry<K, N, S>[] table = primaryTable__		if (isRehashing()) {_			_			final int localRehashIndex = rehashIndex__			final int localCopyLength = table.length - localRehashIndex__			StateTableEntry<K, N, S>[] copy = new StateTableEntry[localRehashIndex + table.length]__			_			System.arraycopy(table, localRehashIndex, copy, 0, localCopyLength)___			_			_			table = incrementalRehashTable__			System.arraycopy(table, 0, copy, localCopyLength, localRehashIndex)__			System.arraycopy(table, table.length >>> 1, copy, localCopyLength + localRehashIndex, localRehashIndex)___			return copy__		} else {_			_			return Arrays.copyOf(table, table.length)__		}_	};creates,combined,copy,of,the,table,arrays,for,a,snapshot,this,method,must,be,called,by,the,same,thread,that,does,modifications,to,the,link,copy,on,write,state,table;visible,for,testing,suppress,warnings,unchecked,state,table,entry,k,n,s,snapshot,table,arrays,synchronized,snapshot,versions,if,state,table,version,0,throw,new,illegal,state,exception,version,count,overflow,in,copy,on,write,state,table,enforcing,restart,highest,required,snapshot,version,state,table,version,snapshot,versions,add,highest,required,snapshot,version,state,table,entry,k,n,s,table,primary,table,if,is,rehashing,final,int,local,rehash,index,rehash,index,final,int,local,copy,length,table,length,local,rehash,index,state,table,entry,k,n,s,copy,new,state,table,entry,local,rehash,index,table,length,system,arraycopy,table,local,rehash,index,copy,0,local,copy,length,table,incremental,rehash,table,system,arraycopy,table,0,copy,local,copy,length,local,rehash,index,system,arraycopy,table,table,length,1,copy,local,copy,length,local,rehash,index,local,rehash,index,return,copy,else,return,arrays,copy,of,table,table,length
CopyOnWriteStateTable -> @VisibleForTesting 	@SuppressWarnings("unchecked") 	StateTableEntry<K, N, S>[] snapshotTableArrays();1494180263;Creates (combined) copy of the table arrays for a snapshot. This method must be called by the same Thread that_does modifications to the {@link CopyOnWriteStateTable}.;@VisibleForTesting_	@SuppressWarnings("unchecked")_	StateTableEntry<K, N, S>[] snapshotTableArrays() {__		_		_		_		synchronized (snapshotVersions) {__			_			if (++stateTableVersion < 0) {_				_				throw new IllegalStateException("Version count overflow in CopyOnWriteStateTable. Enforcing restart.")__			}__			highestRequiredSnapshotVersion = stateTableVersion__			snapshotVersions.add(highestRequiredSnapshotVersion)__		}__		StateTableEntry<K, N, S>[] table = primaryTable__		if (isRehashing()) {_			_			final int localRehashIndex = rehashIndex__			final int localCopyLength = table.length - localRehashIndex__			StateTableEntry<K, N, S>[] copy = new StateTableEntry[localRehashIndex + table.length]__			_			System.arraycopy(table, localRehashIndex, copy, 0, localCopyLength)___			_			_			table = incrementalRehashTable__			System.arraycopy(table, 0, copy, localCopyLength, localRehashIndex)__			System.arraycopy(table, table.length >>> 1, copy, localCopyLength + localRehashIndex, localRehashIndex)___			return copy__		} else {_			_			return Arrays.copyOf(table, table.length)__		}_	};creates,combined,copy,of,the,table,arrays,for,a,snapshot,this,method,must,be,called,by,the,same,thread,that,does,modifications,to,the,link,copy,on,write,state,table;visible,for,testing,suppress,warnings,unchecked,state,table,entry,k,n,s,snapshot,table,arrays,synchronized,snapshot,versions,if,state,table,version,0,throw,new,illegal,state,exception,version,count,overflow,in,copy,on,write,state,table,enforcing,restart,highest,required,snapshot,version,state,table,version,snapshot,versions,add,highest,required,snapshot,version,state,table,entry,k,n,s,table,primary,table,if,is,rehashing,final,int,local,rehash,index,rehash,index,final,int,local,copy,length,table,length,local,rehash,index,state,table,entry,k,n,s,copy,new,state,table,entry,local,rehash,index,table,length,system,arraycopy,table,local,rehash,index,copy,0,local,copy,length,table,incremental,rehash,table,system,arraycopy,table,0,copy,local,copy,length,local,rehash,index,system,arraycopy,table,table,length,1,copy,local,copy,length,local,rehash,index,local,rehash,index,return,copy,else,return,arrays,copy,of,table,table,length
CopyOnWriteStateTable -> @VisibleForTesting 	@SuppressWarnings("unchecked") 	StateTableEntry<K, N, S>[] snapshotTableArrays();1506609393;Creates (combined) copy of the table arrays for a snapshot. This method must be called by the same Thread that_does modifications to the {@link CopyOnWriteStateTable}.;@VisibleForTesting_	@SuppressWarnings("unchecked")_	StateTableEntry<K, N, S>[] snapshotTableArrays() {__		_		_		_		synchronized (snapshotVersions) {__			_			if (++stateTableVersion < 0) {_				_				throw new IllegalStateException("Version count overflow in CopyOnWriteStateTable. Enforcing restart.")__			}__			highestRequiredSnapshotVersion = stateTableVersion__			snapshotVersions.add(highestRequiredSnapshotVersion)__		}__		StateTableEntry<K, N, S>[] table = primaryTable__		if (isRehashing()) {_			_			final int localRehashIndex = rehashIndex__			final int localCopyLength = table.length - localRehashIndex__			StateTableEntry<K, N, S>[] copy = new StateTableEntry[localRehashIndex + table.length]__			_			System.arraycopy(table, localRehashIndex, copy, 0, localCopyLength)___			_			_			table = incrementalRehashTable__			System.arraycopy(table, 0, copy, localCopyLength, localRehashIndex)__			System.arraycopy(table, table.length >>> 1, copy, localCopyLength + localRehashIndex, localRehashIndex)___			return copy__		} else {_			_			return Arrays.copyOf(table, table.length)__		}_	};creates,combined,copy,of,the,table,arrays,for,a,snapshot,this,method,must,be,called,by,the,same,thread,that,does,modifications,to,the,link,copy,on,write,state,table;visible,for,testing,suppress,warnings,unchecked,state,table,entry,k,n,s,snapshot,table,arrays,synchronized,snapshot,versions,if,state,table,version,0,throw,new,illegal,state,exception,version,count,overflow,in,copy,on,write,state,table,enforcing,restart,highest,required,snapshot,version,state,table,version,snapshot,versions,add,highest,required,snapshot,version,state,table,entry,k,n,s,table,primary,table,if,is,rehashing,final,int,local,rehash,index,rehash,index,final,int,local,copy,length,table,length,local,rehash,index,state,table,entry,k,n,s,copy,new,state,table,entry,local,rehash,index,table,length,system,arraycopy,table,local,rehash,index,copy,0,local,copy,length,table,incremental,rehash,table,system,arraycopy,table,0,copy,local,copy,length,local,rehash,index,system,arraycopy,table,table,length,1,copy,local,copy,length,local,rehash,index,local,rehash,index,return,copy,else,return,arrays,copy,of,table,table,length
CopyOnWriteStateTable -> @VisibleForTesting 	@SuppressWarnings("unchecked") 	StateTableEntry<K, N, S>[] snapshotTableArrays();1519379856;Creates (combined) copy of the table arrays for a snapshot. This method must be called by the same Thread that_does modifications to the {@link CopyOnWriteStateTable}.;@VisibleForTesting_	@SuppressWarnings("unchecked")_	StateTableEntry<K, N, S>[] snapshotTableArrays() {__		_		_		_		synchronized (snapshotVersions) {__			_			if (++stateTableVersion < 0) {_				_				throw new IllegalStateException("Version count overflow in CopyOnWriteStateTable. Enforcing restart.")__			}__			highestRequiredSnapshotVersion = stateTableVersion__			snapshotVersions.add(highestRequiredSnapshotVersion)__		}__		StateTableEntry<K, N, S>[] table = primaryTable__		if (isRehashing()) {_			_			final int localRehashIndex = rehashIndex__			final int localCopyLength = table.length - localRehashIndex__			StateTableEntry<K, N, S>[] copy = new StateTableEntry[localRehashIndex + table.length]__			_			System.arraycopy(table, localRehashIndex, copy, 0, localCopyLength)___			_			_			table = incrementalRehashTable__			System.arraycopy(table, 0, copy, localCopyLength, localRehashIndex)__			System.arraycopy(table, table.length >>> 1, copy, localCopyLength + localRehashIndex, localRehashIndex)___			return copy__		} else {_			_			return Arrays.copyOf(table, table.length)__		}_	};creates,combined,copy,of,the,table,arrays,for,a,snapshot,this,method,must,be,called,by,the,same,thread,that,does,modifications,to,the,link,copy,on,write,state,table;visible,for,testing,suppress,warnings,unchecked,state,table,entry,k,n,s,snapshot,table,arrays,synchronized,snapshot,versions,if,state,table,version,0,throw,new,illegal,state,exception,version,count,overflow,in,copy,on,write,state,table,enforcing,restart,highest,required,snapshot,version,state,table,version,snapshot,versions,add,highest,required,snapshot,version,state,table,entry,k,n,s,table,primary,table,if,is,rehashing,final,int,local,rehash,index,rehash,index,final,int,local,copy,length,table,length,local,rehash,index,state,table,entry,k,n,s,copy,new,state,table,entry,local,rehash,index,table,length,system,arraycopy,table,local,rehash,index,copy,0,local,copy,length,table,incremental,rehash,table,system,arraycopy,table,0,copy,local,copy,length,local,rehash,index,system,arraycopy,table,table,length,1,copy,local,copy,length,local,rehash,index,local,rehash,index,return,copy,else,return,arrays,copy,of,table,table,length
CopyOnWriteStateTable -> @VisibleForTesting 	@SuppressWarnings("unchecked") 	StateTableEntry<K, N, S>[] snapshotTableArrays();1529089579;Creates (combined) copy of the table arrays for a snapshot. This method must be called by the same Thread that_does modifications to the {@link CopyOnWriteStateTable}.;@VisibleForTesting_	@SuppressWarnings("unchecked")_	StateTableEntry<K, N, S>[] snapshotTableArrays() {__		_		_		_		synchronized (snapshotVersions) {__			_			if (++stateTableVersion < 0) {_				_				throw new IllegalStateException("Version count overflow in CopyOnWriteStateTable. Enforcing restart.")__			}__			highestRequiredSnapshotVersion = stateTableVersion__			snapshotVersions.add(highestRequiredSnapshotVersion)__		}__		StateTableEntry<K, N, S>[] table = primaryTable__		if (isRehashing()) {_			_			final int localRehashIndex = rehashIndex__			final int localCopyLength = table.length - localRehashIndex__			StateTableEntry<K, N, S>[] copy = new StateTableEntry[localRehashIndex + table.length]__			_			System.arraycopy(table, localRehashIndex, copy, 0, localCopyLength)___			_			_			table = incrementalRehashTable__			System.arraycopy(table, 0, copy, localCopyLength, localRehashIndex)__			System.arraycopy(table, table.length >>> 1, copy, localCopyLength + localRehashIndex, localRehashIndex)___			return copy__		} else {_			_			return Arrays.copyOf(table, table.length)__		}_	};creates,combined,copy,of,the,table,arrays,for,a,snapshot,this,method,must,be,called,by,the,same,thread,that,does,modifications,to,the,link,copy,on,write,state,table;visible,for,testing,suppress,warnings,unchecked,state,table,entry,k,n,s,snapshot,table,arrays,synchronized,snapshot,versions,if,state,table,version,0,throw,new,illegal,state,exception,version,count,overflow,in,copy,on,write,state,table,enforcing,restart,highest,required,snapshot,version,state,table,version,snapshot,versions,add,highest,required,snapshot,version,state,table,entry,k,n,s,table,primary,table,if,is,rehashing,final,int,local,rehash,index,rehash,index,final,int,local,copy,length,table,length,local,rehash,index,state,table,entry,k,n,s,copy,new,state,table,entry,local,rehash,index,table,length,system,arraycopy,table,local,rehash,index,copy,0,local,copy,length,table,incremental,rehash,table,system,arraycopy,table,0,copy,local,copy,length,local,rehash,index,system,arraycopy,table,table,length,1,copy,local,copy,length,local,rehash,index,local,rehash,index,return,copy,else,return,arrays,copy,of,table,table,length
CopyOnWriteStateTable -> @VisibleForTesting 	@SuppressWarnings("unchecked") 	StateTableEntry<K, N, S>[] snapshotTableArrays();1529089584;Creates (combined) copy of the table arrays for a snapshot. This method must be called by the same Thread that_does modifications to the {@link CopyOnWriteStateTable}.;@VisibleForTesting_	@SuppressWarnings("unchecked")_	StateTableEntry<K, N, S>[] snapshotTableArrays() {__		_		_		_		synchronized (snapshotVersions) {__			_			if (++stateTableVersion < 0) {_				_				throw new IllegalStateException("Version count overflow in CopyOnWriteStateTable. Enforcing restart.")__			}__			highestRequiredSnapshotVersion = stateTableVersion__			snapshotVersions.add(highestRequiredSnapshotVersion)__		}__		StateTableEntry<K, N, S>[] table = primaryTable__		if (isRehashing()) {_			_			final int localRehashIndex = rehashIndex__			final int localCopyLength = table.length - localRehashIndex__			StateTableEntry<K, N, S>[] copy = new StateTableEntry[localRehashIndex + table.length]__			_			System.arraycopy(table, localRehashIndex, copy, 0, localCopyLength)___			_			_			table = incrementalRehashTable__			System.arraycopy(table, 0, copy, localCopyLength, localRehashIndex)__			System.arraycopy(table, table.length >>> 1, copy, localCopyLength + localRehashIndex, localRehashIndex)___			return copy__		} else {_			_			return Arrays.copyOf(table, table.length)__		}_	};creates,combined,copy,of,the,table,arrays,for,a,snapshot,this,method,must,be,called,by,the,same,thread,that,does,modifications,to,the,link,copy,on,write,state,table;visible,for,testing,suppress,warnings,unchecked,state,table,entry,k,n,s,snapshot,table,arrays,synchronized,snapshot,versions,if,state,table,version,0,throw,new,illegal,state,exception,version,count,overflow,in,copy,on,write,state,table,enforcing,restart,highest,required,snapshot,version,state,table,version,snapshot,versions,add,highest,required,snapshot,version,state,table,entry,k,n,s,table,primary,table,if,is,rehashing,final,int,local,rehash,index,rehash,index,final,int,local,copy,length,table,length,local,rehash,index,state,table,entry,k,n,s,copy,new,state,table,entry,local,rehash,index,table,length,system,arraycopy,table,local,rehash,index,copy,0,local,copy,length,table,incremental,rehash,table,system,arraycopy,table,0,copy,local,copy,length,local,rehash,index,system,arraycopy,table,table,length,1,copy,local,copy,length,local,rehash,index,local,rehash,index,return,copy,else,return,arrays,copy,of,table,table,length
CopyOnWriteStateTable -> @VisibleForTesting 	@SuppressWarnings("unchecked") 	StateTableEntry<K, N, S>[] snapshotTableArrays();1529307900;Creates (combined) copy of the table arrays for a snapshot. This method must be called by the same Thread that_does modifications to the {@link CopyOnWriteStateTable}.;@VisibleForTesting_	@SuppressWarnings("unchecked")_	StateTableEntry<K, N, S>[] snapshotTableArrays() {__		_		_		_		synchronized (snapshotVersions) {__			_			if (++stateTableVersion < 0) {_				_				throw new IllegalStateException("Version count overflow in CopyOnWriteStateTable. Enforcing restart.")__			}__			highestRequiredSnapshotVersion = stateTableVersion__			snapshotVersions.add(highestRequiredSnapshotVersion)__		}__		StateTableEntry<K, N, S>[] table = primaryTable___		_		_		_		_		_		final int totalTableIndexSize = rehashIndex + table.length__		final int copiedArraySize = Math.max(totalTableIndexSize, size())__		final StateTableEntry<K, N, S>[] copy = new StateTableEntry[copiedArraySize]___		if (isRehashing()) {_			_			final int localRehashIndex = rehashIndex__			final int localCopyLength = table.length - localRehashIndex__			_			System.arraycopy(table, localRehashIndex, copy, 0, localCopyLength)___			_			_			table = incrementalRehashTable__			System.arraycopy(table, 0, copy, localCopyLength, localRehashIndex)__			System.arraycopy(table, table.length >>> 1, copy, localCopyLength + localRehashIndex, localRehashIndex)__		} else {_			_			System.arraycopy(table, 0, copy, 0, table.length)__		}__		return copy__	};creates,combined,copy,of,the,table,arrays,for,a,snapshot,this,method,must,be,called,by,the,same,thread,that,does,modifications,to,the,link,copy,on,write,state,table;visible,for,testing,suppress,warnings,unchecked,state,table,entry,k,n,s,snapshot,table,arrays,synchronized,snapshot,versions,if,state,table,version,0,throw,new,illegal,state,exception,version,count,overflow,in,copy,on,write,state,table,enforcing,restart,highest,required,snapshot,version,state,table,version,snapshot,versions,add,highest,required,snapshot,version,state,table,entry,k,n,s,table,primary,table,final,int,total,table,index,size,rehash,index,table,length,final,int,copied,array,size,math,max,total,table,index,size,size,final,state,table,entry,k,n,s,copy,new,state,table,entry,copied,array,size,if,is,rehashing,final,int,local,rehash,index,rehash,index,final,int,local,copy,length,table,length,local,rehash,index,system,arraycopy,table,local,rehash,index,copy,0,local,copy,length,table,incremental,rehash,table,system,arraycopy,table,0,copy,local,copy,length,local,rehash,index,system,arraycopy,table,table,length,1,copy,local,copy,length,local,rehash,index,local,rehash,index,else,system,arraycopy,table,0,copy,0,table,length,return,copy
CopyOnWriteStateTable -> @VisibleForTesting 	@SuppressWarnings("unchecked") 	StateTableEntry<K, N, S>[] snapshotTableArrays();1530639128;Creates (combined) copy of the table arrays for a snapshot. This method must be called by the same Thread that_does modifications to the {@link CopyOnWriteStateTable}.;@VisibleForTesting_	@SuppressWarnings("unchecked")_	StateTableEntry<K, N, S>[] snapshotTableArrays() {__		_		_		_		synchronized (snapshotVersions) {__			_			if (++stateTableVersion < 0) {_				_				throw new IllegalStateException("Version count overflow in CopyOnWriteStateTable. Enforcing restart.")__			}__			highestRequiredSnapshotVersion = stateTableVersion__			snapshotVersions.add(highestRequiredSnapshotVersion)__		}__		StateTableEntry<K, N, S>[] table = primaryTable___		_		_		_		_		_		final int totalTableIndexSize = rehashIndex + table.length__		final int copiedArraySize = Math.max(totalTableIndexSize, size())__		final StateTableEntry<K, N, S>[] copy = new StateTableEntry[copiedArraySize]___		if (isRehashing()) {_			_			final int localRehashIndex = rehashIndex__			final int localCopyLength = table.length - localRehashIndex__			_			System.arraycopy(table, localRehashIndex, copy, 0, localCopyLength)___			_			_			table = incrementalRehashTable__			System.arraycopy(table, 0, copy, localCopyLength, localRehashIndex)__			System.arraycopy(table, table.length >>> 1, copy, localCopyLength + localRehashIndex, localRehashIndex)__		} else {_			_			System.arraycopy(table, 0, copy, 0, table.length)__		}__		return copy__	};creates,combined,copy,of,the,table,arrays,for,a,snapshot,this,method,must,be,called,by,the,same,thread,that,does,modifications,to,the,link,copy,on,write,state,table;visible,for,testing,suppress,warnings,unchecked,state,table,entry,k,n,s,snapshot,table,arrays,synchronized,snapshot,versions,if,state,table,version,0,throw,new,illegal,state,exception,version,count,overflow,in,copy,on,write,state,table,enforcing,restart,highest,required,snapshot,version,state,table,version,snapshot,versions,add,highest,required,snapshot,version,state,table,entry,k,n,s,table,primary,table,final,int,total,table,index,size,rehash,index,table,length,final,int,copied,array,size,math,max,total,table,index,size,size,final,state,table,entry,k,n,s,copy,new,state,table,entry,copied,array,size,if,is,rehashing,final,int,local,rehash,index,rehash,index,final,int,local,copy,length,table,length,local,rehash,index,system,arraycopy,table,local,rehash,index,copy,0,local,copy,length,table,incremental,rehash,table,system,arraycopy,table,0,copy,local,copy,length,local,rehash,index,system,arraycopy,table,table,length,1,copy,local,copy,length,local,rehash,index,local,rehash,index,else,system,arraycopy,table,0,copy,0,table,length,return,copy
CopyOnWriteStateTable -> @VisibleForTesting 	@SuppressWarnings("unchecked") 	StateTableEntry<K, N, S>[] snapshotTableArrays();1531771917;Creates (combined) copy of the table arrays for a snapshot. This method must be called by the same Thread that_does modifications to the {@link CopyOnWriteStateTable}.;@VisibleForTesting_	@SuppressWarnings("unchecked")_	StateTableEntry<K, N, S>[] snapshotTableArrays() {__		_		_		_		synchronized (snapshotVersions) {__			_			if (++stateTableVersion < 0) {_				_				throw new IllegalStateException("Version count overflow in CopyOnWriteStateTable. Enforcing restart.")__			}__			highestRequiredSnapshotVersion = stateTableVersion__			snapshotVersions.add(highestRequiredSnapshotVersion)__		}__		StateTableEntry<K, N, S>[] table = primaryTable___		_		_		_		_		_		final int totalTableIndexSize = rehashIndex + table.length__		final int copiedArraySize = Math.max(totalTableIndexSize, size())__		final StateTableEntry<K, N, S>[] copy = new StateTableEntry[copiedArraySize]___		if (isRehashing()) {_			_			final int localRehashIndex = rehashIndex__			final int localCopyLength = table.length - localRehashIndex__			_			System.arraycopy(table, localRehashIndex, copy, 0, localCopyLength)___			_			_			table = incrementalRehashTable__			System.arraycopy(table, 0, copy, localCopyLength, localRehashIndex)__			System.arraycopy(table, table.length >>> 1, copy, localCopyLength + localRehashIndex, localRehashIndex)__		} else {_			_			System.arraycopy(table, 0, copy, 0, table.length)__		}__		return copy__	};creates,combined,copy,of,the,table,arrays,for,a,snapshot,this,method,must,be,called,by,the,same,thread,that,does,modifications,to,the,link,copy,on,write,state,table;visible,for,testing,suppress,warnings,unchecked,state,table,entry,k,n,s,snapshot,table,arrays,synchronized,snapshot,versions,if,state,table,version,0,throw,new,illegal,state,exception,version,count,overflow,in,copy,on,write,state,table,enforcing,restart,highest,required,snapshot,version,state,table,version,snapshot,versions,add,highest,required,snapshot,version,state,table,entry,k,n,s,table,primary,table,final,int,total,table,index,size,rehash,index,table,length,final,int,copied,array,size,math,max,total,table,index,size,size,final,state,table,entry,k,n,s,copy,new,state,table,entry,copied,array,size,if,is,rehashing,final,int,local,rehash,index,rehash,index,final,int,local,copy,length,table,length,local,rehash,index,system,arraycopy,table,local,rehash,index,copy,0,local,copy,length,table,incremental,rehash,table,system,arraycopy,table,0,copy,local,copy,length,local,rehash,index,system,arraycopy,table,table,length,1,copy,local,copy,length,local,rehash,index,local,rehash,index,else,system,arraycopy,table,0,copy,0,table,length,return,copy
CopyOnWriteStateTable -> @VisibleForTesting 	@SuppressWarnings("unchecked") 	StateTableEntry<K, N, S>[] snapshotTableArrays();1548755874;Creates (combined) copy of the table arrays for a snapshot. This method must be called by the same Thread that_does modifications to the {@link CopyOnWriteStateTable}.;@VisibleForTesting_	@SuppressWarnings("unchecked")_	StateTableEntry<K, N, S>[] snapshotTableArrays() {__		_		_		_		synchronized (snapshotVersions) {__			_			if (++stateTableVersion < 0) {_				_				throw new IllegalStateException("Version count overflow in CopyOnWriteStateTable. Enforcing restart.")__			}__			highestRequiredSnapshotVersion = stateTableVersion__			snapshotVersions.add(highestRequiredSnapshotVersion)__		}__		StateTableEntry<K, N, S>[] table = primaryTable___		_		_		_		_		_		final int totalTableIndexSize = rehashIndex + table.length__		final int copiedArraySize = Math.max(totalTableIndexSize, size())__		final StateTableEntry<K, N, S>[] copy = new StateTableEntry[copiedArraySize]___		if (isRehashing()) {_			_			final int localRehashIndex = rehashIndex__			final int localCopyLength = table.length - localRehashIndex__			_			System.arraycopy(table, localRehashIndex, copy, 0, localCopyLength)___			_			_			table = incrementalRehashTable__			System.arraycopy(table, 0, copy, localCopyLength, localRehashIndex)__			System.arraycopy(table, table.length >>> 1, copy, localCopyLength + localRehashIndex, localRehashIndex)__		} else {_			_			System.arraycopy(table, 0, copy, 0, table.length)__		}__		return copy__	};creates,combined,copy,of,the,table,arrays,for,a,snapshot,this,method,must,be,called,by,the,same,thread,that,does,modifications,to,the,link,copy,on,write,state,table;visible,for,testing,suppress,warnings,unchecked,state,table,entry,k,n,s,snapshot,table,arrays,synchronized,snapshot,versions,if,state,table,version,0,throw,new,illegal,state,exception,version,count,overflow,in,copy,on,write,state,table,enforcing,restart,highest,required,snapshot,version,state,table,version,snapshot,versions,add,highest,required,snapshot,version,state,table,entry,k,n,s,table,primary,table,final,int,total,table,index,size,rehash,index,table,length,final,int,copied,array,size,math,max,total,table,index,size,size,final,state,table,entry,k,n,s,copy,new,state,table,entry,copied,array,size,if,is,rehashing,final,int,local,rehash,index,rehash,index,final,int,local,copy,length,table,length,local,rehash,index,system,arraycopy,table,local,rehash,index,copy,0,local,copy,length,table,incremental,rehash,table,system,arraycopy,table,0,copy,local,copy,length,local,rehash,index,system,arraycopy,table,table,length,1,copy,local,copy,length,local,rehash,index,local,rehash,index,else,system,arraycopy,table,0,copy,0,table,length,return,copy
CopyOnWriteStateTable -> @SuppressWarnings("unchecked") 	private CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyValueStateBackendMetaInfo<N, S> metaInfo, int capacity);1531771917;Constructs a new {@code StateTable} instance with the specified capacity.__@param keyContext the key context._@param metaInfo   the meta information, including the type serializer for state copy-on-write._@param capacity   the initial capacity of this hash map._@throws IllegalArgumentException when the capacity is less than zero.;@SuppressWarnings("unchecked")_	private CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyValueStateBackendMetaInfo<N, S> metaInfo, int capacity) {_		super(keyContext, metaInfo)___		_		this.primaryTable = (StateTableEntry<K, N, S>[]) EMPTY_TABLE__		this.incrementalRehashTable = (StateTableEntry<K, N, S>[]) EMPTY_TABLE___		_		this.primaryTableSize = 0__		this.incrementalRehashTableSize = 0___		this.rehashIndex = 0__		this.stateTableVersion = 0__		this.highestRequiredSnapshotVersion = 0__		this.snapshotVersions = new TreeSet<>()___		if (capacity < 0) {_			throw new IllegalArgumentException("Capacity: " + capacity)__		}__		if (capacity == 0) {_			threshold = -1__			return__		}__		if (capacity < MINIMUM_CAPACITY) {_			capacity = MINIMUM_CAPACITY__		} else if (capacity > MAXIMUM_CAPACITY) {_			capacity = MAXIMUM_CAPACITY__		} else {_			capacity = MathUtils.roundUpToPowerOfTwo(capacity)__		}_		primaryTable = makeTable(capacity)__	};constructs,a,new,code,state,table,instance,with,the,specified,capacity,param,key,context,the,key,context,param,meta,info,the,meta,information,including,the,type,serializer,for,state,copy,on,write,param,capacity,the,initial,capacity,of,this,hash,map,throws,illegal,argument,exception,when,the,capacity,is,less,than,zero;suppress,warnings,unchecked,private,copy,on,write,state,table,internal,key,context,k,key,context,registered,key,value,state,backend,meta,info,n,s,meta,info,int,capacity,super,key,context,meta,info,this,primary,table,state,table,entry,k,n,s,this,incremental,rehash,table,state,table,entry,k,n,s,this,primary,table,size,0,this,incremental,rehash,table,size,0,this,rehash,index,0,this,state,table,version,0,this,highest,required,snapshot,version,0,this,snapshot,versions,new,tree,set,if,capacity,0,throw,new,illegal,argument,exception,capacity,capacity,if,capacity,0,threshold,1,return,if,capacity,capacity,else,if,capacity,capacity,else,capacity,math,utils,round,up,to,power,of,two,capacity,primary,table,make,table,capacity
CopyOnWriteStateTable -> @SuppressWarnings("unchecked") 	private CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyValueStateBackendMetaInfo<N, S> metaInfo, int capacity);1548755874;Constructs a new {@code StateTable} instance with the specified capacity.__@param keyContext the key context._@param metaInfo   the meta information, including the type serializer for state copy-on-write._@param capacity   the initial capacity of this hash map._@throws IllegalArgumentException when the capacity is less than zero.;@SuppressWarnings("unchecked")_	private CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyValueStateBackendMetaInfo<N, S> metaInfo, int capacity) {_		super(keyContext, metaInfo)___		_		this.primaryTable = (StateTableEntry<K, N, S>[]) EMPTY_TABLE__		this.incrementalRehashTable = (StateTableEntry<K, N, S>[]) EMPTY_TABLE___		_		this.primaryTableSize = 0__		this.incrementalRehashTableSize = 0___		this.rehashIndex = 0__		this.stateTableVersion = 0__		this.highestRequiredSnapshotVersion = 0__		this.snapshotVersions = new TreeSet<>()___		if (capacity < 0) {_			throw new IllegalArgumentException("Capacity: " + capacity)__		}__		if (capacity == 0) {_			threshold = -1__			return__		}__		if (capacity < MINIMUM_CAPACITY) {_			capacity = MINIMUM_CAPACITY__		} else if (capacity > MAXIMUM_CAPACITY) {_			capacity = MAXIMUM_CAPACITY__		} else {_			capacity = MathUtils.roundUpToPowerOfTwo(capacity)__		}_		primaryTable = makeTable(capacity)__	};constructs,a,new,code,state,table,instance,with,the,specified,capacity,param,key,context,the,key,context,param,meta,info,the,meta,information,including,the,type,serializer,for,state,copy,on,write,param,capacity,the,initial,capacity,of,this,hash,map,throws,illegal,argument,exception,when,the,capacity,is,less,than,zero;suppress,warnings,unchecked,private,copy,on,write,state,table,internal,key,context,k,key,context,registered,key,value,state,backend,meta,info,n,s,meta,info,int,capacity,super,key,context,meta,info,this,primary,table,state,table,entry,k,n,s,this,incremental,rehash,table,state,table,entry,k,n,s,this,primary,table,size,0,this,incremental,rehash,table,size,0,this,rehash,index,0,this,state,table,version,0,this,highest,required,snapshot,version,0,this,snapshot,versions,new,tree,set,if,capacity,0,throw,new,illegal,argument,exception,capacity,capacity,if,capacity,0,threshold,1,return,if,capacity,capacity,else,if,capacity,capacity,else,capacity,math,utils,round,up,to,power,of,two,capacity,primary,table,make,table,capacity
CopyOnWriteStateTable -> void releaseSnapshot(CopyOnWriteStateTableSnapshot<K, N, S> snapshotToRelease);1489685642;Releases a snapshot for this {@link CopyOnWriteStateTable}. This method should be called once a snapshot is no more needed,_so that the {@link CopyOnWriteStateTable} can stop considering this snapshot for copy-on-write, thus avoiding unnecessary_object creation.__@param snapshotToRelease the snapshot to release, which was previously created by this state table.;void releaseSnapshot(CopyOnWriteStateTableSnapshot<K, N, S> snapshotToRelease) {__		Preconditions.checkArgument(snapshotToRelease.isOwner(this),_				"Cannot release snapshot which is owned by a different state table.")___		releaseSnapshot(snapshotToRelease.getSnapshotVersion())__	};releases,a,snapshot,for,this,link,copy,on,write,state,table,this,method,should,be,called,once,a,snapshot,is,no,more,needed,so,that,the,link,copy,on,write,state,table,can,stop,considering,this,snapshot,for,copy,on,write,thus,avoiding,unnecessary,object,creation,param,snapshot,to,release,the,snapshot,to,release,which,was,previously,created,by,this,state,table;void,release,snapshot,copy,on,write,state,table,snapshot,k,n,s,snapshot,to,release,preconditions,check,argument,snapshot,to,release,is,owner,this,cannot,release,snapshot,which,is,owned,by,a,different,state,table,release,snapshot,snapshot,to,release,get,snapshot,version
CopyOnWriteStateTable -> void releaseSnapshot(CopyOnWriteStateTableSnapshot<K, N, S> snapshotToRelease);1494180263;Releases a snapshot for this {@link CopyOnWriteStateTable}. This method should be called once a snapshot is no more needed,_so that the {@link CopyOnWriteStateTable} can stop considering this snapshot for copy-on-write, thus avoiding unnecessary_object creation.__@param snapshotToRelease the snapshot to release, which was previously created by this state table.;void releaseSnapshot(CopyOnWriteStateTableSnapshot<K, N, S> snapshotToRelease) {__		Preconditions.checkArgument(snapshotToRelease.isOwner(this),_				"Cannot release snapshot which is owned by a different state table.")___		releaseSnapshot(snapshotToRelease.getSnapshotVersion())__	};releases,a,snapshot,for,this,link,copy,on,write,state,table,this,method,should,be,called,once,a,snapshot,is,no,more,needed,so,that,the,link,copy,on,write,state,table,can,stop,considering,this,snapshot,for,copy,on,write,thus,avoiding,unnecessary,object,creation,param,snapshot,to,release,the,snapshot,to,release,which,was,previously,created,by,this,state,table;void,release,snapshot,copy,on,write,state,table,snapshot,k,n,s,snapshot,to,release,preconditions,check,argument,snapshot,to,release,is,owner,this,cannot,release,snapshot,which,is,owned,by,a,different,state,table,release,snapshot,snapshot,to,release,get,snapshot,version
CopyOnWriteStateTable -> void releaseSnapshot(CopyOnWriteStateTableSnapshot<K, N, S> snapshotToRelease);1506609393;Releases a snapshot for this {@link CopyOnWriteStateTable}. This method should be called once a snapshot is no more needed,_so that the {@link CopyOnWriteStateTable} can stop considering this snapshot for copy-on-write, thus avoiding unnecessary_object creation.__@param snapshotToRelease the snapshot to release, which was previously created by this state table.;void releaseSnapshot(CopyOnWriteStateTableSnapshot<K, N, S> snapshotToRelease) {__		Preconditions.checkArgument(snapshotToRelease.isOwner(this),_				"Cannot release snapshot which is owned by a different state table.")___		releaseSnapshot(snapshotToRelease.getSnapshotVersion())__	};releases,a,snapshot,for,this,link,copy,on,write,state,table,this,method,should,be,called,once,a,snapshot,is,no,more,needed,so,that,the,link,copy,on,write,state,table,can,stop,considering,this,snapshot,for,copy,on,write,thus,avoiding,unnecessary,object,creation,param,snapshot,to,release,the,snapshot,to,release,which,was,previously,created,by,this,state,table;void,release,snapshot,copy,on,write,state,table,snapshot,k,n,s,snapshot,to,release,preconditions,check,argument,snapshot,to,release,is,owner,this,cannot,release,snapshot,which,is,owned,by,a,different,state,table,release,snapshot,snapshot,to,release,get,snapshot,version
CopyOnWriteStateTable -> void releaseSnapshot(CopyOnWriteStateTableSnapshot<K, N, S> snapshotToRelease);1519379856;Releases a snapshot for this {@link CopyOnWriteStateTable}. This method should be called once a snapshot is no more needed,_so that the {@link CopyOnWriteStateTable} can stop considering this snapshot for copy-on-write, thus avoiding unnecessary_object creation.__@param snapshotToRelease the snapshot to release, which was previously created by this state table.;void releaseSnapshot(CopyOnWriteStateTableSnapshot<K, N, S> snapshotToRelease) {__		Preconditions.checkArgument(snapshotToRelease.isOwner(this),_				"Cannot release snapshot which is owned by a different state table.")___		releaseSnapshot(snapshotToRelease.getSnapshotVersion())__	};releases,a,snapshot,for,this,link,copy,on,write,state,table,this,method,should,be,called,once,a,snapshot,is,no,more,needed,so,that,the,link,copy,on,write,state,table,can,stop,considering,this,snapshot,for,copy,on,write,thus,avoiding,unnecessary,object,creation,param,snapshot,to,release,the,snapshot,to,release,which,was,previously,created,by,this,state,table;void,release,snapshot,copy,on,write,state,table,snapshot,k,n,s,snapshot,to,release,preconditions,check,argument,snapshot,to,release,is,owner,this,cannot,release,snapshot,which,is,owned,by,a,different,state,table,release,snapshot,snapshot,to,release,get,snapshot,version
CopyOnWriteStateTable -> void releaseSnapshot(CopyOnWriteStateTableSnapshot<K, N, S> snapshotToRelease);1529089579;Releases a snapshot for this {@link CopyOnWriteStateTable}. This method should be called once a snapshot is no more needed,_so that the {@link CopyOnWriteStateTable} can stop considering this snapshot for copy-on-write, thus avoiding unnecessary_object creation.__@param snapshotToRelease the snapshot to release, which was previously created by this state table.;void releaseSnapshot(CopyOnWriteStateTableSnapshot<K, N, S> snapshotToRelease) {__		Preconditions.checkArgument(snapshotToRelease.isOwner(this),_				"Cannot release snapshot which is owned by a different state table.")___		releaseSnapshot(snapshotToRelease.getSnapshotVersion())__	};releases,a,snapshot,for,this,link,copy,on,write,state,table,this,method,should,be,called,once,a,snapshot,is,no,more,needed,so,that,the,link,copy,on,write,state,table,can,stop,considering,this,snapshot,for,copy,on,write,thus,avoiding,unnecessary,object,creation,param,snapshot,to,release,the,snapshot,to,release,which,was,previously,created,by,this,state,table;void,release,snapshot,copy,on,write,state,table,snapshot,k,n,s,snapshot,to,release,preconditions,check,argument,snapshot,to,release,is,owner,this,cannot,release,snapshot,which,is,owned,by,a,different,state,table,release,snapshot,snapshot,to,release,get,snapshot,version
CopyOnWriteStateTable -> void releaseSnapshot(CopyOnWriteStateTableSnapshot<K, N, S> snapshotToRelease);1529089584;Releases a snapshot for this {@link CopyOnWriteStateTable}. This method should be called once a snapshot is no more needed,_so that the {@link CopyOnWriteStateTable} can stop considering this snapshot for copy-on-write, thus avoiding unnecessary_object creation.__@param snapshotToRelease the snapshot to release, which was previously created by this state table.;void releaseSnapshot(CopyOnWriteStateTableSnapshot<K, N, S> snapshotToRelease) {__		Preconditions.checkArgument(snapshotToRelease.isOwner(this),_				"Cannot release snapshot which is owned by a different state table.")___		releaseSnapshot(snapshotToRelease.getSnapshotVersion())__	};releases,a,snapshot,for,this,link,copy,on,write,state,table,this,method,should,be,called,once,a,snapshot,is,no,more,needed,so,that,the,link,copy,on,write,state,table,can,stop,considering,this,snapshot,for,copy,on,write,thus,avoiding,unnecessary,object,creation,param,snapshot,to,release,the,snapshot,to,release,which,was,previously,created,by,this,state,table;void,release,snapshot,copy,on,write,state,table,snapshot,k,n,s,snapshot,to,release,preconditions,check,argument,snapshot,to,release,is,owner,this,cannot,release,snapshot,which,is,owned,by,a,different,state,table,release,snapshot,snapshot,to,release,get,snapshot,version
CopyOnWriteStateTable -> void releaseSnapshot(CopyOnWriteStateTableSnapshot<K, N, S> snapshotToRelease);1529307900;Releases a snapshot for this {@link CopyOnWriteStateTable}. This method should be called once a snapshot is no more needed,_so that the {@link CopyOnWriteStateTable} can stop considering this snapshot for copy-on-write, thus avoiding unnecessary_object creation.__@param snapshotToRelease the snapshot to release, which was previously created by this state table.;void releaseSnapshot(CopyOnWriteStateTableSnapshot<K, N, S> snapshotToRelease) {__		Preconditions.checkArgument(snapshotToRelease.isOwner(this),_				"Cannot release snapshot which is owned by a different state table.")___		releaseSnapshot(snapshotToRelease.getSnapshotVersion())__	};releases,a,snapshot,for,this,link,copy,on,write,state,table,this,method,should,be,called,once,a,snapshot,is,no,more,needed,so,that,the,link,copy,on,write,state,table,can,stop,considering,this,snapshot,for,copy,on,write,thus,avoiding,unnecessary,object,creation,param,snapshot,to,release,the,snapshot,to,release,which,was,previously,created,by,this,state,table;void,release,snapshot,copy,on,write,state,table,snapshot,k,n,s,snapshot,to,release,preconditions,check,argument,snapshot,to,release,is,owner,this,cannot,release,snapshot,which,is,owned,by,a,different,state,table,release,snapshot,snapshot,to,release,get,snapshot,version
CopyOnWriteStateTable -> void releaseSnapshot(CopyOnWriteStateTableSnapshot<K, N, S> snapshotToRelease);1530639128;Releases a snapshot for this {@link CopyOnWriteStateTable}. This method should be called once a snapshot is no more needed,_so that the {@link CopyOnWriteStateTable} can stop considering this snapshot for copy-on-write, thus avoiding unnecessary_object creation.__@param snapshotToRelease the snapshot to release, which was previously created by this state table.;void releaseSnapshot(CopyOnWriteStateTableSnapshot<K, N, S> snapshotToRelease) {__		Preconditions.checkArgument(snapshotToRelease.isOwner(this),_				"Cannot release snapshot which is owned by a different state table.")___		releaseSnapshot(snapshotToRelease.getSnapshotVersion())__	};releases,a,snapshot,for,this,link,copy,on,write,state,table,this,method,should,be,called,once,a,snapshot,is,no,more,needed,so,that,the,link,copy,on,write,state,table,can,stop,considering,this,snapshot,for,copy,on,write,thus,avoiding,unnecessary,object,creation,param,snapshot,to,release,the,snapshot,to,release,which,was,previously,created,by,this,state,table;void,release,snapshot,copy,on,write,state,table,snapshot,k,n,s,snapshot,to,release,preconditions,check,argument,snapshot,to,release,is,owner,this,cannot,release,snapshot,which,is,owned,by,a,different,state,table,release,snapshot,snapshot,to,release,get,snapshot,version
CopyOnWriteStateTable -> void releaseSnapshot(CopyOnWriteStateTableSnapshot<K, N, S> snapshotToRelease);1531771917;Releases a snapshot for this {@link CopyOnWriteStateTable}. This method should be called once a snapshot is no more needed,_so that the {@link CopyOnWriteStateTable} can stop considering this snapshot for copy-on-write, thus avoiding unnecessary_object creation.__@param snapshotToRelease the snapshot to release, which was previously created by this state table.;void releaseSnapshot(CopyOnWriteStateTableSnapshot<K, N, S> snapshotToRelease) {__		Preconditions.checkArgument(snapshotToRelease.isOwner(this),_				"Cannot release snapshot which is owned by a different state table.")___		releaseSnapshot(snapshotToRelease.getSnapshotVersion())__	};releases,a,snapshot,for,this,link,copy,on,write,state,table,this,method,should,be,called,once,a,snapshot,is,no,more,needed,so,that,the,link,copy,on,write,state,table,can,stop,considering,this,snapshot,for,copy,on,write,thus,avoiding,unnecessary,object,creation,param,snapshot,to,release,the,snapshot,to,release,which,was,previously,created,by,this,state,table;void,release,snapshot,copy,on,write,state,table,snapshot,k,n,s,snapshot,to,release,preconditions,check,argument,snapshot,to,release,is,owner,this,cannot,release,snapshot,which,is,owned,by,a,different,state,table,release,snapshot,snapshot,to,release,get,snapshot,version
CopyOnWriteStateTable -> void releaseSnapshot(CopyOnWriteStateTableSnapshot<K, N, S> snapshotToRelease);1548755874;Releases a snapshot for this {@link CopyOnWriteStateTable}. This method should be called once a snapshot is no more needed,_so that the {@link CopyOnWriteStateTable} can stop considering this snapshot for copy-on-write, thus avoiding unnecessary_object creation.__@param snapshotToRelease the snapshot to release, which was previously created by this state table.;void releaseSnapshot(CopyOnWriteStateTableSnapshot<K, N, S> snapshotToRelease) {__		Preconditions.checkArgument(snapshotToRelease.isOwner(this),_				"Cannot release snapshot which is owned by a different state table.")___		releaseSnapshot(snapshotToRelease.getSnapshotVersion())__	};releases,a,snapshot,for,this,link,copy,on,write,state,table,this,method,should,be,called,once,a,snapshot,is,no,more,needed,so,that,the,link,copy,on,write,state,table,can,stop,considering,this,snapshot,for,copy,on,write,thus,avoiding,unnecessary,object,creation,param,snapshot,to,release,the,snapshot,to,release,which,was,previously,created,by,this,state,table;void,release,snapshot,copy,on,write,state,table,snapshot,k,n,s,snapshot,to,release,preconditions,check,argument,snapshot,to,release,is,owner,this,cannot,release,snapshot,which,is,owned,by,a,different,state,table,release,snapshot,snapshot,to,release,get,snapshot,version
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> removeEntry(K key, N namespace);1489685642;Helper method that is the basis for operations that remove mappings.;private StateTableEntry<K, N, S> removeEntry(K key, N namespace) {__		final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace)__		final StateTableEntry<K, N, S>[] tab = selectActiveTable(hash)__		int index = hash & (tab.length - 1)___		for (StateTableEntry<K, N, S> e = tab[index], prev = null_ e != null_ prev = e, e = e.next) {_			if (e.hash == hash && key.equals(e.key) && namespace.equals(e.namespace)) {_				if (prev == null) {_					tab[index] = e.next__				} else {_					_					if (prev.entryVersion < highestRequiredSnapshotVersion) {_						prev = handleChainedEntryCopyOnWrite(tab, index, prev)__					}_					prev.next = e.next__				}_				++modCount__				if (tab == primaryTable) {_					--primaryTableSize__				} else {_					--incrementalRehashTableSize__				}_				return e__			}_		}_		return null__	};helper,method,that,is,the,basis,for,operations,that,remove,mappings;private,state,table,entry,k,n,s,remove,entry,k,key,n,namespace,final,int,hash,compute,hash,for,operation,and,do,incremental,rehash,key,namespace,final,state,table,entry,k,n,s,tab,select,active,table,hash,int,index,hash,tab,length,1,for,state,table,entry,k,n,s,e,tab,index,prev,null,e,null,prev,e,e,e,next,if,e,hash,hash,key,equals,e,key,namespace,equals,e,namespace,if,prev,null,tab,index,e,next,else,if,prev,entry,version,highest,required,snapshot,version,prev,handle,chained,entry,copy,on,write,tab,index,prev,prev,next,e,next,mod,count,if,tab,primary,table,primary,table,size,else,incremental,rehash,table,size,return,e,return,null
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> removeEntry(K key, N namespace);1494180263;Helper method that is the basis for operations that remove mappings.;private StateTableEntry<K, N, S> removeEntry(K key, N namespace) {__		final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace)__		final StateTableEntry<K, N, S>[] tab = selectActiveTable(hash)__		int index = hash & (tab.length - 1)___		for (StateTableEntry<K, N, S> e = tab[index], prev = null_ e != null_ prev = e, e = e.next) {_			if (e.hash == hash && key.equals(e.key) && namespace.equals(e.namespace)) {_				if (prev == null) {_					tab[index] = e.next__				} else {_					_					if (prev.entryVersion < highestRequiredSnapshotVersion) {_						prev = handleChainedEntryCopyOnWrite(tab, index, prev)__					}_					prev.next = e.next__				}_				++modCount__				if (tab == primaryTable) {_					--primaryTableSize__				} else {_					--incrementalRehashTableSize__				}_				return e__			}_		}_		return null__	};helper,method,that,is,the,basis,for,operations,that,remove,mappings;private,state,table,entry,k,n,s,remove,entry,k,key,n,namespace,final,int,hash,compute,hash,for,operation,and,do,incremental,rehash,key,namespace,final,state,table,entry,k,n,s,tab,select,active,table,hash,int,index,hash,tab,length,1,for,state,table,entry,k,n,s,e,tab,index,prev,null,e,null,prev,e,e,e,next,if,e,hash,hash,key,equals,e,key,namespace,equals,e,namespace,if,prev,null,tab,index,e,next,else,if,prev,entry,version,highest,required,snapshot,version,prev,handle,chained,entry,copy,on,write,tab,index,prev,prev,next,e,next,mod,count,if,tab,primary,table,primary,table,size,else,incremental,rehash,table,size,return,e,return,null
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> removeEntry(K key, N namespace);1506609393;Helper method that is the basis for operations that remove mappings.;private StateTableEntry<K, N, S> removeEntry(K key, N namespace) {__		final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace)__		final StateTableEntry<K, N, S>[] tab = selectActiveTable(hash)__		int index = hash & (tab.length - 1)___		for (StateTableEntry<K, N, S> e = tab[index], prev = null_ e != null_ prev = e, e = e.next) {_			if (e.hash == hash && key.equals(e.key) && namespace.equals(e.namespace)) {_				if (prev == null) {_					tab[index] = e.next__				} else {_					_					if (prev.entryVersion < highestRequiredSnapshotVersion) {_						prev = handleChainedEntryCopyOnWrite(tab, index, prev)__					}_					prev.next = e.next__				}_				++modCount__				if (tab == primaryTable) {_					--primaryTableSize__				} else {_					--incrementalRehashTableSize__				}_				return e__			}_		}_		return null__	};helper,method,that,is,the,basis,for,operations,that,remove,mappings;private,state,table,entry,k,n,s,remove,entry,k,key,n,namespace,final,int,hash,compute,hash,for,operation,and,do,incremental,rehash,key,namespace,final,state,table,entry,k,n,s,tab,select,active,table,hash,int,index,hash,tab,length,1,for,state,table,entry,k,n,s,e,tab,index,prev,null,e,null,prev,e,e,e,next,if,e,hash,hash,key,equals,e,key,namespace,equals,e,namespace,if,prev,null,tab,index,e,next,else,if,prev,entry,version,highest,required,snapshot,version,prev,handle,chained,entry,copy,on,write,tab,index,prev,prev,next,e,next,mod,count,if,tab,primary,table,primary,table,size,else,incremental,rehash,table,size,return,e,return,null
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> removeEntry(K key, N namespace);1519379856;Helper method that is the basis for operations that remove mappings.;private StateTableEntry<K, N, S> removeEntry(K key, N namespace) {__		final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace)__		final StateTableEntry<K, N, S>[] tab = selectActiveTable(hash)__		int index = hash & (tab.length - 1)___		for (StateTableEntry<K, N, S> e = tab[index], prev = null_ e != null_ prev = e, e = e.next) {_			if (e.hash == hash && key.equals(e.key) && namespace.equals(e.namespace)) {_				if (prev == null) {_					tab[index] = e.next__				} else {_					_					if (prev.entryVersion < highestRequiredSnapshotVersion) {_						prev = handleChainedEntryCopyOnWrite(tab, index, prev)__					}_					prev.next = e.next__				}_				++modCount__				if (tab == primaryTable) {_					--primaryTableSize__				} else {_					--incrementalRehashTableSize__				}_				return e__			}_		}_		return null__	};helper,method,that,is,the,basis,for,operations,that,remove,mappings;private,state,table,entry,k,n,s,remove,entry,k,key,n,namespace,final,int,hash,compute,hash,for,operation,and,do,incremental,rehash,key,namespace,final,state,table,entry,k,n,s,tab,select,active,table,hash,int,index,hash,tab,length,1,for,state,table,entry,k,n,s,e,tab,index,prev,null,e,null,prev,e,e,e,next,if,e,hash,hash,key,equals,e,key,namespace,equals,e,namespace,if,prev,null,tab,index,e,next,else,if,prev,entry,version,highest,required,snapshot,version,prev,handle,chained,entry,copy,on,write,tab,index,prev,prev,next,e,next,mod,count,if,tab,primary,table,primary,table,size,else,incremental,rehash,table,size,return,e,return,null
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> removeEntry(K key, N namespace);1529089579;Helper method that is the basis for operations that remove mappings.;private StateTableEntry<K, N, S> removeEntry(K key, N namespace) {__		final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace)__		final StateTableEntry<K, N, S>[] tab = selectActiveTable(hash)__		int index = hash & (tab.length - 1)___		for (StateTableEntry<K, N, S> e = tab[index], prev = null_ e != null_ prev = e, e = e.next) {_			if (e.hash == hash && key.equals(e.key) && namespace.equals(e.namespace)) {_				if (prev == null) {_					tab[index] = e.next__				} else {_					_					if (prev.entryVersion < highestRequiredSnapshotVersion) {_						prev = handleChainedEntryCopyOnWrite(tab, index, prev)__					}_					prev.next = e.next__				}_				++modCount__				if (tab == primaryTable) {_					--primaryTableSize__				} else {_					--incrementalRehashTableSize__				}_				return e__			}_		}_		return null__	};helper,method,that,is,the,basis,for,operations,that,remove,mappings;private,state,table,entry,k,n,s,remove,entry,k,key,n,namespace,final,int,hash,compute,hash,for,operation,and,do,incremental,rehash,key,namespace,final,state,table,entry,k,n,s,tab,select,active,table,hash,int,index,hash,tab,length,1,for,state,table,entry,k,n,s,e,tab,index,prev,null,e,null,prev,e,e,e,next,if,e,hash,hash,key,equals,e,key,namespace,equals,e,namespace,if,prev,null,tab,index,e,next,else,if,prev,entry,version,highest,required,snapshot,version,prev,handle,chained,entry,copy,on,write,tab,index,prev,prev,next,e,next,mod,count,if,tab,primary,table,primary,table,size,else,incremental,rehash,table,size,return,e,return,null
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> removeEntry(K key, N namespace);1529089584;Helper method that is the basis for operations that remove mappings.;private StateTableEntry<K, N, S> removeEntry(K key, N namespace) {__		final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace)__		final StateTableEntry<K, N, S>[] tab = selectActiveTable(hash)__		int index = hash & (tab.length - 1)___		for (StateTableEntry<K, N, S> e = tab[index], prev = null_ e != null_ prev = e, e = e.next) {_			if (e.hash == hash && key.equals(e.key) && namespace.equals(e.namespace)) {_				if (prev == null) {_					tab[index] = e.next__				} else {_					_					if (prev.entryVersion < highestRequiredSnapshotVersion) {_						prev = handleChainedEntryCopyOnWrite(tab, index, prev)__					}_					prev.next = e.next__				}_				++modCount__				if (tab == primaryTable) {_					--primaryTableSize__				} else {_					--incrementalRehashTableSize__				}_				return e__			}_		}_		return null__	};helper,method,that,is,the,basis,for,operations,that,remove,mappings;private,state,table,entry,k,n,s,remove,entry,k,key,n,namespace,final,int,hash,compute,hash,for,operation,and,do,incremental,rehash,key,namespace,final,state,table,entry,k,n,s,tab,select,active,table,hash,int,index,hash,tab,length,1,for,state,table,entry,k,n,s,e,tab,index,prev,null,e,null,prev,e,e,e,next,if,e,hash,hash,key,equals,e,key,namespace,equals,e,namespace,if,prev,null,tab,index,e,next,else,if,prev,entry,version,highest,required,snapshot,version,prev,handle,chained,entry,copy,on,write,tab,index,prev,prev,next,e,next,mod,count,if,tab,primary,table,primary,table,size,else,incremental,rehash,table,size,return,e,return,null
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> removeEntry(K key, N namespace);1529307900;Helper method that is the basis for operations that remove mappings.;private StateTableEntry<K, N, S> removeEntry(K key, N namespace) {__		final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace)__		final StateTableEntry<K, N, S>[] tab = selectActiveTable(hash)__		int index = hash & (tab.length - 1)___		for (StateTableEntry<K, N, S> e = tab[index], prev = null_ e != null_ prev = e, e = e.next) {_			if (e.hash == hash && key.equals(e.key) && namespace.equals(e.namespace)) {_				if (prev == null) {_					tab[index] = e.next__				} else {_					_					if (prev.entryVersion < highestRequiredSnapshotVersion) {_						prev = handleChainedEntryCopyOnWrite(tab, index, prev)__					}_					prev.next = e.next__				}_				++modCount__				if (tab == primaryTable) {_					--primaryTableSize__				} else {_					--incrementalRehashTableSize__				}_				return e__			}_		}_		return null__	};helper,method,that,is,the,basis,for,operations,that,remove,mappings;private,state,table,entry,k,n,s,remove,entry,k,key,n,namespace,final,int,hash,compute,hash,for,operation,and,do,incremental,rehash,key,namespace,final,state,table,entry,k,n,s,tab,select,active,table,hash,int,index,hash,tab,length,1,for,state,table,entry,k,n,s,e,tab,index,prev,null,e,null,prev,e,e,e,next,if,e,hash,hash,key,equals,e,key,namespace,equals,e,namespace,if,prev,null,tab,index,e,next,else,if,prev,entry,version,highest,required,snapshot,version,prev,handle,chained,entry,copy,on,write,tab,index,prev,prev,next,e,next,mod,count,if,tab,primary,table,primary,table,size,else,incremental,rehash,table,size,return,e,return,null
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> removeEntry(K key, N namespace);1530639128;Helper method that is the basis for operations that remove mappings.;private StateTableEntry<K, N, S> removeEntry(K key, N namespace) {__		final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace)__		final StateTableEntry<K, N, S>[] tab = selectActiveTable(hash)__		int index = hash & (tab.length - 1)___		for (StateTableEntry<K, N, S> e = tab[index], prev = null_ e != null_ prev = e, e = e.next) {_			if (e.hash == hash && key.equals(e.key) && namespace.equals(e.namespace)) {_				if (prev == null) {_					tab[index] = e.next__				} else {_					_					if (prev.entryVersion < highestRequiredSnapshotVersion) {_						prev = handleChainedEntryCopyOnWrite(tab, index, prev)__					}_					prev.next = e.next__				}_				++modCount__				if (tab == primaryTable) {_					--primaryTableSize__				} else {_					--incrementalRehashTableSize__				}_				return e__			}_		}_		return null__	};helper,method,that,is,the,basis,for,operations,that,remove,mappings;private,state,table,entry,k,n,s,remove,entry,k,key,n,namespace,final,int,hash,compute,hash,for,operation,and,do,incremental,rehash,key,namespace,final,state,table,entry,k,n,s,tab,select,active,table,hash,int,index,hash,tab,length,1,for,state,table,entry,k,n,s,e,tab,index,prev,null,e,null,prev,e,e,e,next,if,e,hash,hash,key,equals,e,key,namespace,equals,e,namespace,if,prev,null,tab,index,e,next,else,if,prev,entry,version,highest,required,snapshot,version,prev,handle,chained,entry,copy,on,write,tab,index,prev,prev,next,e,next,mod,count,if,tab,primary,table,primary,table,size,else,incremental,rehash,table,size,return,e,return,null
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> removeEntry(K key, N namespace);1531771917;Helper method that is the basis for operations that remove mappings.;private StateTableEntry<K, N, S> removeEntry(K key, N namespace) {__		final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace)__		final StateTableEntry<K, N, S>[] tab = selectActiveTable(hash)__		int index = hash & (tab.length - 1)___		for (StateTableEntry<K, N, S> e = tab[index], prev = null_ e != null_ prev = e, e = e.next) {_			if (e.hash == hash && key.equals(e.key) && namespace.equals(e.namespace)) {_				if (prev == null) {_					tab[index] = e.next__				} else {_					_					if (prev.entryVersion < highestRequiredSnapshotVersion) {_						prev = handleChainedEntryCopyOnWrite(tab, index, prev)__					}_					prev.next = e.next__				}_				++modCount__				if (tab == primaryTable) {_					--primaryTableSize__				} else {_					--incrementalRehashTableSize__				}_				return e__			}_		}_		return null__	};helper,method,that,is,the,basis,for,operations,that,remove,mappings;private,state,table,entry,k,n,s,remove,entry,k,key,n,namespace,final,int,hash,compute,hash,for,operation,and,do,incremental,rehash,key,namespace,final,state,table,entry,k,n,s,tab,select,active,table,hash,int,index,hash,tab,length,1,for,state,table,entry,k,n,s,e,tab,index,prev,null,e,null,prev,e,e,e,next,if,e,hash,hash,key,equals,e,key,namespace,equals,e,namespace,if,prev,null,tab,index,e,next,else,if,prev,entry,version,highest,required,snapshot,version,prev,handle,chained,entry,copy,on,write,tab,index,prev,prev,next,e,next,mod,count,if,tab,primary,table,primary,table,size,else,incremental,rehash,table,size,return,e,return,null
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> removeEntry(K key, N namespace);1548755874;Helper method that is the basis for operations that remove mappings.;private StateTableEntry<K, N, S> removeEntry(K key, N namespace) {__		final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace)__		final StateTableEntry<K, N, S>[] tab = selectActiveTable(hash)__		int index = hash & (tab.length - 1)___		for (StateTableEntry<K, N, S> e = tab[index], prev = null_ e != null_ prev = e, e = e.next) {_			if (e.hash == hash && key.equals(e.key) && namespace.equals(e.namespace)) {_				if (prev == null) {_					tab[index] = e.next__				} else {_					_					if (prev.entryVersion < highestRequiredSnapshotVersion) {_						prev = handleChainedEntryCopyOnWrite(tab, index, prev)__					}_					prev.next = e.next__				}_				++modCount__				if (tab == primaryTable) {_					--primaryTableSize__				} else {_					--incrementalRehashTableSize__				}_				return e__			}_		}_		return null__	};helper,method,that,is,the,basis,for,operations,that,remove,mappings;private,state,table,entry,k,n,s,remove,entry,k,key,n,namespace,final,int,hash,compute,hash,for,operation,and,do,incremental,rehash,key,namespace,final,state,table,entry,k,n,s,tab,select,active,table,hash,int,index,hash,tab,length,1,for,state,table,entry,k,n,s,e,tab,index,prev,null,e,null,prev,e,e,e,next,if,e,hash,hash,key,equals,e,key,namespace,equals,e,namespace,if,prev,null,tab,index,e,next,else,if,prev,entry,version,highest,required,snapshot,version,prev,handle,chained,entry,copy,on,write,tab,index,prev,prev,next,e,next,mod,count,if,tab,primary,table,primary,table,size,else,incremental,rehash,table,size,return,e,return,null
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> addNewStateTableEntry( 			StateTableEntry<K, N, S>[] table, 			K key, 			N namespace, 			int hash);1489685642;Creates and inserts a new {@link StateTableEntry}.;private StateTableEntry<K, N, S> addNewStateTableEntry(_			StateTableEntry<K, N, S>[] table,_			K key,_			N namespace,_			int hash) {__		_		if (namespace.equals(lastNamespace)) {_			namespace = lastNamespace__		} else {_			lastNamespace = namespace__		}__		int index = hash & (table.length - 1)__		StateTableEntry<K, N, S> newEntry = new StateTableEntry<>(_				key,_				namespace,_				null,_				hash,_				table[index],_				stateTableVersion,_				stateTableVersion)__		table[index] = newEntry___		if (table == primaryTable) {_			++primaryTableSize__		} else {_			++incrementalRehashTableSize__		}_		return newEntry__	};creates,and,inserts,a,new,link,state,table,entry;private,state,table,entry,k,n,s,add,new,state,table,entry,state,table,entry,k,n,s,table,k,key,n,namespace,int,hash,if,namespace,equals,last,namespace,namespace,last,namespace,else,last,namespace,namespace,int,index,hash,table,length,1,state,table,entry,k,n,s,new,entry,new,state,table,entry,key,namespace,null,hash,table,index,state,table,version,state,table,version,table,index,new,entry,if,table,primary,table,primary,table,size,else,incremental,rehash,table,size,return,new,entry
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> addNewStateTableEntry( 			StateTableEntry<K, N, S>[] table, 			K key, 			N namespace, 			int hash);1494180263;Creates and inserts a new {@link StateTableEntry}.;private StateTableEntry<K, N, S> addNewStateTableEntry(_			StateTableEntry<K, N, S>[] table,_			K key,_			N namespace,_			int hash) {__		_		if (namespace.equals(lastNamespace)) {_			namespace = lastNamespace__		} else {_			lastNamespace = namespace__		}__		int index = hash & (table.length - 1)__		StateTableEntry<K, N, S> newEntry = new StateTableEntry<>(_				key,_				namespace,_				null,_				hash,_				table[index],_				stateTableVersion,_				stateTableVersion)__		table[index] = newEntry___		if (table == primaryTable) {_			++primaryTableSize__		} else {_			++incrementalRehashTableSize__		}_		return newEntry__	};creates,and,inserts,a,new,link,state,table,entry;private,state,table,entry,k,n,s,add,new,state,table,entry,state,table,entry,k,n,s,table,k,key,n,namespace,int,hash,if,namespace,equals,last,namespace,namespace,last,namespace,else,last,namespace,namespace,int,index,hash,table,length,1,state,table,entry,k,n,s,new,entry,new,state,table,entry,key,namespace,null,hash,table,index,state,table,version,state,table,version,table,index,new,entry,if,table,primary,table,primary,table,size,else,incremental,rehash,table,size,return,new,entry
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> addNewStateTableEntry( 			StateTableEntry<K, N, S>[] table, 			K key, 			N namespace, 			int hash);1506609393;Creates and inserts a new {@link StateTableEntry}.;private StateTableEntry<K, N, S> addNewStateTableEntry(_			StateTableEntry<K, N, S>[] table,_			K key,_			N namespace,_			int hash) {__		_		if (namespace.equals(lastNamespace)) {_			namespace = lastNamespace__		} else {_			lastNamespace = namespace__		}__		int index = hash & (table.length - 1)__		StateTableEntry<K, N, S> newEntry = new StateTableEntry<>(_				key,_				namespace,_				null,_				hash,_				table[index],_				stateTableVersion,_				stateTableVersion)__		table[index] = newEntry___		if (table == primaryTable) {_			++primaryTableSize__		} else {_			++incrementalRehashTableSize__		}_		return newEntry__	};creates,and,inserts,a,new,link,state,table,entry;private,state,table,entry,k,n,s,add,new,state,table,entry,state,table,entry,k,n,s,table,k,key,n,namespace,int,hash,if,namespace,equals,last,namespace,namespace,last,namespace,else,last,namespace,namespace,int,index,hash,table,length,1,state,table,entry,k,n,s,new,entry,new,state,table,entry,key,namespace,null,hash,table,index,state,table,version,state,table,version,table,index,new,entry,if,table,primary,table,primary,table,size,else,incremental,rehash,table,size,return,new,entry
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> addNewStateTableEntry( 			StateTableEntry<K, N, S>[] table, 			K key, 			N namespace, 			int hash);1519379856;Creates and inserts a new {@link StateTableEntry}.;private StateTableEntry<K, N, S> addNewStateTableEntry(_			StateTableEntry<K, N, S>[] table,_			K key,_			N namespace,_			int hash) {__		_		if (namespace.equals(lastNamespace)) {_			namespace = lastNamespace__		} else {_			lastNamespace = namespace__		}__		int index = hash & (table.length - 1)__		StateTableEntry<K, N, S> newEntry = new StateTableEntry<>(_				key,_				namespace,_				null,_				hash,_				table[index],_				stateTableVersion,_				stateTableVersion)__		table[index] = newEntry___		if (table == primaryTable) {_			++primaryTableSize__		} else {_			++incrementalRehashTableSize__		}_		return newEntry__	};creates,and,inserts,a,new,link,state,table,entry;private,state,table,entry,k,n,s,add,new,state,table,entry,state,table,entry,k,n,s,table,k,key,n,namespace,int,hash,if,namespace,equals,last,namespace,namespace,last,namespace,else,last,namespace,namespace,int,index,hash,table,length,1,state,table,entry,k,n,s,new,entry,new,state,table,entry,key,namespace,null,hash,table,index,state,table,version,state,table,version,table,index,new,entry,if,table,primary,table,primary,table,size,else,incremental,rehash,table,size,return,new,entry
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> addNewStateTableEntry( 			StateTableEntry<K, N, S>[] table, 			K key, 			N namespace, 			int hash);1529089579;Creates and inserts a new {@link StateTableEntry}.;private StateTableEntry<K, N, S> addNewStateTableEntry(_			StateTableEntry<K, N, S>[] table,_			K key,_			N namespace,_			int hash) {__		_		if (namespace.equals(lastNamespace)) {_			namespace = lastNamespace__		} else {_			lastNamespace = namespace__		}__		int index = hash & (table.length - 1)__		StateTableEntry<K, N, S> newEntry = new StateTableEntry<>(_				key,_				namespace,_				null,_				hash,_				table[index],_				stateTableVersion,_				stateTableVersion)__		table[index] = newEntry___		if (table == primaryTable) {_			++primaryTableSize__		} else {_			++incrementalRehashTableSize__		}_		return newEntry__	};creates,and,inserts,a,new,link,state,table,entry;private,state,table,entry,k,n,s,add,new,state,table,entry,state,table,entry,k,n,s,table,k,key,n,namespace,int,hash,if,namespace,equals,last,namespace,namespace,last,namespace,else,last,namespace,namespace,int,index,hash,table,length,1,state,table,entry,k,n,s,new,entry,new,state,table,entry,key,namespace,null,hash,table,index,state,table,version,state,table,version,table,index,new,entry,if,table,primary,table,primary,table,size,else,incremental,rehash,table,size,return,new,entry
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> addNewStateTableEntry( 			StateTableEntry<K, N, S>[] table, 			K key, 			N namespace, 			int hash);1529089584;Creates and inserts a new {@link StateTableEntry}.;private StateTableEntry<K, N, S> addNewStateTableEntry(_			StateTableEntry<K, N, S>[] table,_			K key,_			N namespace,_			int hash) {__		_		if (namespace.equals(lastNamespace)) {_			namespace = lastNamespace__		} else {_			lastNamespace = namespace__		}__		int index = hash & (table.length - 1)__		StateTableEntry<K, N, S> newEntry = new StateTableEntry<>(_				key,_				namespace,_				null,_				hash,_				table[index],_				stateTableVersion,_				stateTableVersion)__		table[index] = newEntry___		if (table == primaryTable) {_			++primaryTableSize__		} else {_			++incrementalRehashTableSize__		}_		return newEntry__	};creates,and,inserts,a,new,link,state,table,entry;private,state,table,entry,k,n,s,add,new,state,table,entry,state,table,entry,k,n,s,table,k,key,n,namespace,int,hash,if,namespace,equals,last,namespace,namespace,last,namespace,else,last,namespace,namespace,int,index,hash,table,length,1,state,table,entry,k,n,s,new,entry,new,state,table,entry,key,namespace,null,hash,table,index,state,table,version,state,table,version,table,index,new,entry,if,table,primary,table,primary,table,size,else,incremental,rehash,table,size,return,new,entry
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> addNewStateTableEntry( 			StateTableEntry<K, N, S>[] table, 			K key, 			N namespace, 			int hash);1529307900;Creates and inserts a new {@link StateTableEntry}.;private StateTableEntry<K, N, S> addNewStateTableEntry(_			StateTableEntry<K, N, S>[] table,_			K key,_			N namespace,_			int hash) {__		_		if (namespace.equals(lastNamespace)) {_			namespace = lastNamespace__		} else {_			lastNamespace = namespace__		}__		int index = hash & (table.length - 1)__		StateTableEntry<K, N, S> newEntry = new StateTableEntry<>(_				key,_				namespace,_				null,_				hash,_				table[index],_				stateTableVersion,_				stateTableVersion)__		table[index] = newEntry___		if (table == primaryTable) {_			++primaryTableSize__		} else {_			++incrementalRehashTableSize__		}_		return newEntry__	};creates,and,inserts,a,new,link,state,table,entry;private,state,table,entry,k,n,s,add,new,state,table,entry,state,table,entry,k,n,s,table,k,key,n,namespace,int,hash,if,namespace,equals,last,namespace,namespace,last,namespace,else,last,namespace,namespace,int,index,hash,table,length,1,state,table,entry,k,n,s,new,entry,new,state,table,entry,key,namespace,null,hash,table,index,state,table,version,state,table,version,table,index,new,entry,if,table,primary,table,primary,table,size,else,incremental,rehash,table,size,return,new,entry
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> addNewStateTableEntry( 			StateTableEntry<K, N, S>[] table, 			K key, 			N namespace, 			int hash);1530639128;Creates and inserts a new {@link StateTableEntry}.;private StateTableEntry<K, N, S> addNewStateTableEntry(_			StateTableEntry<K, N, S>[] table,_			K key,_			N namespace,_			int hash) {__		_		if (namespace.equals(lastNamespace)) {_			namespace = lastNamespace__		} else {_			lastNamespace = namespace__		}__		int index = hash & (table.length - 1)__		StateTableEntry<K, N, S> newEntry = new StateTableEntry<>(_				key,_				namespace,_				null,_				hash,_				table[index],_				stateTableVersion,_				stateTableVersion)__		table[index] = newEntry___		if (table == primaryTable) {_			++primaryTableSize__		} else {_			++incrementalRehashTableSize__		}_		return newEntry__	};creates,and,inserts,a,new,link,state,table,entry;private,state,table,entry,k,n,s,add,new,state,table,entry,state,table,entry,k,n,s,table,k,key,n,namespace,int,hash,if,namespace,equals,last,namespace,namespace,last,namespace,else,last,namespace,namespace,int,index,hash,table,length,1,state,table,entry,k,n,s,new,entry,new,state,table,entry,key,namespace,null,hash,table,index,state,table,version,state,table,version,table,index,new,entry,if,table,primary,table,primary,table,size,else,incremental,rehash,table,size,return,new,entry
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> addNewStateTableEntry( 			StateTableEntry<K, N, S>[] table, 			K key, 			N namespace, 			int hash);1531771917;Creates and inserts a new {@link StateTableEntry}.;private StateTableEntry<K, N, S> addNewStateTableEntry(_			StateTableEntry<K, N, S>[] table,_			K key,_			N namespace,_			int hash) {__		_		if (namespace.equals(lastNamespace)) {_			namespace = lastNamespace__		} else {_			lastNamespace = namespace__		}__		int index = hash & (table.length - 1)__		StateTableEntry<K, N, S> newEntry = new StateTableEntry<>(_				key,_				namespace,_				null,_				hash,_				table[index],_				stateTableVersion,_				stateTableVersion)__		table[index] = newEntry___		if (table == primaryTable) {_			++primaryTableSize__		} else {_			++incrementalRehashTableSize__		}_		return newEntry__	};creates,and,inserts,a,new,link,state,table,entry;private,state,table,entry,k,n,s,add,new,state,table,entry,state,table,entry,k,n,s,table,k,key,n,namespace,int,hash,if,namespace,equals,last,namespace,namespace,last,namespace,else,last,namespace,namespace,int,index,hash,table,length,1,state,table,entry,k,n,s,new,entry,new,state,table,entry,key,namespace,null,hash,table,index,state,table,version,state,table,version,table,index,new,entry,if,table,primary,table,primary,table,size,else,incremental,rehash,table,size,return,new,entry
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> addNewStateTableEntry( 			StateTableEntry<K, N, S>[] table, 			K key, 			N namespace, 			int hash);1548755874;Creates and inserts a new {@link StateTableEntry}.;private StateTableEntry<K, N, S> addNewStateTableEntry(_			StateTableEntry<K, N, S>[] table,_			K key,_			N namespace,_			int hash) {__		_		if (namespace.equals(lastNamespace)) {_			namespace = lastNamespace__		} else {_			lastNamespace = namespace__		}__		int index = hash & (table.length - 1)__		StateTableEntry<K, N, S> newEntry = new StateTableEntry<>(_				key,_				namespace,_				null,_				hash,_				table[index],_				stateTableVersion,_				stateTableVersion)__		table[index] = newEntry___		if (table == primaryTable) {_			++primaryTableSize__		} else {_			++incrementalRehashTableSize__		}_		return newEntry__	};creates,and,inserts,a,new,link,state,table,entry;private,state,table,entry,k,n,s,add,new,state,table,entry,state,table,entry,k,n,s,table,k,key,n,namespace,int,hash,if,namespace,equals,last,namespace,namespace,last,namespace,else,last,namespace,namespace,int,index,hash,table,length,1,state,table,entry,k,n,s,new,entry,new,state,table,entry,key,namespace,null,hash,table,index,state,table,version,state,table,version,table,index,new,entry,if,table,primary,table,primary,table,size,else,incremental,rehash,table,size,return,new,entry
CopyOnWriteStateTable -> private int computeHashForOperationAndDoIncrementalRehash(K key, N namespace);1489685642;Computes the hash for the composite of key and namespace and performs some steps of incremental rehash if_incremental rehashing is in progress.;private int computeHashForOperationAndDoIncrementalRehash(K key, N namespace) {__		checkKeyNamespacePreconditions(key, namespace)___		if (isRehashing()) {_			incrementalRehash()__		}__		return compositeHash(key, namespace)__	};computes,the,hash,for,the,composite,of,key,and,namespace,and,performs,some,steps,of,incremental,rehash,if,incremental,rehashing,is,in,progress;private,int,compute,hash,for,operation,and,do,incremental,rehash,k,key,n,namespace,check,key,namespace,preconditions,key,namespace,if,is,rehashing,incremental,rehash,return,composite,hash,key,namespace
CopyOnWriteStateTable -> private int computeHashForOperationAndDoIncrementalRehash(K key, N namespace);1494180263;Computes the hash for the composite of key and namespace and performs some steps of incremental rehash if_incremental rehashing is in progress.;private int computeHashForOperationAndDoIncrementalRehash(K key, N namespace) {__		checkKeyNamespacePreconditions(key, namespace)___		if (isRehashing()) {_			incrementalRehash()__		}__		return compositeHash(key, namespace)__	};computes,the,hash,for,the,composite,of,key,and,namespace,and,performs,some,steps,of,incremental,rehash,if,incremental,rehashing,is,in,progress;private,int,compute,hash,for,operation,and,do,incremental,rehash,k,key,n,namespace,check,key,namespace,preconditions,key,namespace,if,is,rehashing,incremental,rehash,return,composite,hash,key,namespace
CopyOnWriteStateTable -> private int computeHashForOperationAndDoIncrementalRehash(K key, N namespace);1506609393;Computes the hash for the composite of key and namespace and performs some steps of incremental rehash if_incremental rehashing is in progress.;private int computeHashForOperationAndDoIncrementalRehash(K key, N namespace) {__		checkKeyNamespacePreconditions(key, namespace)___		if (isRehashing()) {_			incrementalRehash()__		}__		return compositeHash(key, namespace)__	};computes,the,hash,for,the,composite,of,key,and,namespace,and,performs,some,steps,of,incremental,rehash,if,incremental,rehashing,is,in,progress;private,int,compute,hash,for,operation,and,do,incremental,rehash,k,key,n,namespace,check,key,namespace,preconditions,key,namespace,if,is,rehashing,incremental,rehash,return,composite,hash,key,namespace
CopyOnWriteStateTable -> private int computeHashForOperationAndDoIncrementalRehash(K key, N namespace);1519379856;Computes the hash for the composite of key and namespace and performs some steps of incremental rehash if_incremental rehashing is in progress.;private int computeHashForOperationAndDoIncrementalRehash(K key, N namespace) {__		checkKeyNamespacePreconditions(key, namespace)___		if (isRehashing()) {_			incrementalRehash()__		}__		return compositeHash(key, namespace)__	};computes,the,hash,for,the,composite,of,key,and,namespace,and,performs,some,steps,of,incremental,rehash,if,incremental,rehashing,is,in,progress;private,int,compute,hash,for,operation,and,do,incremental,rehash,k,key,n,namespace,check,key,namespace,preconditions,key,namespace,if,is,rehashing,incremental,rehash,return,composite,hash,key,namespace
CopyOnWriteStateTable -> private int computeHashForOperationAndDoIncrementalRehash(K key, N namespace);1529089579;Computes the hash for the composite of key and namespace and performs some steps of incremental rehash if_incremental rehashing is in progress.;private int computeHashForOperationAndDoIncrementalRehash(K key, N namespace) {__		checkKeyNamespacePreconditions(key, namespace)___		if (isRehashing()) {_			incrementalRehash()__		}__		return compositeHash(key, namespace)__	};computes,the,hash,for,the,composite,of,key,and,namespace,and,performs,some,steps,of,incremental,rehash,if,incremental,rehashing,is,in,progress;private,int,compute,hash,for,operation,and,do,incremental,rehash,k,key,n,namespace,check,key,namespace,preconditions,key,namespace,if,is,rehashing,incremental,rehash,return,composite,hash,key,namespace
CopyOnWriteStateTable -> private int computeHashForOperationAndDoIncrementalRehash(K key, N namespace);1529089584;Computes the hash for the composite of key and namespace and performs some steps of incremental rehash if_incremental rehashing is in progress.;private int computeHashForOperationAndDoIncrementalRehash(K key, N namespace) {__		checkKeyNamespacePreconditions(key, namespace)___		if (isRehashing()) {_			incrementalRehash()__		}__		return compositeHash(key, namespace)__	};computes,the,hash,for,the,composite,of,key,and,namespace,and,performs,some,steps,of,incremental,rehash,if,incremental,rehashing,is,in,progress;private,int,compute,hash,for,operation,and,do,incremental,rehash,k,key,n,namespace,check,key,namespace,preconditions,key,namespace,if,is,rehashing,incremental,rehash,return,composite,hash,key,namespace
CopyOnWriteStateTable -> private int computeHashForOperationAndDoIncrementalRehash(K key, N namespace);1529307900;Computes the hash for the composite of key and namespace and performs some steps of incremental rehash if_incremental rehashing is in progress.;private int computeHashForOperationAndDoIncrementalRehash(K key, N namespace) {__		checkKeyNamespacePreconditions(key, namespace)___		if (isRehashing()) {_			incrementalRehash()__		}__		return compositeHash(key, namespace)__	};computes,the,hash,for,the,composite,of,key,and,namespace,and,performs,some,steps,of,incremental,rehash,if,incremental,rehashing,is,in,progress;private,int,compute,hash,for,operation,and,do,incremental,rehash,k,key,n,namespace,check,key,namespace,preconditions,key,namespace,if,is,rehashing,incremental,rehash,return,composite,hash,key,namespace
CopyOnWriteStateTable -> private int computeHashForOperationAndDoIncrementalRehash(K key, N namespace);1530639128;Computes the hash for the composite of key and namespace and performs some steps of incremental rehash if_incremental rehashing is in progress.;private int computeHashForOperationAndDoIncrementalRehash(K key, N namespace) {__		checkKeyNamespacePreconditions(key, namespace)___		if (isRehashing()) {_			incrementalRehash()__		}__		return compositeHash(key, namespace)__	};computes,the,hash,for,the,composite,of,key,and,namespace,and,performs,some,steps,of,incremental,rehash,if,incremental,rehashing,is,in,progress;private,int,compute,hash,for,operation,and,do,incremental,rehash,k,key,n,namespace,check,key,namespace,preconditions,key,namespace,if,is,rehashing,incremental,rehash,return,composite,hash,key,namespace
CopyOnWriteStateTable -> private int computeHashForOperationAndDoIncrementalRehash(K key, N namespace);1531771917;Computes the hash for the composite of key and namespace and performs some steps of incremental rehash if_incremental rehashing is in progress.;private int computeHashForOperationAndDoIncrementalRehash(K key, N namespace) {__		checkKeyNamespacePreconditions(key, namespace)___		if (isRehashing()) {_			incrementalRehash()__		}__		return compositeHash(key, namespace)__	};computes,the,hash,for,the,composite,of,key,and,namespace,and,performs,some,steps,of,incremental,rehash,if,incremental,rehashing,is,in,progress;private,int,compute,hash,for,operation,and,do,incremental,rehash,k,key,n,namespace,check,key,namespace,preconditions,key,namespace,if,is,rehashing,incremental,rehash,return,composite,hash,key,namespace
CopyOnWriteStateTable -> private int computeHashForOperationAndDoIncrementalRehash(K key, N namespace);1548755874;Computes the hash for the composite of key and namespace and performs some steps of incremental rehash if_incremental rehashing is in progress.;private int computeHashForOperationAndDoIncrementalRehash(K key, N namespace) {__		checkKeyNamespacePreconditions(key, namespace)___		if (isRehashing()) {_			incrementalRehash()__		}__		return compositeHash(key, namespace)__	};computes,the,hash,for,the,composite,of,key,and,namespace,and,performs,some,steps,of,incremental,rehash,if,incremental,rehashing,is,in,progress;private,int,compute,hash,for,operation,and,do,incremental,rehash,k,key,n,namespace,check,key,namespace,preconditions,key,namespace,if,is,rehashing,incremental,rehash,return,composite,hash,key,namespace
CopyOnWriteStateTable -> @Override 	public CopyOnWriteStateTableSnapshot<K, N, S> createSnapshot();1489685642;Creates a snapshot of this {@link CopyOnWriteStateTable}, to be written in checkpointing. The snapshot integrity_is protected through copy-on-write from the {@link CopyOnWriteStateTable}. Users should call_{@link #releaseSnapshot(CopyOnWriteStateTableSnapshot)} after using the returned object.__@return a snapshot from this {@link CopyOnWriteStateTable}, for checkpointing.;@Override_	public CopyOnWriteStateTableSnapshot<K, N, S> createSnapshot() {_		return new CopyOnWriteStateTableSnapshot<>(this)__	};creates,a,snapshot,of,this,link,copy,on,write,state,table,to,be,written,in,checkpointing,the,snapshot,integrity,is,protected,through,copy,on,write,from,the,link,copy,on,write,state,table,users,should,call,link,release,snapshot,copy,on,write,state,table,snapshot,after,using,the,returned,object,return,a,snapshot,from,this,link,copy,on,write,state,table,for,checkpointing;override,public,copy,on,write,state,table,snapshot,k,n,s,create,snapshot,return,new,copy,on,write,state,table,snapshot,this
CopyOnWriteStateTable -> @Override 	public CopyOnWriteStateTableSnapshot<K, N, S> createSnapshot();1494180263;Creates a snapshot of this {@link CopyOnWriteStateTable}, to be written in checkpointing. The snapshot integrity_is protected through copy-on-write from the {@link CopyOnWriteStateTable}. Users should call_{@link #releaseSnapshot(CopyOnWriteStateTableSnapshot)} after using the returned object.__@return a snapshot from this {@link CopyOnWriteStateTable}, for checkpointing.;@Override_	public CopyOnWriteStateTableSnapshot<K, N, S> createSnapshot() {_		return new CopyOnWriteStateTableSnapshot<>(this)__	};creates,a,snapshot,of,this,link,copy,on,write,state,table,to,be,written,in,checkpointing,the,snapshot,integrity,is,protected,through,copy,on,write,from,the,link,copy,on,write,state,table,users,should,call,link,release,snapshot,copy,on,write,state,table,snapshot,after,using,the,returned,object,return,a,snapshot,from,this,link,copy,on,write,state,table,for,checkpointing;override,public,copy,on,write,state,table,snapshot,k,n,s,create,snapshot,return,new,copy,on,write,state,table,snapshot,this
CopyOnWriteStateTable -> @Override 	public CopyOnWriteStateTableSnapshot<K, N, S> createSnapshot();1506609393;Creates a snapshot of this {@link CopyOnWriteStateTable}, to be written in checkpointing. The snapshot integrity_is protected through copy-on-write from the {@link CopyOnWriteStateTable}. Users should call_{@link #releaseSnapshot(CopyOnWriteStateTableSnapshot)} after using the returned object.__@return a snapshot from this {@link CopyOnWriteStateTable}, for checkpointing.;@Override_	public CopyOnWriteStateTableSnapshot<K, N, S> createSnapshot() {_		return new CopyOnWriteStateTableSnapshot<>(this)__	};creates,a,snapshot,of,this,link,copy,on,write,state,table,to,be,written,in,checkpointing,the,snapshot,integrity,is,protected,through,copy,on,write,from,the,link,copy,on,write,state,table,users,should,call,link,release,snapshot,copy,on,write,state,table,snapshot,after,using,the,returned,object,return,a,snapshot,from,this,link,copy,on,write,state,table,for,checkpointing;override,public,copy,on,write,state,table,snapshot,k,n,s,create,snapshot,return,new,copy,on,write,state,table,snapshot,this
CopyOnWriteStateTable -> @Override 	public CopyOnWriteStateTableSnapshot<K, N, S> createSnapshot();1519379856;Creates a snapshot of this {@link CopyOnWriteStateTable}, to be written in checkpointing. The snapshot integrity_is protected through copy-on-write from the {@link CopyOnWriteStateTable}. Users should call_{@link #releaseSnapshot(CopyOnWriteStateTableSnapshot)} after using the returned object.__@return a snapshot from this {@link CopyOnWriteStateTable}, for checkpointing.;@Override_	public CopyOnWriteStateTableSnapshot<K, N, S> createSnapshot() {_		return new CopyOnWriteStateTableSnapshot<>(this)__	};creates,a,snapshot,of,this,link,copy,on,write,state,table,to,be,written,in,checkpointing,the,snapshot,integrity,is,protected,through,copy,on,write,from,the,link,copy,on,write,state,table,users,should,call,link,release,snapshot,copy,on,write,state,table,snapshot,after,using,the,returned,object,return,a,snapshot,from,this,link,copy,on,write,state,table,for,checkpointing;override,public,copy,on,write,state,table,snapshot,k,n,s,create,snapshot,return,new,copy,on,write,state,table,snapshot,this
CopyOnWriteStateTable -> @Override 	public CopyOnWriteStateTableSnapshot<K, N, S> createSnapshot();1529089579;Creates a snapshot of this {@link CopyOnWriteStateTable}, to be written in checkpointing. The snapshot integrity_is protected through copy-on-write from the {@link CopyOnWriteStateTable}. Users should call_{@link #releaseSnapshot(CopyOnWriteStateTableSnapshot)} after using the returned object.__@return a snapshot from this {@link CopyOnWriteStateTable}, for checkpointing.;@Override_	public CopyOnWriteStateTableSnapshot<K, N, S> createSnapshot() {_		return new CopyOnWriteStateTableSnapshot<>(this)__	};creates,a,snapshot,of,this,link,copy,on,write,state,table,to,be,written,in,checkpointing,the,snapshot,integrity,is,protected,through,copy,on,write,from,the,link,copy,on,write,state,table,users,should,call,link,release,snapshot,copy,on,write,state,table,snapshot,after,using,the,returned,object,return,a,snapshot,from,this,link,copy,on,write,state,table,for,checkpointing;override,public,copy,on,write,state,table,snapshot,k,n,s,create,snapshot,return,new,copy,on,write,state,table,snapshot,this
CopyOnWriteStateTable -> @Override 	public CopyOnWriteStateTableSnapshot<K, N, S> createSnapshot();1529089584;Creates a snapshot of this {@link CopyOnWriteStateTable}, to be written in checkpointing. The snapshot integrity_is protected through copy-on-write from the {@link CopyOnWriteStateTable}. Users should call_{@link #releaseSnapshot(CopyOnWriteStateTableSnapshot)} after using the returned object.__@return a snapshot from this {@link CopyOnWriteStateTable}, for checkpointing.;@Override_	public CopyOnWriteStateTableSnapshot<K, N, S> createSnapshot() {_		return new CopyOnWriteStateTableSnapshot<>(this)__	};creates,a,snapshot,of,this,link,copy,on,write,state,table,to,be,written,in,checkpointing,the,snapshot,integrity,is,protected,through,copy,on,write,from,the,link,copy,on,write,state,table,users,should,call,link,release,snapshot,copy,on,write,state,table,snapshot,after,using,the,returned,object,return,a,snapshot,from,this,link,copy,on,write,state,table,for,checkpointing;override,public,copy,on,write,state,table,snapshot,k,n,s,create,snapshot,return,new,copy,on,write,state,table,snapshot,this
CopyOnWriteStateTable -> @Override 	public CopyOnWriteStateTableSnapshot<K, N, S> createSnapshot();1529307900;Creates a snapshot of this {@link CopyOnWriteStateTable}, to be written in checkpointing. The snapshot integrity_is protected through copy-on-write from the {@link CopyOnWriteStateTable}. Users should call_{@link #releaseSnapshot(CopyOnWriteStateTableSnapshot)} after using the returned object.__@return a snapshot from this {@link CopyOnWriteStateTable}, for checkpointing.;@Override_	public CopyOnWriteStateTableSnapshot<K, N, S> createSnapshot() {_		return new CopyOnWriteStateTableSnapshot<>(this)__	};creates,a,snapshot,of,this,link,copy,on,write,state,table,to,be,written,in,checkpointing,the,snapshot,integrity,is,protected,through,copy,on,write,from,the,link,copy,on,write,state,table,users,should,call,link,release,snapshot,copy,on,write,state,table,snapshot,after,using,the,returned,object,return,a,snapshot,from,this,link,copy,on,write,state,table,for,checkpointing;override,public,copy,on,write,state,table,snapshot,k,n,s,create,snapshot,return,new,copy,on,write,state,table,snapshot,this
CopyOnWriteStateTable -> @Override 	public CopyOnWriteStateTableSnapshot<K, N, S> createSnapshot();1530639128;Creates a snapshot of this {@link CopyOnWriteStateTable}, to be written in checkpointing. The snapshot integrity_is protected through copy-on-write from the {@link CopyOnWriteStateTable}. Users should call_{@link #releaseSnapshot(CopyOnWriteStateTableSnapshot)} after using the returned object.__@return a snapshot from this {@link CopyOnWriteStateTable}, for checkpointing.;@Override_	public CopyOnWriteStateTableSnapshot<K, N, S> createSnapshot() {_		return new CopyOnWriteStateTableSnapshot<>(this)__	};creates,a,snapshot,of,this,link,copy,on,write,state,table,to,be,written,in,checkpointing,the,snapshot,integrity,is,protected,through,copy,on,write,from,the,link,copy,on,write,state,table,users,should,call,link,release,snapshot,copy,on,write,state,table,snapshot,after,using,the,returned,object,return,a,snapshot,from,this,link,copy,on,write,state,table,for,checkpointing;override,public,copy,on,write,state,table,snapshot,k,n,s,create,snapshot,return,new,copy,on,write,state,table,snapshot,this
CopyOnWriteStateTable -> private void doubleCapacity();1489685642;Doubles the capacity of the hash table. Existing entries are placed in_the correct bucket on the enlarged table. If the current capacity is,_MAXIMUM_CAPACITY, this method is a no-op. Returns the table, which_will be new unless we were already at MAXIMUM_CAPACITY.;private void doubleCapacity() {__		_		Preconditions.checkState(!isRehashing(), "There is already a rehash in progress.")___		StateTableEntry<K, N, S>[] oldTable = primaryTable___		int oldCapacity = oldTable.length___		if (oldCapacity == MAXIMUM_CAPACITY) {_			return__		}__		incrementalRehashTable = makeTable(oldCapacity * 2)__	};doubles,the,capacity,of,the,hash,table,existing,entries,are,placed,in,the,correct,bucket,on,the,enlarged,table,if,the,current,capacity,is,this,method,is,a,no,op,returns,the,table,which,will,be,new,unless,we,were,already,at;private,void,double,capacity,preconditions,check,state,is,rehashing,there,is,already,a,rehash,in,progress,state,table,entry,k,n,s,old,table,primary,table,int,old,capacity,old,table,length,if,old,capacity,return,incremental,rehash,table,make,table,old,capacity,2
CopyOnWriteStateTable -> private void doubleCapacity();1494180263;Doubles the capacity of the hash table. Existing entries are placed in_the correct bucket on the enlarged table. If the current capacity is,_MAXIMUM_CAPACITY, this method is a no-op. Returns the table, which_will be new unless we were already at MAXIMUM_CAPACITY.;private void doubleCapacity() {__		_		Preconditions.checkState(!isRehashing(), "There is already a rehash in progress.")___		StateTableEntry<K, N, S>[] oldTable = primaryTable___		int oldCapacity = oldTable.length___		if (oldCapacity == MAXIMUM_CAPACITY) {_			return__		}__		incrementalRehashTable = makeTable(oldCapacity * 2)__	};doubles,the,capacity,of,the,hash,table,existing,entries,are,placed,in,the,correct,bucket,on,the,enlarged,table,if,the,current,capacity,is,this,method,is,a,no,op,returns,the,table,which,will,be,new,unless,we,were,already,at;private,void,double,capacity,preconditions,check,state,is,rehashing,there,is,already,a,rehash,in,progress,state,table,entry,k,n,s,old,table,primary,table,int,old,capacity,old,table,length,if,old,capacity,return,incremental,rehash,table,make,table,old,capacity,2
CopyOnWriteStateTable -> private void doubleCapacity();1506609393;Doubles the capacity of the hash table. Existing entries are placed in_the correct bucket on the enlarged table. If the current capacity is,_MAXIMUM_CAPACITY, this method is a no-op. Returns the table, which_will be new unless we were already at MAXIMUM_CAPACITY.;private void doubleCapacity() {__		_		Preconditions.checkState(!isRehashing(), "There is already a rehash in progress.")___		StateTableEntry<K, N, S>[] oldTable = primaryTable___		int oldCapacity = oldTable.length___		if (oldCapacity == MAXIMUM_CAPACITY) {_			return__		}__		incrementalRehashTable = makeTable(oldCapacity * 2)__	};doubles,the,capacity,of,the,hash,table,existing,entries,are,placed,in,the,correct,bucket,on,the,enlarged,table,if,the,current,capacity,is,this,method,is,a,no,op,returns,the,table,which,will,be,new,unless,we,were,already,at;private,void,double,capacity,preconditions,check,state,is,rehashing,there,is,already,a,rehash,in,progress,state,table,entry,k,n,s,old,table,primary,table,int,old,capacity,old,table,length,if,old,capacity,return,incremental,rehash,table,make,table,old,capacity,2
CopyOnWriteStateTable -> private void doubleCapacity();1519379856;Doubles the capacity of the hash table. Existing entries are placed in_the correct bucket on the enlarged table. If the current capacity is,_MAXIMUM_CAPACITY, this method is a no-op. Returns the table, which_will be new unless we were already at MAXIMUM_CAPACITY.;private void doubleCapacity() {__		_		Preconditions.checkState(!isRehashing(), "There is already a rehash in progress.")___		StateTableEntry<K, N, S>[] oldTable = primaryTable___		int oldCapacity = oldTable.length___		if (oldCapacity == MAXIMUM_CAPACITY) {_			return__		}__		incrementalRehashTable = makeTable(oldCapacity * 2)__	};doubles,the,capacity,of,the,hash,table,existing,entries,are,placed,in,the,correct,bucket,on,the,enlarged,table,if,the,current,capacity,is,this,method,is,a,no,op,returns,the,table,which,will,be,new,unless,we,were,already,at;private,void,double,capacity,preconditions,check,state,is,rehashing,there,is,already,a,rehash,in,progress,state,table,entry,k,n,s,old,table,primary,table,int,old,capacity,old,table,length,if,old,capacity,return,incremental,rehash,table,make,table,old,capacity,2
CopyOnWriteStateTable -> private void doubleCapacity();1529089579;Doubles the capacity of the hash table. Existing entries are placed in_the correct bucket on the enlarged table. If the current capacity is,_MAXIMUM_CAPACITY, this method is a no-op. Returns the table, which_will be new unless we were already at MAXIMUM_CAPACITY.;private void doubleCapacity() {__		_		Preconditions.checkState(!isRehashing(), "There is already a rehash in progress.")___		StateTableEntry<K, N, S>[] oldTable = primaryTable___		int oldCapacity = oldTable.length___		if (oldCapacity == MAXIMUM_CAPACITY) {_			return__		}__		incrementalRehashTable = makeTable(oldCapacity * 2)__	};doubles,the,capacity,of,the,hash,table,existing,entries,are,placed,in,the,correct,bucket,on,the,enlarged,table,if,the,current,capacity,is,this,method,is,a,no,op,returns,the,table,which,will,be,new,unless,we,were,already,at;private,void,double,capacity,preconditions,check,state,is,rehashing,there,is,already,a,rehash,in,progress,state,table,entry,k,n,s,old,table,primary,table,int,old,capacity,old,table,length,if,old,capacity,return,incremental,rehash,table,make,table,old,capacity,2
CopyOnWriteStateTable -> private void doubleCapacity();1529089584;Doubles the capacity of the hash table. Existing entries are placed in_the correct bucket on the enlarged table. If the current capacity is,_MAXIMUM_CAPACITY, this method is a no-op. Returns the table, which_will be new unless we were already at MAXIMUM_CAPACITY.;private void doubleCapacity() {__		_		Preconditions.checkState(!isRehashing(), "There is already a rehash in progress.")___		StateTableEntry<K, N, S>[] oldTable = primaryTable___		int oldCapacity = oldTable.length___		if (oldCapacity == MAXIMUM_CAPACITY) {_			return__		}__		incrementalRehashTable = makeTable(oldCapacity * 2)__	};doubles,the,capacity,of,the,hash,table,existing,entries,are,placed,in,the,correct,bucket,on,the,enlarged,table,if,the,current,capacity,is,this,method,is,a,no,op,returns,the,table,which,will,be,new,unless,we,were,already,at;private,void,double,capacity,preconditions,check,state,is,rehashing,there,is,already,a,rehash,in,progress,state,table,entry,k,n,s,old,table,primary,table,int,old,capacity,old,table,length,if,old,capacity,return,incremental,rehash,table,make,table,old,capacity,2
CopyOnWriteStateTable -> private void doubleCapacity();1529307900;Doubles the capacity of the hash table. Existing entries are placed in_the correct bucket on the enlarged table. If the current capacity is,_MAXIMUM_CAPACITY, this method is a no-op. Returns the table, which_will be new unless we were already at MAXIMUM_CAPACITY.;private void doubleCapacity() {__		_		Preconditions.checkState(!isRehashing(), "There is already a rehash in progress.")___		StateTableEntry<K, N, S>[] oldTable = primaryTable___		int oldCapacity = oldTable.length___		if (oldCapacity == MAXIMUM_CAPACITY) {_			return__		}__		incrementalRehashTable = makeTable(oldCapacity * 2)__	};doubles,the,capacity,of,the,hash,table,existing,entries,are,placed,in,the,correct,bucket,on,the,enlarged,table,if,the,current,capacity,is,this,method,is,a,no,op,returns,the,table,which,will,be,new,unless,we,were,already,at;private,void,double,capacity,preconditions,check,state,is,rehashing,there,is,already,a,rehash,in,progress,state,table,entry,k,n,s,old,table,primary,table,int,old,capacity,old,table,length,if,old,capacity,return,incremental,rehash,table,make,table,old,capacity,2
CopyOnWriteStateTable -> private void doubleCapacity();1530639128;Doubles the capacity of the hash table. Existing entries are placed in_the correct bucket on the enlarged table. If the current capacity is,_MAXIMUM_CAPACITY, this method is a no-op. Returns the table, which_will be new unless we were already at MAXIMUM_CAPACITY.;private void doubleCapacity() {__		_		Preconditions.checkState(!isRehashing(), "There is already a rehash in progress.")___		StateTableEntry<K, N, S>[] oldTable = primaryTable___		int oldCapacity = oldTable.length___		if (oldCapacity == MAXIMUM_CAPACITY) {_			return__		}__		incrementalRehashTable = makeTable(oldCapacity * 2)__	};doubles,the,capacity,of,the,hash,table,existing,entries,are,placed,in,the,correct,bucket,on,the,enlarged,table,if,the,current,capacity,is,this,method,is,a,no,op,returns,the,table,which,will,be,new,unless,we,were,already,at;private,void,double,capacity,preconditions,check,state,is,rehashing,there,is,already,a,rehash,in,progress,state,table,entry,k,n,s,old,table,primary,table,int,old,capacity,old,table,length,if,old,capacity,return,incremental,rehash,table,make,table,old,capacity,2
CopyOnWriteStateTable -> private void doubleCapacity();1531771917;Doubles the capacity of the hash table. Existing entries are placed in_the correct bucket on the enlarged table. If the current capacity is,_MAXIMUM_CAPACITY, this method is a no-op. Returns the table, which_will be new unless we were already at MAXIMUM_CAPACITY.;private void doubleCapacity() {__		_		Preconditions.checkState(!isRehashing(), "There is already a rehash in progress.")___		StateTableEntry<K, N, S>[] oldTable = primaryTable___		int oldCapacity = oldTable.length___		if (oldCapacity == MAXIMUM_CAPACITY) {_			return__		}__		incrementalRehashTable = makeTable(oldCapacity * 2)__	};doubles,the,capacity,of,the,hash,table,existing,entries,are,placed,in,the,correct,bucket,on,the,enlarged,table,if,the,current,capacity,is,this,method,is,a,no,op,returns,the,table,which,will,be,new,unless,we,were,already,at;private,void,double,capacity,preconditions,check,state,is,rehashing,there,is,already,a,rehash,in,progress,state,table,entry,k,n,s,old,table,primary,table,int,old,capacity,old,table,length,if,old,capacity,return,incremental,rehash,table,make,table,old,capacity,2
CopyOnWriteStateTable -> private void doubleCapacity();1548755874;Doubles the capacity of the hash table. Existing entries are placed in_the correct bucket on the enlarged table. If the current capacity is,_MAXIMUM_CAPACITY, this method is a no-op. Returns the table, which_will be new unless we were already at MAXIMUM_CAPACITY.;private void doubleCapacity() {__		_		Preconditions.checkState(!isRehashing(), "There is already a rehash in progress.")___		StateTableEntry<K, N, S>[] oldTable = primaryTable___		int oldCapacity = oldTable.length___		if (oldCapacity == MAXIMUM_CAPACITY) {_			return__		}__		incrementalRehashTable = makeTable(oldCapacity * 2)__	};doubles,the,capacity,of,the,hash,table,existing,entries,are,placed,in,the,correct,bucket,on,the,enlarged,table,if,the,current,capacity,is,this,method,is,a,no,op,returns,the,table,which,will,be,new,unless,we,were,already,at;private,void,double,capacity,preconditions,check,state,is,rehashing,there,is,already,a,rehash,in,progress,state,table,entry,k,n,s,old,table,primary,table,int,old,capacity,old,table,length,if,old,capacity,return,incremental,rehash,table,make,table,old,capacity,2
CopyOnWriteStateTable -> void remove(K key, N namespace);1489685642;Removes the mapping with the specified key/namespace composite key from this map. This method should be preferred_over {@link #removeAndGetOld(Object, Object)} when the caller is not interested in the old value, because this_can potentially reduce copy-on-write activity.__@param key       the key of the mapping to remove. Not null._@param namespace the namespace of the mapping to remove. Not null.;void remove(K key, N namespace) {_		removeEntry(key, namespace)__	};removes,the,mapping,with,the,specified,key,namespace,composite,key,from,this,map,this,method,should,be,preferred,over,link,remove,and,get,old,object,object,when,the,caller,is,not,interested,in,the,old,value,because,this,can,potentially,reduce,copy,on,write,activity,param,key,the,key,of,the,mapping,to,remove,not,null,param,namespace,the,namespace,of,the,mapping,to,remove,not,null;void,remove,k,key,n,namespace,remove,entry,key,namespace
CopyOnWriteStateTable -> void remove(K key, N namespace);1494180263;Removes the mapping with the specified key/namespace composite key from this map. This method should be preferred_over {@link #removeAndGetOld(Object, Object)} when the caller is not interested in the old value, because this_can potentially reduce copy-on-write activity.__@param key       the key of the mapping to remove. Not null._@param namespace the namespace of the mapping to remove. Not null.;void remove(K key, N namespace) {_		removeEntry(key, namespace)__	};removes,the,mapping,with,the,specified,key,namespace,composite,key,from,this,map,this,method,should,be,preferred,over,link,remove,and,get,old,object,object,when,the,caller,is,not,interested,in,the,old,value,because,this,can,potentially,reduce,copy,on,write,activity,param,key,the,key,of,the,mapping,to,remove,not,null,param,namespace,the,namespace,of,the,mapping,to,remove,not,null;void,remove,k,key,n,namespace,remove,entry,key,namespace
CopyOnWriteStateTable -> void remove(K key, N namespace);1506609393;Removes the mapping with the specified key/namespace composite key from this map. This method should be preferred_over {@link #removeAndGetOld(Object, Object)} when the caller is not interested in the old value, because this_can potentially reduce copy-on-write activity.__@param key       the key of the mapping to remove. Not null._@param namespace the namespace of the mapping to remove. Not null.;void remove(K key, N namespace) {_		removeEntry(key, namespace)__	};removes,the,mapping,with,the,specified,key,namespace,composite,key,from,this,map,this,method,should,be,preferred,over,link,remove,and,get,old,object,object,when,the,caller,is,not,interested,in,the,old,value,because,this,can,potentially,reduce,copy,on,write,activity,param,key,the,key,of,the,mapping,to,remove,not,null,param,namespace,the,namespace,of,the,mapping,to,remove,not,null;void,remove,k,key,n,namespace,remove,entry,key,namespace
CopyOnWriteStateTable -> void remove(K key, N namespace);1519379856;Removes the mapping with the specified key/namespace composite key from this map. This method should be preferred_over {@link #removeAndGetOld(Object, Object)} when the caller is not interested in the old value, because this_can potentially reduce copy-on-write activity.__@param key       the key of the mapping to remove. Not null._@param namespace the namespace of the mapping to remove. Not null.;void remove(K key, N namespace) {_		removeEntry(key, namespace)__	};removes,the,mapping,with,the,specified,key,namespace,composite,key,from,this,map,this,method,should,be,preferred,over,link,remove,and,get,old,object,object,when,the,caller,is,not,interested,in,the,old,value,because,this,can,potentially,reduce,copy,on,write,activity,param,key,the,key,of,the,mapping,to,remove,not,null,param,namespace,the,namespace,of,the,mapping,to,remove,not,null;void,remove,k,key,n,namespace,remove,entry,key,namespace
CopyOnWriteStateTable -> void remove(K key, N namespace);1529089579;Removes the mapping with the specified key/namespace composite key from this map. This method should be preferred_over {@link #removeAndGetOld(Object, Object)} when the caller is not interested in the old value, because this_can potentially reduce copy-on-write activity.__@param key       the key of the mapping to remove. Not null._@param namespace the namespace of the mapping to remove. Not null.;void remove(K key, N namespace) {_		removeEntry(key, namespace)__	};removes,the,mapping,with,the,specified,key,namespace,composite,key,from,this,map,this,method,should,be,preferred,over,link,remove,and,get,old,object,object,when,the,caller,is,not,interested,in,the,old,value,because,this,can,potentially,reduce,copy,on,write,activity,param,key,the,key,of,the,mapping,to,remove,not,null,param,namespace,the,namespace,of,the,mapping,to,remove,not,null;void,remove,k,key,n,namespace,remove,entry,key,namespace
CopyOnWriteStateTable -> void remove(K key, N namespace);1529089584;Removes the mapping with the specified key/namespace composite key from this map. This method should be preferred_over {@link #removeAndGetOld(Object, Object)} when the caller is not interested in the old value, because this_can potentially reduce copy-on-write activity.__@param key       the key of the mapping to remove. Not null._@param namespace the namespace of the mapping to remove. Not null.;void remove(K key, N namespace) {_		removeEntry(key, namespace)__	};removes,the,mapping,with,the,specified,key,namespace,composite,key,from,this,map,this,method,should,be,preferred,over,link,remove,and,get,old,object,object,when,the,caller,is,not,interested,in,the,old,value,because,this,can,potentially,reduce,copy,on,write,activity,param,key,the,key,of,the,mapping,to,remove,not,null,param,namespace,the,namespace,of,the,mapping,to,remove,not,null;void,remove,k,key,n,namespace,remove,entry,key,namespace
CopyOnWriteStateTable -> void remove(K key, N namespace);1529307900;Removes the mapping with the specified key/namespace composite key from this map. This method should be preferred_over {@link #removeAndGetOld(Object, Object)} when the caller is not interested in the old value, because this_can potentially reduce copy-on-write activity.__@param key       the key of the mapping to remove. Not null._@param namespace the namespace of the mapping to remove. Not null.;void remove(K key, N namespace) {_		removeEntry(key, namespace)__	};removes,the,mapping,with,the,specified,key,namespace,composite,key,from,this,map,this,method,should,be,preferred,over,link,remove,and,get,old,object,object,when,the,caller,is,not,interested,in,the,old,value,because,this,can,potentially,reduce,copy,on,write,activity,param,key,the,key,of,the,mapping,to,remove,not,null,param,namespace,the,namespace,of,the,mapping,to,remove,not,null;void,remove,k,key,n,namespace,remove,entry,key,namespace
CopyOnWriteStateTable -> void remove(K key, N namespace);1530639128;Removes the mapping with the specified key/namespace composite key from this map. This method should be preferred_over {@link #removeAndGetOld(Object, Object)} when the caller is not interested in the old value, because this_can potentially reduce copy-on-write activity.__@param key       the key of the mapping to remove. Not null._@param namespace the namespace of the mapping to remove. Not null.;void remove(K key, N namespace) {_		removeEntry(key, namespace)__	};removes,the,mapping,with,the,specified,key,namespace,composite,key,from,this,map,this,method,should,be,preferred,over,link,remove,and,get,old,object,object,when,the,caller,is,not,interested,in,the,old,value,because,this,can,potentially,reduce,copy,on,write,activity,param,key,the,key,of,the,mapping,to,remove,not,null,param,namespace,the,namespace,of,the,mapping,to,remove,not,null;void,remove,k,key,n,namespace,remove,entry,key,namespace
CopyOnWriteStateTable -> void remove(K key, N namespace);1531771917;Removes the mapping with the specified key/namespace composite key from this map. This method should be preferred_over {@link #removeAndGetOld(Object, Object)} when the caller is not interested in the old value, because this_can potentially reduce copy-on-write activity.__@param key       the key of the mapping to remove. Not null._@param namespace the namespace of the mapping to remove. Not null.;void remove(K key, N namespace) {_		removeEntry(key, namespace)__	};removes,the,mapping,with,the,specified,key,namespace,composite,key,from,this,map,this,method,should,be,preferred,over,link,remove,and,get,old,object,object,when,the,caller,is,not,interested,in,the,old,value,because,this,can,potentially,reduce,copy,on,write,activity,param,key,the,key,of,the,mapping,to,remove,not,null,param,namespace,the,namespace,of,the,mapping,to,remove,not,null;void,remove,k,key,n,namespace,remove,entry,key,namespace
CopyOnWriteStateTable -> void remove(K key, N namespace);1548755874;Removes the mapping with the specified key/namespace composite key from this map. This method should be preferred_over {@link #removeAndGetOld(Object, Object)} when the caller is not interested in the old value, because this_can potentially reduce copy-on-write activity.__@param key       the key of the mapping to remove. Not null._@param namespace the namespace of the mapping to remove. Not null.;void remove(K key, N namespace) {_		removeEntry(key, namespace)__	};removes,the,mapping,with,the,specified,key,namespace,composite,key,from,this,map,this,method,should,be,preferred,over,link,remove,and,get,old,object,object,when,the,caller,is,not,interested,in,the,old,value,because,this,can,potentially,reduce,copy,on,write,activity,param,key,the,key,of,the,mapping,to,remove,not,null,param,namespace,the,namespace,of,the,mapping,to,remove,not,null;void,remove,k,key,n,namespace,remove,entry,key,namespace
CopyOnWriteStateTable -> private StateTableEntry<K, N, S>[] selectActiveTable(int hashCode);1489685642;Select the sub-table which is responsible for entries with the given hash code.__@param hashCode the hash code which we use to decide about the table that is responsible._@return the index of the sub-table that is responsible for the entry with the given hash code.;private StateTableEntry<K, N, S>[] selectActiveTable(int hashCode) {_		return (hashCode & (primaryTable.length - 1)) >= rehashIndex ? primaryTable : incrementalRehashTable__	};select,the,sub,table,which,is,responsible,for,entries,with,the,given,hash,code,param,hash,code,the,hash,code,which,we,use,to,decide,about,the,table,that,is,responsible,return,the,index,of,the,sub,table,that,is,responsible,for,the,entry,with,the,given,hash,code;private,state,table,entry,k,n,s,select,active,table,int,hash,code,return,hash,code,primary,table,length,1,rehash,index,primary,table,incremental,rehash,table
CopyOnWriteStateTable -> private StateTableEntry<K, N, S>[] selectActiveTable(int hashCode);1494180263;Select the sub-table which is responsible for entries with the given hash code.__@param hashCode the hash code which we use to decide about the table that is responsible._@return the index of the sub-table that is responsible for the entry with the given hash code.;private StateTableEntry<K, N, S>[] selectActiveTable(int hashCode) {_		return (hashCode & (primaryTable.length - 1)) >= rehashIndex ? primaryTable : incrementalRehashTable__	};select,the,sub,table,which,is,responsible,for,entries,with,the,given,hash,code,param,hash,code,the,hash,code,which,we,use,to,decide,about,the,table,that,is,responsible,return,the,index,of,the,sub,table,that,is,responsible,for,the,entry,with,the,given,hash,code;private,state,table,entry,k,n,s,select,active,table,int,hash,code,return,hash,code,primary,table,length,1,rehash,index,primary,table,incremental,rehash,table
CopyOnWriteStateTable -> private StateTableEntry<K, N, S>[] selectActiveTable(int hashCode);1506609393;Select the sub-table which is responsible for entries with the given hash code.__@param hashCode the hash code which we use to decide about the table that is responsible._@return the index of the sub-table that is responsible for the entry with the given hash code.;private StateTableEntry<K, N, S>[] selectActiveTable(int hashCode) {_		return (hashCode & (primaryTable.length - 1)) >= rehashIndex ? primaryTable : incrementalRehashTable__	};select,the,sub,table,which,is,responsible,for,entries,with,the,given,hash,code,param,hash,code,the,hash,code,which,we,use,to,decide,about,the,table,that,is,responsible,return,the,index,of,the,sub,table,that,is,responsible,for,the,entry,with,the,given,hash,code;private,state,table,entry,k,n,s,select,active,table,int,hash,code,return,hash,code,primary,table,length,1,rehash,index,primary,table,incremental,rehash,table
CopyOnWriteStateTable -> private StateTableEntry<K, N, S>[] selectActiveTable(int hashCode);1519379856;Select the sub-table which is responsible for entries with the given hash code.__@param hashCode the hash code which we use to decide about the table that is responsible._@return the index of the sub-table that is responsible for the entry with the given hash code.;private StateTableEntry<K, N, S>[] selectActiveTable(int hashCode) {_		return (hashCode & (primaryTable.length - 1)) >= rehashIndex ? primaryTable : incrementalRehashTable__	};select,the,sub,table,which,is,responsible,for,entries,with,the,given,hash,code,param,hash,code,the,hash,code,which,we,use,to,decide,about,the,table,that,is,responsible,return,the,index,of,the,sub,table,that,is,responsible,for,the,entry,with,the,given,hash,code;private,state,table,entry,k,n,s,select,active,table,int,hash,code,return,hash,code,primary,table,length,1,rehash,index,primary,table,incremental,rehash,table
CopyOnWriteStateTable -> private StateTableEntry<K, N, S>[] selectActiveTable(int hashCode);1529089579;Select the sub-table which is responsible for entries with the given hash code.__@param hashCode the hash code which we use to decide about the table that is responsible._@return the index of the sub-table that is responsible for the entry with the given hash code.;private StateTableEntry<K, N, S>[] selectActiveTable(int hashCode) {_		return (hashCode & (primaryTable.length - 1)) >= rehashIndex ? primaryTable : incrementalRehashTable__	};select,the,sub,table,which,is,responsible,for,entries,with,the,given,hash,code,param,hash,code,the,hash,code,which,we,use,to,decide,about,the,table,that,is,responsible,return,the,index,of,the,sub,table,that,is,responsible,for,the,entry,with,the,given,hash,code;private,state,table,entry,k,n,s,select,active,table,int,hash,code,return,hash,code,primary,table,length,1,rehash,index,primary,table,incremental,rehash,table
CopyOnWriteStateTable -> private StateTableEntry<K, N, S>[] selectActiveTable(int hashCode);1529089584;Select the sub-table which is responsible for entries with the given hash code.__@param hashCode the hash code which we use to decide about the table that is responsible._@return the index of the sub-table that is responsible for the entry with the given hash code.;private StateTableEntry<K, N, S>[] selectActiveTable(int hashCode) {_		return (hashCode & (primaryTable.length - 1)) >= rehashIndex ? primaryTable : incrementalRehashTable__	};select,the,sub,table,which,is,responsible,for,entries,with,the,given,hash,code,param,hash,code,the,hash,code,which,we,use,to,decide,about,the,table,that,is,responsible,return,the,index,of,the,sub,table,that,is,responsible,for,the,entry,with,the,given,hash,code;private,state,table,entry,k,n,s,select,active,table,int,hash,code,return,hash,code,primary,table,length,1,rehash,index,primary,table,incremental,rehash,table
CopyOnWriteStateTable -> private StateTableEntry<K, N, S>[] selectActiveTable(int hashCode);1529307900;Select the sub-table which is responsible for entries with the given hash code.__@param hashCode the hash code which we use to decide about the table that is responsible._@return the index of the sub-table that is responsible for the entry with the given hash code.;private StateTableEntry<K, N, S>[] selectActiveTable(int hashCode) {_		return (hashCode & (primaryTable.length - 1)) >= rehashIndex ? primaryTable : incrementalRehashTable__	};select,the,sub,table,which,is,responsible,for,entries,with,the,given,hash,code,param,hash,code,the,hash,code,which,we,use,to,decide,about,the,table,that,is,responsible,return,the,index,of,the,sub,table,that,is,responsible,for,the,entry,with,the,given,hash,code;private,state,table,entry,k,n,s,select,active,table,int,hash,code,return,hash,code,primary,table,length,1,rehash,index,primary,table,incremental,rehash,table
CopyOnWriteStateTable -> private StateTableEntry<K, N, S>[] selectActiveTable(int hashCode);1530639128;Select the sub-table which is responsible for entries with the given hash code.__@param hashCode the hash code which we use to decide about the table that is responsible._@return the index of the sub-table that is responsible for the entry with the given hash code.;private StateTableEntry<K, N, S>[] selectActiveTable(int hashCode) {_		return (hashCode & (primaryTable.length - 1)) >= rehashIndex ? primaryTable : incrementalRehashTable__	};select,the,sub,table,which,is,responsible,for,entries,with,the,given,hash,code,param,hash,code,the,hash,code,which,we,use,to,decide,about,the,table,that,is,responsible,return,the,index,of,the,sub,table,that,is,responsible,for,the,entry,with,the,given,hash,code;private,state,table,entry,k,n,s,select,active,table,int,hash,code,return,hash,code,primary,table,length,1,rehash,index,primary,table,incremental,rehash,table
CopyOnWriteStateTable -> private StateTableEntry<K, N, S>[] selectActiveTable(int hashCode);1531771917;Select the sub-table which is responsible for entries with the given hash code.__@param hashCode the hash code which we use to decide about the table that is responsible._@return the index of the sub-table that is responsible for the entry with the given hash code.;private StateTableEntry<K, N, S>[] selectActiveTable(int hashCode) {_		return (hashCode & (primaryTable.length - 1)) >= rehashIndex ? primaryTable : incrementalRehashTable__	};select,the,sub,table,which,is,responsible,for,entries,with,the,given,hash,code,param,hash,code,the,hash,code,which,we,use,to,decide,about,the,table,that,is,responsible,return,the,index,of,the,sub,table,that,is,responsible,for,the,entry,with,the,given,hash,code;private,state,table,entry,k,n,s,select,active,table,int,hash,code,return,hash,code,primary,table,length,1,rehash,index,primary,table,incremental,rehash,table
CopyOnWriteStateTable -> private StateTableEntry<K, N, S>[] selectActiveTable(int hashCode);1548755874;Select the sub-table which is responsible for entries with the given hash code.__@param hashCode the hash code which we use to decide about the table that is responsible._@return the index of the sub-table that is responsible for the entry with the given hash code.;private StateTableEntry<K, N, S>[] selectActiveTable(int hashCode) {_		return (hashCode & (primaryTable.length - 1)) >= rehashIndex ? primaryTable : incrementalRehashTable__	};select,the,sub,table,which,is,responsible,for,entries,with,the,given,hash,code,param,hash,code,the,hash,code,which,we,use,to,decide,about,the,table,that,is,responsible,return,the,index,of,the,sub,table,that,is,responsible,for,the,entry,with,the,given,hash,code;private,state,table,entry,k,n,s,select,active,table,int,hash,code,return,hash,code,primary,table,length,1,rehash,index,primary,table,incremental,rehash,table
CopyOnWriteStateTable -> @Override 	public int size();1489685642;Returns the total number of entries in this {@link CopyOnWriteStateTable}. This is the sum of both sub-tables.__@return the number of entries in this {@link CopyOnWriteStateTable}.;@Override_	public int size() {_		return primaryTableSize + incrementalRehashTableSize__	};returns,the,total,number,of,entries,in,this,link,copy,on,write,state,table,this,is,the,sum,of,both,sub,tables,return,the,number,of,entries,in,this,link,copy,on,write,state,table;override,public,int,size,return,primary,table,size,incremental,rehash,table,size
CopyOnWriteStateTable -> @Override 	public int size();1494180263;Returns the total number of entries in this {@link CopyOnWriteStateTable}. This is the sum of both sub-tables.__@return the number of entries in this {@link CopyOnWriteStateTable}.;@Override_	public int size() {_		return primaryTableSize + incrementalRehashTableSize__	};returns,the,total,number,of,entries,in,this,link,copy,on,write,state,table,this,is,the,sum,of,both,sub,tables,return,the,number,of,entries,in,this,link,copy,on,write,state,table;override,public,int,size,return,primary,table,size,incremental,rehash,table,size
CopyOnWriteStateTable -> @Override 	public int size();1506609393;Returns the total number of entries in this {@link CopyOnWriteStateTable}. This is the sum of both sub-tables.__@return the number of entries in this {@link CopyOnWriteStateTable}.;@Override_	public int size() {_		return primaryTableSize + incrementalRehashTableSize__	};returns,the,total,number,of,entries,in,this,link,copy,on,write,state,table,this,is,the,sum,of,both,sub,tables,return,the,number,of,entries,in,this,link,copy,on,write,state,table;override,public,int,size,return,primary,table,size,incremental,rehash,table,size
CopyOnWriteStateTable -> @Override 	public int size();1519379856;Returns the total number of entries in this {@link CopyOnWriteStateTable}. This is the sum of both sub-tables.__@return the number of entries in this {@link CopyOnWriteStateTable}.;@Override_	public int size() {_		return primaryTableSize + incrementalRehashTableSize__	};returns,the,total,number,of,entries,in,this,link,copy,on,write,state,table,this,is,the,sum,of,both,sub,tables,return,the,number,of,entries,in,this,link,copy,on,write,state,table;override,public,int,size,return,primary,table,size,incremental,rehash,table,size
CopyOnWriteStateTable -> @Override 	public int size();1529089579;Returns the total number of entries in this {@link CopyOnWriteStateTable}. This is the sum of both sub-tables.__@return the number of entries in this {@link CopyOnWriteStateTable}.;@Override_	public int size() {_		return primaryTableSize + incrementalRehashTableSize__	};returns,the,total,number,of,entries,in,this,link,copy,on,write,state,table,this,is,the,sum,of,both,sub,tables,return,the,number,of,entries,in,this,link,copy,on,write,state,table;override,public,int,size,return,primary,table,size,incremental,rehash,table,size
CopyOnWriteStateTable -> @Override 	public int size();1529089584;Returns the total number of entries in this {@link CopyOnWriteStateTable}. This is the sum of both sub-tables.__@return the number of entries in this {@link CopyOnWriteStateTable}.;@Override_	public int size() {_		return primaryTableSize + incrementalRehashTableSize__	};returns,the,total,number,of,entries,in,this,link,copy,on,write,state,table,this,is,the,sum,of,both,sub,tables,return,the,number,of,entries,in,this,link,copy,on,write,state,table;override,public,int,size,return,primary,table,size,incremental,rehash,table,size
CopyOnWriteStateTable -> @Override 	public int size();1529307900;Returns the total number of entries in this {@link CopyOnWriteStateTable}. This is the sum of both sub-tables.__@return the number of entries in this {@link CopyOnWriteStateTable}.;@Override_	public int size() {_		return primaryTableSize + incrementalRehashTableSize__	};returns,the,total,number,of,entries,in,this,link,copy,on,write,state,table,this,is,the,sum,of,both,sub,tables,return,the,number,of,entries,in,this,link,copy,on,write,state,table;override,public,int,size,return,primary,table,size,incremental,rehash,table,size
CopyOnWriteStateTable -> @Override 	public int size();1530639128;Returns the total number of entries in this {@link CopyOnWriteStateTable}. This is the sum of both sub-tables.__@return the number of entries in this {@link CopyOnWriteStateTable}.;@Override_	public int size() {_		return primaryTableSize + incrementalRehashTableSize__	};returns,the,total,number,of,entries,in,this,link,copy,on,write,state,table,this,is,the,sum,of,both,sub,tables,return,the,number,of,entries,in,this,link,copy,on,write,state,table;override,public,int,size,return,primary,table,size,incremental,rehash,table,size
CopyOnWriteStateTable -> @Override 	public int size();1531771917;Returns the total number of entries in this {@link CopyOnWriteStateTable}. This is the sum of both sub-tables.__@return the number of entries in this {@link CopyOnWriteStateTable}.;@Override_	public int size() {_		return primaryTableSize + incrementalRehashTableSize__	};returns,the,total,number,of,entries,in,this,link,copy,on,write,state,table,this,is,the,sum,of,both,sub,tables,return,the,number,of,entries,in,this,link,copy,on,write,state,table;override,public,int,size,return,primary,table,size,incremental,rehash,table,size
CopyOnWriteStateTable -> @Override 	public int size();1548755874;Returns the total number of entries in this {@link CopyOnWriteStateTable}. This is the sum of both sub-tables.__@return the number of entries in this {@link CopyOnWriteStateTable}.;@Override_	public int size() {_		return primaryTableSize + incrementalRehashTableSize__	};returns,the,total,number,of,entries,in,this,link,copy,on,write,state,table,this,is,the,sum,of,both,sub,tables,return,the,number,of,entries,in,this,link,copy,on,write,state,table;override,public,int,size,return,primary,table,size,incremental,rehash,table,size
CopyOnWriteStateTable -> private static int compositeHash(Object key, Object namespace);1489685642;Helper function that creates and scrambles a composite hash for key and namespace.;private static int compositeHash(Object key, Object namespace) {_		_		return MathUtils.bitMix(key.hashCode() ^ namespace.hashCode())__	};helper,function,that,creates,and,scrambles,a,composite,hash,for,key,and,namespace;private,static,int,composite,hash,object,key,object,namespace,return,math,utils,bit,mix,key,hash,code,namespace,hash,code
CopyOnWriteStateTable -> private static int compositeHash(Object key, Object namespace);1494180263;Helper function that creates and scrambles a composite hash for key and namespace.;private static int compositeHash(Object key, Object namespace) {_		_		return MathUtils.bitMix(key.hashCode() ^ namespace.hashCode())__	};helper,function,that,creates,and,scrambles,a,composite,hash,for,key,and,namespace;private,static,int,composite,hash,object,key,object,namespace,return,math,utils,bit,mix,key,hash,code,namespace,hash,code
CopyOnWriteStateTable -> private static int compositeHash(Object key, Object namespace);1506609393;Helper function that creates and scrambles a composite hash for key and namespace.;private static int compositeHash(Object key, Object namespace) {_		_		return MathUtils.bitMix(key.hashCode() ^ namespace.hashCode())__	};helper,function,that,creates,and,scrambles,a,composite,hash,for,key,and,namespace;private,static,int,composite,hash,object,key,object,namespace,return,math,utils,bit,mix,key,hash,code,namespace,hash,code
CopyOnWriteStateTable -> private static int compositeHash(Object key, Object namespace);1519379856;Helper function that creates and scrambles a composite hash for key and namespace.;private static int compositeHash(Object key, Object namespace) {_		_		return MathUtils.bitMix(key.hashCode() ^ namespace.hashCode())__	};helper,function,that,creates,and,scrambles,a,composite,hash,for,key,and,namespace;private,static,int,composite,hash,object,key,object,namespace,return,math,utils,bit,mix,key,hash,code,namespace,hash,code
CopyOnWriteStateTable -> private static int compositeHash(Object key, Object namespace);1529089579;Helper function that creates and scrambles a composite hash for key and namespace.;private static int compositeHash(Object key, Object namespace) {_		_		return MathUtils.bitMix(key.hashCode() ^ namespace.hashCode())__	};helper,function,that,creates,and,scrambles,a,composite,hash,for,key,and,namespace;private,static,int,composite,hash,object,key,object,namespace,return,math,utils,bit,mix,key,hash,code,namespace,hash,code
CopyOnWriteStateTable -> private static int compositeHash(Object key, Object namespace);1529089584;Helper function that creates and scrambles a composite hash for key and namespace.;private static int compositeHash(Object key, Object namespace) {_		_		return MathUtils.bitMix(key.hashCode() ^ namespace.hashCode())__	};helper,function,that,creates,and,scrambles,a,composite,hash,for,key,and,namespace;private,static,int,composite,hash,object,key,object,namespace,return,math,utils,bit,mix,key,hash,code,namespace,hash,code
CopyOnWriteStateTable -> private static int compositeHash(Object key, Object namespace);1529307900;Helper function that creates and scrambles a composite hash for key and namespace.;private static int compositeHash(Object key, Object namespace) {_		_		return MathUtils.bitMix(key.hashCode() ^ namespace.hashCode())__	};helper,function,that,creates,and,scrambles,a,composite,hash,for,key,and,namespace;private,static,int,composite,hash,object,key,object,namespace,return,math,utils,bit,mix,key,hash,code,namespace,hash,code
CopyOnWriteStateTable -> private static int compositeHash(Object key, Object namespace);1530639128;Helper function that creates and scrambles a composite hash for key and namespace.;private static int compositeHash(Object key, Object namespace) {_		_		return MathUtils.bitMix(key.hashCode() ^ namespace.hashCode())__	};helper,function,that,creates,and,scrambles,a,composite,hash,for,key,and,namespace;private,static,int,composite,hash,object,key,object,namespace,return,math,utils,bit,mix,key,hash,code,namespace,hash,code
CopyOnWriteStateTable -> private static int compositeHash(Object key, Object namespace);1531771917;Helper function that creates and scrambles a composite hash for key and namespace.;private static int compositeHash(Object key, Object namespace) {_		_		return MathUtils.bitMix(key.hashCode() ^ namespace.hashCode())__	};helper,function,that,creates,and,scrambles,a,composite,hash,for,key,and,namespace;private,static,int,composite,hash,object,key,object,namespace,return,math,utils,bit,mix,key,hash,code,namespace,hash,code
CopyOnWriteStateTable -> private static int compositeHash(Object key, Object namespace);1548755874;Helper function that creates and scrambles a composite hash for key and namespace.;private static int compositeHash(Object key, Object namespace) {_		_		return MathUtils.bitMix(key.hashCode() ^ namespace.hashCode())__	};helper,function,that,creates,and,scrambles,a,composite,hash,for,key,and,namespace;private,static,int,composite,hash,object,key,object,namespace,return,math,utils,bit,mix,key,hash,code,namespace,hash,code
CopyOnWriteStateTable -> @Nonnull 	@Override 	public CopyOnWriteStateTableSnapshot<K, N, S> stateSnapshot();1531771917;Creates a snapshot of this {@link CopyOnWriteStateTable}, to be written in checkpointing. The snapshot integrity_is protected through copy-on-write from the {@link CopyOnWriteStateTable}. Users should call_{@link #releaseSnapshot(CopyOnWriteStateTableSnapshot)} after using the returned object.__@return a snapshot from this {@link CopyOnWriteStateTable}, for checkpointing.;@Nonnull_	@Override_	public CopyOnWriteStateTableSnapshot<K, N, S> stateSnapshot() {_		return new CopyOnWriteStateTableSnapshot<>(this)__	};creates,a,snapshot,of,this,link,copy,on,write,state,table,to,be,written,in,checkpointing,the,snapshot,integrity,is,protected,through,copy,on,write,from,the,link,copy,on,write,state,table,users,should,call,link,release,snapshot,copy,on,write,state,table,snapshot,after,using,the,returned,object,return,a,snapshot,from,this,link,copy,on,write,state,table,for,checkpointing;nonnull,override,public,copy,on,write,state,table,snapshot,k,n,s,state,snapshot,return,new,copy,on,write,state,table,snapshot,this
CopyOnWriteStateTable -> @Nonnull 	@Override 	public CopyOnWriteStateTableSnapshot<K, N, S> stateSnapshot();1548755874;Creates a snapshot of this {@link CopyOnWriteStateTable}, to be written in checkpointing. The snapshot integrity_is protected through copy-on-write from the {@link CopyOnWriteStateTable}. Users should call_{@link #releaseSnapshot(CopyOnWriteStateTableSnapshot)} after using the returned object.__@return a snapshot from this {@link CopyOnWriteStateTable}, for checkpointing.;@Nonnull_	@Override_	public CopyOnWriteStateTableSnapshot<K, N, S> stateSnapshot() {_		return new CopyOnWriteStateTableSnapshot<>(this)__	};creates,a,snapshot,of,this,link,copy,on,write,state,table,to,be,written,in,checkpointing,the,snapshot,integrity,is,protected,through,copy,on,write,from,the,link,copy,on,write,state,table,users,should,call,link,release,snapshot,copy,on,write,state,table,snapshot,after,using,the,returned,object,return,a,snapshot,from,this,link,copy,on,write,state,table,for,checkpointing;nonnull,override,public,copy,on,write,state,table,snapshot,k,n,s,state,snapshot,return,new,copy,on,write,state,table,snapshot,this
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> putEntry(K key, N namespace);1489685642;Helper method that is the basis for operations that add mappings.;private StateTableEntry<K, N, S> putEntry(K key, N namespace) {__		final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace)__		final StateTableEntry<K, N, S>[] tab = selectActiveTable(hash)__		int index = hash & (tab.length - 1)___		for (StateTableEntry<K, N, S> e = tab[index]_ e != null_ e = e.next) {_			if (e.hash == hash && key.equals(e.key) && namespace.equals(e.namespace)) {__				_				if (e.entryVersion < highestRequiredSnapshotVersion) {_					e = handleChainedEntryCopyOnWrite(tab, index, e)__				}__				return e__			}_		}__		++modCount__		if (size() > threshold) {_			doubleCapacity()__		}__		return addNewStateTableEntry(tab, key, namespace, hash)__	};helper,method,that,is,the,basis,for,operations,that,add,mappings;private,state,table,entry,k,n,s,put,entry,k,key,n,namespace,final,int,hash,compute,hash,for,operation,and,do,incremental,rehash,key,namespace,final,state,table,entry,k,n,s,tab,select,active,table,hash,int,index,hash,tab,length,1,for,state,table,entry,k,n,s,e,tab,index,e,null,e,e,next,if,e,hash,hash,key,equals,e,key,namespace,equals,e,namespace,if,e,entry,version,highest,required,snapshot,version,e,handle,chained,entry,copy,on,write,tab,index,e,return,e,mod,count,if,size,threshold,double,capacity,return,add,new,state,table,entry,tab,key,namespace,hash
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> putEntry(K key, N namespace);1494180263;Helper method that is the basis for operations that add mappings.;private StateTableEntry<K, N, S> putEntry(K key, N namespace) {__		final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace)__		final StateTableEntry<K, N, S>[] tab = selectActiveTable(hash)__		int index = hash & (tab.length - 1)___		for (StateTableEntry<K, N, S> e = tab[index]_ e != null_ e = e.next) {_			if (e.hash == hash && key.equals(e.key) && namespace.equals(e.namespace)) {__				_				if (e.entryVersion < highestRequiredSnapshotVersion) {_					e = handleChainedEntryCopyOnWrite(tab, index, e)__				}__				return e__			}_		}__		++modCount__		if (size() > threshold) {_			doubleCapacity()__		}__		return addNewStateTableEntry(tab, key, namespace, hash)__	};helper,method,that,is,the,basis,for,operations,that,add,mappings;private,state,table,entry,k,n,s,put,entry,k,key,n,namespace,final,int,hash,compute,hash,for,operation,and,do,incremental,rehash,key,namespace,final,state,table,entry,k,n,s,tab,select,active,table,hash,int,index,hash,tab,length,1,for,state,table,entry,k,n,s,e,tab,index,e,null,e,e,next,if,e,hash,hash,key,equals,e,key,namespace,equals,e,namespace,if,e,entry,version,highest,required,snapshot,version,e,handle,chained,entry,copy,on,write,tab,index,e,return,e,mod,count,if,size,threshold,double,capacity,return,add,new,state,table,entry,tab,key,namespace,hash
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> putEntry(K key, N namespace);1506609393;Helper method that is the basis for operations that add mappings.;private StateTableEntry<K, N, S> putEntry(K key, N namespace) {__		final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace)__		final StateTableEntry<K, N, S>[] tab = selectActiveTable(hash)__		int index = hash & (tab.length - 1)___		for (StateTableEntry<K, N, S> e = tab[index]_ e != null_ e = e.next) {_			if (e.hash == hash && key.equals(e.key) && namespace.equals(e.namespace)) {__				_				if (e.entryVersion < highestRequiredSnapshotVersion) {_					e = handleChainedEntryCopyOnWrite(tab, index, e)__				}__				return e__			}_		}__		++modCount__		if (size() > threshold) {_			doubleCapacity()__		}__		return addNewStateTableEntry(tab, key, namespace, hash)__	};helper,method,that,is,the,basis,for,operations,that,add,mappings;private,state,table,entry,k,n,s,put,entry,k,key,n,namespace,final,int,hash,compute,hash,for,operation,and,do,incremental,rehash,key,namespace,final,state,table,entry,k,n,s,tab,select,active,table,hash,int,index,hash,tab,length,1,for,state,table,entry,k,n,s,e,tab,index,e,null,e,e,next,if,e,hash,hash,key,equals,e,key,namespace,equals,e,namespace,if,e,entry,version,highest,required,snapshot,version,e,handle,chained,entry,copy,on,write,tab,index,e,return,e,mod,count,if,size,threshold,double,capacity,return,add,new,state,table,entry,tab,key,namespace,hash
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> putEntry(K key, N namespace);1519379856;Helper method that is the basis for operations that add mappings.;private StateTableEntry<K, N, S> putEntry(K key, N namespace) {__		final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace)__		final StateTableEntry<K, N, S>[] tab = selectActiveTable(hash)__		int index = hash & (tab.length - 1)___		for (StateTableEntry<K, N, S> e = tab[index]_ e != null_ e = e.next) {_			if (e.hash == hash && key.equals(e.key) && namespace.equals(e.namespace)) {__				_				if (e.entryVersion < highestRequiredSnapshotVersion) {_					e = handleChainedEntryCopyOnWrite(tab, index, e)__				}__				return e__			}_		}__		++modCount__		if (size() > threshold) {_			doubleCapacity()__		}__		return addNewStateTableEntry(tab, key, namespace, hash)__	};helper,method,that,is,the,basis,for,operations,that,add,mappings;private,state,table,entry,k,n,s,put,entry,k,key,n,namespace,final,int,hash,compute,hash,for,operation,and,do,incremental,rehash,key,namespace,final,state,table,entry,k,n,s,tab,select,active,table,hash,int,index,hash,tab,length,1,for,state,table,entry,k,n,s,e,tab,index,e,null,e,e,next,if,e,hash,hash,key,equals,e,key,namespace,equals,e,namespace,if,e,entry,version,highest,required,snapshot,version,e,handle,chained,entry,copy,on,write,tab,index,e,return,e,mod,count,if,size,threshold,double,capacity,return,add,new,state,table,entry,tab,key,namespace,hash
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> putEntry(K key, N namespace);1529089579;Helper method that is the basis for operations that add mappings.;private StateTableEntry<K, N, S> putEntry(K key, N namespace) {__		final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace)__		final StateTableEntry<K, N, S>[] tab = selectActiveTable(hash)__		int index = hash & (tab.length - 1)___		for (StateTableEntry<K, N, S> e = tab[index]_ e != null_ e = e.next) {_			if (e.hash == hash && key.equals(e.key) && namespace.equals(e.namespace)) {__				_				if (e.entryVersion < highestRequiredSnapshotVersion) {_					e = handleChainedEntryCopyOnWrite(tab, index, e)__				}__				return e__			}_		}__		++modCount__		if (size() > threshold) {_			doubleCapacity()__		}__		return addNewStateTableEntry(tab, key, namespace, hash)__	};helper,method,that,is,the,basis,for,operations,that,add,mappings;private,state,table,entry,k,n,s,put,entry,k,key,n,namespace,final,int,hash,compute,hash,for,operation,and,do,incremental,rehash,key,namespace,final,state,table,entry,k,n,s,tab,select,active,table,hash,int,index,hash,tab,length,1,for,state,table,entry,k,n,s,e,tab,index,e,null,e,e,next,if,e,hash,hash,key,equals,e,key,namespace,equals,e,namespace,if,e,entry,version,highest,required,snapshot,version,e,handle,chained,entry,copy,on,write,tab,index,e,return,e,mod,count,if,size,threshold,double,capacity,return,add,new,state,table,entry,tab,key,namespace,hash
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> putEntry(K key, N namespace);1529089584;Helper method that is the basis for operations that add mappings.;private StateTableEntry<K, N, S> putEntry(K key, N namespace) {__		final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace)__		final StateTableEntry<K, N, S>[] tab = selectActiveTable(hash)__		int index = hash & (tab.length - 1)___		for (StateTableEntry<K, N, S> e = tab[index]_ e != null_ e = e.next) {_			if (e.hash == hash && key.equals(e.key) && namespace.equals(e.namespace)) {__				_				if (e.entryVersion < highestRequiredSnapshotVersion) {_					e = handleChainedEntryCopyOnWrite(tab, index, e)__				}__				return e__			}_		}__		++modCount__		if (size() > threshold) {_			doubleCapacity()__		}__		return addNewStateTableEntry(tab, key, namespace, hash)__	};helper,method,that,is,the,basis,for,operations,that,add,mappings;private,state,table,entry,k,n,s,put,entry,k,key,n,namespace,final,int,hash,compute,hash,for,operation,and,do,incremental,rehash,key,namespace,final,state,table,entry,k,n,s,tab,select,active,table,hash,int,index,hash,tab,length,1,for,state,table,entry,k,n,s,e,tab,index,e,null,e,e,next,if,e,hash,hash,key,equals,e,key,namespace,equals,e,namespace,if,e,entry,version,highest,required,snapshot,version,e,handle,chained,entry,copy,on,write,tab,index,e,return,e,mod,count,if,size,threshold,double,capacity,return,add,new,state,table,entry,tab,key,namespace,hash
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> putEntry(K key, N namespace);1529307900;Helper method that is the basis for operations that add mappings.;private StateTableEntry<K, N, S> putEntry(K key, N namespace) {__		final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace)__		final StateTableEntry<K, N, S>[] tab = selectActiveTable(hash)__		int index = hash & (tab.length - 1)___		for (StateTableEntry<K, N, S> e = tab[index]_ e != null_ e = e.next) {_			if (e.hash == hash && key.equals(e.key) && namespace.equals(e.namespace)) {__				_				if (e.entryVersion < highestRequiredSnapshotVersion) {_					e = handleChainedEntryCopyOnWrite(tab, index, e)__				}__				return e__			}_		}__		++modCount__		if (size() > threshold) {_			doubleCapacity()__		}__		return addNewStateTableEntry(tab, key, namespace, hash)__	};helper,method,that,is,the,basis,for,operations,that,add,mappings;private,state,table,entry,k,n,s,put,entry,k,key,n,namespace,final,int,hash,compute,hash,for,operation,and,do,incremental,rehash,key,namespace,final,state,table,entry,k,n,s,tab,select,active,table,hash,int,index,hash,tab,length,1,for,state,table,entry,k,n,s,e,tab,index,e,null,e,e,next,if,e,hash,hash,key,equals,e,key,namespace,equals,e,namespace,if,e,entry,version,highest,required,snapshot,version,e,handle,chained,entry,copy,on,write,tab,index,e,return,e,mod,count,if,size,threshold,double,capacity,return,add,new,state,table,entry,tab,key,namespace,hash
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> putEntry(K key, N namespace);1530639128;Helper method that is the basis for operations that add mappings.;private StateTableEntry<K, N, S> putEntry(K key, N namespace) {__		final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace)__		final StateTableEntry<K, N, S>[] tab = selectActiveTable(hash)__		int index = hash & (tab.length - 1)___		for (StateTableEntry<K, N, S> e = tab[index]_ e != null_ e = e.next) {_			if (e.hash == hash && key.equals(e.key) && namespace.equals(e.namespace)) {__				_				if (e.entryVersion < highestRequiredSnapshotVersion) {_					e = handleChainedEntryCopyOnWrite(tab, index, e)__				}__				return e__			}_		}__		++modCount__		if (size() > threshold) {_			doubleCapacity()__		}__		return addNewStateTableEntry(tab, key, namespace, hash)__	};helper,method,that,is,the,basis,for,operations,that,add,mappings;private,state,table,entry,k,n,s,put,entry,k,key,n,namespace,final,int,hash,compute,hash,for,operation,and,do,incremental,rehash,key,namespace,final,state,table,entry,k,n,s,tab,select,active,table,hash,int,index,hash,tab,length,1,for,state,table,entry,k,n,s,e,tab,index,e,null,e,e,next,if,e,hash,hash,key,equals,e,key,namespace,equals,e,namespace,if,e,entry,version,highest,required,snapshot,version,e,handle,chained,entry,copy,on,write,tab,index,e,return,e,mod,count,if,size,threshold,double,capacity,return,add,new,state,table,entry,tab,key,namespace,hash
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> putEntry(K key, N namespace);1531771917;Helper method that is the basis for operations that add mappings.;private StateTableEntry<K, N, S> putEntry(K key, N namespace) {__		final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace)__		final StateTableEntry<K, N, S>[] tab = selectActiveTable(hash)__		int index = hash & (tab.length - 1)___		for (StateTableEntry<K, N, S> e = tab[index]_ e != null_ e = e.next) {_			if (e.hash == hash && key.equals(e.key) && namespace.equals(e.namespace)) {__				_				if (e.entryVersion < highestRequiredSnapshotVersion) {_					e = handleChainedEntryCopyOnWrite(tab, index, e)__				}__				return e__			}_		}__		++modCount__		if (size() > threshold) {_			doubleCapacity()__		}__		return addNewStateTableEntry(tab, key, namespace, hash)__	};helper,method,that,is,the,basis,for,operations,that,add,mappings;private,state,table,entry,k,n,s,put,entry,k,key,n,namespace,final,int,hash,compute,hash,for,operation,and,do,incremental,rehash,key,namespace,final,state,table,entry,k,n,s,tab,select,active,table,hash,int,index,hash,tab,length,1,for,state,table,entry,k,n,s,e,tab,index,e,null,e,e,next,if,e,hash,hash,key,equals,e,key,namespace,equals,e,namespace,if,e,entry,version,highest,required,snapshot,version,e,handle,chained,entry,copy,on,write,tab,index,e,return,e,mod,count,if,size,threshold,double,capacity,return,add,new,state,table,entry,tab,key,namespace,hash
CopyOnWriteStateTable -> private StateTableEntry<K, N, S> putEntry(K key, N namespace);1548755874;Helper method that is the basis for operations that add mappings.;private StateTableEntry<K, N, S> putEntry(K key, N namespace) {__		final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace)__		final StateTableEntry<K, N, S>[] tab = selectActiveTable(hash)__		int index = hash & (tab.length - 1)___		for (StateTableEntry<K, N, S> e = tab[index]_ e != null_ e = e.next) {_			if (e.hash == hash && key.equals(e.key) && namespace.equals(e.namespace)) {__				_				if (e.entryVersion < highestRequiredSnapshotVersion) {_					e = handleChainedEntryCopyOnWrite(tab, index, e)__				}__				return e__			}_		}__		++modCount__		if (size() > threshold) {_			doubleCapacity()__		}__		return addNewStateTableEntry(tab, key, namespace, hash)__	};helper,method,that,is,the,basis,for,operations,that,add,mappings;private,state,table,entry,k,n,s,put,entry,k,key,n,namespace,final,int,hash,compute,hash,for,operation,and,do,incremental,rehash,key,namespace,final,state,table,entry,k,n,s,tab,select,active,table,hash,int,index,hash,tab,length,1,for,state,table,entry,k,n,s,e,tab,index,e,null,e,e,next,if,e,hash,hash,key,equals,e,key,namespace,equals,e,namespace,if,e,entry,version,highest,required,snapshot,version,e,handle,chained,entry,copy,on,write,tab,index,e,return,e,mod,count,if,size,threshold,double,capacity,return,add,new,state,table,entry,tab,key,namespace,hash
CopyOnWriteStateTable -> @SuppressWarnings("unchecked") 	private CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo, int capacity);1494180263;Constructs a new {@code StateTable} instance with the specified capacity.__@param keyContext the key context._@param metaInfo   the meta information, including the type serializer for state copy-on-write._@param capacity   the initial capacity of this hash map._@throws IllegalArgumentException when the capacity is less than zero.;@SuppressWarnings("unchecked")_	private CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo, int capacity) {_		super(keyContext, metaInfo)___		_		this.primaryTable = (StateTableEntry<K, N, S>[]) EMPTY_TABLE__		this.incrementalRehashTable = (StateTableEntry<K, N, S>[]) EMPTY_TABLE___		_		this.primaryTableSize = 0__		this.incrementalRehashTableSize = 0___		this.rehashIndex = 0__		this.stateTableVersion = 0__		this.highestRequiredSnapshotVersion = 0__		this.snapshotVersions = new TreeSet<>()___		if (capacity < 0) {_			throw new IllegalArgumentException("Capacity: " + capacity)__		}__		if (capacity == 0) {_			threshold = -1__			return__		}__		if (capacity < MINIMUM_CAPACITY) {_			capacity = MINIMUM_CAPACITY__		} else if (capacity > MAXIMUM_CAPACITY) {_			capacity = MAXIMUM_CAPACITY__		} else {_			capacity = MathUtils.roundUpToPowerOfTwo(capacity)__		}_		primaryTable = makeTable(capacity)__	};constructs,a,new,code,state,table,instance,with,the,specified,capacity,param,key,context,the,key,context,param,meta,info,the,meta,information,including,the,type,serializer,for,state,copy,on,write,param,capacity,the,initial,capacity,of,this,hash,map,throws,illegal,argument,exception,when,the,capacity,is,less,than,zero;suppress,warnings,unchecked,private,copy,on,write,state,table,internal,key,context,k,key,context,registered,keyed,backend,state,meta,info,n,s,meta,info,int,capacity,super,key,context,meta,info,this,primary,table,state,table,entry,k,n,s,this,incremental,rehash,table,state,table,entry,k,n,s,this,primary,table,size,0,this,incremental,rehash,table,size,0,this,rehash,index,0,this,state,table,version,0,this,highest,required,snapshot,version,0,this,snapshot,versions,new,tree,set,if,capacity,0,throw,new,illegal,argument,exception,capacity,capacity,if,capacity,0,threshold,1,return,if,capacity,capacity,else,if,capacity,capacity,else,capacity,math,utils,round,up,to,power,of,two,capacity,primary,table,make,table,capacity
CopyOnWriteStateTable -> @SuppressWarnings("unchecked") 	private CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo, int capacity);1506609393;Constructs a new {@code StateTable} instance with the specified capacity.__@param keyContext the key context._@param metaInfo   the meta information, including the type serializer for state copy-on-write._@param capacity   the initial capacity of this hash map._@throws IllegalArgumentException when the capacity is less than zero.;@SuppressWarnings("unchecked")_	private CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo, int capacity) {_		super(keyContext, metaInfo)___		_		this.primaryTable = (StateTableEntry<K, N, S>[]) EMPTY_TABLE__		this.incrementalRehashTable = (StateTableEntry<K, N, S>[]) EMPTY_TABLE___		_		this.primaryTableSize = 0__		this.incrementalRehashTableSize = 0___		this.rehashIndex = 0__		this.stateTableVersion = 0__		this.highestRequiredSnapshotVersion = 0__		this.snapshotVersions = new TreeSet<>()___		if (capacity < 0) {_			throw new IllegalArgumentException("Capacity: " + capacity)__		}__		if (capacity == 0) {_			threshold = -1__			return__		}__		if (capacity < MINIMUM_CAPACITY) {_			capacity = MINIMUM_CAPACITY__		} else if (capacity > MAXIMUM_CAPACITY) {_			capacity = MAXIMUM_CAPACITY__		} else {_			capacity = MathUtils.roundUpToPowerOfTwo(capacity)__		}_		primaryTable = makeTable(capacity)__	};constructs,a,new,code,state,table,instance,with,the,specified,capacity,param,key,context,the,key,context,param,meta,info,the,meta,information,including,the,type,serializer,for,state,copy,on,write,param,capacity,the,initial,capacity,of,this,hash,map,throws,illegal,argument,exception,when,the,capacity,is,less,than,zero;suppress,warnings,unchecked,private,copy,on,write,state,table,internal,key,context,k,key,context,registered,keyed,backend,state,meta,info,n,s,meta,info,int,capacity,super,key,context,meta,info,this,primary,table,state,table,entry,k,n,s,this,incremental,rehash,table,state,table,entry,k,n,s,this,primary,table,size,0,this,incremental,rehash,table,size,0,this,rehash,index,0,this,state,table,version,0,this,highest,required,snapshot,version,0,this,snapshot,versions,new,tree,set,if,capacity,0,throw,new,illegal,argument,exception,capacity,capacity,if,capacity,0,threshold,1,return,if,capacity,capacity,else,if,capacity,capacity,else,capacity,math,utils,round,up,to,power,of,two,capacity,primary,table,make,table,capacity
CopyOnWriteStateTable -> @SuppressWarnings("unchecked") 	private CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo, int capacity);1519379856;Constructs a new {@code StateTable} instance with the specified capacity.__@param keyContext the key context._@param metaInfo   the meta information, including the type serializer for state copy-on-write._@param capacity   the initial capacity of this hash map._@throws IllegalArgumentException when the capacity is less than zero.;@SuppressWarnings("unchecked")_	private CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo, int capacity) {_		super(keyContext, metaInfo)___		_		this.primaryTable = (StateTableEntry<K, N, S>[]) EMPTY_TABLE__		this.incrementalRehashTable = (StateTableEntry<K, N, S>[]) EMPTY_TABLE___		_		this.primaryTableSize = 0__		this.incrementalRehashTableSize = 0___		this.rehashIndex = 0__		this.stateTableVersion = 0__		this.highestRequiredSnapshotVersion = 0__		this.snapshotVersions = new TreeSet<>()___		if (capacity < 0) {_			throw new IllegalArgumentException("Capacity: " + capacity)__		}__		if (capacity == 0) {_			threshold = -1__			return__		}__		if (capacity < MINIMUM_CAPACITY) {_			capacity = MINIMUM_CAPACITY__		} else if (capacity > MAXIMUM_CAPACITY) {_			capacity = MAXIMUM_CAPACITY__		} else {_			capacity = MathUtils.roundUpToPowerOfTwo(capacity)__		}_		primaryTable = makeTable(capacity)__	};constructs,a,new,code,state,table,instance,with,the,specified,capacity,param,key,context,the,key,context,param,meta,info,the,meta,information,including,the,type,serializer,for,state,copy,on,write,param,capacity,the,initial,capacity,of,this,hash,map,throws,illegal,argument,exception,when,the,capacity,is,less,than,zero;suppress,warnings,unchecked,private,copy,on,write,state,table,internal,key,context,k,key,context,registered,keyed,backend,state,meta,info,n,s,meta,info,int,capacity,super,key,context,meta,info,this,primary,table,state,table,entry,k,n,s,this,incremental,rehash,table,state,table,entry,k,n,s,this,primary,table,size,0,this,incremental,rehash,table,size,0,this,rehash,index,0,this,state,table,version,0,this,highest,required,snapshot,version,0,this,snapshot,versions,new,tree,set,if,capacity,0,throw,new,illegal,argument,exception,capacity,capacity,if,capacity,0,threshold,1,return,if,capacity,capacity,else,if,capacity,capacity,else,capacity,math,utils,round,up,to,power,of,two,capacity,primary,table,make,table,capacity
CopyOnWriteStateTable -> @SuppressWarnings("unchecked") 	private CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo, int capacity);1529089579;Constructs a new {@code StateTable} instance with the specified capacity.__@param keyContext the key context._@param metaInfo   the meta information, including the type serializer for state copy-on-write._@param capacity   the initial capacity of this hash map._@throws IllegalArgumentException when the capacity is less than zero.;@SuppressWarnings("unchecked")_	private CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo, int capacity) {_		super(keyContext, metaInfo)___		_		this.primaryTable = (StateTableEntry<K, N, S>[]) EMPTY_TABLE__		this.incrementalRehashTable = (StateTableEntry<K, N, S>[]) EMPTY_TABLE___		_		this.primaryTableSize = 0__		this.incrementalRehashTableSize = 0___		this.rehashIndex = 0__		this.stateTableVersion = 0__		this.highestRequiredSnapshotVersion = 0__		this.snapshotVersions = new TreeSet<>()___		if (capacity < 0) {_			throw new IllegalArgumentException("Capacity: " + capacity)__		}__		if (capacity == 0) {_			threshold = -1__			return__		}__		if (capacity < MINIMUM_CAPACITY) {_			capacity = MINIMUM_CAPACITY__		} else if (capacity > MAXIMUM_CAPACITY) {_			capacity = MAXIMUM_CAPACITY__		} else {_			capacity = MathUtils.roundUpToPowerOfTwo(capacity)__		}_		primaryTable = makeTable(capacity)__	};constructs,a,new,code,state,table,instance,with,the,specified,capacity,param,key,context,the,key,context,param,meta,info,the,meta,information,including,the,type,serializer,for,state,copy,on,write,param,capacity,the,initial,capacity,of,this,hash,map,throws,illegal,argument,exception,when,the,capacity,is,less,than,zero;suppress,warnings,unchecked,private,copy,on,write,state,table,internal,key,context,k,key,context,registered,keyed,backend,state,meta,info,n,s,meta,info,int,capacity,super,key,context,meta,info,this,primary,table,state,table,entry,k,n,s,this,incremental,rehash,table,state,table,entry,k,n,s,this,primary,table,size,0,this,incremental,rehash,table,size,0,this,rehash,index,0,this,state,table,version,0,this,highest,required,snapshot,version,0,this,snapshot,versions,new,tree,set,if,capacity,0,throw,new,illegal,argument,exception,capacity,capacity,if,capacity,0,threshold,1,return,if,capacity,capacity,else,if,capacity,capacity,else,capacity,math,utils,round,up,to,power,of,two,capacity,primary,table,make,table,capacity
CopyOnWriteStateTable -> @SuppressWarnings("unchecked") 	private CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo, int capacity);1529089584;Constructs a new {@code StateTable} instance with the specified capacity.__@param keyContext the key context._@param metaInfo   the meta information, including the type serializer for state copy-on-write._@param capacity   the initial capacity of this hash map._@throws IllegalArgumentException when the capacity is less than zero.;@SuppressWarnings("unchecked")_	private CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo, int capacity) {_		super(keyContext, metaInfo)___		_		this.primaryTable = (StateTableEntry<K, N, S>[]) EMPTY_TABLE__		this.incrementalRehashTable = (StateTableEntry<K, N, S>[]) EMPTY_TABLE___		_		this.primaryTableSize = 0__		this.incrementalRehashTableSize = 0___		this.rehashIndex = 0__		this.stateTableVersion = 0__		this.highestRequiredSnapshotVersion = 0__		this.snapshotVersions = new TreeSet<>()___		if (capacity < 0) {_			throw new IllegalArgumentException("Capacity: " + capacity)__		}__		if (capacity == 0) {_			threshold = -1__			return__		}__		if (capacity < MINIMUM_CAPACITY) {_			capacity = MINIMUM_CAPACITY__		} else if (capacity > MAXIMUM_CAPACITY) {_			capacity = MAXIMUM_CAPACITY__		} else {_			capacity = MathUtils.roundUpToPowerOfTwo(capacity)__		}_		primaryTable = makeTable(capacity)__	};constructs,a,new,code,state,table,instance,with,the,specified,capacity,param,key,context,the,key,context,param,meta,info,the,meta,information,including,the,type,serializer,for,state,copy,on,write,param,capacity,the,initial,capacity,of,this,hash,map,throws,illegal,argument,exception,when,the,capacity,is,less,than,zero;suppress,warnings,unchecked,private,copy,on,write,state,table,internal,key,context,k,key,context,registered,keyed,backend,state,meta,info,n,s,meta,info,int,capacity,super,key,context,meta,info,this,primary,table,state,table,entry,k,n,s,this,incremental,rehash,table,state,table,entry,k,n,s,this,primary,table,size,0,this,incremental,rehash,table,size,0,this,rehash,index,0,this,state,table,version,0,this,highest,required,snapshot,version,0,this,snapshot,versions,new,tree,set,if,capacity,0,throw,new,illegal,argument,exception,capacity,capacity,if,capacity,0,threshold,1,return,if,capacity,capacity,else,if,capacity,capacity,else,capacity,math,utils,round,up,to,power,of,two,capacity,primary,table,make,table,capacity
CopyOnWriteStateTable -> @SuppressWarnings("unchecked") 	private CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo, int capacity);1529307900;Constructs a new {@code StateTable} instance with the specified capacity.__@param keyContext the key context._@param metaInfo   the meta information, including the type serializer for state copy-on-write._@param capacity   the initial capacity of this hash map._@throws IllegalArgumentException when the capacity is less than zero.;@SuppressWarnings("unchecked")_	private CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo, int capacity) {_		super(keyContext, metaInfo)___		_		this.primaryTable = (StateTableEntry<K, N, S>[]) EMPTY_TABLE__		this.incrementalRehashTable = (StateTableEntry<K, N, S>[]) EMPTY_TABLE___		_		this.primaryTableSize = 0__		this.incrementalRehashTableSize = 0___		this.rehashIndex = 0__		this.stateTableVersion = 0__		this.highestRequiredSnapshotVersion = 0__		this.snapshotVersions = new TreeSet<>()___		if (capacity < 0) {_			throw new IllegalArgumentException("Capacity: " + capacity)__		}__		if (capacity == 0) {_			threshold = -1__			return__		}__		if (capacity < MINIMUM_CAPACITY) {_			capacity = MINIMUM_CAPACITY__		} else if (capacity > MAXIMUM_CAPACITY) {_			capacity = MAXIMUM_CAPACITY__		} else {_			capacity = MathUtils.roundUpToPowerOfTwo(capacity)__		}_		primaryTable = makeTable(capacity)__	};constructs,a,new,code,state,table,instance,with,the,specified,capacity,param,key,context,the,key,context,param,meta,info,the,meta,information,including,the,type,serializer,for,state,copy,on,write,param,capacity,the,initial,capacity,of,this,hash,map,throws,illegal,argument,exception,when,the,capacity,is,less,than,zero;suppress,warnings,unchecked,private,copy,on,write,state,table,internal,key,context,k,key,context,registered,keyed,backend,state,meta,info,n,s,meta,info,int,capacity,super,key,context,meta,info,this,primary,table,state,table,entry,k,n,s,this,incremental,rehash,table,state,table,entry,k,n,s,this,primary,table,size,0,this,incremental,rehash,table,size,0,this,rehash,index,0,this,state,table,version,0,this,highest,required,snapshot,version,0,this,snapshot,versions,new,tree,set,if,capacity,0,throw,new,illegal,argument,exception,capacity,capacity,if,capacity,0,threshold,1,return,if,capacity,capacity,else,if,capacity,capacity,else,capacity,math,utils,round,up,to,power,of,two,capacity,primary,table,make,table,capacity
CopyOnWriteStateTable -> @SuppressWarnings("unchecked") 	private CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo, int capacity);1530639128;Constructs a new {@code StateTable} instance with the specified capacity.__@param keyContext the key context._@param metaInfo   the meta information, including the type serializer for state copy-on-write._@param capacity   the initial capacity of this hash map._@throws IllegalArgumentException when the capacity is less than zero.;@SuppressWarnings("unchecked")_	private CopyOnWriteStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo, int capacity) {_		super(keyContext, metaInfo)___		_		this.primaryTable = (StateTableEntry<K, N, S>[]) EMPTY_TABLE__		this.incrementalRehashTable = (StateTableEntry<K, N, S>[]) EMPTY_TABLE___		_		this.primaryTableSize = 0__		this.incrementalRehashTableSize = 0___		this.rehashIndex = 0__		this.stateTableVersion = 0__		this.highestRequiredSnapshotVersion = 0__		this.snapshotVersions = new TreeSet<>()___		if (capacity < 0) {_			throw new IllegalArgumentException("Capacity: " + capacity)__		}__		if (capacity == 0) {_			threshold = -1__			return__		}__		if (capacity < MINIMUM_CAPACITY) {_			capacity = MINIMUM_CAPACITY__		} else if (capacity > MAXIMUM_CAPACITY) {_			capacity = MAXIMUM_CAPACITY__		} else {_			capacity = MathUtils.roundUpToPowerOfTwo(capacity)__		}_		primaryTable = makeTable(capacity)__	};constructs,a,new,code,state,table,instance,with,the,specified,capacity,param,key,context,the,key,context,param,meta,info,the,meta,information,including,the,type,serializer,for,state,copy,on,write,param,capacity,the,initial,capacity,of,this,hash,map,throws,illegal,argument,exception,when,the,capacity,is,less,than,zero;suppress,warnings,unchecked,private,copy,on,write,state,table,internal,key,context,k,key,context,registered,keyed,backend,state,meta,info,n,s,meta,info,int,capacity,super,key,context,meta,info,this,primary,table,state,table,entry,k,n,s,this,incremental,rehash,table,state,table,entry,k,n,s,this,primary,table,size,0,this,incremental,rehash,table,size,0,this,rehash,index,0,this,state,table,version,0,this,highest,required,snapshot,version,0,this,snapshot,versions,new,tree,set,if,capacity,0,throw,new,illegal,argument,exception,capacity,capacity,if,capacity,0,threshold,1,return,if,capacity,capacity,else,if,capacity,capacity,else,capacity,math,utils,round,up,to,power,of,two,capacity,primary,table,make,table,capacity
CopyOnWriteStateTable -> @VisibleForTesting 	boolean isRehashing();1489685642;Returns true, if an incremental rehash is in progress.;@VisibleForTesting_	boolean isRehashing() {_		_		return EMPTY_TABLE != incrementalRehashTable__	};returns,true,if,an,incremental,rehash,is,in,progress;visible,for,testing,boolean,is,rehashing,return,incremental,rehash,table
CopyOnWriteStateTable -> @VisibleForTesting 	boolean isRehashing();1494180263;Returns true, if an incremental rehash is in progress.;@VisibleForTesting_	boolean isRehashing() {_		_		return EMPTY_TABLE != incrementalRehashTable__	};returns,true,if,an,incremental,rehash,is,in,progress;visible,for,testing,boolean,is,rehashing,return,incremental,rehash,table
CopyOnWriteStateTable -> @VisibleForTesting 	boolean isRehashing();1506609393;Returns true, if an incremental rehash is in progress.;@VisibleForTesting_	boolean isRehashing() {_		_		return EMPTY_TABLE != incrementalRehashTable__	};returns,true,if,an,incremental,rehash,is,in,progress;visible,for,testing,boolean,is,rehashing,return,incremental,rehash,table
CopyOnWriteStateTable -> @VisibleForTesting 	boolean isRehashing();1519379856;Returns true, if an incremental rehash is in progress.;@VisibleForTesting_	boolean isRehashing() {_		_		return EMPTY_TABLE != incrementalRehashTable__	};returns,true,if,an,incremental,rehash,is,in,progress;visible,for,testing,boolean,is,rehashing,return,incremental,rehash,table
CopyOnWriteStateTable -> @VisibleForTesting 	boolean isRehashing();1529089579;Returns true, if an incremental rehash is in progress.;@VisibleForTesting_	boolean isRehashing() {_		_		return EMPTY_TABLE != incrementalRehashTable__	};returns,true,if,an,incremental,rehash,is,in,progress;visible,for,testing,boolean,is,rehashing,return,incremental,rehash,table
CopyOnWriteStateTable -> @VisibleForTesting 	boolean isRehashing();1529089584;Returns true, if an incremental rehash is in progress.;@VisibleForTesting_	boolean isRehashing() {_		_		return EMPTY_TABLE != incrementalRehashTable__	};returns,true,if,an,incremental,rehash,is,in,progress;visible,for,testing,boolean,is,rehashing,return,incremental,rehash,table
CopyOnWriteStateTable -> @VisibleForTesting 	boolean isRehashing();1529307900;Returns true, if an incremental rehash is in progress.;@VisibleForTesting_	boolean isRehashing() {_		_		return EMPTY_TABLE != incrementalRehashTable__	};returns,true,if,an,incremental,rehash,is,in,progress;visible,for,testing,boolean,is,rehashing,return,incremental,rehash,table
CopyOnWriteStateTable -> @VisibleForTesting 	boolean isRehashing();1530639128;Returns true, if an incremental rehash is in progress.;@VisibleForTesting_	boolean isRehashing() {_		_		return EMPTY_TABLE != incrementalRehashTable__	};returns,true,if,an,incremental,rehash,is,in,progress;visible,for,testing,boolean,is,rehashing,return,incremental,rehash,table
CopyOnWriteStateTable -> @VisibleForTesting 	boolean isRehashing();1531771917;Returns true, if an incremental rehash is in progress.;@VisibleForTesting_	boolean isRehashing() {_		_		return EMPTY_TABLE != incrementalRehashTable__	};returns,true,if,an,incremental,rehash,is,in,progress;visible,for,testing,boolean,is,rehashing,return,incremental,rehash,table
CopyOnWriteStateTable -> @VisibleForTesting 	boolean isRehashing();1548755874;Returns true, if an incremental rehash is in progress.;@VisibleForTesting_	boolean isRehashing() {_		_		return EMPTY_TABLE != incrementalRehashTable__	};returns,true,if,an,incremental,rehash,is,in,progress;visible,for,testing,boolean,is,rehashing,return,incremental,rehash,table
