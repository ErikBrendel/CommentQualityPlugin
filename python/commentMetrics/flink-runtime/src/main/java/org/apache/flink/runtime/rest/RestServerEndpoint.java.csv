# id;timestamp;commentText;codeText;commentWords;codeWords
RestServerEndpoint -> public final void start() throws Exception;1519052657;Starts this REST server endpoint.__@throws Exception if we cannot start the RestServerEndpoint;public final void start() throws Exception {_		synchronized (lock) {_			Preconditions.checkState(state == State.CREATED, "The RestServerEndpoint cannot be restarted.")___			log.info("Starting rest endpoint.")___			final Router router = new Router()__			final CompletableFuture<String> restAddressFuture = new CompletableFuture<>()___			List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = initializeHandlers(restAddressFuture)___			_			Collections.sort(_				handlers,_				RestHandlerUrlComparator.INSTANCE)___			handlers.forEach(handler -> {_				log.debug("Register handler {} under {}@{}.", handler.f1, handler.f0.getHttpMethod(), handler.f0.getTargetRestEndpointURL())__				registerHandler(router, handler)__			})___			ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {__				@Override_				protected void initChannel(SocketChannel ch) {_					Handler handler = new RouterHandler(router)___					_					if (sslEngine != null) {_						ch.pipeline().addLast("ssl", new SslHandler(sslEngine))__					}__					ch.pipeline()_						.addLast(new HttpServerCodec())_						.addLast(new FileUploadHandler(uploadDir))_						.addLast(new HttpObjectAggregator(MAX_REQUEST_SIZE_BYTES))_						.addLast(handler.name(), handler)_						.addLast(new PipelineErrorHandler(log))__				}_			}___			NioEventLoopGroup bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory("flink-rest-server-netty-boss"))__			NioEventLoopGroup workerGroup = new NioEventLoopGroup(0, new DefaultThreadFactory("flink-rest-server-netty-worker"))___			bootstrap = new ServerBootstrap()__			bootstrap_				.group(bossGroup, workerGroup)_				.channel(NioServerSocketChannel.class)_				.childHandler(initializer)___			final ChannelFuture channel__			if (configuredAddress == null) {_				channel = bootstrap.bind(configuredPort)__			} else {_				channel = bootstrap.bind(configuredAddress, configuredPort)__			}_			serverChannel = channel.syncUninterruptibly().channel()___			InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress()__			String address = bindAddress.getAddress().getHostAddress()__			int port = bindAddress.getPort()___			log.info("Rest endpoint listening at {}:{}", address, port)___			final String protocol___			if (sslEngine != null) {_				protocol = "https://"__			} else {_				protocol = "http://"__			}__			restAddress = protocol + address + ':' + port___			restAddressFuture.complete(restAddress)___			state = State.RUNNING___			startInternal()__		}_	};starts,this,rest,server,endpoint,throws,exception,if,we,cannot,start,the,rest,server,endpoint;public,final,void,start,throws,exception,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,cannot,be,restarted,log,info,starting,rest,endpoint,final,router,router,new,router,final,completable,future,string,rest,address,future,new,completable,future,list,tuple2,rest,handler,specification,channel,inbound,handler,handlers,initialize,handlers,rest,address,future,collections,sort,handlers,rest,handler,url,comparator,instance,handlers,for,each,handler,log,debug,register,handler,under,handler,f1,handler,f0,get,http,method,handler,f0,get,target,rest,endpoint,url,register,handler,router,handler,channel,initializer,socket,channel,initializer,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,ch,handler,handler,new,router,handler,router,if,ssl,engine,null,ch,pipeline,add,last,ssl,new,ssl,handler,ssl,engine,ch,pipeline,add,last,new,http,server,codec,add,last,new,file,upload,handler,upload,dir,add,last,new,http,object,aggregator,add,last,handler,name,handler,add,last,new,pipeline,error,handler,log,nio,event,loop,group,boss,group,new,nio,event,loop,group,1,new,default,thread,factory,flink,rest,server,netty,boss,nio,event,loop,group,worker,group,new,nio,event,loop,group,0,new,default,thread,factory,flink,rest,server,netty,worker,bootstrap,new,server,bootstrap,bootstrap,group,boss,group,worker,group,channel,nio,server,socket,channel,class,child,handler,initializer,final,channel,future,channel,if,configured,address,null,channel,bootstrap,bind,configured,port,else,channel,bootstrap,bind,configured,address,configured,port,server,channel,channel,sync,uninterruptibly,channel,inet,socket,address,bind,address,inet,socket,address,server,channel,local,address,string,address,bind,address,get,address,get,host,address,int,port,bind,address,get,port,log,info,rest,endpoint,listening,at,address,port,final,string,protocol,if,ssl,engine,null,protocol,https,else,protocol,http,rest,address,protocol,address,port,rest,address,future,complete,rest,address,state,state,running,start,internal
RestServerEndpoint -> public final void start() throws Exception;1519406530;Starts this REST server endpoint.__@throws Exception if we cannot start the RestServerEndpoint;public final void start() throws Exception {_		synchronized (lock) {_			Preconditions.checkState(state == State.CREATED, "The RestServerEndpoint cannot be restarted.")___			log.info("Starting rest endpoint.")___			final Router router = new Router()__			final CompletableFuture<String> restAddressFuture = new CompletableFuture<>()___			List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = initializeHandlers(restAddressFuture)___			_			Collections.sort(_				handlers,_				RestHandlerUrlComparator.INSTANCE)___			handlers.forEach(handler -> {_				log.debug("Register handler {} under {}@{}.", handler.f1, handler.f0.getHttpMethod(), handler.f0.getTargetRestEndpointURL())__				registerHandler(router, handler)__			})___			ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {__				@Override_				protected void initChannel(SocketChannel ch) {_					Handler handler = new RouterHandler(router)___					_					if (sslEngine != null) {_						ch.pipeline().addLast("ssl", new SslHandler(sslEngine))__					}__					ch.pipeline()_						.addLast(new HttpServerCodec())_						.addLast(new FileUploadHandler(uploadDir))_						.addLast(new HttpObjectAggregator(MAX_REQUEST_SIZE_BYTES))_						.addLast(handler.name(), handler)_						.addLast(new PipelineErrorHandler(log))__				}_			}___			NioEventLoopGroup bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory("flink-rest-server-netty-boss"))__			NioEventLoopGroup workerGroup = new NioEventLoopGroup(0, new DefaultThreadFactory("flink-rest-server-netty-worker"))___			bootstrap = new ServerBootstrap()__			bootstrap_				.group(bossGroup, workerGroup)_				.channel(NioServerSocketChannel.class)_				.childHandler(initializer)___			final ChannelFuture channel__			if (configuredAddress == null) {_				channel = bootstrap.bind(configuredPort)__			} else {_				channel = bootstrap.bind(configuredAddress, configuredPort)__			}_			serverChannel = channel.syncUninterruptibly().channel()___			InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress()__			String address = bindAddress.getAddress().getHostAddress()__			int port = bindAddress.getPort()___			log.info("Rest endpoint listening at {}:{}", address, port)___			final String protocol___			if (sslEngine != null) {_				protocol = "https://"__			} else {_				protocol = "http://"__			}__			restAddress = protocol + address + ':' + port___			restAddressFuture.complete(restAddress)___			state = State.RUNNING___			startInternal()__		}_	};starts,this,rest,server,endpoint,throws,exception,if,we,cannot,start,the,rest,server,endpoint;public,final,void,start,throws,exception,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,cannot,be,restarted,log,info,starting,rest,endpoint,final,router,router,new,router,final,completable,future,string,rest,address,future,new,completable,future,list,tuple2,rest,handler,specification,channel,inbound,handler,handlers,initialize,handlers,rest,address,future,collections,sort,handlers,rest,handler,url,comparator,instance,handlers,for,each,handler,log,debug,register,handler,under,handler,f1,handler,f0,get,http,method,handler,f0,get,target,rest,endpoint,url,register,handler,router,handler,channel,initializer,socket,channel,initializer,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,ch,handler,handler,new,router,handler,router,if,ssl,engine,null,ch,pipeline,add,last,ssl,new,ssl,handler,ssl,engine,ch,pipeline,add,last,new,http,server,codec,add,last,new,file,upload,handler,upload,dir,add,last,new,http,object,aggregator,add,last,handler,name,handler,add,last,new,pipeline,error,handler,log,nio,event,loop,group,boss,group,new,nio,event,loop,group,1,new,default,thread,factory,flink,rest,server,netty,boss,nio,event,loop,group,worker,group,new,nio,event,loop,group,0,new,default,thread,factory,flink,rest,server,netty,worker,bootstrap,new,server,bootstrap,bootstrap,group,boss,group,worker,group,channel,nio,server,socket,channel,class,child,handler,initializer,final,channel,future,channel,if,configured,address,null,channel,bootstrap,bind,configured,port,else,channel,bootstrap,bind,configured,address,configured,port,server,channel,channel,sync,uninterruptibly,channel,inet,socket,address,bind,address,inet,socket,address,server,channel,local,address,string,address,bind,address,get,address,get,host,address,int,port,bind,address,get,port,log,info,rest,endpoint,listening,at,address,port,final,string,protocol,if,ssl,engine,null,protocol,https,else,protocol,http,rest,address,protocol,address,port,rest,address,future,complete,rest,address,state,state,running,start,internal
RestServerEndpoint -> public final void start() throws Exception;1521016670;Starts this REST server endpoint.__@throws Exception if we cannot start the RestServerEndpoint;public final void start() throws Exception {_		synchronized (lock) {_			Preconditions.checkState(state == State.CREATED, "The RestServerEndpoint cannot be restarted.")___			log.info("Starting rest endpoint.")___			final Router router = new Router()__			final CompletableFuture<String> restAddressFuture = new CompletableFuture<>()___			List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = initializeHandlers(restAddressFuture)___			_			Collections.sort(_				handlers,_				RestHandlerUrlComparator.INSTANCE)___			handlers.forEach(handler -> {_				log.debug("Register handler {} under {}@{}.", handler.f1, handler.f0.getHttpMethod(), handler.f0.getTargetRestEndpointURL())__				registerHandler(router, handler)__			})___			ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {__				@Override_				protected void initChannel(SocketChannel ch) {_					Handler handler = new RouterHandler(router)___					_					if (sslEngine != null) {_						ch.pipeline().addLast("ssl", new SslHandler(sslEngine))__					}__					ch.pipeline()_						.addLast(new HttpServerCodec())_						.addLast(new FileUploadHandler(uploadDir))_						.addLast(new HttpObjectAggregator(maxContentLength))_						.addLast(handler.name(), handler)_						.addLast(new PipelineErrorHandler(log))__				}_			}___			NioEventLoopGroup bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory("flink-rest-server-netty-boss"))__			NioEventLoopGroup workerGroup = new NioEventLoopGroup(0, new DefaultThreadFactory("flink-rest-server-netty-worker"))___			bootstrap = new ServerBootstrap()__			bootstrap_				.group(bossGroup, workerGroup)_				.channel(NioServerSocketChannel.class)_				.childHandler(initializer)___			final ChannelFuture channel__			if (configuredAddress == null) {_				channel = bootstrap.bind(configuredPort)__			} else {_				channel = bootstrap.bind(configuredAddress, configuredPort)__			}_			serverChannel = channel.syncUninterruptibly().channel()___			InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress()__			String address = bindAddress.getAddress().getHostAddress()__			int port = bindAddress.getPort()___			log.info("Rest endpoint listening at {}:{}", address, port)___			final String protocol___			if (sslEngine != null) {_				protocol = "https://"__			} else {_				protocol = "http://"__			}__			restAddress = protocol + address + ':' + port___			restAddressFuture.complete(restAddress)___			state = State.RUNNING___			startInternal()__		}_	};starts,this,rest,server,endpoint,throws,exception,if,we,cannot,start,the,rest,server,endpoint;public,final,void,start,throws,exception,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,cannot,be,restarted,log,info,starting,rest,endpoint,final,router,router,new,router,final,completable,future,string,rest,address,future,new,completable,future,list,tuple2,rest,handler,specification,channel,inbound,handler,handlers,initialize,handlers,rest,address,future,collections,sort,handlers,rest,handler,url,comparator,instance,handlers,for,each,handler,log,debug,register,handler,under,handler,f1,handler,f0,get,http,method,handler,f0,get,target,rest,endpoint,url,register,handler,router,handler,channel,initializer,socket,channel,initializer,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,ch,handler,handler,new,router,handler,router,if,ssl,engine,null,ch,pipeline,add,last,ssl,new,ssl,handler,ssl,engine,ch,pipeline,add,last,new,http,server,codec,add,last,new,file,upload,handler,upload,dir,add,last,new,http,object,aggregator,max,content,length,add,last,handler,name,handler,add,last,new,pipeline,error,handler,log,nio,event,loop,group,boss,group,new,nio,event,loop,group,1,new,default,thread,factory,flink,rest,server,netty,boss,nio,event,loop,group,worker,group,new,nio,event,loop,group,0,new,default,thread,factory,flink,rest,server,netty,worker,bootstrap,new,server,bootstrap,bootstrap,group,boss,group,worker,group,channel,nio,server,socket,channel,class,child,handler,initializer,final,channel,future,channel,if,configured,address,null,channel,bootstrap,bind,configured,port,else,channel,bootstrap,bind,configured,address,configured,port,server,channel,channel,sync,uninterruptibly,channel,inet,socket,address,bind,address,inet,socket,address,server,channel,local,address,string,address,bind,address,get,address,get,host,address,int,port,bind,address,get,port,log,info,rest,endpoint,listening,at,address,port,final,string,protocol,if,ssl,engine,null,protocol,https,else,protocol,http,rest,address,protocol,address,port,rest,address,future,complete,rest,address,state,state,running,start,internal
RestServerEndpoint -> public final void start() throws Exception;1521016671;Starts this REST server endpoint.__@throws Exception if we cannot start the RestServerEndpoint;public final void start() throws Exception {_		synchronized (lock) {_			Preconditions.checkState(state == State.CREATED, "The RestServerEndpoint cannot be restarted.")___			log.info("Starting rest endpoint.")___			final Router router = new Router()__			final CompletableFuture<String> restAddressFuture = new CompletableFuture<>()___			List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = initializeHandlers(restAddressFuture)___			_			Collections.sort(_				handlers,_				RestHandlerUrlComparator.INSTANCE)___			handlers.forEach(handler -> {_				log.debug("Register handler {} under {}@{}.", handler.f1, handler.f0.getHttpMethod(), handler.f0.getTargetRestEndpointURL())__				registerHandler(router, handler)__			})___			ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {__				@Override_				protected void initChannel(SocketChannel ch) {_					Handler handler = new RouterHandler(router)___					_					if (sslEngine != null) {_						ch.pipeline().addLast("ssl", new SslHandler(sslEngine))__					}__					ch.pipeline()_						.addLast(new HttpServerCodec())_						.addLast(new FileUploadHandler(uploadDir))_						.addLast(new HttpObjectAggregator(maxContentLength))_						.addLast(handler.name(), handler)_						.addLast(new PipelineErrorHandler(log))__				}_			}___			NioEventLoopGroup bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory("flink-rest-server-netty-boss"))__			NioEventLoopGroup workerGroup = new NioEventLoopGroup(0, new DefaultThreadFactory("flink-rest-server-netty-worker"))___			bootstrap = new ServerBootstrap()__			bootstrap_				.group(bossGroup, workerGroup)_				.channel(NioServerSocketChannel.class)_				.childHandler(initializer)___			final ChannelFuture channel__			if (configuredAddress == null) {_				channel = bootstrap.bind(configuredPort)__			} else {_				channel = bootstrap.bind(configuredAddress, configuredPort)__			}_			serverChannel = channel.syncUninterruptibly().channel()___			InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress()__			String address = bindAddress.getAddress().getHostAddress()__			int port = bindAddress.getPort()___			log.info("Rest endpoint listening at {}:{}", address, port)___			final String protocol___			if (sslEngine != null) {_				protocol = "https://"__			} else {_				protocol = "http://"__			}__			restAddress = protocol + address + ':' + port___			restAddressFuture.complete(restAddress)___			state = State.RUNNING___			startInternal()__		}_	};starts,this,rest,server,endpoint,throws,exception,if,we,cannot,start,the,rest,server,endpoint;public,final,void,start,throws,exception,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,cannot,be,restarted,log,info,starting,rest,endpoint,final,router,router,new,router,final,completable,future,string,rest,address,future,new,completable,future,list,tuple2,rest,handler,specification,channel,inbound,handler,handlers,initialize,handlers,rest,address,future,collections,sort,handlers,rest,handler,url,comparator,instance,handlers,for,each,handler,log,debug,register,handler,under,handler,f1,handler,f0,get,http,method,handler,f0,get,target,rest,endpoint,url,register,handler,router,handler,channel,initializer,socket,channel,initializer,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,ch,handler,handler,new,router,handler,router,if,ssl,engine,null,ch,pipeline,add,last,ssl,new,ssl,handler,ssl,engine,ch,pipeline,add,last,new,http,server,codec,add,last,new,file,upload,handler,upload,dir,add,last,new,http,object,aggregator,max,content,length,add,last,handler,name,handler,add,last,new,pipeline,error,handler,log,nio,event,loop,group,boss,group,new,nio,event,loop,group,1,new,default,thread,factory,flink,rest,server,netty,boss,nio,event,loop,group,worker,group,new,nio,event,loop,group,0,new,default,thread,factory,flink,rest,server,netty,worker,bootstrap,new,server,bootstrap,bootstrap,group,boss,group,worker,group,channel,nio,server,socket,channel,class,child,handler,initializer,final,channel,future,channel,if,configured,address,null,channel,bootstrap,bind,configured,port,else,channel,bootstrap,bind,configured,address,configured,port,server,channel,channel,sync,uninterruptibly,channel,inet,socket,address,bind,address,inet,socket,address,server,channel,local,address,string,address,bind,address,get,address,get,host,address,int,port,bind,address,get,port,log,info,rest,endpoint,listening,at,address,port,final,string,protocol,if,ssl,engine,null,protocol,https,else,protocol,http,rest,address,protocol,address,port,rest,address,future,complete,rest,address,state,state,running,start,internal
RestServerEndpoint -> public final void start() throws Exception;1521016671;Starts this REST server endpoint.__@throws Exception if we cannot start the RestServerEndpoint;public final void start() throws Exception {_		synchronized (lock) {_			Preconditions.checkState(state == State.CREATED, "The RestServerEndpoint cannot be restarted.")___			log.info("Starting rest endpoint.")___			final Router router = new Router()__			final CompletableFuture<String> restAddressFuture = new CompletableFuture<>()___			List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = initializeHandlers(restAddressFuture)___			_			Collections.sort(_				handlers,_				RestHandlerUrlComparator.INSTANCE)___			handlers.forEach(handler -> {_				log.debug("Register handler {} under {}@{}.", handler.f1, handler.f0.getHttpMethod(), handler.f0.getTargetRestEndpointURL())__				registerHandler(router, handler)__			})___			ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {__				@Override_				protected void initChannel(SocketChannel ch) {_					Handler handler = new RouterHandler(router, responseHeaders)___					_					if (sslEngine != null) {_						ch.pipeline().addLast("ssl", new SslHandler(sslEngine))__					}__					ch.pipeline()_						.addLast(new HttpServerCodec())_						.addLast(new FileUploadHandler(uploadDir))_						.addLast(new FlinkHttpObjectAggregator(maxContentLength, responseHeaders))_						.addLast(handler.name(), handler)_						.addLast(new PipelineErrorHandler(log, responseHeaders))__				}_			}___			NioEventLoopGroup bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory("flink-rest-server-netty-boss"))__			NioEventLoopGroup workerGroup = new NioEventLoopGroup(0, new DefaultThreadFactory("flink-rest-server-netty-worker"))___			bootstrap = new ServerBootstrap()__			bootstrap_				.group(bossGroup, workerGroup)_				.channel(NioServerSocketChannel.class)_				.childHandler(initializer)___			final ChannelFuture channel__			if (configuredAddress == null) {_				channel = bootstrap.bind(configuredPort)__			} else {_				channel = bootstrap.bind(configuredAddress, configuredPort)__			}_			serverChannel = channel.syncUninterruptibly().channel()___			InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress()__			String address = bindAddress.getAddress().getHostAddress()__			int port = bindAddress.getPort()___			log.info("Rest endpoint listening at {}:{}", address, port)___			final String protocol___			if (sslEngine != null) {_				protocol = "https://"__			} else {_				protocol = "http://"__			}__			restAddress = protocol + address + ':' + port___			restAddressFuture.complete(restAddress)___			state = State.RUNNING___			startInternal()__		}_	};starts,this,rest,server,endpoint,throws,exception,if,we,cannot,start,the,rest,server,endpoint;public,final,void,start,throws,exception,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,cannot,be,restarted,log,info,starting,rest,endpoint,final,router,router,new,router,final,completable,future,string,rest,address,future,new,completable,future,list,tuple2,rest,handler,specification,channel,inbound,handler,handlers,initialize,handlers,rest,address,future,collections,sort,handlers,rest,handler,url,comparator,instance,handlers,for,each,handler,log,debug,register,handler,under,handler,f1,handler,f0,get,http,method,handler,f0,get,target,rest,endpoint,url,register,handler,router,handler,channel,initializer,socket,channel,initializer,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,ch,handler,handler,new,router,handler,router,response,headers,if,ssl,engine,null,ch,pipeline,add,last,ssl,new,ssl,handler,ssl,engine,ch,pipeline,add,last,new,http,server,codec,add,last,new,file,upload,handler,upload,dir,add,last,new,flink,http,object,aggregator,max,content,length,response,headers,add,last,handler,name,handler,add,last,new,pipeline,error,handler,log,response,headers,nio,event,loop,group,boss,group,new,nio,event,loop,group,1,new,default,thread,factory,flink,rest,server,netty,boss,nio,event,loop,group,worker,group,new,nio,event,loop,group,0,new,default,thread,factory,flink,rest,server,netty,worker,bootstrap,new,server,bootstrap,bootstrap,group,boss,group,worker,group,channel,nio,server,socket,channel,class,child,handler,initializer,final,channel,future,channel,if,configured,address,null,channel,bootstrap,bind,configured,port,else,channel,bootstrap,bind,configured,address,configured,port,server,channel,channel,sync,uninterruptibly,channel,inet,socket,address,bind,address,inet,socket,address,server,channel,local,address,string,address,bind,address,get,address,get,host,address,int,port,bind,address,get,port,log,info,rest,endpoint,listening,at,address,port,final,string,protocol,if,ssl,engine,null,protocol,https,else,protocol,http,rest,address,protocol,address,port,rest,address,future,complete,rest,address,state,state,running,start,internal
RestServerEndpoint -> public final void start() throws Exception;1521385094;Starts this REST server endpoint.__@throws Exception if we cannot start the RestServerEndpoint;public final void start() throws Exception {_		synchronized (lock) {_			Preconditions.checkState(state == State.CREATED, "The RestServerEndpoint cannot be restarted.")___			log.info("Starting rest endpoint.")___			final Router router = new Router()__			final CompletableFuture<String> restAddressFuture = new CompletableFuture<>()___			List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = initializeHandlers(restAddressFuture)___			_			Collections.sort(_				handlers,_				RestHandlerUrlComparator.INSTANCE)___			handlers.forEach(handler -> {_				log.debug("Register handler {} under {}@{}.", handler.f1, handler.f0.getHttpMethod(), handler.f0.getTargetRestEndpointURL())__				registerHandler(router, handler)__			})___			ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {__				@Override_				protected void initChannel(SocketChannel ch) {_					Handler handler = new RouterHandler(router, responseHeaders)___					_					if (sslEngine != null) {_						ch.pipeline().addLast("ssl", new SslHandler(sslEngine))__					}__					ch.pipeline()_						.addLast(new HttpServerCodec())_						.addLast(new FileUploadHandler(uploadDir))_						.addLast(new FlinkHttpObjectAggregator(maxContentLength, responseHeaders))_						.addLast(handler.name(), handler)_						.addLast(new PipelineErrorHandler(log, responseHeaders))__				}_			}___			NioEventLoopGroup bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory("flink-rest-server-netty-boss"))__			NioEventLoopGroup workerGroup = new NioEventLoopGroup(0, new DefaultThreadFactory("flink-rest-server-netty-worker"))___			bootstrap = new ServerBootstrap()__			bootstrap_				.group(bossGroup, workerGroup)_				.channel(NioServerSocketChannel.class)_				.childHandler(initializer)___			final ChannelFuture channel__			if (restBindAddress == null) {_				channel = bootstrap.bind(restBindPort)__			} else {_				channel = bootstrap.bind(restBindAddress, restBindPort)__			}_			serverChannel = channel.syncUninterruptibly().channel()___			final InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress()__			final String advertisedAddress__			if (bindAddress.getAddress().isAnyLocalAddress()) {_				advertisedAddress = this.restAddress__			} else {_				advertisedAddress = bindAddress.getAddress().getHostAddress()__			}_			final int port = bindAddress.getPort()___			log.info("Rest endpoint listening at {}:{}", advertisedAddress, port)___			final String protocol___			if (sslEngine != null) {_				protocol = "https://"__			} else {_				protocol = "http://"__			}__			restBaseUrl = protocol + advertisedAddress + ':' + port___			restAddressFuture.complete(restBaseUrl)___			state = State.RUNNING___			startInternal()__		}_	};starts,this,rest,server,endpoint,throws,exception,if,we,cannot,start,the,rest,server,endpoint;public,final,void,start,throws,exception,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,cannot,be,restarted,log,info,starting,rest,endpoint,final,router,router,new,router,final,completable,future,string,rest,address,future,new,completable,future,list,tuple2,rest,handler,specification,channel,inbound,handler,handlers,initialize,handlers,rest,address,future,collections,sort,handlers,rest,handler,url,comparator,instance,handlers,for,each,handler,log,debug,register,handler,under,handler,f1,handler,f0,get,http,method,handler,f0,get,target,rest,endpoint,url,register,handler,router,handler,channel,initializer,socket,channel,initializer,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,ch,handler,handler,new,router,handler,router,response,headers,if,ssl,engine,null,ch,pipeline,add,last,ssl,new,ssl,handler,ssl,engine,ch,pipeline,add,last,new,http,server,codec,add,last,new,file,upload,handler,upload,dir,add,last,new,flink,http,object,aggregator,max,content,length,response,headers,add,last,handler,name,handler,add,last,new,pipeline,error,handler,log,response,headers,nio,event,loop,group,boss,group,new,nio,event,loop,group,1,new,default,thread,factory,flink,rest,server,netty,boss,nio,event,loop,group,worker,group,new,nio,event,loop,group,0,new,default,thread,factory,flink,rest,server,netty,worker,bootstrap,new,server,bootstrap,bootstrap,group,boss,group,worker,group,channel,nio,server,socket,channel,class,child,handler,initializer,final,channel,future,channel,if,rest,bind,address,null,channel,bootstrap,bind,rest,bind,port,else,channel,bootstrap,bind,rest,bind,address,rest,bind,port,server,channel,channel,sync,uninterruptibly,channel,final,inet,socket,address,bind,address,inet,socket,address,server,channel,local,address,final,string,advertised,address,if,bind,address,get,address,is,any,local,address,advertised,address,this,rest,address,else,advertised,address,bind,address,get,address,get,host,address,final,int,port,bind,address,get,port,log,info,rest,endpoint,listening,at,advertised,address,port,final,string,protocol,if,ssl,engine,null,protocol,https,else,protocol,http,rest,base,url,protocol,advertised,address,port,rest,address,future,complete,rest,base,url,state,state,running,start,internal
RestServerEndpoint -> public final void start() throws Exception;1521804758;Starts this REST server endpoint.__@throws Exception if we cannot start the RestServerEndpoint;public final void start() throws Exception {_		synchronized (lock) {_			Preconditions.checkState(state == State.CREATED, "The RestServerEndpoint cannot be restarted.")___			log.info("Starting rest endpoint.")___			final Router router = new Router()__			final CompletableFuture<String> restAddressFuture = new CompletableFuture<>()___			List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = initializeHandlers(restAddressFuture)___			_			Collections.sort(_				handlers,_				RestHandlerUrlComparator.INSTANCE)___			handlers.forEach(handler -> {_				log.debug("Register handler {} under {}@{}.", handler.f1, handler.f0.getHttpMethod(), handler.f0.getTargetRestEndpointURL())__				registerHandler(router, handler)__			})___			ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {__				@Override_				protected void initChannel(SocketChannel ch) {_					Handler handler = new RouterHandler(router, responseHeaders)___					_					if (sslEngine != null) {_						ch.pipeline().addLast("ssl", new SslHandler(sslEngine))__					}__					ch.pipeline()_						.addLast(new HttpServerCodec())_						.addLast(new FileUploadHandler(uploadDir))_						.addLast(new FlinkHttpObjectAggregator(maxContentLength, responseHeaders))_						.addLast(handler.name(), handler)_						.addLast(new PipelineErrorHandler(log, responseHeaders))__				}_			}___			NioEventLoopGroup bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory("flink-rest-server-netty-boss"))__			NioEventLoopGroup workerGroup = new NioEventLoopGroup(0, new DefaultThreadFactory("flink-rest-server-netty-worker"))___			bootstrap = new ServerBootstrap()__			bootstrap_				.group(bossGroup, workerGroup)_				.channel(NioServerSocketChannel.class)_				.childHandler(initializer)___			final ChannelFuture channel__			if (restBindAddress == null) {_				channel = bootstrap.bind(restBindPort)__			} else {_				channel = bootstrap.bind(restBindAddress, restBindPort)__			}_			serverChannel = channel.syncUninterruptibly().channel()___			final InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress()__			final String advertisedAddress__			if (bindAddress.getAddress().isAnyLocalAddress()) {_				advertisedAddress = this.restAddress__			} else {_				advertisedAddress = bindAddress.getAddress().getHostAddress()__			}_			final int port = bindAddress.getPort()___			log.info("Rest endpoint listening at {}:{}", advertisedAddress, port)___			final String protocol___			if (sslEngine != null) {_				protocol = "https://"__			} else {_				protocol = "http://"__			}__			restBaseUrl = protocol + advertisedAddress + ':' + port___			restAddressFuture.complete(restBaseUrl)___			state = State.RUNNING___			startInternal()__		}_	};starts,this,rest,server,endpoint,throws,exception,if,we,cannot,start,the,rest,server,endpoint;public,final,void,start,throws,exception,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,cannot,be,restarted,log,info,starting,rest,endpoint,final,router,router,new,router,final,completable,future,string,rest,address,future,new,completable,future,list,tuple2,rest,handler,specification,channel,inbound,handler,handlers,initialize,handlers,rest,address,future,collections,sort,handlers,rest,handler,url,comparator,instance,handlers,for,each,handler,log,debug,register,handler,under,handler,f1,handler,f0,get,http,method,handler,f0,get,target,rest,endpoint,url,register,handler,router,handler,channel,initializer,socket,channel,initializer,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,ch,handler,handler,new,router,handler,router,response,headers,if,ssl,engine,null,ch,pipeline,add,last,ssl,new,ssl,handler,ssl,engine,ch,pipeline,add,last,new,http,server,codec,add,last,new,file,upload,handler,upload,dir,add,last,new,flink,http,object,aggregator,max,content,length,response,headers,add,last,handler,name,handler,add,last,new,pipeline,error,handler,log,response,headers,nio,event,loop,group,boss,group,new,nio,event,loop,group,1,new,default,thread,factory,flink,rest,server,netty,boss,nio,event,loop,group,worker,group,new,nio,event,loop,group,0,new,default,thread,factory,flink,rest,server,netty,worker,bootstrap,new,server,bootstrap,bootstrap,group,boss,group,worker,group,channel,nio,server,socket,channel,class,child,handler,initializer,final,channel,future,channel,if,rest,bind,address,null,channel,bootstrap,bind,rest,bind,port,else,channel,bootstrap,bind,rest,bind,address,rest,bind,port,server,channel,channel,sync,uninterruptibly,channel,final,inet,socket,address,bind,address,inet,socket,address,server,channel,local,address,final,string,advertised,address,if,bind,address,get,address,is,any,local,address,advertised,address,this,rest,address,else,advertised,address,bind,address,get,address,get,host,address,final,int,port,bind,address,get,port,log,info,rest,endpoint,listening,at,advertised,address,port,final,string,protocol,if,ssl,engine,null,protocol,https,else,protocol,http,rest,base,url,protocol,advertised,address,port,rest,address,future,complete,rest,base,url,state,state,running,start,internal
RestServerEndpoint -> public final void start() throws Exception;1521804758;Starts this REST server endpoint.__@throws Exception if we cannot start the RestServerEndpoint;public final void start() throws Exception {_		synchronized (lock) {_			Preconditions.checkState(state == State.CREATED, "The RestServerEndpoint cannot be restarted.")___			log.info("Starting rest endpoint.")___			final Router router = new Router()__			final CompletableFuture<String> restAddressFuture = new CompletableFuture<>()___			List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = initializeHandlers(restAddressFuture)___			_			Collections.sort(_				handlers,_				RestHandlerUrlComparator.INSTANCE)___			handlers.forEach(handler -> {_				log.debug("Register handler {} under {}@{}.", handler.f1, handler.f0.getHttpMethod(), handler.f0.getTargetRestEndpointURL())__				registerHandler(router, handler)__			})___			ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {__				@Override_				protected void initChannel(SocketChannel ch) {_					Handler handler = new RouterHandler(router, responseHeaders)___					_					if (sslEngine != null) {_						ch.pipeline().addLast("ssl", new SslHandler(sslEngine))__					}__					ch.pipeline()_						.addLast(new HttpServerCodec())_						.addLast(new FileUploadHandler(uploadDir))_						.addLast(new FlinkHttpObjectAggregator(maxContentLength, responseHeaders))_						.addLast(handler.name(), handler)_						.addLast(new PipelineErrorHandler(log, responseHeaders))__				}_			}___			NioEventLoopGroup bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory("flink-rest-server-netty-boss"))__			NioEventLoopGroup workerGroup = new NioEventLoopGroup(0, new DefaultThreadFactory("flink-rest-server-netty-worker"))___			bootstrap = new ServerBootstrap()__			bootstrap_				.group(bossGroup, workerGroup)_				.channel(NioServerSocketChannel.class)_				.childHandler(initializer)___			final ChannelFuture channel__			if (restBindAddress == null) {_				channel = bootstrap.bind(restBindPort)__			} else {_				channel = bootstrap.bind(restBindAddress, restBindPort)__			}_			serverChannel = channel.syncUninterruptibly().channel()___			final InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress()__			final String advertisedAddress__			if (bindAddress.getAddress().isAnyLocalAddress()) {_				advertisedAddress = this.restAddress__			} else {_				advertisedAddress = bindAddress.getAddress().getHostAddress()__			}_			final int port = bindAddress.getPort()___			log.info("Rest endpoint listening at {}:{}", advertisedAddress, port)___			final String protocol___			if (sslEngine != null) {_				protocol = "https://"__			} else {_				protocol = "http://"__			}__			restBaseUrl = protocol + advertisedAddress + ':' + port___			restAddressFuture.complete(restBaseUrl)___			state = State.RUNNING___			startInternal()__		}_	};starts,this,rest,server,endpoint,throws,exception,if,we,cannot,start,the,rest,server,endpoint;public,final,void,start,throws,exception,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,cannot,be,restarted,log,info,starting,rest,endpoint,final,router,router,new,router,final,completable,future,string,rest,address,future,new,completable,future,list,tuple2,rest,handler,specification,channel,inbound,handler,handlers,initialize,handlers,rest,address,future,collections,sort,handlers,rest,handler,url,comparator,instance,handlers,for,each,handler,log,debug,register,handler,under,handler,f1,handler,f0,get,http,method,handler,f0,get,target,rest,endpoint,url,register,handler,router,handler,channel,initializer,socket,channel,initializer,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,ch,handler,handler,new,router,handler,router,response,headers,if,ssl,engine,null,ch,pipeline,add,last,ssl,new,ssl,handler,ssl,engine,ch,pipeline,add,last,new,http,server,codec,add,last,new,file,upload,handler,upload,dir,add,last,new,flink,http,object,aggregator,max,content,length,response,headers,add,last,handler,name,handler,add,last,new,pipeline,error,handler,log,response,headers,nio,event,loop,group,boss,group,new,nio,event,loop,group,1,new,default,thread,factory,flink,rest,server,netty,boss,nio,event,loop,group,worker,group,new,nio,event,loop,group,0,new,default,thread,factory,flink,rest,server,netty,worker,bootstrap,new,server,bootstrap,bootstrap,group,boss,group,worker,group,channel,nio,server,socket,channel,class,child,handler,initializer,final,channel,future,channel,if,rest,bind,address,null,channel,bootstrap,bind,rest,bind,port,else,channel,bootstrap,bind,rest,bind,address,rest,bind,port,server,channel,channel,sync,uninterruptibly,channel,final,inet,socket,address,bind,address,inet,socket,address,server,channel,local,address,final,string,advertised,address,if,bind,address,get,address,is,any,local,address,advertised,address,this,rest,address,else,advertised,address,bind,address,get,address,get,host,address,final,int,port,bind,address,get,port,log,info,rest,endpoint,listening,at,advertised,address,port,final,string,protocol,if,ssl,engine,null,protocol,https,else,protocol,http,rest,base,url,protocol,advertised,address,port,rest,address,future,complete,rest,base,url,state,state,running,start,internal
RestServerEndpoint -> public final void start() throws Exception;1525904579;Starts this REST server endpoint.__@throws Exception if we cannot start the RestServerEndpoint;public final void start() throws Exception {_		synchronized (lock) {_			Preconditions.checkState(state == State.CREATED, "The RestServerEndpoint cannot be restarted.")___			log.info("Starting rest endpoint.")___			final Router router = new Router()__			final CompletableFuture<String> restAddressFuture = new CompletableFuture<>()___			List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = initializeHandlers(restAddressFuture)___			_			Collections.sort(_				handlers,_				RestHandlerUrlComparator.INSTANCE)___			handlers.forEach(handler -> {_				log.debug("Register handler {} under {}@{}.", handler.f1, handler.f0.getHttpMethod(), handler.f0.getTargetRestEndpointURL())__				registerHandler(router, handler)__			})___			ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {__				@Override_				protected void initChannel(SocketChannel ch) {_					Handler handler = new RouterHandler(router, responseHeaders)___					_					if (sslEngineFactory != null) {_						ch.pipeline().addLast("ssl", new SslHandler(sslEngineFactory.createSSLEngine()))__					}__					ch.pipeline()_						.addLast(new HttpServerCodec())_						.addLast(new FileUploadHandler(uploadDir))_						.addLast(new FlinkHttpObjectAggregator(maxContentLength, responseHeaders))_						.addLast(new ChunkedWriteHandler())_						.addLast(handler.name(), handler)_						.addLast(new PipelineErrorHandler(log, responseHeaders))__				}_			}___			NioEventLoopGroup bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory("flink-rest-server-netty-boss"))__			NioEventLoopGroup workerGroup = new NioEventLoopGroup(0, new DefaultThreadFactory("flink-rest-server-netty-worker"))___			bootstrap = new ServerBootstrap()__			bootstrap_				.group(bossGroup, workerGroup)_				.channel(NioServerSocketChannel.class)_				.childHandler(initializer)___			final ChannelFuture channel__			if (restBindAddress == null) {_				channel = bootstrap.bind(restBindPort)__			} else {_				channel = bootstrap.bind(restBindAddress, restBindPort)__			}_			serverChannel = channel.syncUninterruptibly().channel()___			final InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress()__			final String advertisedAddress__			if (bindAddress.getAddress().isAnyLocalAddress()) {_				advertisedAddress = this.restAddress__			} else {_				advertisedAddress = bindAddress.getAddress().getHostAddress()__			}_			final int port = bindAddress.getPort()___			log.info("Rest endpoint listening at {}:{}", advertisedAddress, port)___			final String protocol___			if (sslEngineFactory != null) {_				protocol = "https://"__			} else {_				protocol = "http://"__			}__			restBaseUrl = protocol + advertisedAddress + ':' + port___			restAddressFuture.complete(restBaseUrl)___			state = State.RUNNING___			startInternal()__		}_	};starts,this,rest,server,endpoint,throws,exception,if,we,cannot,start,the,rest,server,endpoint;public,final,void,start,throws,exception,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,cannot,be,restarted,log,info,starting,rest,endpoint,final,router,router,new,router,final,completable,future,string,rest,address,future,new,completable,future,list,tuple2,rest,handler,specification,channel,inbound,handler,handlers,initialize,handlers,rest,address,future,collections,sort,handlers,rest,handler,url,comparator,instance,handlers,for,each,handler,log,debug,register,handler,under,handler,f1,handler,f0,get,http,method,handler,f0,get,target,rest,endpoint,url,register,handler,router,handler,channel,initializer,socket,channel,initializer,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,ch,handler,handler,new,router,handler,router,response,headers,if,ssl,engine,factory,null,ch,pipeline,add,last,ssl,new,ssl,handler,ssl,engine,factory,create,sslengine,ch,pipeline,add,last,new,http,server,codec,add,last,new,file,upload,handler,upload,dir,add,last,new,flink,http,object,aggregator,max,content,length,response,headers,add,last,new,chunked,write,handler,add,last,handler,name,handler,add,last,new,pipeline,error,handler,log,response,headers,nio,event,loop,group,boss,group,new,nio,event,loop,group,1,new,default,thread,factory,flink,rest,server,netty,boss,nio,event,loop,group,worker,group,new,nio,event,loop,group,0,new,default,thread,factory,flink,rest,server,netty,worker,bootstrap,new,server,bootstrap,bootstrap,group,boss,group,worker,group,channel,nio,server,socket,channel,class,child,handler,initializer,final,channel,future,channel,if,rest,bind,address,null,channel,bootstrap,bind,rest,bind,port,else,channel,bootstrap,bind,rest,bind,address,rest,bind,port,server,channel,channel,sync,uninterruptibly,channel,final,inet,socket,address,bind,address,inet,socket,address,server,channel,local,address,final,string,advertised,address,if,bind,address,get,address,is,any,local,address,advertised,address,this,rest,address,else,advertised,address,bind,address,get,address,get,host,address,final,int,port,bind,address,get,port,log,info,rest,endpoint,listening,at,advertised,address,port,final,string,protocol,if,ssl,engine,factory,null,protocol,https,else,protocol,http,rest,base,url,protocol,advertised,address,port,rest,address,future,complete,rest,base,url,state,state,running,start,internal
RestServerEndpoint -> public final void start() throws Exception;1527499265;Starts this REST server endpoint.__@throws Exception if we cannot start the RestServerEndpoint;public final void start() throws Exception {_		synchronized (lock) {_			Preconditions.checkState(state == State.CREATED, "The RestServerEndpoint cannot be restarted.")___			log.info("Starting rest endpoint.")___			final Router router = new Router()__			final CompletableFuture<String> restAddressFuture = new CompletableFuture<>()___			List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = initializeHandlers(restAddressFuture)___			_			Collections.sort(_				handlers,_				RestHandlerUrlComparator.INSTANCE)___			handlers.forEach(handler -> {_				log.debug("Register handler {} under {}@{}.", handler.f1, handler.f0.getHttpMethod(), handler.f0.getTargetRestEndpointURL())__				registerHandler(router, handler)__			})___			ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {__				@Override_				protected void initChannel(SocketChannel ch) {_					RouterHandler handler = new RouterHandler(router, responseHeaders)___					_					if (sslEngineFactory != null) {_						ch.pipeline().addLast("ssl", new SslHandler(sslEngineFactory.createSSLEngine()))__					}__					ch.pipeline()_						.addLast(new HttpServerCodec())_						.addLast(new FileUploadHandler(uploadDir))_						.addLast(new FlinkHttpObjectAggregator(maxContentLength, responseHeaders))_						.addLast(new ChunkedWriteHandler())_						.addLast(handler.getName(), handler)_						.addLast(new PipelineErrorHandler(log, responseHeaders))__				}_			}___			NioEventLoopGroup bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory("flink-rest-server-netty-boss"))__			NioEventLoopGroup workerGroup = new NioEventLoopGroup(0, new DefaultThreadFactory("flink-rest-server-netty-worker"))___			bootstrap = new ServerBootstrap()__			bootstrap_				.group(bossGroup, workerGroup)_				.channel(NioServerSocketChannel.class)_				.childHandler(initializer)___			final ChannelFuture channel__			if (restBindAddress == null) {_				channel = bootstrap.bind(restBindPort)__			} else {_				channel = bootstrap.bind(restBindAddress, restBindPort)__			}_			serverChannel = channel.syncUninterruptibly().channel()___			final InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress()__			final String advertisedAddress__			if (bindAddress.getAddress().isAnyLocalAddress()) {_				advertisedAddress = this.restAddress__			} else {_				advertisedAddress = bindAddress.getAddress().getHostAddress()__			}_			final int port = bindAddress.getPort()___			log.info("Rest endpoint listening at {}:{}", advertisedAddress, port)___			final String protocol___			if (sslEngineFactory != null) {_				protocol = "https://"__			} else {_				protocol = "http://"__			}__			restBaseUrl = protocol + advertisedAddress + ':' + port___			restAddressFuture.complete(restBaseUrl)___			state = State.RUNNING___			startInternal()__		}_	};starts,this,rest,server,endpoint,throws,exception,if,we,cannot,start,the,rest,server,endpoint;public,final,void,start,throws,exception,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,cannot,be,restarted,log,info,starting,rest,endpoint,final,router,router,new,router,final,completable,future,string,rest,address,future,new,completable,future,list,tuple2,rest,handler,specification,channel,inbound,handler,handlers,initialize,handlers,rest,address,future,collections,sort,handlers,rest,handler,url,comparator,instance,handlers,for,each,handler,log,debug,register,handler,under,handler,f1,handler,f0,get,http,method,handler,f0,get,target,rest,endpoint,url,register,handler,router,handler,channel,initializer,socket,channel,initializer,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,ch,router,handler,handler,new,router,handler,router,response,headers,if,ssl,engine,factory,null,ch,pipeline,add,last,ssl,new,ssl,handler,ssl,engine,factory,create,sslengine,ch,pipeline,add,last,new,http,server,codec,add,last,new,file,upload,handler,upload,dir,add,last,new,flink,http,object,aggregator,max,content,length,response,headers,add,last,new,chunked,write,handler,add,last,handler,get,name,handler,add,last,new,pipeline,error,handler,log,response,headers,nio,event,loop,group,boss,group,new,nio,event,loop,group,1,new,default,thread,factory,flink,rest,server,netty,boss,nio,event,loop,group,worker,group,new,nio,event,loop,group,0,new,default,thread,factory,flink,rest,server,netty,worker,bootstrap,new,server,bootstrap,bootstrap,group,boss,group,worker,group,channel,nio,server,socket,channel,class,child,handler,initializer,final,channel,future,channel,if,rest,bind,address,null,channel,bootstrap,bind,rest,bind,port,else,channel,bootstrap,bind,rest,bind,address,rest,bind,port,server,channel,channel,sync,uninterruptibly,channel,final,inet,socket,address,bind,address,inet,socket,address,server,channel,local,address,final,string,advertised,address,if,bind,address,get,address,is,any,local,address,advertised,address,this,rest,address,else,advertised,address,bind,address,get,address,get,host,address,final,int,port,bind,address,get,port,log,info,rest,endpoint,listening,at,advertised,address,port,final,string,protocol,if,ssl,engine,factory,null,protocol,https,else,protocol,http,rest,base,url,protocol,advertised,address,port,rest,address,future,complete,rest,base,url,state,state,running,start,internal
RestServerEndpoint -> public final void start() throws Exception;1528876304;Starts this REST server endpoint.__@throws Exception if we cannot start the RestServerEndpoint;public final void start() throws Exception {_		synchronized (lock) {_			Preconditions.checkState(state == State.CREATED, "The RestServerEndpoint cannot be restarted.")___			log.info("Starting rest endpoint.")___			final Router router = new Router()__			final CompletableFuture<String> restAddressFuture = new CompletableFuture<>()___			List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = initializeHandlers(restAddressFuture)___			_			Collections.sort(_				handlers,_				RestHandlerUrlComparator.INSTANCE)___			handlers.forEach(handler -> {_				log.debug("Register handler {} under {}@{}.", handler.f1, handler.f0.getHttpMethod(), handler.f0.getTargetRestEndpointURL())__				registerHandler(router, handler)__			})___			ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {__				@Override_				protected void initChannel(SocketChannel ch) {_					RouterHandler handler = new RouterHandler(router, responseHeaders)___					_					if (sslEngineFactory != null) {_						ch.pipeline().addLast("ssl", new SslHandler(sslEngineFactory.createSSLEngine()))__					}__					ch.pipeline()_						.addLast(new HttpServerCodec())_						.addLast(new FileUploadHandler(uploadDir))_						.addLast(new FlinkHttpObjectAggregator(maxContentLength, responseHeaders))_						.addLast(new ChunkedWriteHandler())_						.addLast(handler.getName(), handler)_						.addLast(new PipelineErrorHandler(log, responseHeaders))__				}_			}___			NioEventLoopGroup bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory("flink-rest-server-netty-boss"))__			NioEventLoopGroup workerGroup = new NioEventLoopGroup(0, new DefaultThreadFactory("flink-rest-server-netty-worker"))___			bootstrap = new ServerBootstrap()__			bootstrap_				.group(bossGroup, workerGroup)_				.channel(NioServerSocketChannel.class)_				.childHandler(initializer)___			final ChannelFuture channel__			if (restBindAddress == null) {_				channel = bootstrap.bind(restBindPort)__			} else {_				channel = bootstrap.bind(restBindAddress, restBindPort)__			}_			serverChannel = channel.syncUninterruptibly().channel()___			final InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress()__			final String advertisedAddress__			if (bindAddress.getAddress().isAnyLocalAddress()) {_				advertisedAddress = this.restAddress__			} else {_				advertisedAddress = bindAddress.getAddress().getHostAddress()__			}_			final int port = bindAddress.getPort()___			log.info("Rest endpoint listening at {}:{}", advertisedAddress, port)___			final String protocol___			if (sslEngineFactory != null) {_				protocol = "https://"__			} else {_				protocol = "http://"__			}__			restBaseUrl = protocol + advertisedAddress + ':' + port___			restAddressFuture.complete(restBaseUrl)___			state = State.RUNNING___			startInternal()__		}_	};starts,this,rest,server,endpoint,throws,exception,if,we,cannot,start,the,rest,server,endpoint;public,final,void,start,throws,exception,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,cannot,be,restarted,log,info,starting,rest,endpoint,final,router,router,new,router,final,completable,future,string,rest,address,future,new,completable,future,list,tuple2,rest,handler,specification,channel,inbound,handler,handlers,initialize,handlers,rest,address,future,collections,sort,handlers,rest,handler,url,comparator,instance,handlers,for,each,handler,log,debug,register,handler,under,handler,f1,handler,f0,get,http,method,handler,f0,get,target,rest,endpoint,url,register,handler,router,handler,channel,initializer,socket,channel,initializer,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,ch,router,handler,handler,new,router,handler,router,response,headers,if,ssl,engine,factory,null,ch,pipeline,add,last,ssl,new,ssl,handler,ssl,engine,factory,create,sslengine,ch,pipeline,add,last,new,http,server,codec,add,last,new,file,upload,handler,upload,dir,add,last,new,flink,http,object,aggregator,max,content,length,response,headers,add,last,new,chunked,write,handler,add,last,handler,get,name,handler,add,last,new,pipeline,error,handler,log,response,headers,nio,event,loop,group,boss,group,new,nio,event,loop,group,1,new,default,thread,factory,flink,rest,server,netty,boss,nio,event,loop,group,worker,group,new,nio,event,loop,group,0,new,default,thread,factory,flink,rest,server,netty,worker,bootstrap,new,server,bootstrap,bootstrap,group,boss,group,worker,group,channel,nio,server,socket,channel,class,child,handler,initializer,final,channel,future,channel,if,rest,bind,address,null,channel,bootstrap,bind,rest,bind,port,else,channel,bootstrap,bind,rest,bind,address,rest,bind,port,server,channel,channel,sync,uninterruptibly,channel,final,inet,socket,address,bind,address,inet,socket,address,server,channel,local,address,final,string,advertised,address,if,bind,address,get,address,is,any,local,address,advertised,address,this,rest,address,else,advertised,address,bind,address,get,address,get,host,address,final,int,port,bind,address,get,port,log,info,rest,endpoint,listening,at,advertised,address,port,final,string,protocol,if,ssl,engine,factory,null,protocol,https,else,protocol,http,rest,base,url,protocol,advertised,address,port,rest,address,future,complete,rest,base,url,state,state,running,start,internal
RestServerEndpoint -> public final void start() throws Exception;1534259541;Starts this REST server endpoint.__@throws Exception if we cannot start the RestServerEndpoint;public final void start() throws Exception {_		synchronized (lock) {_			Preconditions.checkState(state == State.CREATED, "The RestServerEndpoint cannot be restarted.")___			log.info("Starting rest endpoint.")___			final Router router = new Router()__			final CompletableFuture<String> restAddressFuture = new CompletableFuture<>()___			List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = initializeHandlers(restAddressFuture)___			_			Collections.sort(_				handlers,_				RestHandlerUrlComparator.INSTANCE)___			handlers.forEach(handler -> {_				log.debug("Register handler {} under {}@{}.", handler.f1, handler.f0.getHttpMethod(), handler.f0.getTargetRestEndpointURL())__				registerHandler(router, handler)__			})___			ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {__				@Override_				protected void initChannel(SocketChannel ch) {_					RouterHandler handler = new RouterHandler(router, responseHeaders)___					_					if (sslEngineFactory != null) {_						ch.pipeline().addLast("ssl", new SslHandler(sslEngineFactory.createSSLEngine()))__					}__					ch.pipeline()_						.addLast(new HttpServerCodec())_						.addLast(new FileUploadHandler(uploadDir))_						.addLast(new FlinkHttpObjectAggregator(maxContentLength, responseHeaders))_						.addLast(new ChunkedWriteHandler())_						.addLast(handler.getName(), handler)_						.addLast(new PipelineErrorHandler(log, responseHeaders))__				}_			}___			NioEventLoopGroup bossGroup = new NioEventLoopGroup(1, new ExecutorThreadFactory("flink-rest-server-netty-boss"))__			NioEventLoopGroup workerGroup = new NioEventLoopGroup(0, new ExecutorThreadFactory("flink-rest-server-netty-worker"))___			bootstrap = new ServerBootstrap()__			bootstrap_				.group(bossGroup, workerGroup)_				.channel(NioServerSocketChannel.class)_				.childHandler(initializer)___			final ChannelFuture channel__			if (restBindAddress == null) {_				channel = bootstrap.bind(restBindPort)__			} else {_				channel = bootstrap.bind(restBindAddress, restBindPort)__			}_			serverChannel = channel.syncUninterruptibly().channel()___			final InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress()__			final String advertisedAddress__			if (bindAddress.getAddress().isAnyLocalAddress()) {_				advertisedAddress = this.restAddress__			} else {_				advertisedAddress = bindAddress.getAddress().getHostAddress()__			}_			final int port = bindAddress.getPort()___			log.info("Rest endpoint listening at {}:{}", advertisedAddress, port)___			final String protocol___			if (sslEngineFactory != null) {_				protocol = "https://"__			} else {_				protocol = "http://"__			}__			restBaseUrl = protocol + advertisedAddress + ':' + port___			restAddressFuture.complete(restBaseUrl)___			state = State.RUNNING___			startInternal()__		}_	};starts,this,rest,server,endpoint,throws,exception,if,we,cannot,start,the,rest,server,endpoint;public,final,void,start,throws,exception,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,cannot,be,restarted,log,info,starting,rest,endpoint,final,router,router,new,router,final,completable,future,string,rest,address,future,new,completable,future,list,tuple2,rest,handler,specification,channel,inbound,handler,handlers,initialize,handlers,rest,address,future,collections,sort,handlers,rest,handler,url,comparator,instance,handlers,for,each,handler,log,debug,register,handler,under,handler,f1,handler,f0,get,http,method,handler,f0,get,target,rest,endpoint,url,register,handler,router,handler,channel,initializer,socket,channel,initializer,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,ch,router,handler,handler,new,router,handler,router,response,headers,if,ssl,engine,factory,null,ch,pipeline,add,last,ssl,new,ssl,handler,ssl,engine,factory,create,sslengine,ch,pipeline,add,last,new,http,server,codec,add,last,new,file,upload,handler,upload,dir,add,last,new,flink,http,object,aggregator,max,content,length,response,headers,add,last,new,chunked,write,handler,add,last,handler,get,name,handler,add,last,new,pipeline,error,handler,log,response,headers,nio,event,loop,group,boss,group,new,nio,event,loop,group,1,new,executor,thread,factory,flink,rest,server,netty,boss,nio,event,loop,group,worker,group,new,nio,event,loop,group,0,new,executor,thread,factory,flink,rest,server,netty,worker,bootstrap,new,server,bootstrap,bootstrap,group,boss,group,worker,group,channel,nio,server,socket,channel,class,child,handler,initializer,final,channel,future,channel,if,rest,bind,address,null,channel,bootstrap,bind,rest,bind,port,else,channel,bootstrap,bind,rest,bind,address,rest,bind,port,server,channel,channel,sync,uninterruptibly,channel,final,inet,socket,address,bind,address,inet,socket,address,server,channel,local,address,final,string,advertised,address,if,bind,address,get,address,is,any,local,address,advertised,address,this,rest,address,else,advertised,address,bind,address,get,address,get,host,address,final,int,port,bind,address,get,port,log,info,rest,endpoint,listening,at,advertised,address,port,final,string,protocol,if,ssl,engine,factory,null,protocol,https,else,protocol,http,rest,base,url,protocol,advertised,address,port,rest,address,future,complete,rest,base,url,state,state,running,start,internal
RestServerEndpoint -> public final void start() throws Exception;1535963626;Starts this REST server endpoint.__@throws Exception if we cannot start the RestServerEndpoint;public final void start() throws Exception {_		synchronized (lock) {_			Preconditions.checkState(state == State.CREATED, "The RestServerEndpoint cannot be restarted.")___			log.info("Starting rest endpoint.")___			final Router router = new Router()__			final CompletableFuture<String> restAddressFuture = new CompletableFuture<>()___			List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = initializeHandlers(restAddressFuture)___			_			Collections.sort(_				handlers,_				RestHandlerUrlComparator.INSTANCE)___			handlers.forEach(handler -> {_				registerHandler(router, handler, log)__			})___			ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {__				@Override_				protected void initChannel(SocketChannel ch) {_					RouterHandler handler = new RouterHandler(router, responseHeaders)___					_					if (sslEngineFactory != null) {_						ch.pipeline().addLast("ssl", new SslHandler(sslEngineFactory.createSSLEngine()))__					}__					ch.pipeline()_						.addLast(new HttpServerCodec())_						.addLast(new FileUploadHandler(uploadDir))_						.addLast(new FlinkHttpObjectAggregator(maxContentLength, responseHeaders))_						.addLast(new ChunkedWriteHandler())_						.addLast(handler.getName(), handler)_						.addLast(new PipelineErrorHandler(log, responseHeaders))__				}_			}___			NioEventLoopGroup bossGroup = new NioEventLoopGroup(1, new ExecutorThreadFactory("flink-rest-server-netty-boss"))__			NioEventLoopGroup workerGroup = new NioEventLoopGroup(0, new ExecutorThreadFactory("flink-rest-server-netty-worker"))___			bootstrap = new ServerBootstrap()__			bootstrap_				.group(bossGroup, workerGroup)_				.channel(NioServerSocketChannel.class)_				.childHandler(initializer)___			final ChannelFuture channel__			if (restBindAddress == null) {_				channel = bootstrap.bind(restBindPort)__			} else {_				channel = bootstrap.bind(restBindAddress, restBindPort)__			}_			serverChannel = channel.syncUninterruptibly().channel()___			final InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress()__			final String advertisedAddress__			if (bindAddress.getAddress().isAnyLocalAddress()) {_				advertisedAddress = this.restAddress__			} else {_				advertisedAddress = bindAddress.getAddress().getHostAddress()__			}_			final int port = bindAddress.getPort()___			log.info("Rest endpoint listening at {}:{}", advertisedAddress, port)___			final String protocol___			if (sslEngineFactory != null) {_				protocol = "https://"__			} else {_				protocol = "http://"__			}__			restBaseUrl = protocol + advertisedAddress + ':' + port___			restAddressFuture.complete(restBaseUrl)___			state = State.RUNNING___			startInternal()__		}_	};starts,this,rest,server,endpoint,throws,exception,if,we,cannot,start,the,rest,server,endpoint;public,final,void,start,throws,exception,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,cannot,be,restarted,log,info,starting,rest,endpoint,final,router,router,new,router,final,completable,future,string,rest,address,future,new,completable,future,list,tuple2,rest,handler,specification,channel,inbound,handler,handlers,initialize,handlers,rest,address,future,collections,sort,handlers,rest,handler,url,comparator,instance,handlers,for,each,handler,register,handler,router,handler,log,channel,initializer,socket,channel,initializer,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,ch,router,handler,handler,new,router,handler,router,response,headers,if,ssl,engine,factory,null,ch,pipeline,add,last,ssl,new,ssl,handler,ssl,engine,factory,create,sslengine,ch,pipeline,add,last,new,http,server,codec,add,last,new,file,upload,handler,upload,dir,add,last,new,flink,http,object,aggregator,max,content,length,response,headers,add,last,new,chunked,write,handler,add,last,handler,get,name,handler,add,last,new,pipeline,error,handler,log,response,headers,nio,event,loop,group,boss,group,new,nio,event,loop,group,1,new,executor,thread,factory,flink,rest,server,netty,boss,nio,event,loop,group,worker,group,new,nio,event,loop,group,0,new,executor,thread,factory,flink,rest,server,netty,worker,bootstrap,new,server,bootstrap,bootstrap,group,boss,group,worker,group,channel,nio,server,socket,channel,class,child,handler,initializer,final,channel,future,channel,if,rest,bind,address,null,channel,bootstrap,bind,rest,bind,port,else,channel,bootstrap,bind,rest,bind,address,rest,bind,port,server,channel,channel,sync,uninterruptibly,channel,final,inet,socket,address,bind,address,inet,socket,address,server,channel,local,address,final,string,advertised,address,if,bind,address,get,address,is,any,local,address,advertised,address,this,rest,address,else,advertised,address,bind,address,get,address,get,host,address,final,int,port,bind,address,get,port,log,info,rest,endpoint,listening,at,advertised,address,port,final,string,protocol,if,ssl,engine,factory,null,protocol,https,else,protocol,http,rest,base,url,protocol,advertised,address,port,rest,address,future,complete,rest,base,url,state,state,running,start,internal
RestServerEndpoint -> public final void start() throws Exception;1536930104;Starts this REST server endpoint.__@throws Exception if we cannot start the RestServerEndpoint;public final void start() throws Exception {_		synchronized (lock) {_			Preconditions.checkState(state == State.CREATED, "The RestServerEndpoint cannot be restarted.")___			log.info("Starting rest endpoint.")___			final Router router = new Router()__			final CompletableFuture<String> restAddressFuture = new CompletableFuture<>()___			List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = initializeHandlers(restAddressFuture)___			_			Collections.sort(_				handlers,_				RestHandlerUrlComparator.INSTANCE)___			handlers.forEach(handler -> {_				registerHandler(router, handler, log)__			})___			ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {__				@Override_				protected void initChannel(SocketChannel ch) {_					RouterHandler handler = new RouterHandler(router, responseHeaders)___					_					if (sslEngineFactory != null) {_						ch.pipeline().addLast("ssl", new SslHandler(sslEngineFactory.createSSLEngine()))__					}__					ch.pipeline()_						.addLast(new HttpServerCodec())_						.addLast(new FileUploadHandler(uploadDir))_						.addLast(new FlinkHttpObjectAggregator(maxContentLength, responseHeaders))_						.addLast(new ChunkedWriteHandler())_						.addLast(handler.getName(), handler)_						.addLast(new PipelineErrorHandler(log, responseHeaders))__				}_			}___			NioEventLoopGroup bossGroup = new NioEventLoopGroup(1, new ExecutorThreadFactory("flink-rest-server-netty-boss"))__			NioEventLoopGroup workerGroup = new NioEventLoopGroup(0, new ExecutorThreadFactory("flink-rest-server-netty-worker"))___			bootstrap = new ServerBootstrap()__			bootstrap_				.group(bossGroup, workerGroup)_				.channel(NioServerSocketChannel.class)_				.childHandler(initializer)___			log.debug("Binding rest endpoint to {}:{}.", restBindAddress, restBindPort)__			final ChannelFuture channel__			if (restBindAddress == null) {_				channel = bootstrap.bind(restBindPort)__			} else {_				channel = bootstrap.bind(restBindAddress, restBindPort)__			}_			serverChannel = channel.syncUninterruptibly().channel()___			final InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress()__			final String advertisedAddress__			if (bindAddress.getAddress().isAnyLocalAddress()) {_				advertisedAddress = this.restAddress__			} else {_				advertisedAddress = bindAddress.getAddress().getHostAddress()__			}_			final int port = bindAddress.getPort()___			log.info("Rest endpoint listening at {}:{}", advertisedAddress, port)___			final String protocol___			if (sslEngineFactory != null) {_				protocol = "https://"__			} else {_				protocol = "http://"__			}__			restBaseUrl = protocol + advertisedAddress + ':' + port___			restAddressFuture.complete(restBaseUrl)___			state = State.RUNNING___			startInternal()__		}_	};starts,this,rest,server,endpoint,throws,exception,if,we,cannot,start,the,rest,server,endpoint;public,final,void,start,throws,exception,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,cannot,be,restarted,log,info,starting,rest,endpoint,final,router,router,new,router,final,completable,future,string,rest,address,future,new,completable,future,list,tuple2,rest,handler,specification,channel,inbound,handler,handlers,initialize,handlers,rest,address,future,collections,sort,handlers,rest,handler,url,comparator,instance,handlers,for,each,handler,register,handler,router,handler,log,channel,initializer,socket,channel,initializer,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,ch,router,handler,handler,new,router,handler,router,response,headers,if,ssl,engine,factory,null,ch,pipeline,add,last,ssl,new,ssl,handler,ssl,engine,factory,create,sslengine,ch,pipeline,add,last,new,http,server,codec,add,last,new,file,upload,handler,upload,dir,add,last,new,flink,http,object,aggregator,max,content,length,response,headers,add,last,new,chunked,write,handler,add,last,handler,get,name,handler,add,last,new,pipeline,error,handler,log,response,headers,nio,event,loop,group,boss,group,new,nio,event,loop,group,1,new,executor,thread,factory,flink,rest,server,netty,boss,nio,event,loop,group,worker,group,new,nio,event,loop,group,0,new,executor,thread,factory,flink,rest,server,netty,worker,bootstrap,new,server,bootstrap,bootstrap,group,boss,group,worker,group,channel,nio,server,socket,channel,class,child,handler,initializer,log,debug,binding,rest,endpoint,to,rest,bind,address,rest,bind,port,final,channel,future,channel,if,rest,bind,address,null,channel,bootstrap,bind,rest,bind,port,else,channel,bootstrap,bind,rest,bind,address,rest,bind,port,server,channel,channel,sync,uninterruptibly,channel,final,inet,socket,address,bind,address,inet,socket,address,server,channel,local,address,final,string,advertised,address,if,bind,address,get,address,is,any,local,address,advertised,address,this,rest,address,else,advertised,address,bind,address,get,address,get,host,address,final,int,port,bind,address,get,port,log,info,rest,endpoint,listening,at,advertised,address,port,final,string,protocol,if,ssl,engine,factory,null,protocol,https,else,protocol,http,rest,base,url,protocol,advertised,address,port,rest,address,future,complete,rest,base,url,state,state,running,start,internal
RestServerEndpoint -> public final void start() throws Exception;1539170288;Starts this REST server endpoint.__@throws Exception if we cannot start the RestServerEndpoint;public final void start() throws Exception {_		synchronized (lock) {_			Preconditions.checkState(state == State.CREATED, "The RestServerEndpoint cannot be restarted.")___			log.info("Starting rest endpoint.")___			final Router router = new Router()__			final CompletableFuture<String> restAddressFuture = new CompletableFuture<>()___			List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = initializeHandlers(restAddressFuture)___			_			Collections.sort(_				handlers,_				RestHandlerUrlComparator.INSTANCE)___			handlers.forEach(handler -> {_				registerHandler(router, handler, log)__			})___			ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {__				@Override_				protected void initChannel(SocketChannel ch) {_					RouterHandler handler = new RouterHandler(router, responseHeaders)___					_					if (sslEngineFactory != null) {_						ch.pipeline().addLast("ssl",_							new RedirectingSslHandler(restAddress, restAddressFuture, sslEngineFactory))__					}__					ch.pipeline()_						.addLast(new HttpServerCodec())_						.addLast(new FileUploadHandler(uploadDir))_						.addLast(new FlinkHttpObjectAggregator(maxContentLength, responseHeaders))_						.addLast(new ChunkedWriteHandler())_						.addLast(handler.getName(), handler)_						.addLast(new PipelineErrorHandler(log, responseHeaders))__				}_			}___			NioEventLoopGroup bossGroup = new NioEventLoopGroup(1, new ExecutorThreadFactory("flink-rest-server-netty-boss"))__			NioEventLoopGroup workerGroup = new NioEventLoopGroup(0, new ExecutorThreadFactory("flink-rest-server-netty-worker"))___			bootstrap = new ServerBootstrap()__			bootstrap_				.group(bossGroup, workerGroup)_				.channel(NioServerSocketChannel.class)_				.childHandler(initializer)___			log.debug("Binding rest endpoint to {}:{}.", restBindAddress, restBindPort)__			final ChannelFuture channel__			if (restBindAddress == null) {_				channel = bootstrap.bind(restBindPort)__			} else {_				channel = bootstrap.bind(restBindAddress, restBindPort)__			}_			serverChannel = channel.syncUninterruptibly().channel()___			final InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress()__			final String advertisedAddress__			if (bindAddress.getAddress().isAnyLocalAddress()) {_				advertisedAddress = this.restAddress__			} else {_				advertisedAddress = bindAddress.getAddress().getHostAddress()__			}_			final int port = bindAddress.getPort()___			log.info("Rest endpoint listening at {}:{}", advertisedAddress, port)___			final String protocol___			if (sslEngineFactory != null) {_				protocol = "https://"__			} else {_				protocol = "http://"__			}__			restBaseUrl = protocol + advertisedAddress + ':' + port___			restAddressFuture.complete(restBaseUrl)___			state = State.RUNNING___			startInternal()__		}_	};starts,this,rest,server,endpoint,throws,exception,if,we,cannot,start,the,rest,server,endpoint;public,final,void,start,throws,exception,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,cannot,be,restarted,log,info,starting,rest,endpoint,final,router,router,new,router,final,completable,future,string,rest,address,future,new,completable,future,list,tuple2,rest,handler,specification,channel,inbound,handler,handlers,initialize,handlers,rest,address,future,collections,sort,handlers,rest,handler,url,comparator,instance,handlers,for,each,handler,register,handler,router,handler,log,channel,initializer,socket,channel,initializer,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,ch,router,handler,handler,new,router,handler,router,response,headers,if,ssl,engine,factory,null,ch,pipeline,add,last,ssl,new,redirecting,ssl,handler,rest,address,rest,address,future,ssl,engine,factory,ch,pipeline,add,last,new,http,server,codec,add,last,new,file,upload,handler,upload,dir,add,last,new,flink,http,object,aggregator,max,content,length,response,headers,add,last,new,chunked,write,handler,add,last,handler,get,name,handler,add,last,new,pipeline,error,handler,log,response,headers,nio,event,loop,group,boss,group,new,nio,event,loop,group,1,new,executor,thread,factory,flink,rest,server,netty,boss,nio,event,loop,group,worker,group,new,nio,event,loop,group,0,new,executor,thread,factory,flink,rest,server,netty,worker,bootstrap,new,server,bootstrap,bootstrap,group,boss,group,worker,group,channel,nio,server,socket,channel,class,child,handler,initializer,log,debug,binding,rest,endpoint,to,rest,bind,address,rest,bind,port,final,channel,future,channel,if,rest,bind,address,null,channel,bootstrap,bind,rest,bind,port,else,channel,bootstrap,bind,rest,bind,address,rest,bind,port,server,channel,channel,sync,uninterruptibly,channel,final,inet,socket,address,bind,address,inet,socket,address,server,channel,local,address,final,string,advertised,address,if,bind,address,get,address,is,any,local,address,advertised,address,this,rest,address,else,advertised,address,bind,address,get,address,get,host,address,final,int,port,bind,address,get,port,log,info,rest,endpoint,listening,at,advertised,address,port,final,string,protocol,if,ssl,engine,factory,null,protocol,https,else,protocol,http,rest,base,url,protocol,advertised,address,port,rest,address,future,complete,rest,base,url,state,state,running,start,internal
RestServerEndpoint -> public final void start() throws Exception;1539934386;Starts this REST server endpoint.__@throws Exception if we cannot start the RestServerEndpoint;public final void start() throws Exception {_		synchronized (lock) {_			Preconditions.checkState(state == State.CREATED, "The RestServerEndpoint cannot be restarted.")___			log.info("Starting rest endpoint.")___			final Router router = new Router()__			final CompletableFuture<String> restAddressFuture = new CompletableFuture<>()___			handlers = initializeHandlers(restAddressFuture)___			_			Collections.sort(_				handlers,_				RestHandlerUrlComparator.INSTANCE)___			handlers.forEach(handler -> {_				registerHandler(router, handler, log)__			})___			ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {__				@Override_				protected void initChannel(SocketChannel ch) {_					RouterHandler handler = new RouterHandler(router, responseHeaders)___					_					if (sslEngineFactory != null) {_						ch.pipeline().addLast("ssl",_							new RedirectingSslHandler(restAddress, restAddressFuture, sslEngineFactory))__					}__					ch.pipeline()_						.addLast(new HttpServerCodec())_						.addLast(new FileUploadHandler(uploadDir))_						.addLast(new FlinkHttpObjectAggregator(maxContentLength, responseHeaders))_						.addLast(new ChunkedWriteHandler())_						.addLast(handler.getName(), handler)_						.addLast(new PipelineErrorHandler(log, responseHeaders))__				}_			}___			NioEventLoopGroup bossGroup = new NioEventLoopGroup(1, new ExecutorThreadFactory("flink-rest-server-netty-boss"))__			NioEventLoopGroup workerGroup = new NioEventLoopGroup(0, new ExecutorThreadFactory("flink-rest-server-netty-worker"))___			bootstrap = new ServerBootstrap()__			bootstrap_				.group(bossGroup, workerGroup)_				.channel(NioServerSocketChannel.class)_				.childHandler(initializer)___			log.debug("Binding rest endpoint to {}:{}.", restBindAddress, restBindPort)__			final ChannelFuture channel__			if (restBindAddress == null) {_				channel = bootstrap.bind(restBindPort)__			} else {_				channel = bootstrap.bind(restBindAddress, restBindPort)__			}_			serverChannel = channel.syncUninterruptibly().channel()___			final InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress()__			final String advertisedAddress__			if (bindAddress.getAddress().isAnyLocalAddress()) {_				advertisedAddress = this.restAddress__			} else {_				advertisedAddress = bindAddress.getAddress().getHostAddress()__			}_			final int port = bindAddress.getPort()___			log.info("Rest endpoint listening at {}:{}", advertisedAddress, port)___			final String protocol___			if (sslEngineFactory != null) {_				protocol = "https://"__			} else {_				protocol = "http://"__			}__			restBaseUrl = protocol + advertisedAddress + ':' + port___			restAddressFuture.complete(restBaseUrl)___			state = State.RUNNING___			startInternal()__		}_	};starts,this,rest,server,endpoint,throws,exception,if,we,cannot,start,the,rest,server,endpoint;public,final,void,start,throws,exception,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,cannot,be,restarted,log,info,starting,rest,endpoint,final,router,router,new,router,final,completable,future,string,rest,address,future,new,completable,future,handlers,initialize,handlers,rest,address,future,collections,sort,handlers,rest,handler,url,comparator,instance,handlers,for,each,handler,register,handler,router,handler,log,channel,initializer,socket,channel,initializer,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,ch,router,handler,handler,new,router,handler,router,response,headers,if,ssl,engine,factory,null,ch,pipeline,add,last,ssl,new,redirecting,ssl,handler,rest,address,rest,address,future,ssl,engine,factory,ch,pipeline,add,last,new,http,server,codec,add,last,new,file,upload,handler,upload,dir,add,last,new,flink,http,object,aggregator,max,content,length,response,headers,add,last,new,chunked,write,handler,add,last,handler,get,name,handler,add,last,new,pipeline,error,handler,log,response,headers,nio,event,loop,group,boss,group,new,nio,event,loop,group,1,new,executor,thread,factory,flink,rest,server,netty,boss,nio,event,loop,group,worker,group,new,nio,event,loop,group,0,new,executor,thread,factory,flink,rest,server,netty,worker,bootstrap,new,server,bootstrap,bootstrap,group,boss,group,worker,group,channel,nio,server,socket,channel,class,child,handler,initializer,log,debug,binding,rest,endpoint,to,rest,bind,address,rest,bind,port,final,channel,future,channel,if,rest,bind,address,null,channel,bootstrap,bind,rest,bind,port,else,channel,bootstrap,bind,rest,bind,address,rest,bind,port,server,channel,channel,sync,uninterruptibly,channel,final,inet,socket,address,bind,address,inet,socket,address,server,channel,local,address,final,string,advertised,address,if,bind,address,get,address,is,any,local,address,advertised,address,this,rest,address,else,advertised,address,bind,address,get,address,get,host,address,final,int,port,bind,address,get,port,log,info,rest,endpoint,listening,at,advertised,address,port,final,string,protocol,if,ssl,engine,factory,null,protocol,https,else,protocol,http,rest,base,url,protocol,advertised,address,port,rest,address,future,complete,rest,base,url,state,state,running,start,internal
RestServerEndpoint -> public final void start() throws Exception;1540215410;Starts this REST server endpoint.__@throws Exception if we cannot start the RestServerEndpoint;public final void start() throws Exception {_		synchronized (lock) {_			Preconditions.checkState(state == State.CREATED, "The RestServerEndpoint cannot be restarted.")___			log.info("Starting rest endpoint.")___			final Router router = new Router()__			final CompletableFuture<String> restAddressFuture = new CompletableFuture<>()___			handlers = initializeHandlers(restAddressFuture)___			_			Collections.sort(_				handlers,_				RestHandlerUrlComparator.INSTANCE)___			handlers.forEach(handler -> {_				registerHandler(router, handler, log)__			})___			ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {__				@Override_				protected void initChannel(SocketChannel ch) {_					RouterHandler handler = new RouterHandler(router, responseHeaders)___					_					if (sslHandlerFactory != null) {_						ch.pipeline().addLast("ssl",_							new RedirectingSslHandler(restAddress, restAddressFuture, sslHandlerFactory))__					}__					ch.pipeline()_						.addLast(new HttpServerCodec())_						.addLast(new FileUploadHandler(uploadDir))_						.addLast(new FlinkHttpObjectAggregator(maxContentLength, responseHeaders))_						.addLast(new ChunkedWriteHandler())_						.addLast(handler.getName(), handler)_						.addLast(new PipelineErrorHandler(log, responseHeaders))__				}_			}___			NioEventLoopGroup bossGroup = new NioEventLoopGroup(1, new ExecutorThreadFactory("flink-rest-server-netty-boss"))__			NioEventLoopGroup workerGroup = new NioEventLoopGroup(0, new ExecutorThreadFactory("flink-rest-server-netty-worker"))___			bootstrap = new ServerBootstrap()__			bootstrap_				.group(bossGroup, workerGroup)_				.channel(NioServerSocketChannel.class)_				.childHandler(initializer)___			log.debug("Binding rest endpoint to {}:{}.", restBindAddress, restBindPort)__			final ChannelFuture channel__			if (restBindAddress == null) {_				channel = bootstrap.bind(restBindPort)__			} else {_				channel = bootstrap.bind(restBindAddress, restBindPort)__			}_			serverChannel = channel.syncUninterruptibly().channel()___			final InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress()__			final String advertisedAddress__			if (bindAddress.getAddress().isAnyLocalAddress()) {_				advertisedAddress = this.restAddress__			} else {_				advertisedAddress = bindAddress.getAddress().getHostAddress()__			}_			final int port = bindAddress.getPort()___			log.info("Rest endpoint listening at {}:{}", advertisedAddress, port)___			final String protocol___			if (sslHandlerFactory != null) {_				protocol = "https://"__			} else {_				protocol = "http://"__			}__			restBaseUrl = protocol + advertisedAddress + ':' + port___			restAddressFuture.complete(restBaseUrl)___			state = State.RUNNING___			startInternal()__		}_	};starts,this,rest,server,endpoint,throws,exception,if,we,cannot,start,the,rest,server,endpoint;public,final,void,start,throws,exception,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,cannot,be,restarted,log,info,starting,rest,endpoint,final,router,router,new,router,final,completable,future,string,rest,address,future,new,completable,future,handlers,initialize,handlers,rest,address,future,collections,sort,handlers,rest,handler,url,comparator,instance,handlers,for,each,handler,register,handler,router,handler,log,channel,initializer,socket,channel,initializer,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,ch,router,handler,handler,new,router,handler,router,response,headers,if,ssl,handler,factory,null,ch,pipeline,add,last,ssl,new,redirecting,ssl,handler,rest,address,rest,address,future,ssl,handler,factory,ch,pipeline,add,last,new,http,server,codec,add,last,new,file,upload,handler,upload,dir,add,last,new,flink,http,object,aggregator,max,content,length,response,headers,add,last,new,chunked,write,handler,add,last,handler,get,name,handler,add,last,new,pipeline,error,handler,log,response,headers,nio,event,loop,group,boss,group,new,nio,event,loop,group,1,new,executor,thread,factory,flink,rest,server,netty,boss,nio,event,loop,group,worker,group,new,nio,event,loop,group,0,new,executor,thread,factory,flink,rest,server,netty,worker,bootstrap,new,server,bootstrap,bootstrap,group,boss,group,worker,group,channel,nio,server,socket,channel,class,child,handler,initializer,log,debug,binding,rest,endpoint,to,rest,bind,address,rest,bind,port,final,channel,future,channel,if,rest,bind,address,null,channel,bootstrap,bind,rest,bind,port,else,channel,bootstrap,bind,rest,bind,address,rest,bind,port,server,channel,channel,sync,uninterruptibly,channel,final,inet,socket,address,bind,address,inet,socket,address,server,channel,local,address,final,string,advertised,address,if,bind,address,get,address,is,any,local,address,advertised,address,this,rest,address,else,advertised,address,bind,address,get,address,get,host,address,final,int,port,bind,address,get,port,log,info,rest,endpoint,listening,at,advertised,address,port,final,string,protocol,if,ssl,handler,factory,null,protocol,https,else,protocol,http,rest,base,url,protocol,advertised,address,port,rest,address,future,complete,rest,base,url,state,state,running,start,internal
RestServerEndpoint -> public final void start() throws Exception;1545326469;Starts this REST server endpoint.__@throws Exception if we cannot start the RestServerEndpoint;public final void start() throws Exception {_		synchronized (lock) {_			Preconditions.checkState(state == State.CREATED, "The RestServerEndpoint cannot be restarted.")___			log.info("Starting rest endpoint.")___			final Router router = new Router()__			final CompletableFuture<String> restAddressFuture = new CompletableFuture<>()___			handlers = initializeHandlers(restAddressFuture)___			_			Collections.sort(_				handlers,_				RestHandlerUrlComparator.INSTANCE)___			handlers.forEach(handler -> {_				registerHandler(router, handler, log)__			})___			ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {__				@Override_				protected void initChannel(SocketChannel ch) {_					RouterHandler handler = new RouterHandler(router, responseHeaders)___					_					if (sslHandlerFactory != null) {_						ch.pipeline().addLast("ssl",_							new RedirectingSslHandler(restAddress, restAddressFuture, sslHandlerFactory))__					}__					ch.pipeline()_						.addLast(new HttpServerCodec())_						.addLast(new FileUploadHandler(uploadDir))_						.addLast(new FlinkHttpObjectAggregator(maxContentLength, responseHeaders))_						.addLast(new ChunkedWriteHandler())_						.addLast(handler.getName(), handler)_						.addLast(new PipelineErrorHandler(log, responseHeaders))__				}_			}___			NioEventLoopGroup bossGroup = new NioEventLoopGroup(1, new ExecutorThreadFactory("flink-rest-server-netty-boss"))__			NioEventLoopGroup workerGroup = new NioEventLoopGroup(0, new ExecutorThreadFactory("flink-rest-server-netty-worker"))___			bootstrap = new ServerBootstrap()__			bootstrap_				.group(bossGroup, workerGroup)_				.channel(NioServerSocketChannel.class)_				.childHandler(initializer)___			log.debug("Binding rest endpoint to {}:{}.", restBindAddress, restBindPort)__			final ChannelFuture channel__			if (restBindAddress == null) {_				channel = bootstrap.bind(restBindPort)__			} else {_				channel = bootstrap.bind(restBindAddress, restBindPort)__			}_			serverChannel = channel.syncUninterruptibly().channel()___			final InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress()__			final String advertisedAddress__			if (bindAddress.getAddress().isAnyLocalAddress()) {_				advertisedAddress = this.restAddress__			} else {_				advertisedAddress = bindAddress.getAddress().getHostAddress()__			}_			final int port = bindAddress.getPort()___			log.info("Rest endpoint listening at {}:{}", advertisedAddress, port)___			final String protocol___			if (sslHandlerFactory != null) {_				protocol = "https://"__			} else {_				protocol = "http://"__			}__			restBaseUrl = protocol + advertisedAddress + ':' + port___			restAddressFuture.complete(restBaseUrl)___			state = State.RUNNING___			startInternal()__		}_	};starts,this,rest,server,endpoint,throws,exception,if,we,cannot,start,the,rest,server,endpoint;public,final,void,start,throws,exception,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,cannot,be,restarted,log,info,starting,rest,endpoint,final,router,router,new,router,final,completable,future,string,rest,address,future,new,completable,future,handlers,initialize,handlers,rest,address,future,collections,sort,handlers,rest,handler,url,comparator,instance,handlers,for,each,handler,register,handler,router,handler,log,channel,initializer,socket,channel,initializer,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,ch,router,handler,handler,new,router,handler,router,response,headers,if,ssl,handler,factory,null,ch,pipeline,add,last,ssl,new,redirecting,ssl,handler,rest,address,rest,address,future,ssl,handler,factory,ch,pipeline,add,last,new,http,server,codec,add,last,new,file,upload,handler,upload,dir,add,last,new,flink,http,object,aggregator,max,content,length,response,headers,add,last,new,chunked,write,handler,add,last,handler,get,name,handler,add,last,new,pipeline,error,handler,log,response,headers,nio,event,loop,group,boss,group,new,nio,event,loop,group,1,new,executor,thread,factory,flink,rest,server,netty,boss,nio,event,loop,group,worker,group,new,nio,event,loop,group,0,new,executor,thread,factory,flink,rest,server,netty,worker,bootstrap,new,server,bootstrap,bootstrap,group,boss,group,worker,group,channel,nio,server,socket,channel,class,child,handler,initializer,log,debug,binding,rest,endpoint,to,rest,bind,address,rest,bind,port,final,channel,future,channel,if,rest,bind,address,null,channel,bootstrap,bind,rest,bind,port,else,channel,bootstrap,bind,rest,bind,address,rest,bind,port,server,channel,channel,sync,uninterruptibly,channel,final,inet,socket,address,bind,address,inet,socket,address,server,channel,local,address,final,string,advertised,address,if,bind,address,get,address,is,any,local,address,advertised,address,this,rest,address,else,advertised,address,bind,address,get,address,get,host,address,final,int,port,bind,address,get,port,log,info,rest,endpoint,listening,at,advertised,address,port,final,string,protocol,if,ssl,handler,factory,null,protocol,https,else,protocol,http,rest,base,url,protocol,advertised,address,port,rest,address,future,complete,rest,base,url,state,state,running,start,internal
RestServerEndpoint -> public final void start() throws Exception;1550222817;Starts this REST server endpoint.__@throws Exception if we cannot start the RestServerEndpoint;public final void start() throws Exception {_		synchronized (lock) {_			Preconditions.checkState(state == State.CREATED, "The RestServerEndpoint cannot be restarted.")___			log.info("Starting rest endpoint.")___			final Router router = new Router()__			final CompletableFuture<String> restAddressFuture = new CompletableFuture<>()___			handlers = initializeHandlers(restAddressFuture)___			_			Collections.sort(_				handlers,_				RestHandlerUrlComparator.INSTANCE)___			handlers.forEach(handler -> {_				registerHandler(router, handler, log)__			})___			ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {__				@Override_				protected void initChannel(SocketChannel ch) {_					RouterHandler handler = new RouterHandler(router, responseHeaders)___					_					if (sslHandlerFactory != null) {_						ch.pipeline().addLast("ssl",_							new RedirectingSslHandler(restAddress, restAddressFuture, sslHandlerFactory))__					}__					ch.pipeline()_						.addLast(new HttpServerCodec())_						.addLast(new FileUploadHandler(uploadDir))_						.addLast(new FlinkHttpObjectAggregator(maxContentLength, responseHeaders))_						.addLast(new ChunkedWriteHandler())_						.addLast(handler.getName(), handler)_						.addLast(new PipelineErrorHandler(log, responseHeaders))__				}_			}___			NioEventLoopGroup bossGroup = new NioEventLoopGroup(1, new ExecutorThreadFactory("flink-rest-server-netty-boss"))__			NioEventLoopGroup workerGroup = new NioEventLoopGroup(0, new ExecutorThreadFactory("flink-rest-server-netty-worker"))___			bootstrap = new ServerBootstrap()__			bootstrap_				.group(bossGroup, workerGroup)_				.channel(NioServerSocketChannel.class)_				.childHandler(initializer)___			Iterator<Integer> portsIterator__			try {_				portsIterator = NetUtils.getPortRangeFromString(restBindPortRange)__			} catch (IllegalConfigurationException e) {_				throw e__			} catch (Exception e) {_				throw new IllegalArgumentException("Invalid port range definition: " + restBindPortRange)__			}__			int chosenPort = 0__			while (portsIterator.hasNext()) {_				try {_					chosenPort = portsIterator.next()__					final ChannelFuture channel__					if (restBindAddress == null) {_						channel = bootstrap.bind(chosenPort)__					} else {_						channel = bootstrap.bind(restBindAddress, chosenPort)__					}_					serverChannel = channel.syncUninterruptibly().channel()__					break__				} catch (final Exception e) {_					_					if (!(e instanceof org.jboss.netty.channel.ChannelException || e instanceof java.net.BindException)) {_						throw e__					}_				}_			}__			if (serverChannel == null) {_				throw new BindException("Could not start rest endpoint on any port in port range " + restBindPortRange)__			}__			log.debug("Binding rest endpoint to {}:{}.", restBindAddress, chosenPort)___			final InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress()__			final String advertisedAddress__			if (bindAddress.getAddress().isAnyLocalAddress()) {_				advertisedAddress = this.restAddress__			} else {_				advertisedAddress = bindAddress.getAddress().getHostAddress()__			}_			final int port = bindAddress.getPort()___			log.info("Rest endpoint listening at {}:{}", advertisedAddress, port)___			final String protocol___			if (sslHandlerFactory != null) {_				protocol = "https://"__			} else {_				protocol = "http://"__			}__			restBaseUrl = protocol + advertisedAddress + ':' + port___			restAddressFuture.complete(restBaseUrl)___			state = State.RUNNING___			startInternal()__		}_	};starts,this,rest,server,endpoint,throws,exception,if,we,cannot,start,the,rest,server,endpoint;public,final,void,start,throws,exception,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,cannot,be,restarted,log,info,starting,rest,endpoint,final,router,router,new,router,final,completable,future,string,rest,address,future,new,completable,future,handlers,initialize,handlers,rest,address,future,collections,sort,handlers,rest,handler,url,comparator,instance,handlers,for,each,handler,register,handler,router,handler,log,channel,initializer,socket,channel,initializer,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,ch,router,handler,handler,new,router,handler,router,response,headers,if,ssl,handler,factory,null,ch,pipeline,add,last,ssl,new,redirecting,ssl,handler,rest,address,rest,address,future,ssl,handler,factory,ch,pipeline,add,last,new,http,server,codec,add,last,new,file,upload,handler,upload,dir,add,last,new,flink,http,object,aggregator,max,content,length,response,headers,add,last,new,chunked,write,handler,add,last,handler,get,name,handler,add,last,new,pipeline,error,handler,log,response,headers,nio,event,loop,group,boss,group,new,nio,event,loop,group,1,new,executor,thread,factory,flink,rest,server,netty,boss,nio,event,loop,group,worker,group,new,nio,event,loop,group,0,new,executor,thread,factory,flink,rest,server,netty,worker,bootstrap,new,server,bootstrap,bootstrap,group,boss,group,worker,group,channel,nio,server,socket,channel,class,child,handler,initializer,iterator,integer,ports,iterator,try,ports,iterator,net,utils,get,port,range,from,string,rest,bind,port,range,catch,illegal,configuration,exception,e,throw,e,catch,exception,e,throw,new,illegal,argument,exception,invalid,port,range,definition,rest,bind,port,range,int,chosen,port,0,while,ports,iterator,has,next,try,chosen,port,ports,iterator,next,final,channel,future,channel,if,rest,bind,address,null,channel,bootstrap,bind,chosen,port,else,channel,bootstrap,bind,rest,bind,address,chosen,port,server,channel,channel,sync,uninterruptibly,channel,break,catch,final,exception,e,if,e,instanceof,org,jboss,netty,channel,channel,exception,e,instanceof,java,net,bind,exception,throw,e,if,server,channel,null,throw,new,bind,exception,could,not,start,rest,endpoint,on,any,port,in,port,range,rest,bind,port,range,log,debug,binding,rest,endpoint,to,rest,bind,address,chosen,port,final,inet,socket,address,bind,address,inet,socket,address,server,channel,local,address,final,string,advertised,address,if,bind,address,get,address,is,any,local,address,advertised,address,this,rest,address,else,advertised,address,bind,address,get,address,get,host,address,final,int,port,bind,address,get,port,log,info,rest,endpoint,listening,at,advertised,address,port,final,string,protocol,if,ssl,handler,factory,null,protocol,https,else,protocol,http,rest,base,url,protocol,advertised,address,port,rest,address,future,complete,rest,base,url,state,state,running,start,internal
RestServerEndpoint -> protected abstract Collection<AbstractRestHandler<?, ?, ?>> initializeHandlers()_;1503738659;This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint_implementation requires.;protected abstract Collection<AbstractRestHandler<?, ?, ?>> initializeHandlers()_;this,method,is,called,at,the,beginning,of,link,start,to,setup,all,handlers,that,the,rest,server,endpoint,implementation,requires;protected,abstract,collection,abstract,rest,handler,initialize,handlers
RestServerEndpoint -> protected abstract Collection<AbstractRestHandler<?, ?, ?>> initializeHandlers()_;1503738660;This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint_implementation requires.;protected abstract Collection<AbstractRestHandler<?, ?, ?>> initializeHandlers()_;this,method,is,called,at,the,beginning,of,link,start,to,setup,all,handlers,that,the,rest,server,endpoint,implementation,requires;protected,abstract,collection,abstract,rest,handler,initialize,handlers
RestServerEndpoint -> protected abstract Collection<AbstractRestHandler<?, ?, ?>> initializeHandlers()_;1505812012;This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint_implementation requires.;protected abstract Collection<AbstractRestHandler<?, ?, ?>> initializeHandlers()_;this,method,is,called,at,the,beginning,of,link,start,to,setup,all,handlers,that,the,rest,server,endpoint,implementation,requires;protected,abstract,collection,abstract,rest,handler,initialize,handlers
RestServerEndpoint -> public void start();1503738659;Starts this REST server endpoint.;public void start() {_		log.info("Starting rest endpoint.")__		initializeHandlers()_			.forEach(this::registerHandler)___		ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {__			@Override_			protected void initChannel(SocketChannel ch) {_				Handler handler = new RouterHandler(router)___				_				if (sslEngine != null) {_					ch.pipeline().addLast("ssl", new SslHandler(sslEngine))__				}__				ch.pipeline()_					.addLast(new HttpServerCodec())_					.addLast(new HttpObjectAggregator(1024 * 1024 * 10))_					.addLast(handler.name(), handler)_					.addLast(new PipelineErrorHandler(log))__			}_		}___		NioEventLoopGroup bossGroup = new NioEventLoopGroup(1)__		NioEventLoopGroup workerGroup = new NioEventLoopGroup()___		bootstrap = new ServerBootstrap()__		bootstrap_			.group(bossGroup, workerGroup)_			.channel(NioServerSocketChannel.class)_			.childHandler(initializer)___		ChannelFuture ch__		if (configuredAddress == null) {_			ch = bootstrap.bind(configuredPort)__		} else {_			ch = bootstrap.bind(configuredAddress, configuredPort)__		}_		serverChannel = ch.syncUninterruptibly().channel()___		InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress()__		String address = bindAddress.getAddress().getHostAddress()__		int port = bindAddress.getPort()___		log.info("Rest endpoint listening at {}" + ':' + "{}", address, port)__	};starts,this,rest,server,endpoint;public,void,start,log,info,starting,rest,endpoint,initialize,handlers,for,each,this,register,handler,channel,initializer,socket,channel,initializer,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,ch,handler,handler,new,router,handler,router,if,ssl,engine,null,ch,pipeline,add,last,ssl,new,ssl,handler,ssl,engine,ch,pipeline,add,last,new,http,server,codec,add,last,new,http,object,aggregator,1024,1024,10,add,last,handler,name,handler,add,last,new,pipeline,error,handler,log,nio,event,loop,group,boss,group,new,nio,event,loop,group,1,nio,event,loop,group,worker,group,new,nio,event,loop,group,bootstrap,new,server,bootstrap,bootstrap,group,boss,group,worker,group,channel,nio,server,socket,channel,class,child,handler,initializer,channel,future,ch,if,configured,address,null,ch,bootstrap,bind,configured,port,else,ch,bootstrap,bind,configured,address,configured,port,server,channel,ch,sync,uninterruptibly,channel,inet,socket,address,bind,address,inet,socket,address,server,channel,local,address,string,address,bind,address,get,address,get,host,address,int,port,bind,address,get,port,log,info,rest,endpoint,listening,at,address,port
RestServerEndpoint -> public void start();1503738660;Starts this REST server endpoint.;public void start() {_		log.info("Starting rest endpoint.")___		final Router router = new Router()___		initializeHandlers().forEach(handler -> registerHandler(router, handler))___		ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {__			@Override_			protected void initChannel(SocketChannel ch) {_				Handler handler = new RouterHandler(router)___				_				if (sslEngine != null) {_					ch.pipeline().addLast("ssl", new SslHandler(sslEngine))__				}__				ch.pipeline()_					.addLast(new HttpServerCodec())_					.addLast(new HttpObjectAggregator(1024 * 1024 * 10))_					.addLast(handler.name(), handler)_					.addLast(new PipelineErrorHandler(log))__			}_		}___		NioEventLoopGroup bossGroup = new NioEventLoopGroup(1)__		NioEventLoopGroup workerGroup = new NioEventLoopGroup()___		bootstrap = new ServerBootstrap()__		bootstrap_			.group(bossGroup, workerGroup)_			.channel(NioServerSocketChannel.class)_			.childHandler(initializer)___		final ChannelFuture channel__		if (configuredAddress == null) {_			channel = bootstrap.bind(configuredPort)__		} else {_			channel = bootstrap.bind(configuredAddress, configuredPort)__		}_		serverChannel = channel.syncUninterruptibly().channel()___		InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress()__		String address = bindAddress.getAddress().getHostAddress()__		int port = bindAddress.getPort()___		log.info("Rest endpoint listening at {}" + ':' + "{}", address, port)__	};starts,this,rest,server,endpoint;public,void,start,log,info,starting,rest,endpoint,final,router,router,new,router,initialize,handlers,for,each,handler,register,handler,router,handler,channel,initializer,socket,channel,initializer,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,ch,handler,handler,new,router,handler,router,if,ssl,engine,null,ch,pipeline,add,last,ssl,new,ssl,handler,ssl,engine,ch,pipeline,add,last,new,http,server,codec,add,last,new,http,object,aggregator,1024,1024,10,add,last,handler,name,handler,add,last,new,pipeline,error,handler,log,nio,event,loop,group,boss,group,new,nio,event,loop,group,1,nio,event,loop,group,worker,group,new,nio,event,loop,group,bootstrap,new,server,bootstrap,bootstrap,group,boss,group,worker,group,channel,nio,server,socket,channel,class,child,handler,initializer,final,channel,future,channel,if,configured,address,null,channel,bootstrap,bind,configured,port,else,channel,bootstrap,bind,configured,address,configured,port,server,channel,channel,sync,uninterruptibly,channel,inet,socket,address,bind,address,inet,socket,address,server,channel,local,address,string,address,bind,address,get,address,get,host,address,int,port,bind,address,get,port,log,info,rest,endpoint,listening,at,address,port
RestServerEndpoint -> public void start();1505812012;Starts this REST server endpoint.;public void start() {_		log.info("Starting rest endpoint.")___		final Router router = new Router()___		initializeHandlers().forEach(handler -> registerHandler(router, handler))___		ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {__			@Override_			protected void initChannel(SocketChannel ch) {_				Handler handler = new RouterHandler(router)___				_				if (sslEngine != null) {_					ch.pipeline().addLast("ssl", new SslHandler(sslEngine))__				}__				ch.pipeline()_					.addLast(new HttpServerCodec())_					.addLast(new HttpObjectAggregator(1024 * 1024 * 10))_					.addLast(handler.name(), handler)_					.addLast(new PipelineErrorHandler(log))__			}_		}___		NioEventLoopGroup bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory("flink-rest-server-netty-boss"))__		NioEventLoopGroup workerGroup = new NioEventLoopGroup(0, new DefaultThreadFactory("flink-rest-server-netty-worker"))___		bootstrap = new ServerBootstrap()__		bootstrap_			.group(bossGroup, workerGroup)_			.channel(NioServerSocketChannel.class)_			.childHandler(initializer)___		final ChannelFuture channel__		if (configuredAddress == null) {_			channel = bootstrap.bind(configuredPort)__		} else {_			channel = bootstrap.bind(configuredAddress, configuredPort)__		}_		serverChannel = channel.syncUninterruptibly().channel()___		InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress()__		String address = bindAddress.getAddress().getHostAddress()__		int port = bindAddress.getPort()___		log.info("Rest endpoint listening at {}" + ':' + "{}", address, port)__	};starts,this,rest,server,endpoint;public,void,start,log,info,starting,rest,endpoint,final,router,router,new,router,initialize,handlers,for,each,handler,register,handler,router,handler,channel,initializer,socket,channel,initializer,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,ch,handler,handler,new,router,handler,router,if,ssl,engine,null,ch,pipeline,add,last,ssl,new,ssl,handler,ssl,engine,ch,pipeline,add,last,new,http,server,codec,add,last,new,http,object,aggregator,1024,1024,10,add,last,handler,name,handler,add,last,new,pipeline,error,handler,log,nio,event,loop,group,boss,group,new,nio,event,loop,group,1,new,default,thread,factory,flink,rest,server,netty,boss,nio,event,loop,group,worker,group,new,nio,event,loop,group,0,new,default,thread,factory,flink,rest,server,netty,worker,bootstrap,new,server,bootstrap,bootstrap,group,boss,group,worker,group,channel,nio,server,socket,channel,class,child,handler,initializer,final,channel,future,channel,if,configured,address,null,channel,bootstrap,bind,configured,port,else,channel,bootstrap,bind,configured,address,configured,port,server,channel,channel,sync,uninterruptibly,channel,inet,socket,address,bind,address,inet,socket,address,server,channel,local,address,string,address,bind,address,get,address,get,host,address,int,port,bind,address,get,port,log,info,rest,endpoint,listening,at,address,port
RestServerEndpoint -> public void start();1505859747;Starts this REST server endpoint.;public void start() {_		log.info("Starting rest endpoint.")___		final Router router = new Router()___		initializeHandlers().forEach(handler -> registerHandler(router, handler))___		ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {__			@Override_			protected void initChannel(SocketChannel ch) {_				Handler handler = new RouterHandler(router)___				_				if (sslEngine != null) {_					ch.pipeline().addLast("ssl", new SslHandler(sslEngine))__				}__				ch.pipeline()_					.addLast(new HttpServerCodec())_					.addLast(new HttpObjectAggregator(1024 * 1024 * 10))_					.addLast(handler.name(), handler)_					.addLast(new PipelineErrorHandler(log))__			}_		}___		NioEventLoopGroup bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory("flink-rest-server-netty-boss"))__		NioEventLoopGroup workerGroup = new NioEventLoopGroup(0, new DefaultThreadFactory("flink-rest-server-netty-worker"))___		bootstrap = new ServerBootstrap()__		bootstrap_			.group(bossGroup, workerGroup)_			.channel(NioServerSocketChannel.class)_			.childHandler(initializer)___		final ChannelFuture channel__		if (configuredAddress == null) {_			channel = bootstrap.bind(configuredPort)__		} else {_			channel = bootstrap.bind(configuredAddress, configuredPort)__		}_		serverChannel = channel.syncUninterruptibly().channel()___		InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress()__		String address = bindAddress.getAddress().getHostAddress()__		int port = bindAddress.getPort()___		log.info("Rest endpoint listening at {}" + ':' + "{}", address, port)__	};starts,this,rest,server,endpoint;public,void,start,log,info,starting,rest,endpoint,final,router,router,new,router,initialize,handlers,for,each,handler,register,handler,router,handler,channel,initializer,socket,channel,initializer,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,ch,handler,handler,new,router,handler,router,if,ssl,engine,null,ch,pipeline,add,last,ssl,new,ssl,handler,ssl,engine,ch,pipeline,add,last,new,http,server,codec,add,last,new,http,object,aggregator,1024,1024,10,add,last,handler,name,handler,add,last,new,pipeline,error,handler,log,nio,event,loop,group,boss,group,new,nio,event,loop,group,1,new,default,thread,factory,flink,rest,server,netty,boss,nio,event,loop,group,worker,group,new,nio,event,loop,group,0,new,default,thread,factory,flink,rest,server,netty,worker,bootstrap,new,server,bootstrap,bootstrap,group,boss,group,worker,group,channel,nio,server,socket,channel,class,child,handler,initializer,final,channel,future,channel,if,configured,address,null,channel,bootstrap,bind,configured,port,else,channel,bootstrap,bind,configured,address,configured,port,server,channel,channel,sync,uninterruptibly,channel,inet,socket,address,bind,address,inet,socket,address,server,channel,local,address,string,address,bind,address,get,address,get,host,address,int,port,bind,address,get,port,log,info,rest,endpoint,listening,at,address,port
RestServerEndpoint -> public void start();1505860453;Starts this REST server endpoint.;public void start() {_		synchronized (lock) {_			if (started) {_				_				return__			}__			log.info("Starting rest endpoint.")___			final Router router = new Router()___			initializeHandlers().forEach(handler -> registerHandler(router, handler))___			ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {__				@Override_				protected void initChannel(SocketChannel ch) {_					Handler handler = new RouterHandler(router)___					_					if (sslEngine != null) {_						ch.pipeline().addLast("ssl", new SslHandler(sslEngine))__					}__					ch.pipeline()_						.addLast(new HttpServerCodec())_						.addLast(new HttpObjectAggregator(1024 * 1024 * 10))_						.addLast(handler.name(), handler)_						.addLast(new PipelineErrorHandler(log))__				}_			}___			NioEventLoopGroup bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory("flink-rest-server-netty-boss"))__			NioEventLoopGroup workerGroup = new NioEventLoopGroup(0, new DefaultThreadFactory("flink-rest-server-netty-worker"))___			bootstrap = new ServerBootstrap()__			bootstrap_				.group(bossGroup, workerGroup)_				.channel(NioServerSocketChannel.class)_				.childHandler(initializer)___			final ChannelFuture channel__			if (configuredAddress == null) {_				channel = bootstrap.bind(configuredPort)__			} else {_				channel = bootstrap.bind(configuredAddress, configuredPort)__			}_			serverChannel = channel.syncUninterruptibly().channel()___			InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress()__			String address = bindAddress.getAddress().getHostAddress()__			int port = bindAddress.getPort()___			log.info("Rest endpoint listening at {}" + ':' + "{}", address, port)___			_			restAddress = address + ':' + port___			started = true__		}_	};starts,this,rest,server,endpoint;public,void,start,synchronized,lock,if,started,return,log,info,starting,rest,endpoint,final,router,router,new,router,initialize,handlers,for,each,handler,register,handler,router,handler,channel,initializer,socket,channel,initializer,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,ch,handler,handler,new,router,handler,router,if,ssl,engine,null,ch,pipeline,add,last,ssl,new,ssl,handler,ssl,engine,ch,pipeline,add,last,new,http,server,codec,add,last,new,http,object,aggregator,1024,1024,10,add,last,handler,name,handler,add,last,new,pipeline,error,handler,log,nio,event,loop,group,boss,group,new,nio,event,loop,group,1,new,default,thread,factory,flink,rest,server,netty,boss,nio,event,loop,group,worker,group,new,nio,event,loop,group,0,new,default,thread,factory,flink,rest,server,netty,worker,bootstrap,new,server,bootstrap,bootstrap,group,boss,group,worker,group,channel,nio,server,socket,channel,class,child,handler,initializer,final,channel,future,channel,if,configured,address,null,channel,bootstrap,bind,configured,port,else,channel,bootstrap,bind,configured,address,configured,port,server,channel,channel,sync,uninterruptibly,channel,inet,socket,address,bind,address,inet,socket,address,server,channel,local,address,string,address,bind,address,get,address,get,host,address,int,port,bind,address,get,port,log,info,rest,endpoint,listening,at,address,port,rest,address,address,port,started,true
RestServerEndpoint -> public void start();1505860691;Starts this REST server endpoint.;public void start() {_		synchronized (lock) {_			if (started) {_				_				return__			}__			log.info("Starting rest endpoint.")___			final Router router = new Router()___			initializeHandlers().forEach(handler -> registerHandler(router, handler))___			ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {__				@Override_				protected void initChannel(SocketChannel ch) {_					Handler handler = new RouterHandler(router)___					_					if (sslEngine != null) {_						ch.pipeline().addLast("ssl", new SslHandler(sslEngine))__					}__					ch.pipeline()_						.addLast(new HttpServerCodec())_						.addLast(new HttpObjectAggregator(1024 * 1024 * 10))_						.addLast(handler.name(), handler)_						.addLast(new PipelineErrorHandler(log))__				}_			}___			NioEventLoopGroup bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory("flink-rest-server-netty-boss"))__			NioEventLoopGroup workerGroup = new NioEventLoopGroup(0, new DefaultThreadFactory("flink-rest-server-netty-worker"))___			bootstrap = new ServerBootstrap()__			bootstrap_				.group(bossGroup, workerGroup)_				.channel(NioServerSocketChannel.class)_				.childHandler(initializer)___			final ChannelFuture channel__			if (configuredAddress == null) {_				channel = bootstrap.bind(configuredPort)__			} else {_				channel = bootstrap.bind(configuredAddress, configuredPort)__			}_			serverChannel = channel.syncUninterruptibly().channel()___			InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress()__			String address = bindAddress.getAddress().getHostAddress()__			int port = bindAddress.getPort()___			log.info("Rest endpoint listening at {}" + ':' + "{}", address, port)___			final String protocol___			if (sslEngine != null) {_				protocol = "https://"__			} else {_				protocol = "http://"__			}_			restAddress = protocol + address + ':' + port___			started = true__		}_	};starts,this,rest,server,endpoint;public,void,start,synchronized,lock,if,started,return,log,info,starting,rest,endpoint,final,router,router,new,router,initialize,handlers,for,each,handler,register,handler,router,handler,channel,initializer,socket,channel,initializer,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,ch,handler,handler,new,router,handler,router,if,ssl,engine,null,ch,pipeline,add,last,ssl,new,ssl,handler,ssl,engine,ch,pipeline,add,last,new,http,server,codec,add,last,new,http,object,aggregator,1024,1024,10,add,last,handler,name,handler,add,last,new,pipeline,error,handler,log,nio,event,loop,group,boss,group,new,nio,event,loop,group,1,new,default,thread,factory,flink,rest,server,netty,boss,nio,event,loop,group,worker,group,new,nio,event,loop,group,0,new,default,thread,factory,flink,rest,server,netty,worker,bootstrap,new,server,bootstrap,bootstrap,group,boss,group,worker,group,channel,nio,server,socket,channel,class,child,handler,initializer,final,channel,future,channel,if,configured,address,null,channel,bootstrap,bind,configured,port,else,channel,bootstrap,bind,configured,address,configured,port,server,channel,channel,sync,uninterruptibly,channel,inet,socket,address,bind,address,inet,socket,address,server,channel,local,address,string,address,bind,address,get,address,get,host,address,int,port,bind,address,get,port,log,info,rest,endpoint,listening,at,address,port,final,string,protocol,if,ssl,engine,null,protocol,https,else,protocol,http,rest,address,protocol,address,port,started,true
RestServerEndpoint -> private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException;1518945174;Checks whether the given directory exists and is writable. If it doesn't exist, this method_will attempt to create it.__@param uploadDir directory to check_@param log logger used for logging output_@throws IOException if the directory does not exist and cannot be created, or if the_directory isn't writable;private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (Files.exists(uploadDir) && Files.isWritable(uploadDir)) {_			log.info("Using directory {} for file uploads.", uploadDir)__		} else if (Files.isWritable(Files.createDirectories(uploadDir))) {_			log.info("Created directory {} for file uploads.", uploadDir)__		} else {_			log.warn("Upload directory {} cannot be created or is not writable.", uploadDir)__			throw new IOException(_				String.format("Upload directory %s cannot be created or is not writable.",_					uploadDir))__		}_	};checks,whether,the,given,directory,exists,and,is,writable,if,it,doesn,t,exist,this,method,will,attempt,to,create,it,param,upload,dir,directory,to,check,param,log,logger,used,for,logging,output,throws,ioexception,if,the,directory,does,not,exist,and,cannot,be,created,or,if,the,directory,isn,t,writable;private,static,synchronized,void,check,and,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,files,is,writable,upload,dir,log,info,using,directory,for,file,uploads,upload,dir,else,if,files,is,writable,files,create,directories,upload,dir,log,info,created,directory,for,file,uploads,upload,dir,else,log,warn,upload,directory,cannot,be,created,or,is,not,writable,upload,dir,throw,new,ioexception,string,format,upload,directory,s,cannot,be,created,or,is,not,writable,upload,dir
RestServerEndpoint -> private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException;1519052657;Checks whether the given directory exists and is writable. If it doesn't exist, this method_will attempt to create it.__@param uploadDir directory to check_@param log logger used for logging output_@throws IOException if the directory does not exist and cannot be created, or if the_directory isn't writable;private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (Files.exists(uploadDir) && Files.isWritable(uploadDir)) {_			log.info("Using directory {} for file uploads.", uploadDir)__		} else if (Files.isWritable(Files.createDirectories(uploadDir))) {_			log.info("Created directory {} for file uploads.", uploadDir)__		} else {_			log.warn("Upload directory {} cannot be created or is not writable.", uploadDir)__			throw new IOException(_				String.format("Upload directory %s cannot be created or is not writable.",_					uploadDir))__		}_	};checks,whether,the,given,directory,exists,and,is,writable,if,it,doesn,t,exist,this,method,will,attempt,to,create,it,param,upload,dir,directory,to,check,param,log,logger,used,for,logging,output,throws,ioexception,if,the,directory,does,not,exist,and,cannot,be,created,or,if,the,directory,isn,t,writable;private,static,synchronized,void,check,and,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,files,is,writable,upload,dir,log,info,using,directory,for,file,uploads,upload,dir,else,if,files,is,writable,files,create,directories,upload,dir,log,info,created,directory,for,file,uploads,upload,dir,else,log,warn,upload,directory,cannot,be,created,or,is,not,writable,upload,dir,throw,new,ioexception,string,format,upload,directory,s,cannot,be,created,or,is,not,writable,upload,dir
RestServerEndpoint -> private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException;1519406530;Checks whether the given directory exists and is writable. If it doesn't exist, this method_will attempt to create it.__@param uploadDir directory to check_@param log logger used for logging output_@throws IOException if the directory does not exist and cannot be created, or if the_directory isn't writable;private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (Files.exists(uploadDir) && Files.isWritable(uploadDir)) {_			log.info("Using directory {} for file uploads.", uploadDir)__		} else if (Files.isWritable(Files.createDirectories(uploadDir))) {_			log.info("Created directory {} for file uploads.", uploadDir)__		} else {_			log.warn("Upload directory {} cannot be created or is not writable.", uploadDir)__			throw new IOException(_				String.format("Upload directory %s cannot be created or is not writable.",_					uploadDir))__		}_	};checks,whether,the,given,directory,exists,and,is,writable,if,it,doesn,t,exist,this,method,will,attempt,to,create,it,param,upload,dir,directory,to,check,param,log,logger,used,for,logging,output,throws,ioexception,if,the,directory,does,not,exist,and,cannot,be,created,or,if,the,directory,isn,t,writable;private,static,synchronized,void,check,and,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,files,is,writable,upload,dir,log,info,using,directory,for,file,uploads,upload,dir,else,if,files,is,writable,files,create,directories,upload,dir,log,info,created,directory,for,file,uploads,upload,dir,else,log,warn,upload,directory,cannot,be,created,or,is,not,writable,upload,dir,throw,new,ioexception,string,format,upload,directory,s,cannot,be,created,or,is,not,writable,upload,dir
RestServerEndpoint -> private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException;1521016670;Checks whether the given directory exists and is writable. If it doesn't exist, this method_will attempt to create it.__@param uploadDir directory to check_@param log logger used for logging output_@throws IOException if the directory does not exist and cannot be created, or if the_directory isn't writable;private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (Files.exists(uploadDir) && Files.isWritable(uploadDir)) {_			log.info("Using directory {} for file uploads.", uploadDir)__		} else if (Files.isWritable(Files.createDirectories(uploadDir))) {_			log.info("Created directory {} for file uploads.", uploadDir)__		} else {_			log.warn("Upload directory {} cannot be created or is not writable.", uploadDir)__			throw new IOException(_				String.format("Upload directory %s cannot be created or is not writable.",_					uploadDir))__		}_	};checks,whether,the,given,directory,exists,and,is,writable,if,it,doesn,t,exist,this,method,will,attempt,to,create,it,param,upload,dir,directory,to,check,param,log,logger,used,for,logging,output,throws,ioexception,if,the,directory,does,not,exist,and,cannot,be,created,or,if,the,directory,isn,t,writable;private,static,synchronized,void,check,and,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,files,is,writable,upload,dir,log,info,using,directory,for,file,uploads,upload,dir,else,if,files,is,writable,files,create,directories,upload,dir,log,info,created,directory,for,file,uploads,upload,dir,else,log,warn,upload,directory,cannot,be,created,or,is,not,writable,upload,dir,throw,new,ioexception,string,format,upload,directory,s,cannot,be,created,or,is,not,writable,upload,dir
RestServerEndpoint -> private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException;1521016671;Checks whether the given directory exists and is writable. If it doesn't exist, this method_will attempt to create it.__@param uploadDir directory to check_@param log logger used for logging output_@throws IOException if the directory does not exist and cannot be created, or if the_directory isn't writable;private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (Files.exists(uploadDir) && Files.isWritable(uploadDir)) {_			log.info("Using directory {} for file uploads.", uploadDir)__		} else if (Files.isWritable(Files.createDirectories(uploadDir))) {_			log.info("Created directory {} for file uploads.", uploadDir)__		} else {_			log.warn("Upload directory {} cannot be created or is not writable.", uploadDir)__			throw new IOException(_				String.format("Upload directory %s cannot be created or is not writable.",_					uploadDir))__		}_	};checks,whether,the,given,directory,exists,and,is,writable,if,it,doesn,t,exist,this,method,will,attempt,to,create,it,param,upload,dir,directory,to,check,param,log,logger,used,for,logging,output,throws,ioexception,if,the,directory,does,not,exist,and,cannot,be,created,or,if,the,directory,isn,t,writable;private,static,synchronized,void,check,and,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,files,is,writable,upload,dir,log,info,using,directory,for,file,uploads,upload,dir,else,if,files,is,writable,files,create,directories,upload,dir,log,info,created,directory,for,file,uploads,upload,dir,else,log,warn,upload,directory,cannot,be,created,or,is,not,writable,upload,dir,throw,new,ioexception,string,format,upload,directory,s,cannot,be,created,or,is,not,writable,upload,dir
RestServerEndpoint -> private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException;1521016671;Checks whether the given directory exists and is writable. If it doesn't exist, this method_will attempt to create it.__@param uploadDir directory to check_@param log logger used for logging output_@throws IOException if the directory does not exist and cannot be created, or if the_directory isn't writable;private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (Files.exists(uploadDir) && Files.isWritable(uploadDir)) {_			log.info("Using directory {} for file uploads.", uploadDir)__		} else if (Files.isWritable(Files.createDirectories(uploadDir))) {_			log.info("Created directory {} for file uploads.", uploadDir)__		} else {_			log.warn("Upload directory {} cannot be created or is not writable.", uploadDir)__			throw new IOException(_				String.format("Upload directory %s cannot be created or is not writable.",_					uploadDir))__		}_	};checks,whether,the,given,directory,exists,and,is,writable,if,it,doesn,t,exist,this,method,will,attempt,to,create,it,param,upload,dir,directory,to,check,param,log,logger,used,for,logging,output,throws,ioexception,if,the,directory,does,not,exist,and,cannot,be,created,or,if,the,directory,isn,t,writable;private,static,synchronized,void,check,and,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,files,is,writable,upload,dir,log,info,using,directory,for,file,uploads,upload,dir,else,if,files,is,writable,files,create,directories,upload,dir,log,info,created,directory,for,file,uploads,upload,dir,else,log,warn,upload,directory,cannot,be,created,or,is,not,writable,upload,dir,throw,new,ioexception,string,format,upload,directory,s,cannot,be,created,or,is,not,writable,upload,dir
RestServerEndpoint -> private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException;1521385094;Checks whether the given directory exists and is writable. If it doesn't exist, this method_will attempt to create it.__@param uploadDir directory to check_@param log logger used for logging output_@throws IOException if the directory does not exist and cannot be created, or if the_directory isn't writable;private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (Files.exists(uploadDir) && Files.isWritable(uploadDir)) {_			log.info("Using directory {} for file uploads.", uploadDir)__		} else if (Files.isWritable(Files.createDirectories(uploadDir))) {_			log.info("Created directory {} for file uploads.", uploadDir)__		} else {_			log.warn("Upload directory {} cannot be created or is not writable.", uploadDir)__			throw new IOException(_				String.format("Upload directory %s cannot be created or is not writable.",_					uploadDir))__		}_	};checks,whether,the,given,directory,exists,and,is,writable,if,it,doesn,t,exist,this,method,will,attempt,to,create,it,param,upload,dir,directory,to,check,param,log,logger,used,for,logging,output,throws,ioexception,if,the,directory,does,not,exist,and,cannot,be,created,or,if,the,directory,isn,t,writable;private,static,synchronized,void,check,and,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,files,is,writable,upload,dir,log,info,using,directory,for,file,uploads,upload,dir,else,if,files,is,writable,files,create,directories,upload,dir,log,info,created,directory,for,file,uploads,upload,dir,else,log,warn,upload,directory,cannot,be,created,or,is,not,writable,upload,dir,throw,new,ioexception,string,format,upload,directory,s,cannot,be,created,or,is,not,writable,upload,dir
RestServerEndpoint -> private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException;1521804758;Checks whether the given directory exists and is writable. If it doesn't exist, this method_will attempt to create it.__@param uploadDir directory to check_@param log logger used for logging output_@throws IOException if the directory does not exist and cannot be created, or if the_directory isn't writable;private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (Files.exists(uploadDir) && Files.isWritable(uploadDir)) {_			log.info("Using directory {} for file uploads.", uploadDir)__		} else if (Files.isWritable(Files.createDirectories(uploadDir))) {_			log.info("Created directory {} for file uploads.", uploadDir)__		} else {_			log.warn("Upload directory {} cannot be created or is not writable.", uploadDir)__			throw new IOException(_				String.format("Upload directory %s cannot be created or is not writable.",_					uploadDir))__		}_	};checks,whether,the,given,directory,exists,and,is,writable,if,it,doesn,t,exist,this,method,will,attempt,to,create,it,param,upload,dir,directory,to,check,param,log,logger,used,for,logging,output,throws,ioexception,if,the,directory,does,not,exist,and,cannot,be,created,or,if,the,directory,isn,t,writable;private,static,synchronized,void,check,and,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,files,is,writable,upload,dir,log,info,using,directory,for,file,uploads,upload,dir,else,if,files,is,writable,files,create,directories,upload,dir,log,info,created,directory,for,file,uploads,upload,dir,else,log,warn,upload,directory,cannot,be,created,or,is,not,writable,upload,dir,throw,new,ioexception,string,format,upload,directory,s,cannot,be,created,or,is,not,writable,upload,dir
RestServerEndpoint -> private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException;1521804758;Checks whether the given directory exists and is writable. If it doesn't exist, this method_will attempt to create it.__@param uploadDir directory to check_@param log logger used for logging output_@throws IOException if the directory does not exist and cannot be created, or if the_directory isn't writable;private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (Files.exists(uploadDir) && Files.isWritable(uploadDir)) {_			log.info("Using directory {} for file uploads.", uploadDir)__		} else if (Files.isWritable(Files.createDirectories(uploadDir))) {_			log.info("Created directory {} for file uploads.", uploadDir)__		} else {_			log.warn("Upload directory {} cannot be created or is not writable.", uploadDir)__			throw new IOException(_				String.format("Upload directory %s cannot be created or is not writable.",_					uploadDir))__		}_	};checks,whether,the,given,directory,exists,and,is,writable,if,it,doesn,t,exist,this,method,will,attempt,to,create,it,param,upload,dir,directory,to,check,param,log,logger,used,for,logging,output,throws,ioexception,if,the,directory,does,not,exist,and,cannot,be,created,or,if,the,directory,isn,t,writable;private,static,synchronized,void,check,and,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,files,is,writable,upload,dir,log,info,using,directory,for,file,uploads,upload,dir,else,if,files,is,writable,files,create,directories,upload,dir,log,info,created,directory,for,file,uploads,upload,dir,else,log,warn,upload,directory,cannot,be,created,or,is,not,writable,upload,dir,throw,new,ioexception,string,format,upload,directory,s,cannot,be,created,or,is,not,writable,upload,dir
RestServerEndpoint -> private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException;1525904579;Checks whether the given directory exists and is writable. If it doesn't exist, this method_will attempt to create it.__@param uploadDir directory to check_@param log logger used for logging output_@throws IOException if the directory does not exist and cannot be created, or if the_directory isn't writable;private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (Files.exists(uploadDir) && Files.isWritable(uploadDir)) {_			log.info("Using directory {} for file uploads.", uploadDir)__		} else if (Files.isWritable(Files.createDirectories(uploadDir))) {_			log.info("Created directory {} for file uploads.", uploadDir)__		} else {_			log.warn("Upload directory {} cannot be created or is not writable.", uploadDir)__			throw new IOException(_				String.format("Upload directory %s cannot be created or is not writable.",_					uploadDir))__		}_	};checks,whether,the,given,directory,exists,and,is,writable,if,it,doesn,t,exist,this,method,will,attempt,to,create,it,param,upload,dir,directory,to,check,param,log,logger,used,for,logging,output,throws,ioexception,if,the,directory,does,not,exist,and,cannot,be,created,or,if,the,directory,isn,t,writable;private,static,synchronized,void,check,and,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,files,is,writable,upload,dir,log,info,using,directory,for,file,uploads,upload,dir,else,if,files,is,writable,files,create,directories,upload,dir,log,info,created,directory,for,file,uploads,upload,dir,else,log,warn,upload,directory,cannot,be,created,or,is,not,writable,upload,dir,throw,new,ioexception,string,format,upload,directory,s,cannot,be,created,or,is,not,writable,upload,dir
RestServerEndpoint -> private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException;1527499265;Checks whether the given directory exists and is writable. If it doesn't exist, this method_will attempt to create it.__@param uploadDir directory to check_@param log logger used for logging output_@throws IOException if the directory does not exist and cannot be created, or if the_directory isn't writable;private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (Files.exists(uploadDir) && Files.isWritable(uploadDir)) {_			log.info("Using directory {} for file uploads.", uploadDir)__		} else if (Files.isWritable(Files.createDirectories(uploadDir))) {_			log.info("Created directory {} for file uploads.", uploadDir)__		} else {_			log.warn("Upload directory {} cannot be created or is not writable.", uploadDir)__			throw new IOException(_				String.format("Upload directory %s cannot be created or is not writable.",_					uploadDir))__		}_	};checks,whether,the,given,directory,exists,and,is,writable,if,it,doesn,t,exist,this,method,will,attempt,to,create,it,param,upload,dir,directory,to,check,param,log,logger,used,for,logging,output,throws,ioexception,if,the,directory,does,not,exist,and,cannot,be,created,or,if,the,directory,isn,t,writable;private,static,synchronized,void,check,and,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,files,is,writable,upload,dir,log,info,using,directory,for,file,uploads,upload,dir,else,if,files,is,writable,files,create,directories,upload,dir,log,info,created,directory,for,file,uploads,upload,dir,else,log,warn,upload,directory,cannot,be,created,or,is,not,writable,upload,dir,throw,new,ioexception,string,format,upload,directory,s,cannot,be,created,or,is,not,writable,upload,dir
RestServerEndpoint -> private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException;1528876304;Checks whether the given directory exists and is writable. If it doesn't exist, this method_will attempt to create it.__@param uploadDir directory to check_@param log logger used for logging output_@throws IOException if the directory does not exist and cannot be created, or if the_directory isn't writable;private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (Files.exists(uploadDir) && Files.isWritable(uploadDir)) {_			log.info("Using directory {} for file uploads.", uploadDir)__		} else if (Files.isWritable(Files.createDirectories(uploadDir))) {_			log.info("Created directory {} for file uploads.", uploadDir)__		} else {_			log.warn("Upload directory {} cannot be created or is not writable.", uploadDir)__			throw new IOException(_				String.format("Upload directory %s cannot be created or is not writable.",_					uploadDir))__		}_	};checks,whether,the,given,directory,exists,and,is,writable,if,it,doesn,t,exist,this,method,will,attempt,to,create,it,param,upload,dir,directory,to,check,param,log,logger,used,for,logging,output,throws,ioexception,if,the,directory,does,not,exist,and,cannot,be,created,or,if,the,directory,isn,t,writable;private,static,synchronized,void,check,and,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,files,is,writable,upload,dir,log,info,using,directory,for,file,uploads,upload,dir,else,if,files,is,writable,files,create,directories,upload,dir,log,info,created,directory,for,file,uploads,upload,dir,else,log,warn,upload,directory,cannot,be,created,or,is,not,writable,upload,dir,throw,new,ioexception,string,format,upload,directory,s,cannot,be,created,or,is,not,writable,upload,dir
RestServerEndpoint -> private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException;1534259541;Checks whether the given directory exists and is writable. If it doesn't exist, this method_will attempt to create it.__@param uploadDir directory to check_@param log logger used for logging output_@throws IOException if the directory does not exist and cannot be created, or if the_directory isn't writable;private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (Files.exists(uploadDir) && Files.isWritable(uploadDir)) {_			log.info("Using directory {} for file uploads.", uploadDir)__		} else if (Files.isWritable(Files.createDirectories(uploadDir))) {_			log.info("Created directory {} for file uploads.", uploadDir)__		} else {_			log.warn("Upload directory {} cannot be created or is not writable.", uploadDir)__			throw new IOException(_				String.format("Upload directory %s cannot be created or is not writable.",_					uploadDir))__		}_	};checks,whether,the,given,directory,exists,and,is,writable,if,it,doesn,t,exist,this,method,will,attempt,to,create,it,param,upload,dir,directory,to,check,param,log,logger,used,for,logging,output,throws,ioexception,if,the,directory,does,not,exist,and,cannot,be,created,or,if,the,directory,isn,t,writable;private,static,synchronized,void,check,and,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,files,is,writable,upload,dir,log,info,using,directory,for,file,uploads,upload,dir,else,if,files,is,writable,files,create,directories,upload,dir,log,info,created,directory,for,file,uploads,upload,dir,else,log,warn,upload,directory,cannot,be,created,or,is,not,writable,upload,dir,throw,new,ioexception,string,format,upload,directory,s,cannot,be,created,or,is,not,writable,upload,dir
RestServerEndpoint -> private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException;1535963626;Checks whether the given directory exists and is writable. If it doesn't exist, this method_will attempt to create it.__@param uploadDir directory to check_@param log logger used for logging output_@throws IOException if the directory does not exist and cannot be created, or if the_directory isn't writable;private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (Files.exists(uploadDir) && Files.isWritable(uploadDir)) {_			log.info("Using directory {} for file uploads.", uploadDir)__		} else if (Files.isWritable(Files.createDirectories(uploadDir))) {_			log.info("Created directory {} for file uploads.", uploadDir)__		} else {_			log.warn("Upload directory {} cannot be created or is not writable.", uploadDir)__			throw new IOException(_				String.format("Upload directory %s cannot be created or is not writable.",_					uploadDir))__		}_	};checks,whether,the,given,directory,exists,and,is,writable,if,it,doesn,t,exist,this,method,will,attempt,to,create,it,param,upload,dir,directory,to,check,param,log,logger,used,for,logging,output,throws,ioexception,if,the,directory,does,not,exist,and,cannot,be,created,or,if,the,directory,isn,t,writable;private,static,synchronized,void,check,and,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,files,is,writable,upload,dir,log,info,using,directory,for,file,uploads,upload,dir,else,if,files,is,writable,files,create,directories,upload,dir,log,info,created,directory,for,file,uploads,upload,dir,else,log,warn,upload,directory,cannot,be,created,or,is,not,writable,upload,dir,throw,new,ioexception,string,format,upload,directory,s,cannot,be,created,or,is,not,writable,upload,dir
RestServerEndpoint -> private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException;1536930104;Checks whether the given directory exists and is writable. If it doesn't exist, this method_will attempt to create it.__@param uploadDir directory to check_@param log logger used for logging output_@throws IOException if the directory does not exist and cannot be created, or if the_directory isn't writable;private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (Files.exists(uploadDir) && Files.isWritable(uploadDir)) {_			log.info("Using directory {} for file uploads.", uploadDir)__		} else if (Files.isWritable(Files.createDirectories(uploadDir))) {_			log.info("Created directory {} for file uploads.", uploadDir)__		} else {_			log.warn("Upload directory {} cannot be created or is not writable.", uploadDir)__			throw new IOException(_				String.format("Upload directory %s cannot be created or is not writable.",_					uploadDir))__		}_	};checks,whether,the,given,directory,exists,and,is,writable,if,it,doesn,t,exist,this,method,will,attempt,to,create,it,param,upload,dir,directory,to,check,param,log,logger,used,for,logging,output,throws,ioexception,if,the,directory,does,not,exist,and,cannot,be,created,or,if,the,directory,isn,t,writable;private,static,synchronized,void,check,and,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,files,is,writable,upload,dir,log,info,using,directory,for,file,uploads,upload,dir,else,if,files,is,writable,files,create,directories,upload,dir,log,info,created,directory,for,file,uploads,upload,dir,else,log,warn,upload,directory,cannot,be,created,or,is,not,writable,upload,dir,throw,new,ioexception,string,format,upload,directory,s,cannot,be,created,or,is,not,writable,upload,dir
RestServerEndpoint -> private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException;1539170288;Checks whether the given directory exists and is writable. If it doesn't exist, this method_will attempt to create it.__@param uploadDir directory to check_@param log logger used for logging output_@throws IOException if the directory does not exist and cannot be created, or if the_directory isn't writable;private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (Files.exists(uploadDir) && Files.isWritable(uploadDir)) {_			log.info("Using directory {} for file uploads.", uploadDir)__		} else if (Files.isWritable(Files.createDirectories(uploadDir))) {_			log.info("Created directory {} for file uploads.", uploadDir)__		} else {_			log.warn("Upload directory {} cannot be created or is not writable.", uploadDir)__			throw new IOException(_				String.format("Upload directory %s cannot be created or is not writable.",_					uploadDir))__		}_	};checks,whether,the,given,directory,exists,and,is,writable,if,it,doesn,t,exist,this,method,will,attempt,to,create,it,param,upload,dir,directory,to,check,param,log,logger,used,for,logging,output,throws,ioexception,if,the,directory,does,not,exist,and,cannot,be,created,or,if,the,directory,isn,t,writable;private,static,synchronized,void,check,and,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,files,is,writable,upload,dir,log,info,using,directory,for,file,uploads,upload,dir,else,if,files,is,writable,files,create,directories,upload,dir,log,info,created,directory,for,file,uploads,upload,dir,else,log,warn,upload,directory,cannot,be,created,or,is,not,writable,upload,dir,throw,new,ioexception,string,format,upload,directory,s,cannot,be,created,or,is,not,writable,upload,dir
RestServerEndpoint -> private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException;1539934386;Checks whether the given directory exists and is writable. If it doesn't exist, this method_will attempt to create it.__@param uploadDir directory to check_@param log logger used for logging output_@throws IOException if the directory does not exist and cannot be created, or if the_directory isn't writable;private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (Files.exists(uploadDir) && Files.isWritable(uploadDir)) {_			log.info("Using directory {} for file uploads.", uploadDir)__		} else if (Files.isWritable(Files.createDirectories(uploadDir))) {_			log.info("Created directory {} for file uploads.", uploadDir)__		} else {_			log.warn("Upload directory {} cannot be created or is not writable.", uploadDir)__			throw new IOException(_				String.format("Upload directory %s cannot be created or is not writable.",_					uploadDir))__		}_	};checks,whether,the,given,directory,exists,and,is,writable,if,it,doesn,t,exist,this,method,will,attempt,to,create,it,param,upload,dir,directory,to,check,param,log,logger,used,for,logging,output,throws,ioexception,if,the,directory,does,not,exist,and,cannot,be,created,or,if,the,directory,isn,t,writable;private,static,synchronized,void,check,and,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,files,is,writable,upload,dir,log,info,using,directory,for,file,uploads,upload,dir,else,if,files,is,writable,files,create,directories,upload,dir,log,info,created,directory,for,file,uploads,upload,dir,else,log,warn,upload,directory,cannot,be,created,or,is,not,writable,upload,dir,throw,new,ioexception,string,format,upload,directory,s,cannot,be,created,or,is,not,writable,upload,dir
RestServerEndpoint -> private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException;1540215410;Checks whether the given directory exists and is writable. If it doesn't exist, this method_will attempt to create it.__@param uploadDir directory to check_@param log logger used for logging output_@throws IOException if the directory does not exist and cannot be created, or if the_directory isn't writable;private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (Files.exists(uploadDir) && Files.isWritable(uploadDir)) {_			log.info("Using directory {} for file uploads.", uploadDir)__		} else if (Files.isWritable(Files.createDirectories(uploadDir))) {_			log.info("Created directory {} for file uploads.", uploadDir)__		} else {_			log.warn("Upload directory {} cannot be created or is not writable.", uploadDir)__			throw new IOException(_				String.format("Upload directory %s cannot be created or is not writable.",_					uploadDir))__		}_	};checks,whether,the,given,directory,exists,and,is,writable,if,it,doesn,t,exist,this,method,will,attempt,to,create,it,param,upload,dir,directory,to,check,param,log,logger,used,for,logging,output,throws,ioexception,if,the,directory,does,not,exist,and,cannot,be,created,or,if,the,directory,isn,t,writable;private,static,synchronized,void,check,and,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,files,is,writable,upload,dir,log,info,using,directory,for,file,uploads,upload,dir,else,if,files,is,writable,files,create,directories,upload,dir,log,info,created,directory,for,file,uploads,upload,dir,else,log,warn,upload,directory,cannot,be,created,or,is,not,writable,upload,dir,throw,new,ioexception,string,format,upload,directory,s,cannot,be,created,or,is,not,writable,upload,dir
RestServerEndpoint -> private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException;1545326469;Checks whether the given directory exists and is writable. If it doesn't exist, this method_will attempt to create it.__@param uploadDir directory to check_@param log logger used for logging output_@throws IOException if the directory does not exist and cannot be created, or if the_directory isn't writable;private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (Files.exists(uploadDir) && Files.isWritable(uploadDir)) {_			log.info("Using directory {} for file uploads.", uploadDir)__		} else if (Files.isWritable(Files.createDirectories(uploadDir))) {_			log.info("Created directory {} for file uploads.", uploadDir)__		} else {_			log.warn("Upload directory {} cannot be created or is not writable.", uploadDir)__			throw new IOException(_				String.format("Upload directory %s cannot be created or is not writable.",_					uploadDir))__		}_	};checks,whether,the,given,directory,exists,and,is,writable,if,it,doesn,t,exist,this,method,will,attempt,to,create,it,param,upload,dir,directory,to,check,param,log,logger,used,for,logging,output,throws,ioexception,if,the,directory,does,not,exist,and,cannot,be,created,or,if,the,directory,isn,t,writable;private,static,synchronized,void,check,and,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,files,is,writable,upload,dir,log,info,using,directory,for,file,uploads,upload,dir,else,if,files,is,writable,files,create,directories,upload,dir,log,info,created,directory,for,file,uploads,upload,dir,else,log,warn,upload,directory,cannot,be,created,or,is,not,writable,upload,dir,throw,new,ioexception,string,format,upload,directory,s,cannot,be,created,or,is,not,writable,upload,dir
RestServerEndpoint -> private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException;1550222817;Checks whether the given directory exists and is writable. If it doesn't exist, this method_will attempt to create it.__@param uploadDir directory to check_@param log logger used for logging output_@throws IOException if the directory does not exist and cannot be created, or if the_directory isn't writable;private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (Files.exists(uploadDir) && Files.isWritable(uploadDir)) {_			log.info("Using directory {} for file uploads.", uploadDir)__		} else if (Files.isWritable(Files.createDirectories(uploadDir))) {_			log.info("Created directory {} for file uploads.", uploadDir)__		} else {_			log.warn("Upload directory {} cannot be created or is not writable.", uploadDir)__			throw new IOException(_				String.format("Upload directory %s cannot be created or is not writable.",_					uploadDir))__		}_	};checks,whether,the,given,directory,exists,and,is,writable,if,it,doesn,t,exist,this,method,will,attempt,to,create,it,param,upload,dir,directory,to,check,param,log,logger,used,for,logging,output,throws,ioexception,if,the,directory,does,not,exist,and,cannot,be,created,or,if,the,directory,isn,t,writable;private,static,synchronized,void,check,and,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,files,is,writable,upload,dir,log,info,using,directory,for,file,uploads,upload,dir,else,if,files,is,writable,files,create,directories,upload,dir,log,info,created,directory,for,file,uploads,upload,dir,else,log,warn,upload,directory,cannot,be,created,or,is,not,writable,upload,dir,throw,new,ioexception,string,format,upload,directory,s,cannot,be,created,or,is,not,writable,upload,dir
RestServerEndpoint -> public String getRestBaseUrl();1521385094;Returns the base URL of the REST server endpoint.__@return REST base URL of this endpoint;public String getRestBaseUrl() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			return restBaseUrl__		}_	};returns,the,base,url,of,the,rest,server,endpoint,return,rest,base,url,of,this,endpoint;public,string,get,rest,base,url,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,return,rest,base,url
RestServerEndpoint -> public String getRestBaseUrl();1521804758;Returns the base URL of the REST server endpoint.__@return REST base URL of this endpoint;public String getRestBaseUrl() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			return restBaseUrl__		}_	};returns,the,base,url,of,the,rest,server,endpoint,return,rest,base,url,of,this,endpoint;public,string,get,rest,base,url,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,return,rest,base,url
RestServerEndpoint -> public String getRestBaseUrl();1521804758;Returns the base URL of the REST server endpoint.__@return REST base URL of this endpoint;public String getRestBaseUrl() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			return restBaseUrl__		}_	};returns,the,base,url,of,the,rest,server,endpoint,return,rest,base,url,of,this,endpoint;public,string,get,rest,base,url,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,return,rest,base,url
RestServerEndpoint -> public String getRestBaseUrl();1525904579;Returns the base URL of the REST server endpoint.__@return REST base URL of this endpoint;public String getRestBaseUrl() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			return restBaseUrl__		}_	};returns,the,base,url,of,the,rest,server,endpoint,return,rest,base,url,of,this,endpoint;public,string,get,rest,base,url,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,return,rest,base,url
RestServerEndpoint -> public String getRestBaseUrl();1527499265;Returns the base URL of the REST server endpoint.__@return REST base URL of this endpoint;public String getRestBaseUrl() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			return restBaseUrl__		}_	};returns,the,base,url,of,the,rest,server,endpoint,return,rest,base,url,of,this,endpoint;public,string,get,rest,base,url,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,return,rest,base,url
RestServerEndpoint -> public String getRestBaseUrl();1528876304;Returns the base URL of the REST server endpoint.__@return REST base URL of this endpoint;public String getRestBaseUrl() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			return restBaseUrl__		}_	};returns,the,base,url,of,the,rest,server,endpoint,return,rest,base,url,of,this,endpoint;public,string,get,rest,base,url,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,return,rest,base,url
RestServerEndpoint -> public String getRestBaseUrl();1534259541;Returns the base URL of the REST server endpoint.__@return REST base URL of this endpoint;public String getRestBaseUrl() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			return restBaseUrl__		}_	};returns,the,base,url,of,the,rest,server,endpoint,return,rest,base,url,of,this,endpoint;public,string,get,rest,base,url,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,return,rest,base,url
RestServerEndpoint -> public String getRestBaseUrl();1535963626;Returns the base URL of the REST server endpoint.__@return REST base URL of this endpoint;public String getRestBaseUrl() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			return restBaseUrl__		}_	};returns,the,base,url,of,the,rest,server,endpoint,return,rest,base,url,of,this,endpoint;public,string,get,rest,base,url,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,return,rest,base,url
RestServerEndpoint -> public String getRestBaseUrl();1536930104;Returns the base URL of the REST server endpoint.__@return REST base URL of this endpoint;public String getRestBaseUrl() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			return restBaseUrl__		}_	};returns,the,base,url,of,the,rest,server,endpoint,return,rest,base,url,of,this,endpoint;public,string,get,rest,base,url,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,return,rest,base,url
RestServerEndpoint -> public String getRestBaseUrl();1539170288;Returns the base URL of the REST server endpoint.__@return REST base URL of this endpoint;public String getRestBaseUrl() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			return restBaseUrl__		}_	};returns,the,base,url,of,the,rest,server,endpoint,return,rest,base,url,of,this,endpoint;public,string,get,rest,base,url,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,return,rest,base,url
RestServerEndpoint -> public String getRestBaseUrl();1539934386;Returns the base URL of the REST server endpoint.__@return REST base URL of this endpoint;public String getRestBaseUrl() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			return restBaseUrl__		}_	};returns,the,base,url,of,the,rest,server,endpoint,return,rest,base,url,of,this,endpoint;public,string,get,rest,base,url,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,return,rest,base,url
RestServerEndpoint -> public String getRestBaseUrl();1540215410;Returns the base URL of the REST server endpoint.__@return REST base URL of this endpoint;public String getRestBaseUrl() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			return restBaseUrl__		}_	};returns,the,base,url,of,the,rest,server,endpoint,return,rest,base,url,of,this,endpoint;public,string,get,rest,base,url,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,return,rest,base,url
RestServerEndpoint -> public String getRestBaseUrl();1545326469;Returns the base URL of the REST server endpoint.__@return REST base URL of this endpoint;public String getRestBaseUrl() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			return restBaseUrl__		}_	};returns,the,base,url,of,the,rest,server,endpoint,return,rest,base,url,of,this,endpoint;public,string,get,rest,base,url,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,return,rest,base,url
RestServerEndpoint -> public String getRestBaseUrl();1550222817;Returns the base URL of the REST server endpoint.__@return REST base URL of this endpoint;public String getRestBaseUrl() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			return restBaseUrl__		}_	};returns,the,base,url,of,the,rest,server,endpoint,return,rest,base,url,of,this,endpoint;public,string,get,rest,base,url,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,return,rest,base,url
RestServerEndpoint -> protected abstract void startInternal() throws Exception_;1519052657;Hook to start sub class specific services.__@throws Exception if an error occurred;protected abstract void startInternal() throws Exception_;hook,to,start,sub,class,specific,services,throws,exception,if,an,error,occurred;protected,abstract,void,start,internal,throws,exception
RestServerEndpoint -> protected abstract void startInternal() throws Exception_;1519406530;Hook to start sub class specific services.__@throws Exception if an error occurred;protected abstract void startInternal() throws Exception_;hook,to,start,sub,class,specific,services,throws,exception,if,an,error,occurred;protected,abstract,void,start,internal,throws,exception
RestServerEndpoint -> protected abstract void startInternal() throws Exception_;1521016670;Hook to start sub class specific services.__@throws Exception if an error occurred;protected abstract void startInternal() throws Exception_;hook,to,start,sub,class,specific,services,throws,exception,if,an,error,occurred;protected,abstract,void,start,internal,throws,exception
RestServerEndpoint -> protected abstract void startInternal() throws Exception_;1521016671;Hook to start sub class specific services.__@throws Exception if an error occurred;protected abstract void startInternal() throws Exception_;hook,to,start,sub,class,specific,services,throws,exception,if,an,error,occurred;protected,abstract,void,start,internal,throws,exception
RestServerEndpoint -> protected abstract void startInternal() throws Exception_;1521016671;Hook to start sub class specific services.__@throws Exception if an error occurred;protected abstract void startInternal() throws Exception_;hook,to,start,sub,class,specific,services,throws,exception,if,an,error,occurred;protected,abstract,void,start,internal,throws,exception
RestServerEndpoint -> protected abstract void startInternal() throws Exception_;1521385094;Hook to start sub class specific services.__@throws Exception if an error occurred;protected abstract void startInternal() throws Exception_;hook,to,start,sub,class,specific,services,throws,exception,if,an,error,occurred;protected,abstract,void,start,internal,throws,exception
RestServerEndpoint -> protected abstract void startInternal() throws Exception_;1521804758;Hook to start sub class specific services.__@throws Exception if an error occurred;protected abstract void startInternal() throws Exception_;hook,to,start,sub,class,specific,services,throws,exception,if,an,error,occurred;protected,abstract,void,start,internal,throws,exception
RestServerEndpoint -> protected abstract void startInternal() throws Exception_;1521804758;Hook to start sub class specific services.__@throws Exception if an error occurred;protected abstract void startInternal() throws Exception_;hook,to,start,sub,class,specific,services,throws,exception,if,an,error,occurred;protected,abstract,void,start,internal,throws,exception
RestServerEndpoint -> protected abstract void startInternal() throws Exception_;1525904579;Hook to start sub class specific services.__@throws Exception if an error occurred;protected abstract void startInternal() throws Exception_;hook,to,start,sub,class,specific,services,throws,exception,if,an,error,occurred;protected,abstract,void,start,internal,throws,exception
RestServerEndpoint -> protected abstract void startInternal() throws Exception_;1527499265;Hook to start sub class specific services.__@throws Exception if an error occurred;protected abstract void startInternal() throws Exception_;hook,to,start,sub,class,specific,services,throws,exception,if,an,error,occurred;protected,abstract,void,start,internal,throws,exception
RestServerEndpoint -> protected abstract void startInternal() throws Exception_;1528876304;Hook to start sub class specific services.__@throws Exception if an error occurred;protected abstract void startInternal() throws Exception_;hook,to,start,sub,class,specific,services,throws,exception,if,an,error,occurred;protected,abstract,void,start,internal,throws,exception
RestServerEndpoint -> protected abstract void startInternal() throws Exception_;1534259541;Hook to start sub class specific services.__@throws Exception if an error occurred;protected abstract void startInternal() throws Exception_;hook,to,start,sub,class,specific,services,throws,exception,if,an,error,occurred;protected,abstract,void,start,internal,throws,exception
RestServerEndpoint -> protected abstract void startInternal() throws Exception_;1535963626;Hook to start sub class specific services.__@throws Exception if an error occurred;protected abstract void startInternal() throws Exception_;hook,to,start,sub,class,specific,services,throws,exception,if,an,error,occurred;protected,abstract,void,start,internal,throws,exception
RestServerEndpoint -> protected abstract void startInternal() throws Exception_;1536930104;Hook to start sub class specific services.__@throws Exception if an error occurred;protected abstract void startInternal() throws Exception_;hook,to,start,sub,class,specific,services,throws,exception,if,an,error,occurred;protected,abstract,void,start,internal,throws,exception
RestServerEndpoint -> protected abstract void startInternal() throws Exception_;1539170288;Hook to start sub class specific services.__@throws Exception if an error occurred;protected abstract void startInternal() throws Exception_;hook,to,start,sub,class,specific,services,throws,exception,if,an,error,occurred;protected,abstract,void,start,internal,throws,exception
RestServerEndpoint -> protected abstract void startInternal() throws Exception_;1539934386;Hook to start sub class specific services.__@throws Exception if an error occurred;protected abstract void startInternal() throws Exception_;hook,to,start,sub,class,specific,services,throws,exception,if,an,error,occurred;protected,abstract,void,start,internal,throws,exception
RestServerEndpoint -> protected abstract void startInternal() throws Exception_;1540215410;Hook to start sub class specific services.__@throws Exception if an error occurred;protected abstract void startInternal() throws Exception_;hook,to,start,sub,class,specific,services,throws,exception,if,an,error,occurred;protected,abstract,void,start,internal,throws,exception
RestServerEndpoint -> protected abstract void startInternal() throws Exception_;1545326469;Hook to start sub class specific services.__@throws Exception if an error occurred;protected abstract void startInternal() throws Exception_;hook,to,start,sub,class,specific,services,throws,exception,if,an,error,occurred;protected,abstract,void,start,internal,throws,exception
RestServerEndpoint -> protected abstract void startInternal() throws Exception_;1550222817;Hook to start sub class specific services.__@throws Exception if an error occurred;protected abstract void startInternal() throws Exception_;hook,to,start,sub,class,specific,services,throws,exception,if,an,error,occurred;protected,abstract,void,start,internal,throws,exception
RestServerEndpoint -> protected CompletableFuture<Void> shutDownInternal();1519052657;Stops this REST server endpoint.__@return Future which is completed once the shut down has been finished.;protected CompletableFuture<Void> shutDownInternal() {__		synchronized (lock) {__			CompletableFuture<?> channelFuture = new CompletableFuture<>()__			if (serverChannel != null) {_				serverChannel.close().addListener(finished -> {_					if (finished.isSuccess()) {_						channelFuture.complete(null)__					} else {_						channelFuture.completeExceptionally(finished.cause())__					}_				})__				serverChannel = null__			}_			CompletableFuture<?> groupFuture = new CompletableFuture<>()__			CompletableFuture<?> childGroupFuture = new CompletableFuture<>()__			final Time gracePeriod = Time.seconds(10L)___			channelFuture.thenRun(() -> {_				if (bootstrap != null) {_					if (bootstrap.group() != null) {_						bootstrap.group().shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									groupFuture.complete(null)__								} else {_									groupFuture.completeExceptionally(finished.cause())__								}_							})__					}_					if (bootstrap.childGroup() != null) {_						bootstrap.childGroup().shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									childGroupFuture.complete(null)__								} else {_									childGroupFuture.completeExceptionally(finished.cause())__								}_							})__					}_					bootstrap = null__				} else {_					_					groupFuture.complete(null)__					childGroupFuture.complete(null)__				}_			})___			final CompletableFuture<Void> channelTerminationFuture = FutureUtils.completeAll(_				Arrays.asList(groupFuture, childGroupFuture))___			return FutureUtils.runAfterwards(_				channelTerminationFuture,_				() -> {_					log.info("Cleaning upload directory {}", uploadDir)__					FileUtils.cleanDirectory(uploadDir.toFile())__				})__		}_	};stops,this,rest,server,endpoint,return,future,which,is,completed,once,the,shut,down,has,been,finished;protected,completable,future,void,shut,down,internal,synchronized,lock,completable,future,channel,future,new,completable,future,if,server,channel,null,server,channel,close,add,listener,finished,if,finished,is,success,channel,future,complete,null,else,channel,future,complete,exceptionally,finished,cause,server,channel,null,completable,future,group,future,new,completable,future,completable,future,child,group,future,new,completable,future,final,time,grace,period,time,seconds,10l,channel,future,then,run,if,bootstrap,null,if,bootstrap,group,null,bootstrap,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,group,future,complete,null,else,group,future,complete,exceptionally,finished,cause,if,bootstrap,child,group,null,bootstrap,child,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,child,group,future,complete,null,else,child,group,future,complete,exceptionally,finished,cause,bootstrap,null,else,group,future,complete,null,child,group,future,complete,null,final,completable,future,void,channel,termination,future,future,utils,complete,all,arrays,as,list,group,future,child,group,future,return,future,utils,run,afterwards,channel,termination,future,log,info,cleaning,upload,directory,upload,dir,file,utils,clean,directory,upload,dir,to,file
RestServerEndpoint -> protected CompletableFuture<Void> shutDownInternal();1519406530;Stops this REST server endpoint.__@return Future which is completed once the shut down has been finished.;protected CompletableFuture<Void> shutDownInternal() {__		synchronized (lock) {__			CompletableFuture<?> channelFuture = new CompletableFuture<>()__			if (serverChannel != null) {_				serverChannel.close().addListener(finished -> {_					if (finished.isSuccess()) {_						channelFuture.complete(null)__					} else {_						channelFuture.completeExceptionally(finished.cause())__					}_				})__				serverChannel = null__			}__			final CompletableFuture<Void> channelTerminationFuture = new CompletableFuture<>()___			channelFuture.thenRun(() -> {_				CompletableFuture<?> groupFuture = new CompletableFuture<>()__				CompletableFuture<?> childGroupFuture = new CompletableFuture<>()__				final Time gracePeriod = Time.seconds(10L)___				if (bootstrap != null) {_					if (bootstrap.group() != null) {_						bootstrap.group().shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									groupFuture.complete(null)__								} else {_									groupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						groupFuture.complete(null)__					}__					if (bootstrap.childGroup() != null) {_						bootstrap.childGroup().shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									childGroupFuture.complete(null)__								} else {_									childGroupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						childGroupFuture.complete(null)__					}__					bootstrap = null__				} else {_					_					groupFuture.complete(null)__					childGroupFuture.complete(null)__				}__				CompletableFuture<Void> combinedFuture = FutureUtils.completeAll(Arrays.asList(groupFuture, childGroupFuture))___				_				_				FutureUtils.orTimeout(combinedFuture, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)___				combinedFuture_					.exceptionally(_						(Throwable throwable) -> {_							if (throwable instanceof TimeoutException) {_								_								log.info("Could not properly shut down Netty. Continue shut down of RestServerEndpoint.")__								return null__							} else {_								throw new CompletionException(ExceptionUtils.stripCompletionException(throwable))__							}_						})_					.whenComplete(_						(Void ignored, Throwable throwable) -> {_							if (throwable != null) {_								channelTerminationFuture.completeExceptionally(throwable)__							} else {_								channelTerminationFuture.complete(null)__							}_						})__			})___			return FutureUtils.runAfterwards(_				channelTerminationFuture,_				() -> {_					log.info("Cleaning upload directory {}", uploadDir)__					FileUtils.cleanDirectory(uploadDir.toFile())__				})__		}_	};stops,this,rest,server,endpoint,return,future,which,is,completed,once,the,shut,down,has,been,finished;protected,completable,future,void,shut,down,internal,synchronized,lock,completable,future,channel,future,new,completable,future,if,server,channel,null,server,channel,close,add,listener,finished,if,finished,is,success,channel,future,complete,null,else,channel,future,complete,exceptionally,finished,cause,server,channel,null,final,completable,future,void,channel,termination,future,new,completable,future,channel,future,then,run,completable,future,group,future,new,completable,future,completable,future,child,group,future,new,completable,future,final,time,grace,period,time,seconds,10l,if,bootstrap,null,if,bootstrap,group,null,bootstrap,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,group,future,complete,null,else,group,future,complete,exceptionally,finished,cause,else,group,future,complete,null,if,bootstrap,child,group,null,bootstrap,child,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,child,group,future,complete,null,else,child,group,future,complete,exceptionally,finished,cause,else,child,group,future,complete,null,bootstrap,null,else,group,future,complete,null,child,group,future,complete,null,completable,future,void,combined,future,future,utils,complete,all,arrays,as,list,group,future,child,group,future,future,utils,or,timeout,combined,future,grace,period,to,milliseconds,time,unit,milliseconds,combined,future,exceptionally,throwable,throwable,if,throwable,instanceof,timeout,exception,log,info,could,not,properly,shut,down,netty,continue,shut,down,of,rest,server,endpoint,return,null,else,throw,new,completion,exception,exception,utils,strip,completion,exception,throwable,when,complete,void,ignored,throwable,throwable,if,throwable,null,channel,termination,future,complete,exceptionally,throwable,else,channel,termination,future,complete,null,return,future,utils,run,afterwards,channel,termination,future,log,info,cleaning,upload,directory,upload,dir,file,utils,clean,directory,upload,dir,to,file
RestServerEndpoint -> protected CompletableFuture<Void> shutDownInternal();1521016670;Stops this REST server endpoint.__@return Future which is completed once the shut down has been finished.;protected CompletableFuture<Void> shutDownInternal() {__		synchronized (lock) {__			CompletableFuture<?> channelFuture = new CompletableFuture<>()__			if (serverChannel != null) {_				serverChannel.close().addListener(finished -> {_					if (finished.isSuccess()) {_						channelFuture.complete(null)__					} else {_						channelFuture.completeExceptionally(finished.cause())__					}_				})__				serverChannel = null__			}__			final CompletableFuture<Void> channelTerminationFuture = new CompletableFuture<>()___			channelFuture.thenRun(() -> {_				CompletableFuture<?> groupFuture = new CompletableFuture<>()__				CompletableFuture<?> childGroupFuture = new CompletableFuture<>()__				final Time gracePeriod = Time.seconds(10L)___				if (bootstrap != null) {_					if (bootstrap.group() != null) {_						bootstrap.group().shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									groupFuture.complete(null)__								} else {_									groupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						groupFuture.complete(null)__					}__					if (bootstrap.childGroup() != null) {_						bootstrap.childGroup().shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									childGroupFuture.complete(null)__								} else {_									childGroupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						childGroupFuture.complete(null)__					}__					bootstrap = null__				} else {_					_					groupFuture.complete(null)__					childGroupFuture.complete(null)__				}__				CompletableFuture<Void> combinedFuture = FutureUtils.completeAll(Arrays.asList(groupFuture, childGroupFuture))___				_				_				FutureUtils.orTimeout(combinedFuture, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)___				combinedFuture_					.exceptionally(_						(Throwable throwable) -> {_							if (throwable instanceof TimeoutException) {_								_								log.info("Could not properly shut down Netty. Continue shut down of RestServerEndpoint.")__								return null__							} else {_								throw new CompletionException(ExceptionUtils.stripCompletionException(throwable))__							}_						})_					.whenComplete(_						(Void ignored, Throwable throwable) -> {_							if (throwable != null) {_								channelTerminationFuture.completeExceptionally(throwable)__							} else {_								channelTerminationFuture.complete(null)__							}_						})__			})___			return FutureUtils.runAfterwards(_				channelTerminationFuture,_				() -> {_					log.info("Cleaning upload directory {}", uploadDir)__					FileUtils.cleanDirectory(uploadDir.toFile())__				})__		}_	};stops,this,rest,server,endpoint,return,future,which,is,completed,once,the,shut,down,has,been,finished;protected,completable,future,void,shut,down,internal,synchronized,lock,completable,future,channel,future,new,completable,future,if,server,channel,null,server,channel,close,add,listener,finished,if,finished,is,success,channel,future,complete,null,else,channel,future,complete,exceptionally,finished,cause,server,channel,null,final,completable,future,void,channel,termination,future,new,completable,future,channel,future,then,run,completable,future,group,future,new,completable,future,completable,future,child,group,future,new,completable,future,final,time,grace,period,time,seconds,10l,if,bootstrap,null,if,bootstrap,group,null,bootstrap,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,group,future,complete,null,else,group,future,complete,exceptionally,finished,cause,else,group,future,complete,null,if,bootstrap,child,group,null,bootstrap,child,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,child,group,future,complete,null,else,child,group,future,complete,exceptionally,finished,cause,else,child,group,future,complete,null,bootstrap,null,else,group,future,complete,null,child,group,future,complete,null,completable,future,void,combined,future,future,utils,complete,all,arrays,as,list,group,future,child,group,future,future,utils,or,timeout,combined,future,grace,period,to,milliseconds,time,unit,milliseconds,combined,future,exceptionally,throwable,throwable,if,throwable,instanceof,timeout,exception,log,info,could,not,properly,shut,down,netty,continue,shut,down,of,rest,server,endpoint,return,null,else,throw,new,completion,exception,exception,utils,strip,completion,exception,throwable,when,complete,void,ignored,throwable,throwable,if,throwable,null,channel,termination,future,complete,exceptionally,throwable,else,channel,termination,future,complete,null,return,future,utils,run,afterwards,channel,termination,future,log,info,cleaning,upload,directory,upload,dir,file,utils,clean,directory,upload,dir,to,file
RestServerEndpoint -> protected CompletableFuture<Void> shutDownInternal();1521016671;Stops this REST server endpoint.__@return Future which is completed once the shut down has been finished.;protected CompletableFuture<Void> shutDownInternal() {__		synchronized (lock) {__			CompletableFuture<?> channelFuture = new CompletableFuture<>()__			if (serverChannel != null) {_				serverChannel.close().addListener(finished -> {_					if (finished.isSuccess()) {_						channelFuture.complete(null)__					} else {_						channelFuture.completeExceptionally(finished.cause())__					}_				})__				serverChannel = null__			}__			final CompletableFuture<Void> channelTerminationFuture = new CompletableFuture<>()___			channelFuture.thenRun(() -> {_				CompletableFuture<?> groupFuture = new CompletableFuture<>()__				CompletableFuture<?> childGroupFuture = new CompletableFuture<>()__				final Time gracePeriod = Time.seconds(10L)___				if (bootstrap != null) {_					if (bootstrap.group() != null) {_						bootstrap.group().shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									groupFuture.complete(null)__								} else {_									groupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						groupFuture.complete(null)__					}__					if (bootstrap.childGroup() != null) {_						bootstrap.childGroup().shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									childGroupFuture.complete(null)__								} else {_									childGroupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						childGroupFuture.complete(null)__					}__					bootstrap = null__				} else {_					_					groupFuture.complete(null)__					childGroupFuture.complete(null)__				}__				CompletableFuture<Void> combinedFuture = FutureUtils.completeAll(Arrays.asList(groupFuture, childGroupFuture))___				_				_				FutureUtils.orTimeout(combinedFuture, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)___				combinedFuture_					.exceptionally(_						(Throwable throwable) -> {_							if (throwable instanceof TimeoutException) {_								_								log.info("Could not properly shut down Netty. Continue shut down of RestServerEndpoint.")__								return null__							} else {_								throw new CompletionException(ExceptionUtils.stripCompletionException(throwable))__							}_						})_					.whenComplete(_						(Void ignored, Throwable throwable) -> {_							if (throwable != null) {_								channelTerminationFuture.completeExceptionally(throwable)__							} else {_								channelTerminationFuture.complete(null)__							}_						})__			})___			return FutureUtils.runAfterwards(_				channelTerminationFuture,_				() -> {_					log.info("Cleaning upload directory {}", uploadDir)__					FileUtils.cleanDirectory(uploadDir.toFile())__				})__		}_	};stops,this,rest,server,endpoint,return,future,which,is,completed,once,the,shut,down,has,been,finished;protected,completable,future,void,shut,down,internal,synchronized,lock,completable,future,channel,future,new,completable,future,if,server,channel,null,server,channel,close,add,listener,finished,if,finished,is,success,channel,future,complete,null,else,channel,future,complete,exceptionally,finished,cause,server,channel,null,final,completable,future,void,channel,termination,future,new,completable,future,channel,future,then,run,completable,future,group,future,new,completable,future,completable,future,child,group,future,new,completable,future,final,time,grace,period,time,seconds,10l,if,bootstrap,null,if,bootstrap,group,null,bootstrap,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,group,future,complete,null,else,group,future,complete,exceptionally,finished,cause,else,group,future,complete,null,if,bootstrap,child,group,null,bootstrap,child,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,child,group,future,complete,null,else,child,group,future,complete,exceptionally,finished,cause,else,child,group,future,complete,null,bootstrap,null,else,group,future,complete,null,child,group,future,complete,null,completable,future,void,combined,future,future,utils,complete,all,arrays,as,list,group,future,child,group,future,future,utils,or,timeout,combined,future,grace,period,to,milliseconds,time,unit,milliseconds,combined,future,exceptionally,throwable,throwable,if,throwable,instanceof,timeout,exception,log,info,could,not,properly,shut,down,netty,continue,shut,down,of,rest,server,endpoint,return,null,else,throw,new,completion,exception,exception,utils,strip,completion,exception,throwable,when,complete,void,ignored,throwable,throwable,if,throwable,null,channel,termination,future,complete,exceptionally,throwable,else,channel,termination,future,complete,null,return,future,utils,run,afterwards,channel,termination,future,log,info,cleaning,upload,directory,upload,dir,file,utils,clean,directory,upload,dir,to,file
RestServerEndpoint -> protected CompletableFuture<Void> shutDownInternal();1521016671;Stops this REST server endpoint.__@return Future which is completed once the shut down has been finished.;protected CompletableFuture<Void> shutDownInternal() {__		synchronized (lock) {__			CompletableFuture<?> channelFuture = new CompletableFuture<>()__			if (serverChannel != null) {_				serverChannel.close().addListener(finished -> {_					if (finished.isSuccess()) {_						channelFuture.complete(null)__					} else {_						channelFuture.completeExceptionally(finished.cause())__					}_				})__				serverChannel = null__			}__			final CompletableFuture<Void> channelTerminationFuture = new CompletableFuture<>()___			channelFuture.thenRun(() -> {_				CompletableFuture<?> groupFuture = new CompletableFuture<>()__				CompletableFuture<?> childGroupFuture = new CompletableFuture<>()__				final Time gracePeriod = Time.seconds(10L)___				if (bootstrap != null) {_					if (bootstrap.group() != null) {_						bootstrap.group().shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									groupFuture.complete(null)__								} else {_									groupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						groupFuture.complete(null)__					}__					if (bootstrap.childGroup() != null) {_						bootstrap.childGroup().shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									childGroupFuture.complete(null)__								} else {_									childGroupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						childGroupFuture.complete(null)__					}__					bootstrap = null__				} else {_					_					groupFuture.complete(null)__					childGroupFuture.complete(null)__				}__				CompletableFuture<Void> combinedFuture = FutureUtils.completeAll(Arrays.asList(groupFuture, childGroupFuture))___				_				_				FutureUtils.orTimeout(combinedFuture, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)___				combinedFuture_					.exceptionally(_						(Throwable throwable) -> {_							if (throwable instanceof TimeoutException) {_								_								log.info("Could not properly shut down Netty. Continue shut down of RestServerEndpoint.")__								return null__							} else {_								throw new CompletionException(ExceptionUtils.stripCompletionException(throwable))__							}_						})_					.whenComplete(_						(Void ignored, Throwable throwable) -> {_							if (throwable != null) {_								channelTerminationFuture.completeExceptionally(throwable)__							} else {_								channelTerminationFuture.complete(null)__							}_						})__			})___			return FutureUtils.runAfterwards(_				channelTerminationFuture,_				() -> {_					log.info("Cleaning upload directory {}", uploadDir)__					FileUtils.cleanDirectory(uploadDir.toFile())__				})__		}_	};stops,this,rest,server,endpoint,return,future,which,is,completed,once,the,shut,down,has,been,finished;protected,completable,future,void,shut,down,internal,synchronized,lock,completable,future,channel,future,new,completable,future,if,server,channel,null,server,channel,close,add,listener,finished,if,finished,is,success,channel,future,complete,null,else,channel,future,complete,exceptionally,finished,cause,server,channel,null,final,completable,future,void,channel,termination,future,new,completable,future,channel,future,then,run,completable,future,group,future,new,completable,future,completable,future,child,group,future,new,completable,future,final,time,grace,period,time,seconds,10l,if,bootstrap,null,if,bootstrap,group,null,bootstrap,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,group,future,complete,null,else,group,future,complete,exceptionally,finished,cause,else,group,future,complete,null,if,bootstrap,child,group,null,bootstrap,child,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,child,group,future,complete,null,else,child,group,future,complete,exceptionally,finished,cause,else,child,group,future,complete,null,bootstrap,null,else,group,future,complete,null,child,group,future,complete,null,completable,future,void,combined,future,future,utils,complete,all,arrays,as,list,group,future,child,group,future,future,utils,or,timeout,combined,future,grace,period,to,milliseconds,time,unit,milliseconds,combined,future,exceptionally,throwable,throwable,if,throwable,instanceof,timeout,exception,log,info,could,not,properly,shut,down,netty,continue,shut,down,of,rest,server,endpoint,return,null,else,throw,new,completion,exception,exception,utils,strip,completion,exception,throwable,when,complete,void,ignored,throwable,throwable,if,throwable,null,channel,termination,future,complete,exceptionally,throwable,else,channel,termination,future,complete,null,return,future,utils,run,afterwards,channel,termination,future,log,info,cleaning,upload,directory,upload,dir,file,utils,clean,directory,upload,dir,to,file
RestServerEndpoint -> protected CompletableFuture<Void> shutDownInternal();1521385094;Stops this REST server endpoint.__@return Future which is completed once the shut down has been finished.;protected CompletableFuture<Void> shutDownInternal() {__		synchronized (lock) {__			CompletableFuture<?> channelFuture = new CompletableFuture<>()__			if (serverChannel != null) {_				serverChannel.close().addListener(finished -> {_					if (finished.isSuccess()) {_						channelFuture.complete(null)__					} else {_						channelFuture.completeExceptionally(finished.cause())__					}_				})__				serverChannel = null__			}__			final CompletableFuture<Void> channelTerminationFuture = new CompletableFuture<>()___			channelFuture.thenRun(() -> {_				CompletableFuture<?> groupFuture = new CompletableFuture<>()__				CompletableFuture<?> childGroupFuture = new CompletableFuture<>()__				final Time gracePeriod = Time.seconds(10L)___				if (bootstrap != null) {_					if (bootstrap.group() != null) {_						bootstrap.group().shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									groupFuture.complete(null)__								} else {_									groupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						groupFuture.complete(null)__					}__					if (bootstrap.childGroup() != null) {_						bootstrap.childGroup().shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									childGroupFuture.complete(null)__								} else {_									childGroupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						childGroupFuture.complete(null)__					}__					bootstrap = null__				} else {_					_					groupFuture.complete(null)__					childGroupFuture.complete(null)__				}__				CompletableFuture<Void> combinedFuture = FutureUtils.completeAll(Arrays.asList(groupFuture, childGroupFuture))___				_				_				FutureUtils.orTimeout(combinedFuture, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)___				combinedFuture_					.exceptionally(_						(Throwable throwable) -> {_							if (throwable instanceof TimeoutException) {_								_								log.info("Could not properly shut down Netty. Continue shut down of RestServerEndpoint.")__								return null__							} else {_								throw new CompletionException(ExceptionUtils.stripCompletionException(throwable))__							}_						})_					.whenComplete(_						(Void ignored, Throwable throwable) -> {_							if (throwable != null) {_								channelTerminationFuture.completeExceptionally(throwable)__							} else {_								channelTerminationFuture.complete(null)__							}_						})__			})___			return FutureUtils.runAfterwards(_				channelTerminationFuture,_				() -> {_					log.info("Cleaning upload directory {}", uploadDir)__					FileUtils.cleanDirectory(uploadDir.toFile())__				})__		}_	};stops,this,rest,server,endpoint,return,future,which,is,completed,once,the,shut,down,has,been,finished;protected,completable,future,void,shut,down,internal,synchronized,lock,completable,future,channel,future,new,completable,future,if,server,channel,null,server,channel,close,add,listener,finished,if,finished,is,success,channel,future,complete,null,else,channel,future,complete,exceptionally,finished,cause,server,channel,null,final,completable,future,void,channel,termination,future,new,completable,future,channel,future,then,run,completable,future,group,future,new,completable,future,completable,future,child,group,future,new,completable,future,final,time,grace,period,time,seconds,10l,if,bootstrap,null,if,bootstrap,group,null,bootstrap,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,group,future,complete,null,else,group,future,complete,exceptionally,finished,cause,else,group,future,complete,null,if,bootstrap,child,group,null,bootstrap,child,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,child,group,future,complete,null,else,child,group,future,complete,exceptionally,finished,cause,else,child,group,future,complete,null,bootstrap,null,else,group,future,complete,null,child,group,future,complete,null,completable,future,void,combined,future,future,utils,complete,all,arrays,as,list,group,future,child,group,future,future,utils,or,timeout,combined,future,grace,period,to,milliseconds,time,unit,milliseconds,combined,future,exceptionally,throwable,throwable,if,throwable,instanceof,timeout,exception,log,info,could,not,properly,shut,down,netty,continue,shut,down,of,rest,server,endpoint,return,null,else,throw,new,completion,exception,exception,utils,strip,completion,exception,throwable,when,complete,void,ignored,throwable,throwable,if,throwable,null,channel,termination,future,complete,exceptionally,throwable,else,channel,termination,future,complete,null,return,future,utils,run,afterwards,channel,termination,future,log,info,cleaning,upload,directory,upload,dir,file,utils,clean,directory,upload,dir,to,file
RestServerEndpoint -> protected CompletableFuture<Void> shutDownInternal();1521804758;Stops this REST server endpoint.__@return Future which is completed once the shut down has been finished.;protected CompletableFuture<Void> shutDownInternal() {__		synchronized (lock) {__			CompletableFuture<?> channelFuture = new CompletableFuture<>()__			if (serverChannel != null) {_				serverChannel.close().addListener(finished -> {_					if (finished.isSuccess()) {_						channelFuture.complete(null)__					} else {_						channelFuture.completeExceptionally(finished.cause())__					}_				})__				serverChannel = null__			}__			final CompletableFuture<Void> channelTerminationFuture = new CompletableFuture<>()___			channelFuture.thenRun(() -> {_				CompletableFuture<?> groupFuture = new CompletableFuture<>()__				CompletableFuture<?> childGroupFuture = new CompletableFuture<>()__				final Time gracePeriod = Time.seconds(10L)___				if (bootstrap != null) {_					if (bootstrap.group() != null) {_						bootstrap.group().shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									groupFuture.complete(null)__								} else {_									groupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						groupFuture.complete(null)__					}__					if (bootstrap.childGroup() != null) {_						bootstrap.childGroup().shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									childGroupFuture.complete(null)__								} else {_									childGroupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						childGroupFuture.complete(null)__					}__					bootstrap = null__				} else {_					_					groupFuture.complete(null)__					childGroupFuture.complete(null)__				}__				CompletableFuture<Void> combinedFuture = FutureUtils.completeAll(Arrays.asList(groupFuture, childGroupFuture))___				_				_				FutureUtils.orTimeout(combinedFuture, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)___				combinedFuture_					.exceptionally(_						(Throwable throwable) -> {_							if (throwable instanceof TimeoutException) {_								_								log.info("Could not properly shut down Netty. Continue shut down of RestServerEndpoint.")__								return null__							} else {_								throw new CompletionException(ExceptionUtils.stripCompletionException(throwable))__							}_						})_					.whenComplete(_						(Void ignored, Throwable throwable) -> {_							if (throwable != null) {_								channelTerminationFuture.completeExceptionally(throwable)__							} else {_								channelTerminationFuture.complete(null)__							}_						})__			})___			return FutureUtils.runAfterwards(_				channelTerminationFuture,_				() -> {_					log.info("Cleaning upload directory {}", uploadDir)__					FileUtils.cleanDirectory(uploadDir.toFile())__				})__		}_	};stops,this,rest,server,endpoint,return,future,which,is,completed,once,the,shut,down,has,been,finished;protected,completable,future,void,shut,down,internal,synchronized,lock,completable,future,channel,future,new,completable,future,if,server,channel,null,server,channel,close,add,listener,finished,if,finished,is,success,channel,future,complete,null,else,channel,future,complete,exceptionally,finished,cause,server,channel,null,final,completable,future,void,channel,termination,future,new,completable,future,channel,future,then,run,completable,future,group,future,new,completable,future,completable,future,child,group,future,new,completable,future,final,time,grace,period,time,seconds,10l,if,bootstrap,null,if,bootstrap,group,null,bootstrap,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,group,future,complete,null,else,group,future,complete,exceptionally,finished,cause,else,group,future,complete,null,if,bootstrap,child,group,null,bootstrap,child,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,child,group,future,complete,null,else,child,group,future,complete,exceptionally,finished,cause,else,child,group,future,complete,null,bootstrap,null,else,group,future,complete,null,child,group,future,complete,null,completable,future,void,combined,future,future,utils,complete,all,arrays,as,list,group,future,child,group,future,future,utils,or,timeout,combined,future,grace,period,to,milliseconds,time,unit,milliseconds,combined,future,exceptionally,throwable,throwable,if,throwable,instanceof,timeout,exception,log,info,could,not,properly,shut,down,netty,continue,shut,down,of,rest,server,endpoint,return,null,else,throw,new,completion,exception,exception,utils,strip,completion,exception,throwable,when,complete,void,ignored,throwable,throwable,if,throwable,null,channel,termination,future,complete,exceptionally,throwable,else,channel,termination,future,complete,null,return,future,utils,run,afterwards,channel,termination,future,log,info,cleaning,upload,directory,upload,dir,file,utils,clean,directory,upload,dir,to,file
RestServerEndpoint -> protected CompletableFuture<Void> shutDownInternal();1521804758;Stops this REST server endpoint.__@return Future which is completed once the shut down has been finished.;protected CompletableFuture<Void> shutDownInternal() {__		synchronized (lock) {__			CompletableFuture<?> channelFuture = new CompletableFuture<>()__			if (serverChannel != null) {_				serverChannel.close().addListener(finished -> {_					if (finished.isSuccess()) {_						channelFuture.complete(null)__					} else {_						channelFuture.completeExceptionally(finished.cause())__					}_				})__				serverChannel = null__			}__			final CompletableFuture<Void> channelTerminationFuture = new CompletableFuture<>()___			channelFuture.thenRun(() -> {_				CompletableFuture<?> groupFuture = new CompletableFuture<>()__				CompletableFuture<?> childGroupFuture = new CompletableFuture<>()__				final Time gracePeriod = Time.seconds(10L)___				if (bootstrap != null) {_					if (bootstrap.group() != null) {_						bootstrap.group().shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									groupFuture.complete(null)__								} else {_									groupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						groupFuture.complete(null)__					}__					if (bootstrap.childGroup() != null) {_						bootstrap.childGroup().shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									childGroupFuture.complete(null)__								} else {_									childGroupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						childGroupFuture.complete(null)__					}__					bootstrap = null__				} else {_					_					groupFuture.complete(null)__					childGroupFuture.complete(null)__				}__				CompletableFuture<Void> combinedFuture = FutureUtils.completeAll(Arrays.asList(groupFuture, childGroupFuture))___				_				_				FutureUtils.orTimeout(combinedFuture, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)___				combinedFuture_					.exceptionally(_						(Throwable throwable) -> {_							if (throwable instanceof TimeoutException) {_								_								log.info("Could not properly shut down Netty. Continue shut down of RestServerEndpoint.")__								return null__							} else {_								throw new CompletionException(ExceptionUtils.stripCompletionException(throwable))__							}_						})_					.whenComplete(_						(Void ignored, Throwable throwable) -> {_							if (throwable != null) {_								channelTerminationFuture.completeExceptionally(throwable)__							} else {_								channelTerminationFuture.complete(null)__							}_						})__			})___			return channelTerminationFuture__		}_	};stops,this,rest,server,endpoint,return,future,which,is,completed,once,the,shut,down,has,been,finished;protected,completable,future,void,shut,down,internal,synchronized,lock,completable,future,channel,future,new,completable,future,if,server,channel,null,server,channel,close,add,listener,finished,if,finished,is,success,channel,future,complete,null,else,channel,future,complete,exceptionally,finished,cause,server,channel,null,final,completable,future,void,channel,termination,future,new,completable,future,channel,future,then,run,completable,future,group,future,new,completable,future,completable,future,child,group,future,new,completable,future,final,time,grace,period,time,seconds,10l,if,bootstrap,null,if,bootstrap,group,null,bootstrap,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,group,future,complete,null,else,group,future,complete,exceptionally,finished,cause,else,group,future,complete,null,if,bootstrap,child,group,null,bootstrap,child,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,child,group,future,complete,null,else,child,group,future,complete,exceptionally,finished,cause,else,child,group,future,complete,null,bootstrap,null,else,group,future,complete,null,child,group,future,complete,null,completable,future,void,combined,future,future,utils,complete,all,arrays,as,list,group,future,child,group,future,future,utils,or,timeout,combined,future,grace,period,to,milliseconds,time,unit,milliseconds,combined,future,exceptionally,throwable,throwable,if,throwable,instanceof,timeout,exception,log,info,could,not,properly,shut,down,netty,continue,shut,down,of,rest,server,endpoint,return,null,else,throw,new,completion,exception,exception,utils,strip,completion,exception,throwable,when,complete,void,ignored,throwable,throwable,if,throwable,null,channel,termination,future,complete,exceptionally,throwable,else,channel,termination,future,complete,null,return,channel,termination,future
RestServerEndpoint -> protected CompletableFuture<Void> shutDownInternal();1525904579;Stops this REST server endpoint.__@return Future which is completed once the shut down has been finished.;protected CompletableFuture<Void> shutDownInternal() {__		synchronized (lock) {__			CompletableFuture<?> channelFuture = new CompletableFuture<>()__			if (serverChannel != null) {_				serverChannel.close().addListener(finished -> {_					if (finished.isSuccess()) {_						channelFuture.complete(null)__					} else {_						channelFuture.completeExceptionally(finished.cause())__					}_				})__				serverChannel = null__			}__			final CompletableFuture<Void> channelTerminationFuture = new CompletableFuture<>()___			channelFuture.thenRun(() -> {_				CompletableFuture<?> groupFuture = new CompletableFuture<>()__				CompletableFuture<?> childGroupFuture = new CompletableFuture<>()__				final Time gracePeriod = Time.seconds(10L)___				if (bootstrap != null) {_					if (bootstrap.group() != null) {_						bootstrap.group().shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									groupFuture.complete(null)__								} else {_									groupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						groupFuture.complete(null)__					}__					if (bootstrap.childGroup() != null) {_						bootstrap.childGroup().shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									childGroupFuture.complete(null)__								} else {_									childGroupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						childGroupFuture.complete(null)__					}__					bootstrap = null__				} else {_					_					groupFuture.complete(null)__					childGroupFuture.complete(null)__				}__				CompletableFuture<Void> combinedFuture = FutureUtils.completeAll(Arrays.asList(groupFuture, childGroupFuture))___				_				_				FutureUtils.orTimeout(combinedFuture, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)___				combinedFuture_					.exceptionally(_						(Throwable throwable) -> {_							if (throwable instanceof TimeoutException) {_								_								log.info("Could not properly shut down Netty. Continue shut down of RestServerEndpoint.")__								return null__							} else {_								throw new CompletionException(ExceptionUtils.stripCompletionException(throwable))__							}_						})_					.whenComplete(_						(Void ignored, Throwable throwable) -> {_							if (throwable != null) {_								channelTerminationFuture.completeExceptionally(throwable)__							} else {_								channelTerminationFuture.complete(null)__							}_						})__			})___			return channelTerminationFuture__		}_	};stops,this,rest,server,endpoint,return,future,which,is,completed,once,the,shut,down,has,been,finished;protected,completable,future,void,shut,down,internal,synchronized,lock,completable,future,channel,future,new,completable,future,if,server,channel,null,server,channel,close,add,listener,finished,if,finished,is,success,channel,future,complete,null,else,channel,future,complete,exceptionally,finished,cause,server,channel,null,final,completable,future,void,channel,termination,future,new,completable,future,channel,future,then,run,completable,future,group,future,new,completable,future,completable,future,child,group,future,new,completable,future,final,time,grace,period,time,seconds,10l,if,bootstrap,null,if,bootstrap,group,null,bootstrap,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,group,future,complete,null,else,group,future,complete,exceptionally,finished,cause,else,group,future,complete,null,if,bootstrap,child,group,null,bootstrap,child,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,child,group,future,complete,null,else,child,group,future,complete,exceptionally,finished,cause,else,child,group,future,complete,null,bootstrap,null,else,group,future,complete,null,child,group,future,complete,null,completable,future,void,combined,future,future,utils,complete,all,arrays,as,list,group,future,child,group,future,future,utils,or,timeout,combined,future,grace,period,to,milliseconds,time,unit,milliseconds,combined,future,exceptionally,throwable,throwable,if,throwable,instanceof,timeout,exception,log,info,could,not,properly,shut,down,netty,continue,shut,down,of,rest,server,endpoint,return,null,else,throw,new,completion,exception,exception,utils,strip,completion,exception,throwable,when,complete,void,ignored,throwable,throwable,if,throwable,null,channel,termination,future,complete,exceptionally,throwable,else,channel,termination,future,complete,null,return,channel,termination,future
RestServerEndpoint -> protected CompletableFuture<Void> shutDownInternal();1527499265;Stops this REST server endpoint.__@return Future which is completed once the shut down has been finished.;protected CompletableFuture<Void> shutDownInternal() {__		synchronized (lock) {__			CompletableFuture<?> channelFuture = new CompletableFuture<>()__			if (serverChannel != null) {_				serverChannel.close().addListener(finished -> {_					if (finished.isSuccess()) {_						channelFuture.complete(null)__					} else {_						channelFuture.completeExceptionally(finished.cause())__					}_				})__				serverChannel = null__			}__			final CompletableFuture<Void> channelTerminationFuture = new CompletableFuture<>()___			channelFuture.thenRun(() -> {_				CompletableFuture<?> groupFuture = new CompletableFuture<>()__				CompletableFuture<?> childGroupFuture = new CompletableFuture<>()__				final Time gracePeriod = Time.seconds(10L)___				if (bootstrap != null) {_					if (bootstrap.group() != null) {_						bootstrap.group().shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									groupFuture.complete(null)__								} else {_									groupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						groupFuture.complete(null)__					}__					if (bootstrap.childGroup() != null) {_						bootstrap.childGroup().shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									childGroupFuture.complete(null)__								} else {_									childGroupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						childGroupFuture.complete(null)__					}__					bootstrap = null__				} else {_					_					groupFuture.complete(null)__					childGroupFuture.complete(null)__				}__				CompletableFuture<Void> combinedFuture = FutureUtils.completeAll(Arrays.asList(groupFuture, childGroupFuture))___				_				_				FutureUtils.orTimeout(combinedFuture, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)___				combinedFuture_					.exceptionally(_						(Throwable throwable) -> {_							if (throwable instanceof TimeoutException) {_								_								log.info("Could not properly shut down Netty. Continue shut down of RestServerEndpoint.")__								return null__							} else {_								throw new CompletionException(ExceptionUtils.stripCompletionException(throwable))__							}_						})_					.whenComplete(_						(Void ignored, Throwable throwable) -> {_							if (throwable != null) {_								channelTerminationFuture.completeExceptionally(throwable)__							} else {_								channelTerminationFuture.complete(null)__							}_						})__			})___			return channelTerminationFuture__		}_	};stops,this,rest,server,endpoint,return,future,which,is,completed,once,the,shut,down,has,been,finished;protected,completable,future,void,shut,down,internal,synchronized,lock,completable,future,channel,future,new,completable,future,if,server,channel,null,server,channel,close,add,listener,finished,if,finished,is,success,channel,future,complete,null,else,channel,future,complete,exceptionally,finished,cause,server,channel,null,final,completable,future,void,channel,termination,future,new,completable,future,channel,future,then,run,completable,future,group,future,new,completable,future,completable,future,child,group,future,new,completable,future,final,time,grace,period,time,seconds,10l,if,bootstrap,null,if,bootstrap,group,null,bootstrap,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,group,future,complete,null,else,group,future,complete,exceptionally,finished,cause,else,group,future,complete,null,if,bootstrap,child,group,null,bootstrap,child,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,child,group,future,complete,null,else,child,group,future,complete,exceptionally,finished,cause,else,child,group,future,complete,null,bootstrap,null,else,group,future,complete,null,child,group,future,complete,null,completable,future,void,combined,future,future,utils,complete,all,arrays,as,list,group,future,child,group,future,future,utils,or,timeout,combined,future,grace,period,to,milliseconds,time,unit,milliseconds,combined,future,exceptionally,throwable,throwable,if,throwable,instanceof,timeout,exception,log,info,could,not,properly,shut,down,netty,continue,shut,down,of,rest,server,endpoint,return,null,else,throw,new,completion,exception,exception,utils,strip,completion,exception,throwable,when,complete,void,ignored,throwable,throwable,if,throwable,null,channel,termination,future,complete,exceptionally,throwable,else,channel,termination,future,complete,null,return,channel,termination,future
RestServerEndpoint -> protected CompletableFuture<Void> shutDownInternal();1528876304;Stops this REST server endpoint.__@return Future which is completed once the shut down has been finished.;protected CompletableFuture<Void> shutDownInternal() {__		synchronized (lock) {__			CompletableFuture<?> channelFuture = new CompletableFuture<>()__			if (serverChannel != null) {_				serverChannel.close().addListener(finished -> {_					if (finished.isSuccess()) {_						channelFuture.complete(null)__					} else {_						channelFuture.completeExceptionally(finished.cause())__					}_				})__				serverChannel = null__			}__			final CompletableFuture<Void> channelTerminationFuture = new CompletableFuture<>()___			channelFuture.thenRun(() -> {_				CompletableFuture<?> groupFuture = new CompletableFuture<>()__				CompletableFuture<?> childGroupFuture = new CompletableFuture<>()__				final Time gracePeriod = Time.seconds(10L)___				if (bootstrap != null) {_					final ServerBootstrapConfig config = bootstrap.config()__					final EventLoopGroup group = config.group()__					if (group != null) {_						group.shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									groupFuture.complete(null)__								} else {_									groupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						groupFuture.complete(null)__					}__					final EventLoopGroup childGroup = config.childGroup()__					if (childGroup != null) {_						childGroup.shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									childGroupFuture.complete(null)__								} else {_									childGroupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						childGroupFuture.complete(null)__					}__					bootstrap = null__				} else {_					_					groupFuture.complete(null)__					childGroupFuture.complete(null)__				}__				CompletableFuture<Void> combinedFuture = FutureUtils.completeAll(Arrays.asList(groupFuture, childGroupFuture))___				combinedFuture.whenComplete(_					(Void ignored, Throwable throwable) -> {_						if (throwable != null) {_							channelTerminationFuture.completeExceptionally(throwable)__						} else {_							channelTerminationFuture.complete(null)__						}_					})__			})___			return channelTerminationFuture__		}_	};stops,this,rest,server,endpoint,return,future,which,is,completed,once,the,shut,down,has,been,finished;protected,completable,future,void,shut,down,internal,synchronized,lock,completable,future,channel,future,new,completable,future,if,server,channel,null,server,channel,close,add,listener,finished,if,finished,is,success,channel,future,complete,null,else,channel,future,complete,exceptionally,finished,cause,server,channel,null,final,completable,future,void,channel,termination,future,new,completable,future,channel,future,then,run,completable,future,group,future,new,completable,future,completable,future,child,group,future,new,completable,future,final,time,grace,period,time,seconds,10l,if,bootstrap,null,final,server,bootstrap,config,config,bootstrap,config,final,event,loop,group,group,config,group,if,group,null,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,group,future,complete,null,else,group,future,complete,exceptionally,finished,cause,else,group,future,complete,null,final,event,loop,group,child,group,config,child,group,if,child,group,null,child,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,child,group,future,complete,null,else,child,group,future,complete,exceptionally,finished,cause,else,child,group,future,complete,null,bootstrap,null,else,group,future,complete,null,child,group,future,complete,null,completable,future,void,combined,future,future,utils,complete,all,arrays,as,list,group,future,child,group,future,combined,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,channel,termination,future,complete,exceptionally,throwable,else,channel,termination,future,complete,null,return,channel,termination,future
RestServerEndpoint -> protected CompletableFuture<Void> shutDownInternal();1534259541;Stops this REST server endpoint.__@return Future which is completed once the shut down has been finished.;protected CompletableFuture<Void> shutDownInternal() {__		synchronized (lock) {__			CompletableFuture<?> channelFuture = new CompletableFuture<>()__			if (serverChannel != null) {_				serverChannel.close().addListener(finished -> {_					if (finished.isSuccess()) {_						channelFuture.complete(null)__					} else {_						channelFuture.completeExceptionally(finished.cause())__					}_				})__				serverChannel = null__			}__			final CompletableFuture<Void> channelTerminationFuture = new CompletableFuture<>()___			channelFuture.thenRun(() -> {_				CompletableFuture<?> groupFuture = new CompletableFuture<>()__				CompletableFuture<?> childGroupFuture = new CompletableFuture<>()__				final Time gracePeriod = Time.seconds(10L)___				if (bootstrap != null) {_					final ServerBootstrapConfig config = bootstrap.config()__					final EventLoopGroup group = config.group()__					if (group != null) {_						group.shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									groupFuture.complete(null)__								} else {_									groupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						groupFuture.complete(null)__					}__					final EventLoopGroup childGroup = config.childGroup()__					if (childGroup != null) {_						childGroup.shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									childGroupFuture.complete(null)__								} else {_									childGroupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						childGroupFuture.complete(null)__					}__					bootstrap = null__				} else {_					_					groupFuture.complete(null)__					childGroupFuture.complete(null)__				}__				CompletableFuture<Void> combinedFuture = FutureUtils.completeAll(Arrays.asList(groupFuture, childGroupFuture))___				combinedFuture.whenComplete(_					(Void ignored, Throwable throwable) -> {_						if (throwable != null) {_							channelTerminationFuture.completeExceptionally(throwable)__						} else {_							channelTerminationFuture.complete(null)__						}_					})__			})___			return channelTerminationFuture__		}_	};stops,this,rest,server,endpoint,return,future,which,is,completed,once,the,shut,down,has,been,finished;protected,completable,future,void,shut,down,internal,synchronized,lock,completable,future,channel,future,new,completable,future,if,server,channel,null,server,channel,close,add,listener,finished,if,finished,is,success,channel,future,complete,null,else,channel,future,complete,exceptionally,finished,cause,server,channel,null,final,completable,future,void,channel,termination,future,new,completable,future,channel,future,then,run,completable,future,group,future,new,completable,future,completable,future,child,group,future,new,completable,future,final,time,grace,period,time,seconds,10l,if,bootstrap,null,final,server,bootstrap,config,config,bootstrap,config,final,event,loop,group,group,config,group,if,group,null,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,group,future,complete,null,else,group,future,complete,exceptionally,finished,cause,else,group,future,complete,null,final,event,loop,group,child,group,config,child,group,if,child,group,null,child,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,child,group,future,complete,null,else,child,group,future,complete,exceptionally,finished,cause,else,child,group,future,complete,null,bootstrap,null,else,group,future,complete,null,child,group,future,complete,null,completable,future,void,combined,future,future,utils,complete,all,arrays,as,list,group,future,child,group,future,combined,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,channel,termination,future,complete,exceptionally,throwable,else,channel,termination,future,complete,null,return,channel,termination,future
RestServerEndpoint -> protected CompletableFuture<Void> shutDownInternal();1535963626;Stops this REST server endpoint.__@return Future which is completed once the shut down has been finished.;protected CompletableFuture<Void> shutDownInternal() {__		synchronized (lock) {__			CompletableFuture<?> channelFuture = new CompletableFuture<>()__			if (serverChannel != null) {_				serverChannel.close().addListener(finished -> {_					if (finished.isSuccess()) {_						channelFuture.complete(null)__					} else {_						channelFuture.completeExceptionally(finished.cause())__					}_				})__				serverChannel = null__			}__			final CompletableFuture<Void> channelTerminationFuture = new CompletableFuture<>()___			channelFuture.thenRun(() -> {_				CompletableFuture<?> groupFuture = new CompletableFuture<>()__				CompletableFuture<?> childGroupFuture = new CompletableFuture<>()__				final Time gracePeriod = Time.seconds(10L)___				if (bootstrap != null) {_					final ServerBootstrapConfig config = bootstrap.config()__					final EventLoopGroup group = config.group()__					if (group != null) {_						group.shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									groupFuture.complete(null)__								} else {_									groupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						groupFuture.complete(null)__					}__					final EventLoopGroup childGroup = config.childGroup()__					if (childGroup != null) {_						childGroup.shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									childGroupFuture.complete(null)__								} else {_									childGroupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						childGroupFuture.complete(null)__					}__					bootstrap = null__				} else {_					_					groupFuture.complete(null)__					childGroupFuture.complete(null)__				}__				CompletableFuture<Void> combinedFuture = FutureUtils.completeAll(Arrays.asList(groupFuture, childGroupFuture))___				combinedFuture.whenComplete(_					(Void ignored, Throwable throwable) -> {_						if (throwable != null) {_							channelTerminationFuture.completeExceptionally(throwable)__						} else {_							channelTerminationFuture.complete(null)__						}_					})__			})___			return channelTerminationFuture__		}_	};stops,this,rest,server,endpoint,return,future,which,is,completed,once,the,shut,down,has,been,finished;protected,completable,future,void,shut,down,internal,synchronized,lock,completable,future,channel,future,new,completable,future,if,server,channel,null,server,channel,close,add,listener,finished,if,finished,is,success,channel,future,complete,null,else,channel,future,complete,exceptionally,finished,cause,server,channel,null,final,completable,future,void,channel,termination,future,new,completable,future,channel,future,then,run,completable,future,group,future,new,completable,future,completable,future,child,group,future,new,completable,future,final,time,grace,period,time,seconds,10l,if,bootstrap,null,final,server,bootstrap,config,config,bootstrap,config,final,event,loop,group,group,config,group,if,group,null,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,group,future,complete,null,else,group,future,complete,exceptionally,finished,cause,else,group,future,complete,null,final,event,loop,group,child,group,config,child,group,if,child,group,null,child,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,child,group,future,complete,null,else,child,group,future,complete,exceptionally,finished,cause,else,child,group,future,complete,null,bootstrap,null,else,group,future,complete,null,child,group,future,complete,null,completable,future,void,combined,future,future,utils,complete,all,arrays,as,list,group,future,child,group,future,combined,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,channel,termination,future,complete,exceptionally,throwable,else,channel,termination,future,complete,null,return,channel,termination,future
RestServerEndpoint -> protected CompletableFuture<Void> shutDownInternal();1536930104;Stops this REST server endpoint.__@return Future which is completed once the shut down has been finished.;protected CompletableFuture<Void> shutDownInternal() {__		synchronized (lock) {__			CompletableFuture<?> channelFuture = new CompletableFuture<>()__			if (serverChannel != null) {_				serverChannel.close().addListener(finished -> {_					if (finished.isSuccess()) {_						channelFuture.complete(null)__					} else {_						channelFuture.completeExceptionally(finished.cause())__					}_				})__				serverChannel = null__			}__			final CompletableFuture<Void> channelTerminationFuture = new CompletableFuture<>()___			channelFuture.thenRun(() -> {_				CompletableFuture<?> groupFuture = new CompletableFuture<>()__				CompletableFuture<?> childGroupFuture = new CompletableFuture<>()__				final Time gracePeriod = Time.seconds(10L)___				if (bootstrap != null) {_					final ServerBootstrapConfig config = bootstrap.config()__					final EventLoopGroup group = config.group()__					if (group != null) {_						group.shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									groupFuture.complete(null)__								} else {_									groupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						groupFuture.complete(null)__					}__					final EventLoopGroup childGroup = config.childGroup()__					if (childGroup != null) {_						childGroup.shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									childGroupFuture.complete(null)__								} else {_									childGroupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						childGroupFuture.complete(null)__					}__					bootstrap = null__				} else {_					_					groupFuture.complete(null)__					childGroupFuture.complete(null)__				}__				CompletableFuture<Void> combinedFuture = FutureUtils.completeAll(Arrays.asList(groupFuture, childGroupFuture))___				combinedFuture.whenComplete(_					(Void ignored, Throwable throwable) -> {_						if (throwable != null) {_							channelTerminationFuture.completeExceptionally(throwable)__						} else {_							channelTerminationFuture.complete(null)__						}_					})__			})___			return channelTerminationFuture__		}_	};stops,this,rest,server,endpoint,return,future,which,is,completed,once,the,shut,down,has,been,finished;protected,completable,future,void,shut,down,internal,synchronized,lock,completable,future,channel,future,new,completable,future,if,server,channel,null,server,channel,close,add,listener,finished,if,finished,is,success,channel,future,complete,null,else,channel,future,complete,exceptionally,finished,cause,server,channel,null,final,completable,future,void,channel,termination,future,new,completable,future,channel,future,then,run,completable,future,group,future,new,completable,future,completable,future,child,group,future,new,completable,future,final,time,grace,period,time,seconds,10l,if,bootstrap,null,final,server,bootstrap,config,config,bootstrap,config,final,event,loop,group,group,config,group,if,group,null,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,group,future,complete,null,else,group,future,complete,exceptionally,finished,cause,else,group,future,complete,null,final,event,loop,group,child,group,config,child,group,if,child,group,null,child,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,child,group,future,complete,null,else,child,group,future,complete,exceptionally,finished,cause,else,child,group,future,complete,null,bootstrap,null,else,group,future,complete,null,child,group,future,complete,null,completable,future,void,combined,future,future,utils,complete,all,arrays,as,list,group,future,child,group,future,combined,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,channel,termination,future,complete,exceptionally,throwable,else,channel,termination,future,complete,null,return,channel,termination,future
RestServerEndpoint -> protected CompletableFuture<Void> shutDownInternal();1539170288;Stops this REST server endpoint.__@return Future which is completed once the shut down has been finished.;protected CompletableFuture<Void> shutDownInternal() {__		synchronized (lock) {__			CompletableFuture<?> channelFuture = new CompletableFuture<>()__			if (serverChannel != null) {_				serverChannel.close().addListener(finished -> {_					if (finished.isSuccess()) {_						channelFuture.complete(null)__					} else {_						channelFuture.completeExceptionally(finished.cause())__					}_				})__				serverChannel = null__			}__			final CompletableFuture<Void> channelTerminationFuture = new CompletableFuture<>()___			channelFuture.thenRun(() -> {_				CompletableFuture<?> groupFuture = new CompletableFuture<>()__				CompletableFuture<?> childGroupFuture = new CompletableFuture<>()__				final Time gracePeriod = Time.seconds(10L)___				if (bootstrap != null) {_					final ServerBootstrapConfig config = bootstrap.config()__					final EventLoopGroup group = config.group()__					if (group != null) {_						group.shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									groupFuture.complete(null)__								} else {_									groupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						groupFuture.complete(null)__					}__					final EventLoopGroup childGroup = config.childGroup()__					if (childGroup != null) {_						childGroup.shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									childGroupFuture.complete(null)__								} else {_									childGroupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						childGroupFuture.complete(null)__					}__					bootstrap = null__				} else {_					_					groupFuture.complete(null)__					childGroupFuture.complete(null)__				}__				CompletableFuture<Void> combinedFuture = FutureUtils.completeAll(Arrays.asList(groupFuture, childGroupFuture))___				combinedFuture.whenComplete(_					(Void ignored, Throwable throwable) -> {_						if (throwable != null) {_							channelTerminationFuture.completeExceptionally(throwable)__						} else {_							channelTerminationFuture.complete(null)__						}_					})__			})___			return channelTerminationFuture__		}_	};stops,this,rest,server,endpoint,return,future,which,is,completed,once,the,shut,down,has,been,finished;protected,completable,future,void,shut,down,internal,synchronized,lock,completable,future,channel,future,new,completable,future,if,server,channel,null,server,channel,close,add,listener,finished,if,finished,is,success,channel,future,complete,null,else,channel,future,complete,exceptionally,finished,cause,server,channel,null,final,completable,future,void,channel,termination,future,new,completable,future,channel,future,then,run,completable,future,group,future,new,completable,future,completable,future,child,group,future,new,completable,future,final,time,grace,period,time,seconds,10l,if,bootstrap,null,final,server,bootstrap,config,config,bootstrap,config,final,event,loop,group,group,config,group,if,group,null,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,group,future,complete,null,else,group,future,complete,exceptionally,finished,cause,else,group,future,complete,null,final,event,loop,group,child,group,config,child,group,if,child,group,null,child,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,child,group,future,complete,null,else,child,group,future,complete,exceptionally,finished,cause,else,child,group,future,complete,null,bootstrap,null,else,group,future,complete,null,child,group,future,complete,null,completable,future,void,combined,future,future,utils,complete,all,arrays,as,list,group,future,child,group,future,combined,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,channel,termination,future,complete,exceptionally,throwable,else,channel,termination,future,complete,null,return,channel,termination,future
RestServerEndpoint -> protected CompletableFuture<Void> shutDownInternal();1539934386;Stops this REST server endpoint.__@return Future which is completed once the shut down has been finished.;protected CompletableFuture<Void> shutDownInternal() {__		synchronized (lock) {__			CompletableFuture<?> channelFuture = new CompletableFuture<>()__			if (serverChannel != null) {_				serverChannel.close().addListener(finished -> {_					if (finished.isSuccess()) {_						channelFuture.complete(null)__					} else {_						channelFuture.completeExceptionally(finished.cause())__					}_				})__				serverChannel = null__			}__			final CompletableFuture<Void> channelTerminationFuture = new CompletableFuture<>()___			channelFuture.thenRun(() -> {_				CompletableFuture<?> groupFuture = new CompletableFuture<>()__				CompletableFuture<?> childGroupFuture = new CompletableFuture<>()__				final Time gracePeriod = Time.seconds(10L)___				if (bootstrap != null) {_					final ServerBootstrapConfig config = bootstrap.config()__					final EventLoopGroup group = config.group()__					if (group != null) {_						group.shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									groupFuture.complete(null)__								} else {_									groupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						groupFuture.complete(null)__					}__					final EventLoopGroup childGroup = config.childGroup()__					if (childGroup != null) {_						childGroup.shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									childGroupFuture.complete(null)__								} else {_									childGroupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						childGroupFuture.complete(null)__					}__					bootstrap = null__				} else {_					_					groupFuture.complete(null)__					childGroupFuture.complete(null)__				}__				CompletableFuture<Void> combinedFuture = FutureUtils.completeAll(Arrays.asList(groupFuture, childGroupFuture))___				combinedFuture.whenComplete(_					(Void ignored, Throwable throwable) -> {_						if (throwable != null) {_							channelTerminationFuture.completeExceptionally(throwable)__						} else {_							channelTerminationFuture.complete(null)__						}_					})__			})___			return channelTerminationFuture__		}_	};stops,this,rest,server,endpoint,return,future,which,is,completed,once,the,shut,down,has,been,finished;protected,completable,future,void,shut,down,internal,synchronized,lock,completable,future,channel,future,new,completable,future,if,server,channel,null,server,channel,close,add,listener,finished,if,finished,is,success,channel,future,complete,null,else,channel,future,complete,exceptionally,finished,cause,server,channel,null,final,completable,future,void,channel,termination,future,new,completable,future,channel,future,then,run,completable,future,group,future,new,completable,future,completable,future,child,group,future,new,completable,future,final,time,grace,period,time,seconds,10l,if,bootstrap,null,final,server,bootstrap,config,config,bootstrap,config,final,event,loop,group,group,config,group,if,group,null,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,group,future,complete,null,else,group,future,complete,exceptionally,finished,cause,else,group,future,complete,null,final,event,loop,group,child,group,config,child,group,if,child,group,null,child,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,child,group,future,complete,null,else,child,group,future,complete,exceptionally,finished,cause,else,child,group,future,complete,null,bootstrap,null,else,group,future,complete,null,child,group,future,complete,null,completable,future,void,combined,future,future,utils,complete,all,arrays,as,list,group,future,child,group,future,combined,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,channel,termination,future,complete,exceptionally,throwable,else,channel,termination,future,complete,null,return,channel,termination,future
RestServerEndpoint -> protected CompletableFuture<Void> shutDownInternal();1540215410;Stops this REST server endpoint.__@return Future which is completed once the shut down has been finished.;protected CompletableFuture<Void> shutDownInternal() {__		synchronized (lock) {__			CompletableFuture<?> channelFuture = new CompletableFuture<>()__			if (serverChannel != null) {_				serverChannel.close().addListener(finished -> {_					if (finished.isSuccess()) {_						channelFuture.complete(null)__					} else {_						channelFuture.completeExceptionally(finished.cause())__					}_				})__				serverChannel = null__			}__			final CompletableFuture<Void> channelTerminationFuture = new CompletableFuture<>()___			channelFuture.thenRun(() -> {_				CompletableFuture<?> groupFuture = new CompletableFuture<>()__				CompletableFuture<?> childGroupFuture = new CompletableFuture<>()__				final Time gracePeriod = Time.seconds(10L)___				if (bootstrap != null) {_					final ServerBootstrapConfig config = bootstrap.config()__					final EventLoopGroup group = config.group()__					if (group != null) {_						group.shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									groupFuture.complete(null)__								} else {_									groupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						groupFuture.complete(null)__					}__					final EventLoopGroup childGroup = config.childGroup()__					if (childGroup != null) {_						childGroup.shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									childGroupFuture.complete(null)__								} else {_									childGroupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						childGroupFuture.complete(null)__					}__					bootstrap = null__				} else {_					_					groupFuture.complete(null)__					childGroupFuture.complete(null)__				}__				CompletableFuture<Void> combinedFuture = FutureUtils.completeAll(Arrays.asList(groupFuture, childGroupFuture))___				combinedFuture.whenComplete(_					(Void ignored, Throwable throwable) -> {_						if (throwable != null) {_							channelTerminationFuture.completeExceptionally(throwable)__						} else {_							channelTerminationFuture.complete(null)__						}_					})__			})___			return channelTerminationFuture__		}_	};stops,this,rest,server,endpoint,return,future,which,is,completed,once,the,shut,down,has,been,finished;protected,completable,future,void,shut,down,internal,synchronized,lock,completable,future,channel,future,new,completable,future,if,server,channel,null,server,channel,close,add,listener,finished,if,finished,is,success,channel,future,complete,null,else,channel,future,complete,exceptionally,finished,cause,server,channel,null,final,completable,future,void,channel,termination,future,new,completable,future,channel,future,then,run,completable,future,group,future,new,completable,future,completable,future,child,group,future,new,completable,future,final,time,grace,period,time,seconds,10l,if,bootstrap,null,final,server,bootstrap,config,config,bootstrap,config,final,event,loop,group,group,config,group,if,group,null,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,group,future,complete,null,else,group,future,complete,exceptionally,finished,cause,else,group,future,complete,null,final,event,loop,group,child,group,config,child,group,if,child,group,null,child,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,child,group,future,complete,null,else,child,group,future,complete,exceptionally,finished,cause,else,child,group,future,complete,null,bootstrap,null,else,group,future,complete,null,child,group,future,complete,null,completable,future,void,combined,future,future,utils,complete,all,arrays,as,list,group,future,child,group,future,combined,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,channel,termination,future,complete,exceptionally,throwable,else,channel,termination,future,complete,null,return,channel,termination,future
RestServerEndpoint -> protected CompletableFuture<Void> shutDownInternal();1545326469;Stops this REST server endpoint.__@return Future which is completed once the shut down has been finished.;protected CompletableFuture<Void> shutDownInternal() {__		synchronized (lock) {__			CompletableFuture<?> channelFuture = new CompletableFuture<>()__			if (serverChannel != null) {_				serverChannel.close().addListener(finished -> {_					if (finished.isSuccess()) {_						channelFuture.complete(null)__					} else {_						channelFuture.completeExceptionally(finished.cause())__					}_				})__				serverChannel = null__			}__			final CompletableFuture<Void> channelTerminationFuture = new CompletableFuture<>()___			channelFuture.thenRun(() -> {_				CompletableFuture<?> groupFuture = new CompletableFuture<>()__				CompletableFuture<?> childGroupFuture = new CompletableFuture<>()__				final Time gracePeriod = Time.seconds(10L)___				if (bootstrap != null) {_					final ServerBootstrapConfig config = bootstrap.config()__					final EventLoopGroup group = config.group()__					if (group != null) {_						group.shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									groupFuture.complete(null)__								} else {_									groupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						groupFuture.complete(null)__					}__					final EventLoopGroup childGroup = config.childGroup()__					if (childGroup != null) {_						childGroup.shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									childGroupFuture.complete(null)__								} else {_									childGroupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						childGroupFuture.complete(null)__					}__					bootstrap = null__				} else {_					_					groupFuture.complete(null)__					childGroupFuture.complete(null)__				}__				CompletableFuture<Void> combinedFuture = FutureUtils.completeAll(Arrays.asList(groupFuture, childGroupFuture))___				combinedFuture.whenComplete(_					(Void ignored, Throwable throwable) -> {_						if (throwable != null) {_							channelTerminationFuture.completeExceptionally(throwable)__						} else {_							channelTerminationFuture.complete(null)__						}_					})__			})___			return channelTerminationFuture__		}_	};stops,this,rest,server,endpoint,return,future,which,is,completed,once,the,shut,down,has,been,finished;protected,completable,future,void,shut,down,internal,synchronized,lock,completable,future,channel,future,new,completable,future,if,server,channel,null,server,channel,close,add,listener,finished,if,finished,is,success,channel,future,complete,null,else,channel,future,complete,exceptionally,finished,cause,server,channel,null,final,completable,future,void,channel,termination,future,new,completable,future,channel,future,then,run,completable,future,group,future,new,completable,future,completable,future,child,group,future,new,completable,future,final,time,grace,period,time,seconds,10l,if,bootstrap,null,final,server,bootstrap,config,config,bootstrap,config,final,event,loop,group,group,config,group,if,group,null,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,group,future,complete,null,else,group,future,complete,exceptionally,finished,cause,else,group,future,complete,null,final,event,loop,group,child,group,config,child,group,if,child,group,null,child,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,child,group,future,complete,null,else,child,group,future,complete,exceptionally,finished,cause,else,child,group,future,complete,null,bootstrap,null,else,group,future,complete,null,child,group,future,complete,null,completable,future,void,combined,future,future,utils,complete,all,arrays,as,list,group,future,child,group,future,combined,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,channel,termination,future,complete,exceptionally,throwable,else,channel,termination,future,complete,null,return,channel,termination,future
RestServerEndpoint -> protected CompletableFuture<Void> shutDownInternal();1550222817;Stops this REST server endpoint.__@return Future which is completed once the shut down has been finished.;protected CompletableFuture<Void> shutDownInternal() {__		synchronized (lock) {__			CompletableFuture<?> channelFuture = new CompletableFuture<>()__			if (serverChannel != null) {_				serverChannel.close().addListener(finished -> {_					if (finished.isSuccess()) {_						channelFuture.complete(null)__					} else {_						channelFuture.completeExceptionally(finished.cause())__					}_				})__				serverChannel = null__			}__			final CompletableFuture<Void> channelTerminationFuture = new CompletableFuture<>()___			channelFuture.thenRun(() -> {_				CompletableFuture<?> groupFuture = new CompletableFuture<>()__				CompletableFuture<?> childGroupFuture = new CompletableFuture<>()__				final Time gracePeriod = Time.seconds(10L)___				if (bootstrap != null) {_					final ServerBootstrapConfig config = bootstrap.config()__					final EventLoopGroup group = config.group()__					if (group != null) {_						group.shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									groupFuture.complete(null)__								} else {_									groupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						groupFuture.complete(null)__					}__					final EventLoopGroup childGroup = config.childGroup()__					if (childGroup != null) {_						childGroup.shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									childGroupFuture.complete(null)__								} else {_									childGroupFuture.completeExceptionally(finished.cause())__								}_							})__					} else {_						childGroupFuture.complete(null)__					}__					bootstrap = null__				} else {_					_					groupFuture.complete(null)__					childGroupFuture.complete(null)__				}__				CompletableFuture<Void> combinedFuture = FutureUtils.completeAll(Arrays.asList(groupFuture, childGroupFuture))___				combinedFuture.whenComplete(_					(Void ignored, Throwable throwable) -> {_						if (throwable != null) {_							channelTerminationFuture.completeExceptionally(throwable)__						} else {_							channelTerminationFuture.complete(null)__						}_					})__			})___			return channelTerminationFuture__		}_	};stops,this,rest,server,endpoint,return,future,which,is,completed,once,the,shut,down,has,been,finished;protected,completable,future,void,shut,down,internal,synchronized,lock,completable,future,channel,future,new,completable,future,if,server,channel,null,server,channel,close,add,listener,finished,if,finished,is,success,channel,future,complete,null,else,channel,future,complete,exceptionally,finished,cause,server,channel,null,final,completable,future,void,channel,termination,future,new,completable,future,channel,future,then,run,completable,future,group,future,new,completable,future,completable,future,child,group,future,new,completable,future,final,time,grace,period,time,seconds,10l,if,bootstrap,null,final,server,bootstrap,config,config,bootstrap,config,final,event,loop,group,group,config,group,if,group,null,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,group,future,complete,null,else,group,future,complete,exceptionally,finished,cause,else,group,future,complete,null,final,event,loop,group,child,group,config,child,group,if,child,group,null,child,group,shutdown,gracefully,0l,grace,period,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,child,group,future,complete,null,else,child,group,future,complete,exceptionally,finished,cause,else,child,group,future,complete,null,bootstrap,null,else,group,future,complete,null,child,group,future,complete,null,completable,future,void,combined,future,future,utils,complete,all,arrays,as,list,group,future,child,group,future,combined,future,when,complete,void,ignored,throwable,throwable,if,throwable,null,channel,termination,future,complete,exceptionally,throwable,else,channel,termination,future,complete,null,return,channel,termination,future
RestServerEndpoint -> public InetSocketAddress getServerAddress();1503738659;Returns the address on which this endpoint is accepting requests.__@return address on which this endpoint is accepting requests;public InetSocketAddress getServerAddress() {_		Channel server = this.serverChannel__		if (server != null) {_			try {_				return ((InetSocketAddress) server.localAddress())__			} catch (Exception e) {_				log.error("Cannot access local server address", e)__			}_		}__		return null__	};returns,the,address,on,which,this,endpoint,is,accepting,requests,return,address,on,which,this,endpoint,is,accepting,requests;public,inet,socket,address,get,server,address,channel,server,this,server,channel,if,server,null,try,return,inet,socket,address,server,local,address,catch,exception,e,log,error,cannot,access,local,server,address,e,return,null
RestServerEndpoint -> public InetSocketAddress getServerAddress();1503738660;Returns the address on which this endpoint is accepting requests.__@return address on which this endpoint is accepting requests;public InetSocketAddress getServerAddress() {_		Channel server = this.serverChannel__		if (server != null) {_			try {_				return ((InetSocketAddress) server.localAddress())__			} catch (Exception e) {_				log.error("Cannot access local server address", e)__			}_		}__		return null__	};returns,the,address,on,which,this,endpoint,is,accepting,requests,return,address,on,which,this,endpoint,is,accepting,requests;public,inet,socket,address,get,server,address,channel,server,this,server,channel,if,server,null,try,return,inet,socket,address,server,local,address,catch,exception,e,log,error,cannot,access,local,server,address,e,return,null
RestServerEndpoint -> public InetSocketAddress getServerAddress();1505812012;Returns the address on which this endpoint is accepting requests.__@return address on which this endpoint is accepting requests;public InetSocketAddress getServerAddress() {_		Channel server = this.serverChannel__		if (server != null) {_			try {_				return ((InetSocketAddress) server.localAddress())__			} catch (Exception e) {_				log.error("Cannot access local server address", e)__			}_		}__		return null__	};returns,the,address,on,which,this,endpoint,is,accepting,requests,return,address,on,which,this,endpoint,is,accepting,requests;public,inet,socket,address,get,server,address,channel,server,this,server,channel,if,server,null,try,return,inet,socket,address,server,local,address,catch,exception,e,log,error,cannot,access,local,server,address,e,return,null
RestServerEndpoint -> public InetSocketAddress getServerAddress();1505859747;Returns the address on which this endpoint is accepting requests.__@return address on which this endpoint is accepting requests;public InetSocketAddress getServerAddress() {_		Channel server = this.serverChannel__		if (server != null) {_			try {_				return ((InetSocketAddress) server.localAddress())__			} catch (Exception e) {_				log.error("Cannot access local server address", e)__			}_		}__		return null__	};returns,the,address,on,which,this,endpoint,is,accepting,requests,return,address,on,which,this,endpoint,is,accepting,requests;public,inet,socket,address,get,server,address,channel,server,this,server,channel,if,server,null,try,return,inet,socket,address,server,local,address,catch,exception,e,log,error,cannot,access,local,server,address,e,return,null
RestServerEndpoint -> public InetSocketAddress getServerAddress();1505860453;Returns the address on which this endpoint is accepting requests.__@return address on which this endpoint is accepting requests;public InetSocketAddress getServerAddress() {_		Preconditions.checkState(started, "The RestServerEndpoint has not been started yet.")__		Channel server = this.serverChannel___		if (server != null) {_			try {_				return ((InetSocketAddress) server.localAddress())__			} catch (Exception e) {_				log.error("Cannot access local server address", e)__			}_		}__		return null__	};returns,the,address,on,which,this,endpoint,is,accepting,requests,return,address,on,which,this,endpoint,is,accepting,requests;public,inet,socket,address,get,server,address,preconditions,check,state,started,the,rest,server,endpoint,has,not,been,started,yet,channel,server,this,server,channel,if,server,null,try,return,inet,socket,address,server,local,address,catch,exception,e,log,error,cannot,access,local,server,address,e,return,null
RestServerEndpoint -> public InetSocketAddress getServerAddress();1505860691;Returns the address on which this endpoint is accepting requests.__@return address on which this endpoint is accepting requests;public InetSocketAddress getServerAddress() {_		Preconditions.checkState(started, "The RestServerEndpoint has not been started yet.")__		Channel server = this.serverChannel___		if (server != null) {_			try {_				return ((InetSocketAddress) server.localAddress())__			} catch (Exception e) {_				log.error("Cannot access local server address", e)__			}_		}__		return null__	};returns,the,address,on,which,this,endpoint,is,accepting,requests,return,address,on,which,this,endpoint,is,accepting,requests;public,inet,socket,address,get,server,address,preconditions,check,state,started,the,rest,server,endpoint,has,not,been,started,yet,channel,server,this,server,channel,if,server,null,try,return,inet,socket,address,server,local,address,catch,exception,e,log,error,cannot,access,local,server,address,e,return,null
RestServerEndpoint -> public InetSocketAddress getServerAddress();1505896530;Returns the address on which this endpoint is accepting requests.__@return address on which this endpoint is accepting requests;public InetSocketAddress getServerAddress() {_		Preconditions.checkState(started, "The RestServerEndpoint has not been started yet.")__		Channel server = this.serverChannel___		if (server != null) {_			try {_				return ((InetSocketAddress) server.localAddress())__			} catch (Exception e) {_				log.error("Cannot access local server address", e)__			}_		}__		return null__	};returns,the,address,on,which,this,endpoint,is,accepting,requests,return,address,on,which,this,endpoint,is,accepting,requests;public,inet,socket,address,get,server,address,preconditions,check,state,started,the,rest,server,endpoint,has,not,been,started,yet,channel,server,this,server,channel,if,server,null,try,return,inet,socket,address,server,local,address,catch,exception,e,log,error,cannot,access,local,server,address,e,return,null
RestServerEndpoint -> public InetSocketAddress getServerAddress();1506553599;Returns the address on which this endpoint is accepting requests.__@return address on which this endpoint is accepting requests;public InetSocketAddress getServerAddress() {_		Preconditions.checkState(started, "The RestServerEndpoint has not been started yet.")__		Channel server = this.serverChannel___		if (server != null) {_			try {_				return ((InetSocketAddress) server.localAddress())__			} catch (Exception e) {_				log.error("Cannot access local server address", e)__			}_		}__		return null__	};returns,the,address,on,which,this,endpoint,is,accepting,requests,return,address,on,which,this,endpoint,is,accepting,requests;public,inet,socket,address,get,server,address,preconditions,check,state,started,the,rest,server,endpoint,has,not,been,started,yet,channel,server,this,server,channel,if,server,null,try,return,inet,socket,address,server,local,address,catch,exception,e,log,error,cannot,access,local,server,address,e,return,null
RestServerEndpoint -> public InetSocketAddress getServerAddress();1507569104;Returns the address on which this endpoint is accepting requests.__@return address on which this endpoint is accepting requests;public InetSocketAddress getServerAddress() {_		Preconditions.checkState(started, "The RestServerEndpoint has not been started yet.")__		Channel server = this.serverChannel___		if (server != null) {_			try {_				return ((InetSocketAddress) server.localAddress())__			} catch (Exception e) {_				log.error("Cannot access local server address", e)__			}_		}__		return null__	};returns,the,address,on,which,this,endpoint,is,accepting,requests,return,address,on,which,this,endpoint,is,accepting,requests;public,inet,socket,address,get,server,address,preconditions,check,state,started,the,rest,server,endpoint,has,not,been,started,yet,channel,server,this,server,channel,if,server,null,try,return,inet,socket,address,server,local,address,catch,exception,e,log,error,cannot,access,local,server,address,e,return,null
RestServerEndpoint -> public InetSocketAddress getServerAddress();1510220918;Returns the address on which this endpoint is accepting requests.__@return address on which this endpoint is accepting requests;public InetSocketAddress getServerAddress() {_		Preconditions.checkState(started, "The RestServerEndpoint has not been started yet.")__		Channel server = this.serverChannel___		if (server != null) {_			try {_				return ((InetSocketAddress) server.localAddress())__			} catch (Exception e) {_				log.error("Cannot access local server address", e)__			}_		}__		return null__	};returns,the,address,on,which,this,endpoint,is,accepting,requests,return,address,on,which,this,endpoint,is,accepting,requests;public,inet,socket,address,get,server,address,preconditions,check,state,started,the,rest,server,endpoint,has,not,been,started,yet,channel,server,this,server,channel,if,server,null,try,return,inet,socket,address,server,local,address,catch,exception,e,log,error,cannot,access,local,server,address,e,return,null
RestServerEndpoint -> public InetSocketAddress getServerAddress();1512650422;Returns the address on which this endpoint is accepting requests.__@return address on which this endpoint is accepting requests;public InetSocketAddress getServerAddress() {_		Preconditions.checkState(started, "The RestServerEndpoint has not been started yet.")__		Channel server = this.serverChannel___		if (server != null) {_			try {_				return ((InetSocketAddress) server.localAddress())__			} catch (Exception e) {_				log.error("Cannot access local server address", e)__			}_		}__		return null__	};returns,the,address,on,which,this,endpoint,is,accepting,requests,return,address,on,which,this,endpoint,is,accepting,requests;public,inet,socket,address,get,server,address,preconditions,check,state,started,the,rest,server,endpoint,has,not,been,started,yet,channel,server,this,server,channel,if,server,null,try,return,inet,socket,address,server,local,address,catch,exception,e,log,error,cannot,access,local,server,address,e,return,null
RestServerEndpoint -> public InetSocketAddress getServerAddress();1516098457;Returns the address on which this endpoint is accepting requests.__@return address on which this endpoint is accepting requests;public InetSocketAddress getServerAddress() {_		Preconditions.checkState(started, "The RestServerEndpoint has not been started yet.")__		Channel server = this.serverChannel___		if (server != null) {_			try {_				return ((InetSocketAddress) server.localAddress())__			} catch (Exception e) {_				log.error("Cannot access local server address", e)__			}_		}__		return null__	};returns,the,address,on,which,this,endpoint,is,accepting,requests,return,address,on,which,this,endpoint,is,accepting,requests;public,inet,socket,address,get,server,address,preconditions,check,state,started,the,rest,server,endpoint,has,not,been,started,yet,channel,server,this,server,channel,if,server,null,try,return,inet,socket,address,server,local,address,catch,exception,e,log,error,cannot,access,local,server,address,e,return,null
RestServerEndpoint -> public InetSocketAddress getServerAddress();1516971023;Returns the address on which this endpoint is accepting requests.__@return address on which this endpoint is accepting requests;public InetSocketAddress getServerAddress() {_		Preconditions.checkState(started, "The RestServerEndpoint has not been started yet.")__		Channel server = this.serverChannel___		if (server != null) {_			try {_				return ((InetSocketAddress) server.localAddress())__			} catch (Exception e) {_				log.error("Cannot access local server address", e)__			}_		}__		return null__	};returns,the,address,on,which,this,endpoint,is,accepting,requests,return,address,on,which,this,endpoint,is,accepting,requests;public,inet,socket,address,get,server,address,preconditions,check,state,started,the,rest,server,endpoint,has,not,been,started,yet,channel,server,this,server,channel,if,server,null,try,return,inet,socket,address,server,local,address,catch,exception,e,log,error,cannot,access,local,server,address,e,return,null
RestServerEndpoint -> public InetSocketAddress getServerAddress();1516971023;Returns the address on which this endpoint is accepting requests.__@return address on which this endpoint is accepting requests;public InetSocketAddress getServerAddress() {_		Preconditions.checkState(started, "The RestServerEndpoint has not been started yet.")__		Channel server = this.serverChannel___		if (server != null) {_			try {_				return ((InetSocketAddress) server.localAddress())__			} catch (Exception e) {_				log.error("Cannot access local server address", e)__			}_		}__		return null__	};returns,the,address,on,which,this,endpoint,is,accepting,requests,return,address,on,which,this,endpoint,is,accepting,requests;public,inet,socket,address,get,server,address,preconditions,check,state,started,the,rest,server,endpoint,has,not,been,started,yet,channel,server,this,server,channel,if,server,null,try,return,inet,socket,address,server,local,address,catch,exception,e,log,error,cannot,access,local,server,address,e,return,null
RestServerEndpoint -> public InetSocketAddress getServerAddress();1518680660;Returns the address on which this endpoint is accepting requests.__@return address on which this endpoint is accepting requests;public InetSocketAddress getServerAddress() {_		Preconditions.checkState(started, "The RestServerEndpoint has not been started yet.")__		Channel server = this.serverChannel___		if (server != null) {_			try {_				return ((InetSocketAddress) server.localAddress())__			} catch (Exception e) {_				log.error("Cannot access local server address", e)__			}_		}__		return null__	};returns,the,address,on,which,this,endpoint,is,accepting,requests,return,address,on,which,this,endpoint,is,accepting,requests;public,inet,socket,address,get,server,address,preconditions,check,state,started,the,rest,server,endpoint,has,not,been,started,yet,channel,server,this,server,channel,if,server,null,try,return,inet,socket,address,server,local,address,catch,exception,e,log,error,cannot,access,local,server,address,e,return,null
RestServerEndpoint -> public InetSocketAddress getServerAddress();1518945174;Returns the address on which this endpoint is accepting requests.__@return address on which this endpoint is accepting requests;public InetSocketAddress getServerAddress() {_		Preconditions.checkState(started, "The RestServerEndpoint has not been started yet.")__		Channel server = this.serverChannel___		if (server != null) {_			try {_				return ((InetSocketAddress) server.localAddress())__			} catch (Exception e) {_				log.error("Cannot access local server address", e)__			}_		}__		return null__	};returns,the,address,on,which,this,endpoint,is,accepting,requests,return,address,on,which,this,endpoint,is,accepting,requests;public,inet,socket,address,get,server,address,preconditions,check,state,started,the,rest,server,endpoint,has,not,been,started,yet,channel,server,this,server,channel,if,server,null,try,return,inet,socket,address,server,local,address,catch,exception,e,log,error,cannot,access,local,server,address,e,return,null
RestServerEndpoint -> public void start() throws Exception;1505896530;Starts this REST server endpoint.__@throws Exception if we cannot start the RestServerEndpoint;public void start() throws Exception {_		synchronized (lock) {_			if (started) {_				_				return__			}__			log.info("Starting rest endpoint.")___			final Router router = new Router()__			final CompletableFuture<String> restAddressFuture = new CompletableFuture<>()___			initializeHandlers(restAddressFuture).forEach(handler -> registerHandler(router, handler))___			ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {__				@Override_				protected void initChannel(SocketChannel ch) {_					Handler handler = new RouterHandler(router)___					_					if (sslEngine != null) {_						ch.pipeline().addLast("ssl", new SslHandler(sslEngine))__					}__					ch.pipeline()_						.addLast(new HttpServerCodec())_						.addLast(new HttpObjectAggregator(1024 * 1024 * 10))_						.addLast(handler.name(), handler)_						.addLast(new PipelineErrorHandler(log))__				}_			}___			NioEventLoopGroup bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory("flink-rest-server-netty-boss"))__			NioEventLoopGroup workerGroup = new NioEventLoopGroup(0, new DefaultThreadFactory("flink-rest-server-netty-worker"))___			bootstrap = new ServerBootstrap()__			bootstrap_				.group(bossGroup, workerGroup)_				.channel(NioServerSocketChannel.class)_				.childHandler(initializer)___			final ChannelFuture channel__			if (configuredAddress == null) {_				channel = bootstrap.bind(configuredPort)__			} else {_				channel = bootstrap.bind(configuredAddress, configuredPort)__			}_			serverChannel = channel.syncUninterruptibly().channel()___			InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress()__			String address = bindAddress.getAddress().getHostAddress()__			int port = bindAddress.getPort()___			log.info("Rest endpoint listening at {}" + ':' + "{}", address, port)___			final String protocol___			if (sslEngine != null) {_				protocol = "https://"__			} else {_				protocol = "http://"__			}__			restAddress = protocol + address + ':' + port___			restAddressFuture.complete(restAddress)___			started = true__		}_	};starts,this,rest,server,endpoint,throws,exception,if,we,cannot,start,the,rest,server,endpoint;public,void,start,throws,exception,synchronized,lock,if,started,return,log,info,starting,rest,endpoint,final,router,router,new,router,final,completable,future,string,rest,address,future,new,completable,future,initialize,handlers,rest,address,future,for,each,handler,register,handler,router,handler,channel,initializer,socket,channel,initializer,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,ch,handler,handler,new,router,handler,router,if,ssl,engine,null,ch,pipeline,add,last,ssl,new,ssl,handler,ssl,engine,ch,pipeline,add,last,new,http,server,codec,add,last,new,http,object,aggregator,1024,1024,10,add,last,handler,name,handler,add,last,new,pipeline,error,handler,log,nio,event,loop,group,boss,group,new,nio,event,loop,group,1,new,default,thread,factory,flink,rest,server,netty,boss,nio,event,loop,group,worker,group,new,nio,event,loop,group,0,new,default,thread,factory,flink,rest,server,netty,worker,bootstrap,new,server,bootstrap,bootstrap,group,boss,group,worker,group,channel,nio,server,socket,channel,class,child,handler,initializer,final,channel,future,channel,if,configured,address,null,channel,bootstrap,bind,configured,port,else,channel,bootstrap,bind,configured,address,configured,port,server,channel,channel,sync,uninterruptibly,channel,inet,socket,address,bind,address,inet,socket,address,server,channel,local,address,string,address,bind,address,get,address,get,host,address,int,port,bind,address,get,port,log,info,rest,endpoint,listening,at,address,port,final,string,protocol,if,ssl,engine,null,protocol,https,else,protocol,http,rest,address,protocol,address,port,rest,address,future,complete,rest,address,started,true
RestServerEndpoint -> public void start() throws Exception;1506553599;Starts this REST server endpoint.__@throws Exception if we cannot start the RestServerEndpoint;public void start() throws Exception {_		synchronized (lock) {_			if (started) {_				_				return__			}__			log.info("Starting rest endpoint.")___			final Router router = new Router()__			final CompletableFuture<String> restAddressFuture = new CompletableFuture<>()___			initializeHandlers(restAddressFuture).forEach(handler -> registerHandler(router, handler))___			ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {__				@Override_				protected void initChannel(SocketChannel ch) {_					Handler handler = new RouterHandler(router)___					_					if (sslEngine != null) {_						ch.pipeline().addLast("ssl", new SslHandler(sslEngine))__					}__					ch.pipeline()_						.addLast(new HttpServerCodec())_						.addLast(new HttpObjectAggregator(1024 * 1024 * 10))_						.addLast(handler.name(), handler)_						.addLast(new PipelineErrorHandler(log))__				}_			}___			NioEventLoopGroup bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory("flink-rest-server-netty-boss"))__			NioEventLoopGroup workerGroup = new NioEventLoopGroup(0, new DefaultThreadFactory("flink-rest-server-netty-worker"))___			bootstrap = new ServerBootstrap()__			bootstrap_				.group(bossGroup, workerGroup)_				.channel(NioServerSocketChannel.class)_				.childHandler(initializer)___			final ChannelFuture channel__			if (configuredAddress == null) {_				channel = bootstrap.bind(configuredPort)__			} else {_				channel = bootstrap.bind(configuredAddress, configuredPort)__			}_			serverChannel = channel.syncUninterruptibly().channel()___			InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress()__			String address = bindAddress.getAddress().getHostAddress()__			int port = bindAddress.getPort()___			log.info("Rest endpoint listening at {}" + ':' + "{}", address, port)___			final String protocol___			if (sslEngine != null) {_				protocol = "https://"__			} else {_				protocol = "http://"__			}__			restAddress = protocol + address + ':' + port___			restAddressFuture.complete(restAddress)___			started = true__		}_	};starts,this,rest,server,endpoint,throws,exception,if,we,cannot,start,the,rest,server,endpoint;public,void,start,throws,exception,synchronized,lock,if,started,return,log,info,starting,rest,endpoint,final,router,router,new,router,final,completable,future,string,rest,address,future,new,completable,future,initialize,handlers,rest,address,future,for,each,handler,register,handler,router,handler,channel,initializer,socket,channel,initializer,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,ch,handler,handler,new,router,handler,router,if,ssl,engine,null,ch,pipeline,add,last,ssl,new,ssl,handler,ssl,engine,ch,pipeline,add,last,new,http,server,codec,add,last,new,http,object,aggregator,1024,1024,10,add,last,handler,name,handler,add,last,new,pipeline,error,handler,log,nio,event,loop,group,boss,group,new,nio,event,loop,group,1,new,default,thread,factory,flink,rest,server,netty,boss,nio,event,loop,group,worker,group,new,nio,event,loop,group,0,new,default,thread,factory,flink,rest,server,netty,worker,bootstrap,new,server,bootstrap,bootstrap,group,boss,group,worker,group,channel,nio,server,socket,channel,class,child,handler,initializer,final,channel,future,channel,if,configured,address,null,channel,bootstrap,bind,configured,port,else,channel,bootstrap,bind,configured,address,configured,port,server,channel,channel,sync,uninterruptibly,channel,inet,socket,address,bind,address,inet,socket,address,server,channel,local,address,string,address,bind,address,get,address,get,host,address,int,port,bind,address,get,port,log,info,rest,endpoint,listening,at,address,port,final,string,protocol,if,ssl,engine,null,protocol,https,else,protocol,http,rest,address,protocol,address,port,rest,address,future,complete,rest,address,started,true
RestServerEndpoint -> public void start() throws Exception;1507569104;Starts this REST server endpoint.__@throws Exception if we cannot start the RestServerEndpoint;public void start() throws Exception {_		synchronized (lock) {_			if (started) {_				_				return__			}__			log.info("Starting rest endpoint.")___			final Router router = new Router()__			final CompletableFuture<String> restAddressFuture = new CompletableFuture<>()___			initializeHandlers(restAddressFuture).forEach(handler -> registerHandler(router, handler))___			ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {__				@Override_				protected void initChannel(SocketChannel ch) {_					Handler handler = new RouterHandler(router)___					_					if (sslEngine != null) {_						ch.pipeline().addLast("ssl", new SslHandler(sslEngine))__					}__					ch.pipeline()_						.addLast(new HttpServerCodec())_						.addLast(new HttpObjectAggregator(MAX_REQUEST_SIZE_BYTES))_						.addLast(handler.name(), handler)_						.addLast(new PipelineErrorHandler(log))__				}_			}___			NioEventLoopGroup bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory("flink-rest-server-netty-boss"))__			NioEventLoopGroup workerGroup = new NioEventLoopGroup(0, new DefaultThreadFactory("flink-rest-server-netty-worker"))___			bootstrap = new ServerBootstrap()__			bootstrap_				.group(bossGroup, workerGroup)_				.channel(NioServerSocketChannel.class)_				.childHandler(initializer)___			final ChannelFuture channel__			if (configuredAddress == null) {_				channel = bootstrap.bind(configuredPort)__			} else {_				channel = bootstrap.bind(configuredAddress, configuredPort)__			}_			serverChannel = channel.syncUninterruptibly().channel()___			InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress()__			String address = bindAddress.getAddress().getHostAddress()__			int port = bindAddress.getPort()___			log.info("Rest endpoint listening at {}" + ':' + "{}", address, port)___			final String protocol___			if (sslEngine != null) {_				protocol = "https://"__			} else {_				protocol = "http://"__			}__			restAddress = protocol + address + ':' + port___			restAddressFuture.complete(restAddress)___			started = true__		}_	};starts,this,rest,server,endpoint,throws,exception,if,we,cannot,start,the,rest,server,endpoint;public,void,start,throws,exception,synchronized,lock,if,started,return,log,info,starting,rest,endpoint,final,router,router,new,router,final,completable,future,string,rest,address,future,new,completable,future,initialize,handlers,rest,address,future,for,each,handler,register,handler,router,handler,channel,initializer,socket,channel,initializer,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,ch,handler,handler,new,router,handler,router,if,ssl,engine,null,ch,pipeline,add,last,ssl,new,ssl,handler,ssl,engine,ch,pipeline,add,last,new,http,server,codec,add,last,new,http,object,aggregator,add,last,handler,name,handler,add,last,new,pipeline,error,handler,log,nio,event,loop,group,boss,group,new,nio,event,loop,group,1,new,default,thread,factory,flink,rest,server,netty,boss,nio,event,loop,group,worker,group,new,nio,event,loop,group,0,new,default,thread,factory,flink,rest,server,netty,worker,bootstrap,new,server,bootstrap,bootstrap,group,boss,group,worker,group,channel,nio,server,socket,channel,class,child,handler,initializer,final,channel,future,channel,if,configured,address,null,channel,bootstrap,bind,configured,port,else,channel,bootstrap,bind,configured,address,configured,port,server,channel,channel,sync,uninterruptibly,channel,inet,socket,address,bind,address,inet,socket,address,server,channel,local,address,string,address,bind,address,get,address,get,host,address,int,port,bind,address,get,port,log,info,rest,endpoint,listening,at,address,port,final,string,protocol,if,ssl,engine,null,protocol,https,else,protocol,http,rest,address,protocol,address,port,rest,address,future,complete,rest,address,started,true
RestServerEndpoint -> public void start() throws Exception;1510220918;Starts this REST server endpoint.__@throws Exception if we cannot start the RestServerEndpoint;public void start() throws Exception {_		synchronized (lock) {_			if (started) {_				_				return__			}__			log.info("Starting rest endpoint.")___			final Router router = new Router()__			final CompletableFuture<String> restAddressFuture = new CompletableFuture<>()___			List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = initializeHandlers(restAddressFuture)___			_			Collections.sort(_				handlers,_				RestHandlerUrlComparator.INSTANCE)___			handlers.forEach(handler -> {_				log.debug("Register handler {} under {}@{}.", handler.f1, handler.f0.getHttpMethod(), handler.f0.getTargetRestEndpointURL())__				registerHandler(router, handler)__			})___			ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {__				@Override_				protected void initChannel(SocketChannel ch) {_					Handler handler = new RouterHandler(router)___					_					if (sslEngine != null) {_						ch.pipeline().addLast("ssl", new SslHandler(sslEngine))__					}__					ch.pipeline()_						.addLast(new HttpServerCodec())_						.addLast(new HttpObjectAggregator(MAX_REQUEST_SIZE_BYTES))_						.addLast(handler.name(), handler)_						.addLast(new PipelineErrorHandler(log))__				}_			}___			NioEventLoopGroup bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory("flink-rest-server-netty-boss"))__			NioEventLoopGroup workerGroup = new NioEventLoopGroup(0, new DefaultThreadFactory("flink-rest-server-netty-worker"))___			bootstrap = new ServerBootstrap()__			bootstrap_				.group(bossGroup, workerGroup)_				.channel(NioServerSocketChannel.class)_				.childHandler(initializer)___			final ChannelFuture channel__			if (configuredAddress == null) {_				channel = bootstrap.bind(configuredPort)__			} else {_				channel = bootstrap.bind(configuredAddress, configuredPort)__			}_			serverChannel = channel.syncUninterruptibly().channel()___			InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress()__			String address = bindAddress.getAddress().getHostAddress()__			int port = bindAddress.getPort()___			log.info("Rest endpoint listening at {}" + ':' + "{}", address, port)___			final String protocol___			if (sslEngine != null) {_				protocol = "https://"__			} else {_				protocol = "http://"__			}__			restAddress = protocol + address + ':' + port___			restAddressFuture.complete(restAddress)___			started = true__		}_	};starts,this,rest,server,endpoint,throws,exception,if,we,cannot,start,the,rest,server,endpoint;public,void,start,throws,exception,synchronized,lock,if,started,return,log,info,starting,rest,endpoint,final,router,router,new,router,final,completable,future,string,rest,address,future,new,completable,future,list,tuple2,rest,handler,specification,channel,inbound,handler,handlers,initialize,handlers,rest,address,future,collections,sort,handlers,rest,handler,url,comparator,instance,handlers,for,each,handler,log,debug,register,handler,under,handler,f1,handler,f0,get,http,method,handler,f0,get,target,rest,endpoint,url,register,handler,router,handler,channel,initializer,socket,channel,initializer,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,ch,handler,handler,new,router,handler,router,if,ssl,engine,null,ch,pipeline,add,last,ssl,new,ssl,handler,ssl,engine,ch,pipeline,add,last,new,http,server,codec,add,last,new,http,object,aggregator,add,last,handler,name,handler,add,last,new,pipeline,error,handler,log,nio,event,loop,group,boss,group,new,nio,event,loop,group,1,new,default,thread,factory,flink,rest,server,netty,boss,nio,event,loop,group,worker,group,new,nio,event,loop,group,0,new,default,thread,factory,flink,rest,server,netty,worker,bootstrap,new,server,bootstrap,bootstrap,group,boss,group,worker,group,channel,nio,server,socket,channel,class,child,handler,initializer,final,channel,future,channel,if,configured,address,null,channel,bootstrap,bind,configured,port,else,channel,bootstrap,bind,configured,address,configured,port,server,channel,channel,sync,uninterruptibly,channel,inet,socket,address,bind,address,inet,socket,address,server,channel,local,address,string,address,bind,address,get,address,get,host,address,int,port,bind,address,get,port,log,info,rest,endpoint,listening,at,address,port,final,string,protocol,if,ssl,engine,null,protocol,https,else,protocol,http,rest,address,protocol,address,port,rest,address,future,complete,rest,address,started,true
RestServerEndpoint -> public void start() throws Exception;1512650422;Starts this REST server endpoint.__@throws Exception if we cannot start the RestServerEndpoint;public void start() throws Exception {_		synchronized (lock) {_			if (started) {_				_				return__			}__			log.info("Starting rest endpoint.")___			final Router router = new Router()__			final CompletableFuture<String> restAddressFuture = new CompletableFuture<>()___			List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = initializeHandlers(restAddressFuture)___			_			Collections.sort(_				handlers,_				RestHandlerUrlComparator.INSTANCE)___			handlers.forEach(handler -> {_				log.debug("Register handler {} under {}@{}.", handler.f1, handler.f0.getHttpMethod(), handler.f0.getTargetRestEndpointURL())__				registerHandler(router, handler)__			})___			ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {__				@Override_				protected void initChannel(SocketChannel ch) {_					Handler handler = new RouterHandler(router)___					_					if (sslEngine != null) {_						ch.pipeline().addLast("ssl", new SslHandler(sslEngine))__					}__					ch.pipeline()_						.addLast(new HttpServerCodec())_						.addLast(new HttpObjectAggregator(MAX_REQUEST_SIZE_BYTES))_						.addLast(handler.name(), handler)_						.addLast(new PipelineErrorHandler(log))__				}_			}___			NioEventLoopGroup bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory("flink-rest-server-netty-boss"))__			NioEventLoopGroup workerGroup = new NioEventLoopGroup(0, new DefaultThreadFactory("flink-rest-server-netty-worker"))___			bootstrap = new ServerBootstrap()__			bootstrap_				.group(bossGroup, workerGroup)_				.channel(NioServerSocketChannel.class)_				.childHandler(initializer)___			final ChannelFuture channel__			if (configuredAddress == null) {_				channel = bootstrap.bind(configuredPort)__			} else {_				channel = bootstrap.bind(configuredAddress, configuredPort)__			}_			serverChannel = channel.syncUninterruptibly().channel()___			InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress()__			String address = bindAddress.getAddress().getHostAddress()__			int port = bindAddress.getPort()___			log.info("Rest endpoint listening at {}" + ':' + "{}", address, port)___			final String protocol___			if (sslEngine != null) {_				protocol = "https://"__			} else {_				protocol = "http://"__			}__			restAddress = protocol + address + ':' + port___			restAddressFuture.complete(restAddress)___			started = true__		}_	};starts,this,rest,server,endpoint,throws,exception,if,we,cannot,start,the,rest,server,endpoint;public,void,start,throws,exception,synchronized,lock,if,started,return,log,info,starting,rest,endpoint,final,router,router,new,router,final,completable,future,string,rest,address,future,new,completable,future,list,tuple2,rest,handler,specification,channel,inbound,handler,handlers,initialize,handlers,rest,address,future,collections,sort,handlers,rest,handler,url,comparator,instance,handlers,for,each,handler,log,debug,register,handler,under,handler,f1,handler,f0,get,http,method,handler,f0,get,target,rest,endpoint,url,register,handler,router,handler,channel,initializer,socket,channel,initializer,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,ch,handler,handler,new,router,handler,router,if,ssl,engine,null,ch,pipeline,add,last,ssl,new,ssl,handler,ssl,engine,ch,pipeline,add,last,new,http,server,codec,add,last,new,http,object,aggregator,add,last,handler,name,handler,add,last,new,pipeline,error,handler,log,nio,event,loop,group,boss,group,new,nio,event,loop,group,1,new,default,thread,factory,flink,rest,server,netty,boss,nio,event,loop,group,worker,group,new,nio,event,loop,group,0,new,default,thread,factory,flink,rest,server,netty,worker,bootstrap,new,server,bootstrap,bootstrap,group,boss,group,worker,group,channel,nio,server,socket,channel,class,child,handler,initializer,final,channel,future,channel,if,configured,address,null,channel,bootstrap,bind,configured,port,else,channel,bootstrap,bind,configured,address,configured,port,server,channel,channel,sync,uninterruptibly,channel,inet,socket,address,bind,address,inet,socket,address,server,channel,local,address,string,address,bind,address,get,address,get,host,address,int,port,bind,address,get,port,log,info,rest,endpoint,listening,at,address,port,final,string,protocol,if,ssl,engine,null,protocol,https,else,protocol,http,rest,address,protocol,address,port,rest,address,future,complete,rest,address,started,true
RestServerEndpoint -> public void start() throws Exception;1516098457;Starts this REST server endpoint.__@throws Exception if we cannot start the RestServerEndpoint;public void start() throws Exception {_		synchronized (lock) {_			if (started) {_				_				return__			}__			log.info("Starting rest endpoint.")___			final Router router = new Router()__			final CompletableFuture<String> restAddressFuture = new CompletableFuture<>()___			List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = initializeHandlers(restAddressFuture)___			_			Collections.sort(_				handlers,_				RestHandlerUrlComparator.INSTANCE)___			handlers.forEach(handler -> {_				log.debug("Register handler {} under {}@{}.", handler.f1, handler.f0.getHttpMethod(), handler.f0.getTargetRestEndpointURL())__				registerHandler(router, handler)__			})___			ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {__				@Override_				protected void initChannel(SocketChannel ch) {_					Handler handler = new RouterHandler(router)___					_					if (sslEngine != null) {_						ch.pipeline().addLast("ssl", new SslHandler(sslEngine))__					}__					ch.pipeline()_						.addLast(new HttpServerCodec())_						.addLast(new HttpObjectAggregator(MAX_REQUEST_SIZE_BYTES))_						.addLast(handler.name(), handler)_						.addLast(new PipelineErrorHandler(log))__				}_			}___			NioEventLoopGroup bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory("flink-rest-server-netty-boss"))__			NioEventLoopGroup workerGroup = new NioEventLoopGroup(0, new DefaultThreadFactory("flink-rest-server-netty-worker"))___			bootstrap = new ServerBootstrap()__			bootstrap_				.group(bossGroup, workerGroup)_				.channel(NioServerSocketChannel.class)_				.childHandler(initializer)___			final ChannelFuture channel__			if (configuredAddress == null) {_				channel = bootstrap.bind(configuredPort)__			} else {_				channel = bootstrap.bind(configuredAddress, configuredPort)__			}_			serverChannel = channel.syncUninterruptibly().channel()___			InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress()__			String address = bindAddress.getAddress().getHostAddress()__			int port = bindAddress.getPort()___			log.info("Rest endpoint listening at {}" + ':' + "{}", address, port)___			final String protocol___			if (sslEngine != null) {_				protocol = "https://"__			} else {_				protocol = "http://"__			}__			restAddress = protocol + address + ':' + port___			restAddressFuture.complete(restAddress)___			started = true__		}_	};starts,this,rest,server,endpoint,throws,exception,if,we,cannot,start,the,rest,server,endpoint;public,void,start,throws,exception,synchronized,lock,if,started,return,log,info,starting,rest,endpoint,final,router,router,new,router,final,completable,future,string,rest,address,future,new,completable,future,list,tuple2,rest,handler,specification,channel,inbound,handler,handlers,initialize,handlers,rest,address,future,collections,sort,handlers,rest,handler,url,comparator,instance,handlers,for,each,handler,log,debug,register,handler,under,handler,f1,handler,f0,get,http,method,handler,f0,get,target,rest,endpoint,url,register,handler,router,handler,channel,initializer,socket,channel,initializer,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,ch,handler,handler,new,router,handler,router,if,ssl,engine,null,ch,pipeline,add,last,ssl,new,ssl,handler,ssl,engine,ch,pipeline,add,last,new,http,server,codec,add,last,new,http,object,aggregator,add,last,handler,name,handler,add,last,new,pipeline,error,handler,log,nio,event,loop,group,boss,group,new,nio,event,loop,group,1,new,default,thread,factory,flink,rest,server,netty,boss,nio,event,loop,group,worker,group,new,nio,event,loop,group,0,new,default,thread,factory,flink,rest,server,netty,worker,bootstrap,new,server,bootstrap,bootstrap,group,boss,group,worker,group,channel,nio,server,socket,channel,class,child,handler,initializer,final,channel,future,channel,if,configured,address,null,channel,bootstrap,bind,configured,port,else,channel,bootstrap,bind,configured,address,configured,port,server,channel,channel,sync,uninterruptibly,channel,inet,socket,address,bind,address,inet,socket,address,server,channel,local,address,string,address,bind,address,get,address,get,host,address,int,port,bind,address,get,port,log,info,rest,endpoint,listening,at,address,port,final,string,protocol,if,ssl,engine,null,protocol,https,else,protocol,http,rest,address,protocol,address,port,rest,address,future,complete,rest,address,started,true
RestServerEndpoint -> public void start() throws Exception;1516971023;Starts this REST server endpoint.__@throws Exception if we cannot start the RestServerEndpoint;public void start() throws Exception {_		synchronized (lock) {_			if (started) {_				_				return__			}__			log.info("Starting rest endpoint.")___			final Router router = new Router()__			final CompletableFuture<String> restAddressFuture = new CompletableFuture<>()___			List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = initializeHandlers(restAddressFuture)___			_			Collections.sort(_				handlers,_				RestHandlerUrlComparator.INSTANCE)___			handlers.forEach(handler -> {_				log.debug("Register handler {} under {}@{}.", handler.f1, handler.f0.getHttpMethod(), handler.f0.getTargetRestEndpointURL())__				registerHandler(router, handler)__			})___			ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {__				@Override_				protected void initChannel(SocketChannel ch) {_					Handler handler = new RouterHandler(router)___					_					if (sslEngine != null) {_						ch.pipeline().addLast("ssl", new SslHandler(sslEngine))__					}__					ch.pipeline()_						.addLast(new HttpServerCodec())_						.addLast(new HttpObjectAggregator(MAX_REQUEST_SIZE_BYTES))_						.addLast(handler.name(), handler)_						.addLast(new PipelineErrorHandler(log))__				}_			}___			NioEventLoopGroup bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory("flink-rest-server-netty-boss"))__			NioEventLoopGroup workerGroup = new NioEventLoopGroup(0, new DefaultThreadFactory("flink-rest-server-netty-worker"))___			bootstrap = new ServerBootstrap()__			bootstrap_				.group(bossGroup, workerGroup)_				.channel(NioServerSocketChannel.class)_				.childHandler(initializer)___			final ChannelFuture channel__			if (configuredAddress == null) {_				channel = bootstrap.bind(configuredPort)__			} else {_				channel = bootstrap.bind(configuredAddress, configuredPort)__			}_			serverChannel = channel.syncUninterruptibly().channel()___			InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress()__			String address = bindAddress.getAddress().getHostAddress()__			int port = bindAddress.getPort()___			log.info("Rest endpoint listening at {}:{}", address, port)___			final String protocol___			if (sslEngine != null) {_				protocol = "https://"__			} else {_				protocol = "http://"__			}__			restAddress = protocol + address + ':' + port___			restAddressFuture.complete(restAddress)___			started = true__		}_	};starts,this,rest,server,endpoint,throws,exception,if,we,cannot,start,the,rest,server,endpoint;public,void,start,throws,exception,synchronized,lock,if,started,return,log,info,starting,rest,endpoint,final,router,router,new,router,final,completable,future,string,rest,address,future,new,completable,future,list,tuple2,rest,handler,specification,channel,inbound,handler,handlers,initialize,handlers,rest,address,future,collections,sort,handlers,rest,handler,url,comparator,instance,handlers,for,each,handler,log,debug,register,handler,under,handler,f1,handler,f0,get,http,method,handler,f0,get,target,rest,endpoint,url,register,handler,router,handler,channel,initializer,socket,channel,initializer,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,ch,handler,handler,new,router,handler,router,if,ssl,engine,null,ch,pipeline,add,last,ssl,new,ssl,handler,ssl,engine,ch,pipeline,add,last,new,http,server,codec,add,last,new,http,object,aggregator,add,last,handler,name,handler,add,last,new,pipeline,error,handler,log,nio,event,loop,group,boss,group,new,nio,event,loop,group,1,new,default,thread,factory,flink,rest,server,netty,boss,nio,event,loop,group,worker,group,new,nio,event,loop,group,0,new,default,thread,factory,flink,rest,server,netty,worker,bootstrap,new,server,bootstrap,bootstrap,group,boss,group,worker,group,channel,nio,server,socket,channel,class,child,handler,initializer,final,channel,future,channel,if,configured,address,null,channel,bootstrap,bind,configured,port,else,channel,bootstrap,bind,configured,address,configured,port,server,channel,channel,sync,uninterruptibly,channel,inet,socket,address,bind,address,inet,socket,address,server,channel,local,address,string,address,bind,address,get,address,get,host,address,int,port,bind,address,get,port,log,info,rest,endpoint,listening,at,address,port,final,string,protocol,if,ssl,engine,null,protocol,https,else,protocol,http,rest,address,protocol,address,port,rest,address,future,complete,rest,address,started,true
RestServerEndpoint -> public void start() throws Exception;1516971023;Starts this REST server endpoint.__@throws Exception if we cannot start the RestServerEndpoint;public void start() throws Exception {_		synchronized (lock) {_			if (started) {_				_				return__			}__			log.info("Starting rest endpoint.")___			final Router router = new Router()__			final CompletableFuture<String> restAddressFuture = new CompletableFuture<>()___			List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = initializeHandlers(restAddressFuture)___			_			Collections.sort(_				handlers,_				RestHandlerUrlComparator.INSTANCE)___			handlers.forEach(handler -> {_				log.debug("Register handler {} under {}@{}.", handler.f1, handler.f0.getHttpMethod(), handler.f0.getTargetRestEndpointURL())__				registerHandler(router, handler)__			})___			ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {__				@Override_				protected void initChannel(SocketChannel ch) {_					Handler handler = new RouterHandler(router)___					_					if (sslEngine != null) {_						ch.pipeline().addLast("ssl", new SslHandler(sslEngine))__					}__					ch.pipeline()_						.addLast(new HttpServerCodec())_						.addLast(new HttpObjectAggregator(MAX_REQUEST_SIZE_BYTES))_						.addLast(handler.name(), handler)_						.addLast(new PipelineErrorHandler(log))__				}_			}___			NioEventLoopGroup bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory("flink-rest-server-netty-boss"))__			NioEventLoopGroup workerGroup = new NioEventLoopGroup(0, new DefaultThreadFactory("flink-rest-server-netty-worker"))___			bootstrap = new ServerBootstrap()__			bootstrap_				.group(bossGroup, workerGroup)_				.channel(NioServerSocketChannel.class)_				.childHandler(initializer)___			final ChannelFuture channel__			if (configuredAddress == null) {_				channel = bootstrap.bind(configuredPort)__			} else {_				channel = bootstrap.bind(configuredAddress, configuredPort)__			}_			serverChannel = channel.syncUninterruptibly().channel()___			InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress()__			String address = bindAddress.getAddress().getHostAddress()__			int port = bindAddress.getPort()___			log.info("Rest endpoint listening at {}:{}", address, port)___			final String protocol___			if (sslEngine != null) {_				protocol = "https://"__			} else {_				protocol = "http://"__			}__			restAddress = protocol + address + ':' + port___			restAddressFuture.complete(restAddress)___			started = true__		}_	};starts,this,rest,server,endpoint,throws,exception,if,we,cannot,start,the,rest,server,endpoint;public,void,start,throws,exception,synchronized,lock,if,started,return,log,info,starting,rest,endpoint,final,router,router,new,router,final,completable,future,string,rest,address,future,new,completable,future,list,tuple2,rest,handler,specification,channel,inbound,handler,handlers,initialize,handlers,rest,address,future,collections,sort,handlers,rest,handler,url,comparator,instance,handlers,for,each,handler,log,debug,register,handler,under,handler,f1,handler,f0,get,http,method,handler,f0,get,target,rest,endpoint,url,register,handler,router,handler,channel,initializer,socket,channel,initializer,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,ch,handler,handler,new,router,handler,router,if,ssl,engine,null,ch,pipeline,add,last,ssl,new,ssl,handler,ssl,engine,ch,pipeline,add,last,new,http,server,codec,add,last,new,http,object,aggregator,add,last,handler,name,handler,add,last,new,pipeline,error,handler,log,nio,event,loop,group,boss,group,new,nio,event,loop,group,1,new,default,thread,factory,flink,rest,server,netty,boss,nio,event,loop,group,worker,group,new,nio,event,loop,group,0,new,default,thread,factory,flink,rest,server,netty,worker,bootstrap,new,server,bootstrap,bootstrap,group,boss,group,worker,group,channel,nio,server,socket,channel,class,child,handler,initializer,final,channel,future,channel,if,configured,address,null,channel,bootstrap,bind,configured,port,else,channel,bootstrap,bind,configured,address,configured,port,server,channel,channel,sync,uninterruptibly,channel,inet,socket,address,bind,address,inet,socket,address,server,channel,local,address,string,address,bind,address,get,address,get,host,address,int,port,bind,address,get,port,log,info,rest,endpoint,listening,at,address,port,final,string,protocol,if,ssl,engine,null,protocol,https,else,protocol,http,rest,address,protocol,address,port,rest,address,future,complete,rest,address,started,true
RestServerEndpoint -> public void start() throws Exception;1518680660;Starts this REST server endpoint.__@throws Exception if we cannot start the RestServerEndpoint;public void start() throws Exception {_		synchronized (lock) {_			if (started) {_				_				return__			}__			log.info("Starting rest endpoint.")___			final Router router = new Router()__			final CompletableFuture<String> restAddressFuture = new CompletableFuture<>()___			List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = initializeHandlers(restAddressFuture)___			_			Collections.sort(_				handlers,_				RestHandlerUrlComparator.INSTANCE)___			handlers.forEach(handler -> {_				log.debug("Register handler {} under {}@{}.", handler.f1, handler.f0.getHttpMethod(), handler.f0.getTargetRestEndpointURL())__				registerHandler(router, handler)__			})___			ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {__				@Override_				protected void initChannel(SocketChannel ch) throws IOException {_					Handler handler = new RouterHandler(router)___					_					if (sslEngine != null) {_						ch.pipeline().addLast("ssl", new SslHandler(sslEngine))__					}__					ch.pipeline()_						.addLast(new HttpServerCodec())_						.addLast(new FileUploadHandler(uploadDir))_						.addLast(new HttpObjectAggregator(MAX_REQUEST_SIZE_BYTES))_						.addLast(handler.name(), handler)_						.addLast(new PipelineErrorHandler(log))__				}_			}___			NioEventLoopGroup bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory("flink-rest-server-netty-boss"))__			NioEventLoopGroup workerGroup = new NioEventLoopGroup(0, new DefaultThreadFactory("flink-rest-server-netty-worker"))___			bootstrap = new ServerBootstrap()__			bootstrap_				.group(bossGroup, workerGroup)_				.channel(NioServerSocketChannel.class)_				.childHandler(initializer)___			final ChannelFuture channel__			if (configuredAddress == null) {_				channel = bootstrap.bind(configuredPort)__			} else {_				channel = bootstrap.bind(configuredAddress, configuredPort)__			}_			serverChannel = channel.syncUninterruptibly().channel()___			InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress()__			String address = bindAddress.getAddress().getHostAddress()__			int port = bindAddress.getPort()___			log.info("Rest endpoint listening at {}:{}", address, port)___			final String protocol___			if (sslEngine != null) {_				protocol = "https://"__			} else {_				protocol = "http://"__			}__			restAddress = protocol + address + ':' + port___			restAddressFuture.complete(restAddress)___			started = true__		}_	};starts,this,rest,server,endpoint,throws,exception,if,we,cannot,start,the,rest,server,endpoint;public,void,start,throws,exception,synchronized,lock,if,started,return,log,info,starting,rest,endpoint,final,router,router,new,router,final,completable,future,string,rest,address,future,new,completable,future,list,tuple2,rest,handler,specification,channel,inbound,handler,handlers,initialize,handlers,rest,address,future,collections,sort,handlers,rest,handler,url,comparator,instance,handlers,for,each,handler,log,debug,register,handler,under,handler,f1,handler,f0,get,http,method,handler,f0,get,target,rest,endpoint,url,register,handler,router,handler,channel,initializer,socket,channel,initializer,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,ch,throws,ioexception,handler,handler,new,router,handler,router,if,ssl,engine,null,ch,pipeline,add,last,ssl,new,ssl,handler,ssl,engine,ch,pipeline,add,last,new,http,server,codec,add,last,new,file,upload,handler,upload,dir,add,last,new,http,object,aggregator,add,last,handler,name,handler,add,last,new,pipeline,error,handler,log,nio,event,loop,group,boss,group,new,nio,event,loop,group,1,new,default,thread,factory,flink,rest,server,netty,boss,nio,event,loop,group,worker,group,new,nio,event,loop,group,0,new,default,thread,factory,flink,rest,server,netty,worker,bootstrap,new,server,bootstrap,bootstrap,group,boss,group,worker,group,channel,nio,server,socket,channel,class,child,handler,initializer,final,channel,future,channel,if,configured,address,null,channel,bootstrap,bind,configured,port,else,channel,bootstrap,bind,configured,address,configured,port,server,channel,channel,sync,uninterruptibly,channel,inet,socket,address,bind,address,inet,socket,address,server,channel,local,address,string,address,bind,address,get,address,get,host,address,int,port,bind,address,get,port,log,info,rest,endpoint,listening,at,address,port,final,string,protocol,if,ssl,engine,null,protocol,https,else,protocol,http,rest,address,protocol,address,port,rest,address,future,complete,rest,address,started,true
RestServerEndpoint -> public void start() throws Exception;1518945174;Starts this REST server endpoint.__@throws Exception if we cannot start the RestServerEndpoint;public void start() throws Exception {_		synchronized (lock) {_			if (started) {_				_				return__			}__			log.info("Starting rest endpoint.")___			final Router router = new Router()__			final CompletableFuture<String> restAddressFuture = new CompletableFuture<>()___			List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = initializeHandlers(restAddressFuture)___			_			Collections.sort(_				handlers,_				RestHandlerUrlComparator.INSTANCE)___			handlers.forEach(handler -> {_				log.debug("Register handler {} under {}@{}.", handler.f1, handler.f0.getHttpMethod(), handler.f0.getTargetRestEndpointURL())__				registerHandler(router, handler)__			})___			ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {__				@Override_				protected void initChannel(SocketChannel ch) {_					Handler handler = new RouterHandler(router)___					_					if (sslEngine != null) {_						ch.pipeline().addLast("ssl", new SslHandler(sslEngine))__					}__					ch.pipeline()_						.addLast(new HttpServerCodec())_						.addLast(new FileUploadHandler(uploadDir))_						.addLast(new HttpObjectAggregator(MAX_REQUEST_SIZE_BYTES))_						.addLast(handler.name(), handler)_						.addLast(new PipelineErrorHandler(log))__				}_			}___			NioEventLoopGroup bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory("flink-rest-server-netty-boss"))__			NioEventLoopGroup workerGroup = new NioEventLoopGroup(0, new DefaultThreadFactory("flink-rest-server-netty-worker"))___			bootstrap = new ServerBootstrap()__			bootstrap_				.group(bossGroup, workerGroup)_				.channel(NioServerSocketChannel.class)_				.childHandler(initializer)___			final ChannelFuture channel__			if (configuredAddress == null) {_				channel = bootstrap.bind(configuredPort)__			} else {_				channel = bootstrap.bind(configuredAddress, configuredPort)__			}_			serverChannel = channel.syncUninterruptibly().channel()___			InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress()__			String address = bindAddress.getAddress().getHostAddress()__			int port = bindAddress.getPort()___			log.info("Rest endpoint listening at {}:{}", address, port)___			final String protocol___			if (sslEngine != null) {_				protocol = "https://"__			} else {_				protocol = "http://"__			}__			restAddress = protocol + address + ':' + port___			restAddressFuture.complete(restAddress)___			started = true__		}_	};starts,this,rest,server,endpoint,throws,exception,if,we,cannot,start,the,rest,server,endpoint;public,void,start,throws,exception,synchronized,lock,if,started,return,log,info,starting,rest,endpoint,final,router,router,new,router,final,completable,future,string,rest,address,future,new,completable,future,list,tuple2,rest,handler,specification,channel,inbound,handler,handlers,initialize,handlers,rest,address,future,collections,sort,handlers,rest,handler,url,comparator,instance,handlers,for,each,handler,log,debug,register,handler,under,handler,f1,handler,f0,get,http,method,handler,f0,get,target,rest,endpoint,url,register,handler,router,handler,channel,initializer,socket,channel,initializer,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,ch,handler,handler,new,router,handler,router,if,ssl,engine,null,ch,pipeline,add,last,ssl,new,ssl,handler,ssl,engine,ch,pipeline,add,last,new,http,server,codec,add,last,new,file,upload,handler,upload,dir,add,last,new,http,object,aggregator,add,last,handler,name,handler,add,last,new,pipeline,error,handler,log,nio,event,loop,group,boss,group,new,nio,event,loop,group,1,new,default,thread,factory,flink,rest,server,netty,boss,nio,event,loop,group,worker,group,new,nio,event,loop,group,0,new,default,thread,factory,flink,rest,server,netty,worker,bootstrap,new,server,bootstrap,bootstrap,group,boss,group,worker,group,channel,nio,server,socket,channel,class,child,handler,initializer,final,channel,future,channel,if,configured,address,null,channel,bootstrap,bind,configured,port,else,channel,bootstrap,bind,configured,address,configured,port,server,channel,channel,sync,uninterruptibly,channel,inet,socket,address,bind,address,inet,socket,address,server,channel,local,address,string,address,bind,address,get,address,get,host,address,int,port,bind,address,get,port,log,info,rest,endpoint,listening,at,address,port,final,string,protocol,if,ssl,engine,null,protocol,https,else,protocol,http,rest,address,protocol,address,port,rest,address,future,complete,rest,address,started,true
RestServerEndpoint -> protected abstract Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;1505896530;This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint_implementation requires.__@param restAddressFuture future rest address of the RestServerEndpoint_@return Collection of AbstractRestHandler which are added to the server endpoint;protected abstract Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;this,method,is,called,at,the,beginning,of,link,start,to,setup,all,handlers,that,the,rest,server,endpoint,implementation,requires,param,rest,address,future,future,rest,address,of,the,rest,server,endpoint,return,collection,of,abstract,rest,handler,which,are,added,to,the,server,endpoint;protected,abstract,collection,tuple2,rest,handler,specification,channel,inbound,handler,initialize,handlers,completable,future,string,rest,address,future
RestServerEndpoint -> protected abstract Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;1506553599;This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint_implementation requires.__@param restAddressFuture future rest address of the RestServerEndpoint_@return Collection of AbstractRestHandler which are added to the server endpoint;protected abstract Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;this,method,is,called,at,the,beginning,of,link,start,to,setup,all,handlers,that,the,rest,server,endpoint,implementation,requires,param,rest,address,future,future,rest,address,of,the,rest,server,endpoint,return,collection,of,abstract,rest,handler,which,are,added,to,the,server,endpoint;protected,abstract,collection,tuple2,rest,handler,specification,channel,inbound,handler,initialize,handlers,completable,future,string,rest,address,future
RestServerEndpoint -> protected abstract Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;1507569104;This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint_implementation requires.__@param restAddressFuture future rest address of the RestServerEndpoint_@return Collection of AbstractRestHandler which are added to the server endpoint;protected abstract Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;this,method,is,called,at,the,beginning,of,link,start,to,setup,all,handlers,that,the,rest,server,endpoint,implementation,requires,param,rest,address,future,future,rest,address,of,the,rest,server,endpoint,return,collection,of,abstract,rest,handler,which,are,added,to,the,server,endpoint;protected,abstract,collection,tuple2,rest,handler,specification,channel,inbound,handler,initialize,handlers,completable,future,string,rest,address,future
RestServerEndpoint -> protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(final CompletableFuture<String> localAddressFuture)_;1545326469;This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint_implementation requires.__@param localAddressFuture future rest address of the RestServerEndpoint_@return Collection of AbstractRestHandler which are added to the server endpoint;protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(final CompletableFuture<String> localAddressFuture)_;this,method,is,called,at,the,beginning,of,link,start,to,setup,all,handlers,that,the,rest,server,endpoint,implementation,requires,param,local,address,future,future,rest,address,of,the,rest,server,endpoint,return,collection,of,abstract,rest,handler,which,are,added,to,the,server,endpoint;protected,abstract,list,tuple2,rest,handler,specification,channel,inbound,handler,initialize,handlers,final,completable,future,string,local,address,future
RestServerEndpoint -> protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(final CompletableFuture<String> localAddressFuture)_;1550222817;This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint_implementation requires.__@param localAddressFuture future rest address of the RestServerEndpoint_@return Collection of AbstractRestHandler which are added to the server endpoint;protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(final CompletableFuture<String> localAddressFuture)_;this,method,is,called,at,the,beginning,of,link,start,to,setup,all,handlers,that,the,rest,server,endpoint,implementation,requires,param,local,address,future,future,rest,address,of,the,rest,server,endpoint,return,collection,of,abstract,rest,handler,which,are,added,to,the,server,endpoint;protected,abstract,list,tuple2,rest,handler,specification,channel,inbound,handler,initialize,handlers,final,completable,future,string,local,address,future
RestServerEndpoint -> protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;1510220918;This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint_implementation requires.__@param restAddressFuture future rest address of the RestServerEndpoint_@return Collection of AbstractRestHandler which are added to the server endpoint;protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;this,method,is,called,at,the,beginning,of,link,start,to,setup,all,handlers,that,the,rest,server,endpoint,implementation,requires,param,rest,address,future,future,rest,address,of,the,rest,server,endpoint,return,collection,of,abstract,rest,handler,which,are,added,to,the,server,endpoint;protected,abstract,list,tuple2,rest,handler,specification,channel,inbound,handler,initialize,handlers,completable,future,string,rest,address,future
RestServerEndpoint -> protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;1512650422;This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint_implementation requires.__@param restAddressFuture future rest address of the RestServerEndpoint_@return Collection of AbstractRestHandler which are added to the server endpoint;protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;this,method,is,called,at,the,beginning,of,link,start,to,setup,all,handlers,that,the,rest,server,endpoint,implementation,requires,param,rest,address,future,future,rest,address,of,the,rest,server,endpoint,return,collection,of,abstract,rest,handler,which,are,added,to,the,server,endpoint;protected,abstract,list,tuple2,rest,handler,specification,channel,inbound,handler,initialize,handlers,completable,future,string,rest,address,future
RestServerEndpoint -> protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;1516098457;This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint_implementation requires.__@param restAddressFuture future rest address of the RestServerEndpoint_@return Collection of AbstractRestHandler which are added to the server endpoint;protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;this,method,is,called,at,the,beginning,of,link,start,to,setup,all,handlers,that,the,rest,server,endpoint,implementation,requires,param,rest,address,future,future,rest,address,of,the,rest,server,endpoint,return,collection,of,abstract,rest,handler,which,are,added,to,the,server,endpoint;protected,abstract,list,tuple2,rest,handler,specification,channel,inbound,handler,initialize,handlers,completable,future,string,rest,address,future
RestServerEndpoint -> protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;1516971023;This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint_implementation requires.__@param restAddressFuture future rest address of the RestServerEndpoint_@return Collection of AbstractRestHandler which are added to the server endpoint;protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;this,method,is,called,at,the,beginning,of,link,start,to,setup,all,handlers,that,the,rest,server,endpoint,implementation,requires,param,rest,address,future,future,rest,address,of,the,rest,server,endpoint,return,collection,of,abstract,rest,handler,which,are,added,to,the,server,endpoint;protected,abstract,list,tuple2,rest,handler,specification,channel,inbound,handler,initialize,handlers,completable,future,string,rest,address,future
RestServerEndpoint -> protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;1516971023;This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint_implementation requires.__@param restAddressFuture future rest address of the RestServerEndpoint_@return Collection of AbstractRestHandler which are added to the server endpoint;protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;this,method,is,called,at,the,beginning,of,link,start,to,setup,all,handlers,that,the,rest,server,endpoint,implementation,requires,param,rest,address,future,future,rest,address,of,the,rest,server,endpoint,return,collection,of,abstract,rest,handler,which,are,added,to,the,server,endpoint;protected,abstract,list,tuple2,rest,handler,specification,channel,inbound,handler,initialize,handlers,completable,future,string,rest,address,future
RestServerEndpoint -> protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;1518680660;This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint_implementation requires.__@param restAddressFuture future rest address of the RestServerEndpoint_@return Collection of AbstractRestHandler which are added to the server endpoint;protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;this,method,is,called,at,the,beginning,of,link,start,to,setup,all,handlers,that,the,rest,server,endpoint,implementation,requires,param,rest,address,future,future,rest,address,of,the,rest,server,endpoint,return,collection,of,abstract,rest,handler,which,are,added,to,the,server,endpoint;protected,abstract,list,tuple2,rest,handler,specification,channel,inbound,handler,initialize,handlers,completable,future,string,rest,address,future
RestServerEndpoint -> protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;1518945174;This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint_implementation requires.__@param restAddressFuture future rest address of the RestServerEndpoint_@return Collection of AbstractRestHandler which are added to the server endpoint;protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;this,method,is,called,at,the,beginning,of,link,start,to,setup,all,handlers,that,the,rest,server,endpoint,implementation,requires,param,rest,address,future,future,rest,address,of,the,rest,server,endpoint,return,collection,of,abstract,rest,handler,which,are,added,to,the,server,endpoint;protected,abstract,list,tuple2,rest,handler,specification,channel,inbound,handler,initialize,handlers,completable,future,string,rest,address,future
RestServerEndpoint -> protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;1519052657;This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint_implementation requires.__@param restAddressFuture future rest address of the RestServerEndpoint_@return Collection of AbstractRestHandler which are added to the server endpoint;protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;this,method,is,called,at,the,beginning,of,link,start,to,setup,all,handlers,that,the,rest,server,endpoint,implementation,requires,param,rest,address,future,future,rest,address,of,the,rest,server,endpoint,return,collection,of,abstract,rest,handler,which,are,added,to,the,server,endpoint;protected,abstract,list,tuple2,rest,handler,specification,channel,inbound,handler,initialize,handlers,completable,future,string,rest,address,future
RestServerEndpoint -> protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;1519406530;This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint_implementation requires.__@param restAddressFuture future rest address of the RestServerEndpoint_@return Collection of AbstractRestHandler which are added to the server endpoint;protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;this,method,is,called,at,the,beginning,of,link,start,to,setup,all,handlers,that,the,rest,server,endpoint,implementation,requires,param,rest,address,future,future,rest,address,of,the,rest,server,endpoint,return,collection,of,abstract,rest,handler,which,are,added,to,the,server,endpoint;protected,abstract,list,tuple2,rest,handler,specification,channel,inbound,handler,initialize,handlers,completable,future,string,rest,address,future
RestServerEndpoint -> protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;1521016670;This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint_implementation requires.__@param restAddressFuture future rest address of the RestServerEndpoint_@return Collection of AbstractRestHandler which are added to the server endpoint;protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;this,method,is,called,at,the,beginning,of,link,start,to,setup,all,handlers,that,the,rest,server,endpoint,implementation,requires,param,rest,address,future,future,rest,address,of,the,rest,server,endpoint,return,collection,of,abstract,rest,handler,which,are,added,to,the,server,endpoint;protected,abstract,list,tuple2,rest,handler,specification,channel,inbound,handler,initialize,handlers,completable,future,string,rest,address,future
RestServerEndpoint -> protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;1521016671;This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint_implementation requires.__@param restAddressFuture future rest address of the RestServerEndpoint_@return Collection of AbstractRestHandler which are added to the server endpoint;protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;this,method,is,called,at,the,beginning,of,link,start,to,setup,all,handlers,that,the,rest,server,endpoint,implementation,requires,param,rest,address,future,future,rest,address,of,the,rest,server,endpoint,return,collection,of,abstract,rest,handler,which,are,added,to,the,server,endpoint;protected,abstract,list,tuple2,rest,handler,specification,channel,inbound,handler,initialize,handlers,completable,future,string,rest,address,future
RestServerEndpoint -> protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;1521016671;This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint_implementation requires.__@param restAddressFuture future rest address of the RestServerEndpoint_@return Collection of AbstractRestHandler which are added to the server endpoint;protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;this,method,is,called,at,the,beginning,of,link,start,to,setup,all,handlers,that,the,rest,server,endpoint,implementation,requires,param,rest,address,future,future,rest,address,of,the,rest,server,endpoint,return,collection,of,abstract,rest,handler,which,are,added,to,the,server,endpoint;protected,abstract,list,tuple2,rest,handler,specification,channel,inbound,handler,initialize,handlers,completable,future,string,rest,address,future
RestServerEndpoint -> protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;1521385094;This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint_implementation requires.__@param restAddressFuture future rest address of the RestServerEndpoint_@return Collection of AbstractRestHandler which are added to the server endpoint;protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;this,method,is,called,at,the,beginning,of,link,start,to,setup,all,handlers,that,the,rest,server,endpoint,implementation,requires,param,rest,address,future,future,rest,address,of,the,rest,server,endpoint,return,collection,of,abstract,rest,handler,which,are,added,to,the,server,endpoint;protected,abstract,list,tuple2,rest,handler,specification,channel,inbound,handler,initialize,handlers,completable,future,string,rest,address,future
RestServerEndpoint -> protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;1521804758;This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint_implementation requires.__@param restAddressFuture future rest address of the RestServerEndpoint_@return Collection of AbstractRestHandler which are added to the server endpoint;protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;this,method,is,called,at,the,beginning,of,link,start,to,setup,all,handlers,that,the,rest,server,endpoint,implementation,requires,param,rest,address,future,future,rest,address,of,the,rest,server,endpoint,return,collection,of,abstract,rest,handler,which,are,added,to,the,server,endpoint;protected,abstract,list,tuple2,rest,handler,specification,channel,inbound,handler,initialize,handlers,completable,future,string,rest,address,future
RestServerEndpoint -> protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;1521804758;This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint_implementation requires.__@param restAddressFuture future rest address of the RestServerEndpoint_@return Collection of AbstractRestHandler which are added to the server endpoint;protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;this,method,is,called,at,the,beginning,of,link,start,to,setup,all,handlers,that,the,rest,server,endpoint,implementation,requires,param,rest,address,future,future,rest,address,of,the,rest,server,endpoint,return,collection,of,abstract,rest,handler,which,are,added,to,the,server,endpoint;protected,abstract,list,tuple2,rest,handler,specification,channel,inbound,handler,initialize,handlers,completable,future,string,rest,address,future
RestServerEndpoint -> protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;1525904579;This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint_implementation requires.__@param restAddressFuture future rest address of the RestServerEndpoint_@return Collection of AbstractRestHandler which are added to the server endpoint;protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;this,method,is,called,at,the,beginning,of,link,start,to,setup,all,handlers,that,the,rest,server,endpoint,implementation,requires,param,rest,address,future,future,rest,address,of,the,rest,server,endpoint,return,collection,of,abstract,rest,handler,which,are,added,to,the,server,endpoint;protected,abstract,list,tuple2,rest,handler,specification,channel,inbound,handler,initialize,handlers,completable,future,string,rest,address,future
RestServerEndpoint -> protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;1527499265;This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint_implementation requires.__@param restAddressFuture future rest address of the RestServerEndpoint_@return Collection of AbstractRestHandler which are added to the server endpoint;protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;this,method,is,called,at,the,beginning,of,link,start,to,setup,all,handlers,that,the,rest,server,endpoint,implementation,requires,param,rest,address,future,future,rest,address,of,the,rest,server,endpoint,return,collection,of,abstract,rest,handler,which,are,added,to,the,server,endpoint;protected,abstract,list,tuple2,rest,handler,specification,channel,inbound,handler,initialize,handlers,completable,future,string,rest,address,future
RestServerEndpoint -> protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;1528876304;This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint_implementation requires.__@param restAddressFuture future rest address of the RestServerEndpoint_@return Collection of AbstractRestHandler which are added to the server endpoint;protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;this,method,is,called,at,the,beginning,of,link,start,to,setup,all,handlers,that,the,rest,server,endpoint,implementation,requires,param,rest,address,future,future,rest,address,of,the,rest,server,endpoint,return,collection,of,abstract,rest,handler,which,are,added,to,the,server,endpoint;protected,abstract,list,tuple2,rest,handler,specification,channel,inbound,handler,initialize,handlers,completable,future,string,rest,address,future
RestServerEndpoint -> protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;1534259541;This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint_implementation requires.__@param restAddressFuture future rest address of the RestServerEndpoint_@return Collection of AbstractRestHandler which are added to the server endpoint;protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;this,method,is,called,at,the,beginning,of,link,start,to,setup,all,handlers,that,the,rest,server,endpoint,implementation,requires,param,rest,address,future,future,rest,address,of,the,rest,server,endpoint,return,collection,of,abstract,rest,handler,which,are,added,to,the,server,endpoint;protected,abstract,list,tuple2,rest,handler,specification,channel,inbound,handler,initialize,handlers,completable,future,string,rest,address,future
RestServerEndpoint -> protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;1535963626;This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint_implementation requires.__@param restAddressFuture future rest address of the RestServerEndpoint_@return Collection of AbstractRestHandler which are added to the server endpoint;protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;this,method,is,called,at,the,beginning,of,link,start,to,setup,all,handlers,that,the,rest,server,endpoint,implementation,requires,param,rest,address,future,future,rest,address,of,the,rest,server,endpoint,return,collection,of,abstract,rest,handler,which,are,added,to,the,server,endpoint;protected,abstract,list,tuple2,rest,handler,specification,channel,inbound,handler,initialize,handlers,completable,future,string,rest,address,future
RestServerEndpoint -> protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;1536930104;This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint_implementation requires.__@param restAddressFuture future rest address of the RestServerEndpoint_@return Collection of AbstractRestHandler which are added to the server endpoint;protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;this,method,is,called,at,the,beginning,of,link,start,to,setup,all,handlers,that,the,rest,server,endpoint,implementation,requires,param,rest,address,future,future,rest,address,of,the,rest,server,endpoint,return,collection,of,abstract,rest,handler,which,are,added,to,the,server,endpoint;protected,abstract,list,tuple2,rest,handler,specification,channel,inbound,handler,initialize,handlers,completable,future,string,rest,address,future
RestServerEndpoint -> protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;1539170288;This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint_implementation requires.__@param restAddressFuture future rest address of the RestServerEndpoint_@return Collection of AbstractRestHandler which are added to the server endpoint;protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;this,method,is,called,at,the,beginning,of,link,start,to,setup,all,handlers,that,the,rest,server,endpoint,implementation,requires,param,rest,address,future,future,rest,address,of,the,rest,server,endpoint,return,collection,of,abstract,rest,handler,which,are,added,to,the,server,endpoint;protected,abstract,list,tuple2,rest,handler,specification,channel,inbound,handler,initialize,handlers,completable,future,string,rest,address,future
RestServerEndpoint -> protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;1539934386;This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint_implementation requires.__@param restAddressFuture future rest address of the RestServerEndpoint_@return Collection of AbstractRestHandler which are added to the server endpoint;protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;this,method,is,called,at,the,beginning,of,link,start,to,setup,all,handlers,that,the,rest,server,endpoint,implementation,requires,param,rest,address,future,future,rest,address,of,the,rest,server,endpoint,return,collection,of,abstract,rest,handler,which,are,added,to,the,server,endpoint;protected,abstract,list,tuple2,rest,handler,specification,channel,inbound,handler,initialize,handlers,completable,future,string,rest,address,future
RestServerEndpoint -> protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;1540215410;This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint_implementation requires.__@param restAddressFuture future rest address of the RestServerEndpoint_@return Collection of AbstractRestHandler which are added to the server endpoint;protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture)_;this,method,is,called,at,the,beginning,of,link,start,to,setup,all,handlers,that,the,rest,server,endpoint,implementation,requires,param,rest,address,future,future,rest,address,of,the,rest,server,endpoint,return,collection,of,abstract,rest,handler,which,are,added,to,the,server,endpoint;protected,abstract,list,tuple2,rest,handler,specification,channel,inbound,handler,initialize,handlers,completable,future,string,rest,address,future
RestServerEndpoint -> public void shutdown(Time timeout);1503738660;Stops this REST server endpoint.;public void shutdown(Time timeout) {_		log.info("Shutting down rest endpoint.")___		CompletableFuture<?> channelFuture = new CompletableFuture<>()__		if (this.serverChannel != null) {_			this.serverChannel.close().addListener(ignored -> channelFuture.complete(null))__		}_		CompletableFuture<?> groupFuture = new CompletableFuture<>()__		CompletableFuture<?> childGroupFuture = new CompletableFuture<>()___		channelFuture.thenRun(() -> {_			if (bootstrap != null) {_				if (bootstrap.group() != null) {_					bootstrap.group().shutdownGracefully(0, timeout.toMilliseconds(), TimeUnit.MILLISECONDS)_						.addListener(ignored -> groupFuture.complete(null))__				}_				if (bootstrap.childGroup() != null) {_					bootstrap.childGroup().shutdownGracefully(0, timeout.toMilliseconds(), TimeUnit.MILLISECONDS)_						.addListener(ignored -> childGroupFuture.complete(null))__				}_			} else {_				_				groupFuture.complete(null)__				childGroupFuture.complete(null)__			}_		})___		try {_			CompletableFuture.allOf(groupFuture, childGroupFuture).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__			log.info("Rest endpoint shutdown complete.")__		} catch (Exception e) {_			log.warn("Rest endpoint shutdown failed.", e)__		}_	};stops,this,rest,server,endpoint;public,void,shutdown,time,timeout,log,info,shutting,down,rest,endpoint,completable,future,channel,future,new,completable,future,if,this,server,channel,null,this,server,channel,close,add,listener,ignored,channel,future,complete,null,completable,future,group,future,new,completable,future,completable,future,child,group,future,new,completable,future,channel,future,then,run,if,bootstrap,null,if,bootstrap,group,null,bootstrap,group,shutdown,gracefully,0,timeout,to,milliseconds,time,unit,milliseconds,add,listener,ignored,group,future,complete,null,if,bootstrap,child,group,null,bootstrap,child,group,shutdown,gracefully,0,timeout,to,milliseconds,time,unit,milliseconds,add,listener,ignored,child,group,future,complete,null,else,group,future,complete,null,child,group,future,complete,null,try,completable,future,all,of,group,future,child,group,future,get,timeout,to,milliseconds,time,unit,milliseconds,log,info,rest,endpoint,shutdown,complete,catch,exception,e,log,warn,rest,endpoint,shutdown,failed,e
RestServerEndpoint -> public void shutdown(Time timeout);1505812012;Stops this REST server endpoint.;public void shutdown(Time timeout) {_		log.info("Shutting down rest endpoint.")___		CompletableFuture<?> channelFuture = new CompletableFuture<>()__		if (this.serverChannel != null) {_			this.serverChannel.close().addListener(ignored -> channelFuture.complete(null))__		}_		CompletableFuture<?> groupFuture = new CompletableFuture<>()__		CompletableFuture<?> childGroupFuture = new CompletableFuture<>()___		channelFuture.thenRun(() -> {_			if (bootstrap != null) {_				if (bootstrap.group() != null) {_					bootstrap.group().shutdownGracefully(0, timeout.toMilliseconds(), TimeUnit.MILLISECONDS)_						.addListener(ignored -> groupFuture.complete(null))__				}_				if (bootstrap.childGroup() != null) {_					bootstrap.childGroup().shutdownGracefully(0, timeout.toMilliseconds(), TimeUnit.MILLISECONDS)_						.addListener(ignored -> childGroupFuture.complete(null))__				}_			} else {_				_				groupFuture.complete(null)__				childGroupFuture.complete(null)__			}_		})___		try {_			CompletableFuture.allOf(groupFuture, childGroupFuture).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__			log.info("Rest endpoint shutdown complete.")__		} catch (Exception e) {_			log.warn("Rest endpoint shutdown failed.", e)__		}_	};stops,this,rest,server,endpoint;public,void,shutdown,time,timeout,log,info,shutting,down,rest,endpoint,completable,future,channel,future,new,completable,future,if,this,server,channel,null,this,server,channel,close,add,listener,ignored,channel,future,complete,null,completable,future,group,future,new,completable,future,completable,future,child,group,future,new,completable,future,channel,future,then,run,if,bootstrap,null,if,bootstrap,group,null,bootstrap,group,shutdown,gracefully,0,timeout,to,milliseconds,time,unit,milliseconds,add,listener,ignored,group,future,complete,null,if,bootstrap,child,group,null,bootstrap,child,group,shutdown,gracefully,0,timeout,to,milliseconds,time,unit,milliseconds,add,listener,ignored,child,group,future,complete,null,else,group,future,complete,null,child,group,future,complete,null,try,completable,future,all,of,group,future,child,group,future,get,timeout,to,milliseconds,time,unit,milliseconds,log,info,rest,endpoint,shutdown,complete,catch,exception,e,log,warn,rest,endpoint,shutdown,failed,e
RestServerEndpoint -> public void shutdown(Time timeout);1505859747;Stops this REST server endpoint.;public void shutdown(Time timeout) {_		log.info("Shutting down rest endpoint.")___		CompletableFuture<?> channelFuture = new CompletableFuture<>()__		if (this.serverChannel != null) {_			this.serverChannel.close().addListener(ignored -> channelFuture.complete(null))__		}_		CompletableFuture<?> groupFuture = new CompletableFuture<>()__		CompletableFuture<?> childGroupFuture = new CompletableFuture<>()___		channelFuture.thenRun(() -> {_			if (bootstrap != null) {_				if (bootstrap.group() != null) {_					bootstrap.group().shutdownGracefully(0, timeout.toMilliseconds(), TimeUnit.MILLISECONDS)_						.addListener(ignored -> groupFuture.complete(null))__				}_				if (bootstrap.childGroup() != null) {_					bootstrap.childGroup().shutdownGracefully(0, timeout.toMilliseconds(), TimeUnit.MILLISECONDS)_						.addListener(ignored -> childGroupFuture.complete(null))__				}_			} else {_				_				groupFuture.complete(null)__				childGroupFuture.complete(null)__			}_		})___		try {_			CompletableFuture.allOf(groupFuture, childGroupFuture).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__			log.info("Rest endpoint shutdown complete.")__		} catch (Exception e) {_			log.warn("Rest endpoint shutdown failed.", e)__		}_	};stops,this,rest,server,endpoint;public,void,shutdown,time,timeout,log,info,shutting,down,rest,endpoint,completable,future,channel,future,new,completable,future,if,this,server,channel,null,this,server,channel,close,add,listener,ignored,channel,future,complete,null,completable,future,group,future,new,completable,future,completable,future,child,group,future,new,completable,future,channel,future,then,run,if,bootstrap,null,if,bootstrap,group,null,bootstrap,group,shutdown,gracefully,0,timeout,to,milliseconds,time,unit,milliseconds,add,listener,ignored,group,future,complete,null,if,bootstrap,child,group,null,bootstrap,child,group,shutdown,gracefully,0,timeout,to,milliseconds,time,unit,milliseconds,add,listener,ignored,child,group,future,complete,null,else,group,future,complete,null,child,group,future,complete,null,try,completable,future,all,of,group,future,child,group,future,get,timeout,to,milliseconds,time,unit,milliseconds,log,info,rest,endpoint,shutdown,complete,catch,exception,e,log,warn,rest,endpoint,shutdown,failed,e
RestServerEndpoint -> public void shutdown(Time timeout);1505860453;Stops this REST server endpoint.;public void shutdown(Time timeout) {__		synchronized (lock) {_			if (!started) {_				_				return__			}__			log.info("Shutting down rest endpoint.")___			CompletableFuture<?> channelFuture = new CompletableFuture<>()__			if (this.serverChannel != null) {_				this.serverChannel.close().addListener(ignored -> channelFuture.complete(null))__				serverChannel = null__			}_			CompletableFuture<?> groupFuture = new CompletableFuture<>()__			CompletableFuture<?> childGroupFuture = new CompletableFuture<>()___			channelFuture.thenRun(() -> {_				if (bootstrap != null) {_					if (bootstrap.group() != null) {_						bootstrap.group().shutdownGracefully(0, timeout.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(ignored -> groupFuture.complete(null))__					}_					if (bootstrap.childGroup() != null) {_						bootstrap.childGroup().shutdownGracefully(0, timeout.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(ignored -> childGroupFuture.complete(null))__					}_					bootstrap = null__				} else {_					_					groupFuture.complete(null)__					childGroupFuture.complete(null)__				}_			})___			try {_				CompletableFuture.allOf(groupFuture, childGroupFuture).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				log.info("Rest endpoint shutdown complete.")__			} catch (Exception e) {_				log.warn("Rest endpoint shutdown failed.", e)__			}__			restAddress = null__			started = false__		}_	};stops,this,rest,server,endpoint;public,void,shutdown,time,timeout,synchronized,lock,if,started,return,log,info,shutting,down,rest,endpoint,completable,future,channel,future,new,completable,future,if,this,server,channel,null,this,server,channel,close,add,listener,ignored,channel,future,complete,null,server,channel,null,completable,future,group,future,new,completable,future,completable,future,child,group,future,new,completable,future,channel,future,then,run,if,bootstrap,null,if,bootstrap,group,null,bootstrap,group,shutdown,gracefully,0,timeout,to,milliseconds,time,unit,milliseconds,add,listener,ignored,group,future,complete,null,if,bootstrap,child,group,null,bootstrap,child,group,shutdown,gracefully,0,timeout,to,milliseconds,time,unit,milliseconds,add,listener,ignored,child,group,future,complete,null,bootstrap,null,else,group,future,complete,null,child,group,future,complete,null,try,completable,future,all,of,group,future,child,group,future,get,timeout,to,milliseconds,time,unit,milliseconds,log,info,rest,endpoint,shutdown,complete,catch,exception,e,log,warn,rest,endpoint,shutdown,failed,e,rest,address,null,started,false
RestServerEndpoint -> public void shutdown(Time timeout);1505860691;Stops this REST server endpoint.;public void shutdown(Time timeout) {__		synchronized (lock) {_			if (!started) {_				_				return__			}__			log.info("Shutting down rest endpoint.")___			CompletableFuture<?> channelFuture = new CompletableFuture<>()__			if (this.serverChannel != null) {_				this.serverChannel.close().addListener(ignored -> channelFuture.complete(null))__				serverChannel = null__			}_			CompletableFuture<?> groupFuture = new CompletableFuture<>()__			CompletableFuture<?> childGroupFuture = new CompletableFuture<>()___			channelFuture.thenRun(() -> {_				if (bootstrap != null) {_					if (bootstrap.group() != null) {_						bootstrap.group().shutdownGracefully(0, timeout.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(ignored -> groupFuture.complete(null))__					}_					if (bootstrap.childGroup() != null) {_						bootstrap.childGroup().shutdownGracefully(0, timeout.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(ignored -> childGroupFuture.complete(null))__					}_					bootstrap = null__				} else {_					_					groupFuture.complete(null)__					childGroupFuture.complete(null)__				}_			})___			try {_				CompletableFuture.allOf(groupFuture, childGroupFuture).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				log.info("Rest endpoint shutdown complete.")__			} catch (Exception e) {_				log.warn("Rest endpoint shutdown failed.", e)__			}__			restAddress = null__			started = false__		}_	};stops,this,rest,server,endpoint;public,void,shutdown,time,timeout,synchronized,lock,if,started,return,log,info,shutting,down,rest,endpoint,completable,future,channel,future,new,completable,future,if,this,server,channel,null,this,server,channel,close,add,listener,ignored,channel,future,complete,null,server,channel,null,completable,future,group,future,new,completable,future,completable,future,child,group,future,new,completable,future,channel,future,then,run,if,bootstrap,null,if,bootstrap,group,null,bootstrap,group,shutdown,gracefully,0,timeout,to,milliseconds,time,unit,milliseconds,add,listener,ignored,group,future,complete,null,if,bootstrap,child,group,null,bootstrap,child,group,shutdown,gracefully,0,timeout,to,milliseconds,time,unit,milliseconds,add,listener,ignored,child,group,future,complete,null,bootstrap,null,else,group,future,complete,null,child,group,future,complete,null,try,completable,future,all,of,group,future,child,group,future,get,timeout,to,milliseconds,time,unit,milliseconds,log,info,rest,endpoint,shutdown,complete,catch,exception,e,log,warn,rest,endpoint,shutdown,failed,e,rest,address,null,started,false
RestServerEndpoint -> public void shutdown(Time timeout);1505896530;Stops this REST server endpoint.;public void shutdown(Time timeout) {__		synchronized (lock) {_			if (!started) {_				_				return__			}__			log.info("Shutting down rest endpoint.")___			CompletableFuture<?> channelFuture = new CompletableFuture<>()__			if (this.serverChannel != null) {_				this.serverChannel.close().addListener(ignored -> channelFuture.complete(null))__				serverChannel = null__			}_			CompletableFuture<?> groupFuture = new CompletableFuture<>()__			CompletableFuture<?> childGroupFuture = new CompletableFuture<>()___			channelFuture.thenRun(() -> {_				if (bootstrap != null) {_					if (bootstrap.group() != null) {_						bootstrap.group().shutdownGracefully(0, timeout.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(ignored -> groupFuture.complete(null))__					}_					if (bootstrap.childGroup() != null) {_						bootstrap.childGroup().shutdownGracefully(0, timeout.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(ignored -> childGroupFuture.complete(null))__					}_					bootstrap = null__				} else {_					_					groupFuture.complete(null)__					childGroupFuture.complete(null)__				}_			})___			try {_				CompletableFuture.allOf(groupFuture, childGroupFuture).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				log.info("Rest endpoint shutdown complete.")__			} catch (Exception e) {_				log.warn("Rest endpoint shutdown failed.", e)__			}__			restAddress = null__			started = false__		}_	};stops,this,rest,server,endpoint;public,void,shutdown,time,timeout,synchronized,lock,if,started,return,log,info,shutting,down,rest,endpoint,completable,future,channel,future,new,completable,future,if,this,server,channel,null,this,server,channel,close,add,listener,ignored,channel,future,complete,null,server,channel,null,completable,future,group,future,new,completable,future,completable,future,child,group,future,new,completable,future,channel,future,then,run,if,bootstrap,null,if,bootstrap,group,null,bootstrap,group,shutdown,gracefully,0,timeout,to,milliseconds,time,unit,milliseconds,add,listener,ignored,group,future,complete,null,if,bootstrap,child,group,null,bootstrap,child,group,shutdown,gracefully,0,timeout,to,milliseconds,time,unit,milliseconds,add,listener,ignored,child,group,future,complete,null,bootstrap,null,else,group,future,complete,null,child,group,future,complete,null,try,completable,future,all,of,group,future,child,group,future,get,timeout,to,milliseconds,time,unit,milliseconds,log,info,rest,endpoint,shutdown,complete,catch,exception,e,log,warn,rest,endpoint,shutdown,failed,e,rest,address,null,started,false
RestServerEndpoint -> public void shutdown(Time timeout);1506553599;Stops this REST server endpoint.;public void shutdown(Time timeout) {__		synchronized (lock) {_			if (!started) {_				_				return__			}__			log.info("Shutting down rest endpoint.")___			CompletableFuture<?> channelFuture = new CompletableFuture<>()__			if (this.serverChannel != null) {_				this.serverChannel.close().addListener(ignored -> channelFuture.complete(null))__				serverChannel = null__			}_			CompletableFuture<?> groupFuture = new CompletableFuture<>()__			CompletableFuture<?> childGroupFuture = new CompletableFuture<>()___			channelFuture.thenRun(() -> {_				if (bootstrap != null) {_					if (bootstrap.group() != null) {_						bootstrap.group().shutdownGracefully(0, timeout.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(ignored -> groupFuture.complete(null))__					}_					if (bootstrap.childGroup() != null) {_						bootstrap.childGroup().shutdownGracefully(0, timeout.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(ignored -> childGroupFuture.complete(null))__					}_					bootstrap = null__				} else {_					_					groupFuture.complete(null)__					childGroupFuture.complete(null)__				}_			})___			try {_				CompletableFuture.allOf(groupFuture, childGroupFuture).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				log.info("Rest endpoint shutdown complete.")__			} catch (Exception e) {_				log.warn("Rest endpoint shutdown failed.", e)__			}__			restAddress = null__			started = false__		}_	};stops,this,rest,server,endpoint;public,void,shutdown,time,timeout,synchronized,lock,if,started,return,log,info,shutting,down,rest,endpoint,completable,future,channel,future,new,completable,future,if,this,server,channel,null,this,server,channel,close,add,listener,ignored,channel,future,complete,null,server,channel,null,completable,future,group,future,new,completable,future,completable,future,child,group,future,new,completable,future,channel,future,then,run,if,bootstrap,null,if,bootstrap,group,null,bootstrap,group,shutdown,gracefully,0,timeout,to,milliseconds,time,unit,milliseconds,add,listener,ignored,group,future,complete,null,if,bootstrap,child,group,null,bootstrap,child,group,shutdown,gracefully,0,timeout,to,milliseconds,time,unit,milliseconds,add,listener,ignored,child,group,future,complete,null,bootstrap,null,else,group,future,complete,null,child,group,future,complete,null,try,completable,future,all,of,group,future,child,group,future,get,timeout,to,milliseconds,time,unit,milliseconds,log,info,rest,endpoint,shutdown,complete,catch,exception,e,log,warn,rest,endpoint,shutdown,failed,e,rest,address,null,started,false
RestServerEndpoint -> public void shutdown(Time timeout);1507569104;Stops this REST server endpoint.;public void shutdown(Time timeout) {__		synchronized (lock) {_			if (!started) {_				_				return__			}__			log.info("Shutting down rest endpoint.")___			CompletableFuture<?> channelFuture = new CompletableFuture<>()__			if (this.serverChannel != null) {_				this.serverChannel.close().addListener(ignored -> channelFuture.complete(null))__				serverChannel = null__			}_			CompletableFuture<?> groupFuture = new CompletableFuture<>()__			CompletableFuture<?> childGroupFuture = new CompletableFuture<>()___			channelFuture.thenRun(() -> {_				if (bootstrap != null) {_					if (bootstrap.group() != null) {_						bootstrap.group().shutdownGracefully(0, timeout.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(ignored -> groupFuture.complete(null))__					}_					if (bootstrap.childGroup() != null) {_						bootstrap.childGroup().shutdownGracefully(0, timeout.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(ignored -> childGroupFuture.complete(null))__					}_					bootstrap = null__				} else {_					_					groupFuture.complete(null)__					childGroupFuture.complete(null)__				}_			})___			try {_				CompletableFuture.allOf(groupFuture, childGroupFuture).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				log.info("Rest endpoint shutdown complete.")__			} catch (Exception e) {_				log.warn("Rest endpoint shutdown failed.", e)__			}__			restAddress = null__			started = false__		}_	};stops,this,rest,server,endpoint;public,void,shutdown,time,timeout,synchronized,lock,if,started,return,log,info,shutting,down,rest,endpoint,completable,future,channel,future,new,completable,future,if,this,server,channel,null,this,server,channel,close,add,listener,ignored,channel,future,complete,null,server,channel,null,completable,future,group,future,new,completable,future,completable,future,child,group,future,new,completable,future,channel,future,then,run,if,bootstrap,null,if,bootstrap,group,null,bootstrap,group,shutdown,gracefully,0,timeout,to,milliseconds,time,unit,milliseconds,add,listener,ignored,group,future,complete,null,if,bootstrap,child,group,null,bootstrap,child,group,shutdown,gracefully,0,timeout,to,milliseconds,time,unit,milliseconds,add,listener,ignored,child,group,future,complete,null,bootstrap,null,else,group,future,complete,null,child,group,future,complete,null,try,completable,future,all,of,group,future,child,group,future,get,timeout,to,milliseconds,time,unit,milliseconds,log,info,rest,endpoint,shutdown,complete,catch,exception,e,log,warn,rest,endpoint,shutdown,failed,e,rest,address,null,started,false
RestServerEndpoint -> public void shutdown(Time timeout);1510220918;Stops this REST server endpoint.;public void shutdown(Time timeout) {__		synchronized (lock) {_			if (!started) {_				_				return__			}__			log.info("Shutting down rest endpoint.")___			CompletableFuture<?> channelFuture = new CompletableFuture<>()__			if (this.serverChannel != null) {_				this.serverChannel.close().addListener(ignored -> channelFuture.complete(null))__				serverChannel = null__			}_			CompletableFuture<?> groupFuture = new CompletableFuture<>()__			CompletableFuture<?> childGroupFuture = new CompletableFuture<>()___			channelFuture.thenRun(() -> {_				if (bootstrap != null) {_					if (bootstrap.group() != null) {_						bootstrap.group().shutdownGracefully(0, timeout.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(ignored -> groupFuture.complete(null))__					}_					if (bootstrap.childGroup() != null) {_						bootstrap.childGroup().shutdownGracefully(0, timeout.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(ignored -> childGroupFuture.complete(null))__					}_					bootstrap = null__				} else {_					_					groupFuture.complete(null)__					childGroupFuture.complete(null)__				}_			})___			try {_				CompletableFuture.allOf(groupFuture, childGroupFuture).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				log.info("Rest endpoint shutdown complete.")__			} catch (Exception e) {_				log.warn("Rest endpoint shutdown failed.", e)__			}__			restAddress = null__			started = false__		}_	};stops,this,rest,server,endpoint;public,void,shutdown,time,timeout,synchronized,lock,if,started,return,log,info,shutting,down,rest,endpoint,completable,future,channel,future,new,completable,future,if,this,server,channel,null,this,server,channel,close,add,listener,ignored,channel,future,complete,null,server,channel,null,completable,future,group,future,new,completable,future,completable,future,child,group,future,new,completable,future,channel,future,then,run,if,bootstrap,null,if,bootstrap,group,null,bootstrap,group,shutdown,gracefully,0,timeout,to,milliseconds,time,unit,milliseconds,add,listener,ignored,group,future,complete,null,if,bootstrap,child,group,null,bootstrap,child,group,shutdown,gracefully,0,timeout,to,milliseconds,time,unit,milliseconds,add,listener,ignored,child,group,future,complete,null,bootstrap,null,else,group,future,complete,null,child,group,future,complete,null,try,completable,future,all,of,group,future,child,group,future,get,timeout,to,milliseconds,time,unit,milliseconds,log,info,rest,endpoint,shutdown,complete,catch,exception,e,log,warn,rest,endpoint,shutdown,failed,e,rest,address,null,started,false
RestServerEndpoint -> public void shutdown(Time timeout);1512650422;Stops this REST server endpoint.;public void shutdown(Time timeout) {__		synchronized (lock) {_			if (!started) {_				_				return__			}__			log.info("Shutting down rest endpoint.")___			CompletableFuture<?> channelFuture = new CompletableFuture<>()__			if (this.serverChannel != null) {_				this.serverChannel.close().addListener(ignored -> channelFuture.complete(null))__				serverChannel = null__			}_			CompletableFuture<?> groupFuture = new CompletableFuture<>()__			CompletableFuture<?> childGroupFuture = new CompletableFuture<>()___			channelFuture.thenRun(() -> {_				if (bootstrap != null) {_					if (bootstrap.group() != null) {_						bootstrap.group().shutdownGracefully(0, timeout.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(ignored -> groupFuture.complete(null))__					}_					if (bootstrap.childGroup() != null) {_						bootstrap.childGroup().shutdownGracefully(0, timeout.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(ignored -> childGroupFuture.complete(null))__					}_					bootstrap = null__				} else {_					_					groupFuture.complete(null)__					childGroupFuture.complete(null)__				}_			})___			try {_				CompletableFuture.allOf(groupFuture, childGroupFuture).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				log.info("Rest endpoint shutdown complete.")__			} catch (Exception e) {_				log.warn("Rest endpoint shutdown failed.", e)__			}__			restAddress = null__			started = false__		}_	};stops,this,rest,server,endpoint;public,void,shutdown,time,timeout,synchronized,lock,if,started,return,log,info,shutting,down,rest,endpoint,completable,future,channel,future,new,completable,future,if,this,server,channel,null,this,server,channel,close,add,listener,ignored,channel,future,complete,null,server,channel,null,completable,future,group,future,new,completable,future,completable,future,child,group,future,new,completable,future,channel,future,then,run,if,bootstrap,null,if,bootstrap,group,null,bootstrap,group,shutdown,gracefully,0,timeout,to,milliseconds,time,unit,milliseconds,add,listener,ignored,group,future,complete,null,if,bootstrap,child,group,null,bootstrap,child,group,shutdown,gracefully,0,timeout,to,milliseconds,time,unit,milliseconds,add,listener,ignored,child,group,future,complete,null,bootstrap,null,else,group,future,complete,null,child,group,future,complete,null,try,completable,future,all,of,group,future,child,group,future,get,timeout,to,milliseconds,time,unit,milliseconds,log,info,rest,endpoint,shutdown,complete,catch,exception,e,log,warn,rest,endpoint,shutdown,failed,e,rest,address,null,started,false
RestServerEndpoint -> public void shutdown(Time timeout);1516098457;Stops this REST server endpoint.;public void shutdown(Time timeout) {__		synchronized (lock) {_			if (!started) {_				_				return__			}__			log.info("Shutting down rest endpoint.")___			CompletableFuture<?> channelFuture = new CompletableFuture<>()__			if (this.serverChannel != null) {_				this.serverChannel.close().addListener(finished -> {_					if (finished.isSuccess()) {_						channelFuture.complete(null)__					} else {_						channelFuture.completeExceptionally(finished.cause())__					}_				})__				serverChannel = null__			}_			CompletableFuture<?> groupFuture = new CompletableFuture<>()__			CompletableFuture<?> childGroupFuture = new CompletableFuture<>()___			channelFuture.thenRun(() -> {_				if (bootstrap != null) {_					if (bootstrap.group() != null) {_						bootstrap.group().shutdownGracefully(0L, timeout.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									groupFuture.complete(null)__								} else {_									groupFuture.completeExceptionally(finished.cause())__								}_							})__					}_					if (bootstrap.childGroup() != null) {_						bootstrap.childGroup().shutdownGracefully(0L, timeout.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									childGroupFuture.complete(null)__								} else {_									childGroupFuture.completeExceptionally(finished.cause())__								}_							})__					}_					bootstrap = null__				} else {_					_					groupFuture.complete(null)__					childGroupFuture.complete(null)__				}_			})___			try {_				CompletableFuture.allOf(groupFuture, childGroupFuture).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				log.info("Rest endpoint shutdown complete.")__			} catch (Exception e) {_				log.warn("Rest endpoint shutdown failed.", e)__			}__			restAddress = null__			started = false__		}_	};stops,this,rest,server,endpoint;public,void,shutdown,time,timeout,synchronized,lock,if,started,return,log,info,shutting,down,rest,endpoint,completable,future,channel,future,new,completable,future,if,this,server,channel,null,this,server,channel,close,add,listener,finished,if,finished,is,success,channel,future,complete,null,else,channel,future,complete,exceptionally,finished,cause,server,channel,null,completable,future,group,future,new,completable,future,completable,future,child,group,future,new,completable,future,channel,future,then,run,if,bootstrap,null,if,bootstrap,group,null,bootstrap,group,shutdown,gracefully,0l,timeout,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,group,future,complete,null,else,group,future,complete,exceptionally,finished,cause,if,bootstrap,child,group,null,bootstrap,child,group,shutdown,gracefully,0l,timeout,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,child,group,future,complete,null,else,child,group,future,complete,exceptionally,finished,cause,bootstrap,null,else,group,future,complete,null,child,group,future,complete,null,try,completable,future,all,of,group,future,child,group,future,get,timeout,to,milliseconds,time,unit,milliseconds,log,info,rest,endpoint,shutdown,complete,catch,exception,e,log,warn,rest,endpoint,shutdown,failed,e,rest,address,null,started,false
RestServerEndpoint -> public void shutdown(Time timeout);1516971023;Stops this REST server endpoint.;public void shutdown(Time timeout) {__		synchronized (lock) {_			if (!started) {_				_				return__			}__			log.info("Shutting down rest endpoint.")___			CompletableFuture<?> channelFuture = new CompletableFuture<>()__			if (this.serverChannel != null) {_				this.serverChannel.close().addListener(finished -> {_					if (finished.isSuccess()) {_						channelFuture.complete(null)__					} else {_						channelFuture.completeExceptionally(finished.cause())__					}_				})__				serverChannel = null__			}_			CompletableFuture<?> groupFuture = new CompletableFuture<>()__			CompletableFuture<?> childGroupFuture = new CompletableFuture<>()___			channelFuture.thenRun(() -> {_				if (bootstrap != null) {_					if (bootstrap.group() != null) {_						bootstrap.group().shutdownGracefully(0L, timeout.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									groupFuture.complete(null)__								} else {_									groupFuture.completeExceptionally(finished.cause())__								}_							})__					}_					if (bootstrap.childGroup() != null) {_						bootstrap.childGroup().shutdownGracefully(0L, timeout.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									childGroupFuture.complete(null)__								} else {_									childGroupFuture.completeExceptionally(finished.cause())__								}_							})__					}_					bootstrap = null__				} else {_					_					groupFuture.complete(null)__					childGroupFuture.complete(null)__				}_			})___			try {_				CompletableFuture.allOf(groupFuture, childGroupFuture).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				log.info("Rest endpoint shutdown complete.")__			} catch (Exception e) {_				log.warn("Rest endpoint shutdown failed.", e)__			}__			restAddress = null__			started = false__		}_	};stops,this,rest,server,endpoint;public,void,shutdown,time,timeout,synchronized,lock,if,started,return,log,info,shutting,down,rest,endpoint,completable,future,channel,future,new,completable,future,if,this,server,channel,null,this,server,channel,close,add,listener,finished,if,finished,is,success,channel,future,complete,null,else,channel,future,complete,exceptionally,finished,cause,server,channel,null,completable,future,group,future,new,completable,future,completable,future,child,group,future,new,completable,future,channel,future,then,run,if,bootstrap,null,if,bootstrap,group,null,bootstrap,group,shutdown,gracefully,0l,timeout,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,group,future,complete,null,else,group,future,complete,exceptionally,finished,cause,if,bootstrap,child,group,null,bootstrap,child,group,shutdown,gracefully,0l,timeout,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,child,group,future,complete,null,else,child,group,future,complete,exceptionally,finished,cause,bootstrap,null,else,group,future,complete,null,child,group,future,complete,null,try,completable,future,all,of,group,future,child,group,future,get,timeout,to,milliseconds,time,unit,milliseconds,log,info,rest,endpoint,shutdown,complete,catch,exception,e,log,warn,rest,endpoint,shutdown,failed,e,rest,address,null,started,false
RestServerEndpoint -> public void shutdown(Time timeout);1516971023;Stops this REST server endpoint.;public void shutdown(Time timeout) {__		synchronized (lock) {_			if (!started) {_				_				return__			}__			log.info("Shutting down rest endpoint.")___			CompletableFuture<?> channelFuture = new CompletableFuture<>()__			if (this.serverChannel != null) {_				this.serverChannel.close().addListener(finished -> {_					if (finished.isSuccess()) {_						channelFuture.complete(null)__					} else {_						channelFuture.completeExceptionally(finished.cause())__					}_				})__				serverChannel = null__			}_			CompletableFuture<?> groupFuture = new CompletableFuture<>()__			CompletableFuture<?> childGroupFuture = new CompletableFuture<>()___			channelFuture.thenRun(() -> {_				if (bootstrap != null) {_					if (bootstrap.group() != null) {_						bootstrap.group().shutdownGracefully(0L, timeout.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									groupFuture.complete(null)__								} else {_									groupFuture.completeExceptionally(finished.cause())__								}_							})__					}_					if (bootstrap.childGroup() != null) {_						bootstrap.childGroup().shutdownGracefully(0L, timeout.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									childGroupFuture.complete(null)__								} else {_									childGroupFuture.completeExceptionally(finished.cause())__								}_							})__					}_					bootstrap = null__				} else {_					_					groupFuture.complete(null)__					childGroupFuture.complete(null)__				}_			})___			try {_				CompletableFuture.allOf(groupFuture, childGroupFuture).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				log.info("Rest endpoint shutdown complete.")__			} catch (Exception e) {_				log.warn("Rest endpoint shutdown failed.", e)__			}__			restAddress = null__			started = false__		}_	};stops,this,rest,server,endpoint;public,void,shutdown,time,timeout,synchronized,lock,if,started,return,log,info,shutting,down,rest,endpoint,completable,future,channel,future,new,completable,future,if,this,server,channel,null,this,server,channel,close,add,listener,finished,if,finished,is,success,channel,future,complete,null,else,channel,future,complete,exceptionally,finished,cause,server,channel,null,completable,future,group,future,new,completable,future,completable,future,child,group,future,new,completable,future,channel,future,then,run,if,bootstrap,null,if,bootstrap,group,null,bootstrap,group,shutdown,gracefully,0l,timeout,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,group,future,complete,null,else,group,future,complete,exceptionally,finished,cause,if,bootstrap,child,group,null,bootstrap,child,group,shutdown,gracefully,0l,timeout,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,child,group,future,complete,null,else,child,group,future,complete,exceptionally,finished,cause,bootstrap,null,else,group,future,complete,null,child,group,future,complete,null,try,completable,future,all,of,group,future,child,group,future,get,timeout,to,milliseconds,time,unit,milliseconds,log,info,rest,endpoint,shutdown,complete,catch,exception,e,log,warn,rest,endpoint,shutdown,failed,e,rest,address,null,started,false
RestServerEndpoint -> public void shutdown(Time timeout);1518680660;Stops this REST server endpoint.;public void shutdown(Time timeout) {__		synchronized (lock) {_			if (!started) {_				_				return__			}__			log.info("Shutting down rest endpoint.")___			CompletableFuture<?> channelFuture = new CompletableFuture<>()__			if (this.serverChannel != null) {_				this.serverChannel.close().addListener(finished -> {_					if (finished.isSuccess()) {_						channelFuture.complete(null)__					} else {_						channelFuture.completeExceptionally(finished.cause())__					}_				})__				serverChannel = null__			}_			CompletableFuture<?> groupFuture = new CompletableFuture<>()__			CompletableFuture<?> childGroupFuture = new CompletableFuture<>()___			channelFuture.thenRun(() -> {_				if (bootstrap != null) {_					if (bootstrap.group() != null) {_						bootstrap.group().shutdownGracefully(0L, timeout.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									groupFuture.complete(null)__								} else {_									groupFuture.completeExceptionally(finished.cause())__								}_							})__					}_					if (bootstrap.childGroup() != null) {_						bootstrap.childGroup().shutdownGracefully(0L, timeout.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									childGroupFuture.complete(null)__								} else {_									childGroupFuture.completeExceptionally(finished.cause())__								}_							})__					}_					bootstrap = null__				} else {_					_					groupFuture.complete(null)__					childGroupFuture.complete(null)__				}_			})___			try {_				CompletableFuture.allOf(groupFuture, childGroupFuture).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				log.info("Rest endpoint shutdown complete.")__			} catch (Exception e) {_				log.warn("Rest endpoint shutdown failed.", e)__			}__			restAddress = null__			started = false___			try {_				log.info("Cleaning upload directory {}", uploadDir)__				FileUtils.cleanDirectory(uploadDir.toFile())__			} catch (IOException e) {_				log.warn("Error while cleaning upload directory {}", uploadDir, e)__			}_		}_	};stops,this,rest,server,endpoint;public,void,shutdown,time,timeout,synchronized,lock,if,started,return,log,info,shutting,down,rest,endpoint,completable,future,channel,future,new,completable,future,if,this,server,channel,null,this,server,channel,close,add,listener,finished,if,finished,is,success,channel,future,complete,null,else,channel,future,complete,exceptionally,finished,cause,server,channel,null,completable,future,group,future,new,completable,future,completable,future,child,group,future,new,completable,future,channel,future,then,run,if,bootstrap,null,if,bootstrap,group,null,bootstrap,group,shutdown,gracefully,0l,timeout,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,group,future,complete,null,else,group,future,complete,exceptionally,finished,cause,if,bootstrap,child,group,null,bootstrap,child,group,shutdown,gracefully,0l,timeout,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,child,group,future,complete,null,else,child,group,future,complete,exceptionally,finished,cause,bootstrap,null,else,group,future,complete,null,child,group,future,complete,null,try,completable,future,all,of,group,future,child,group,future,get,timeout,to,milliseconds,time,unit,milliseconds,log,info,rest,endpoint,shutdown,complete,catch,exception,e,log,warn,rest,endpoint,shutdown,failed,e,rest,address,null,started,false,try,log,info,cleaning,upload,directory,upload,dir,file,utils,clean,directory,upload,dir,to,file,catch,ioexception,e,log,warn,error,while,cleaning,upload,directory,upload,dir,e
RestServerEndpoint -> public void shutdown(Time timeout);1518945174;Stops this REST server endpoint.;public void shutdown(Time timeout) {__		synchronized (lock) {_			if (!started) {_				_				return__			}__			log.info("Shutting down rest endpoint.")___			CompletableFuture<?> channelFuture = new CompletableFuture<>()__			if (this.serverChannel != null) {_				this.serverChannel.close().addListener(finished -> {_					if (finished.isSuccess()) {_						channelFuture.complete(null)__					} else {_						channelFuture.completeExceptionally(finished.cause())__					}_				})__				serverChannel = null__			}_			CompletableFuture<?> groupFuture = new CompletableFuture<>()__			CompletableFuture<?> childGroupFuture = new CompletableFuture<>()___			channelFuture.thenRun(() -> {_				if (bootstrap != null) {_					if (bootstrap.group() != null) {_						bootstrap.group().shutdownGracefully(0L, timeout.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									groupFuture.complete(null)__								} else {_									groupFuture.completeExceptionally(finished.cause())__								}_							})__					}_					if (bootstrap.childGroup() != null) {_						bootstrap.childGroup().shutdownGracefully(0L, timeout.toMilliseconds(), TimeUnit.MILLISECONDS)_							.addListener(finished -> {_								if (finished.isSuccess()) {_									childGroupFuture.complete(null)__								} else {_									childGroupFuture.completeExceptionally(finished.cause())__								}_							})__					}_					bootstrap = null__				} else {_					_					groupFuture.complete(null)__					childGroupFuture.complete(null)__				}_			})___			try {_				CompletableFuture.allOf(groupFuture, childGroupFuture).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				log.info("Rest endpoint shutdown complete.")__			} catch (Exception e) {_				log.warn("Rest endpoint shutdown failed.", e)__			}__			restAddress = null__			started = false___			try {_				log.info("Cleaning upload directory {}", uploadDir)__				FileUtils.cleanDirectory(uploadDir.toFile())__			} catch (IOException e) {_				log.warn("Error while cleaning upload directory {}", uploadDir, e)__			}_		}_	};stops,this,rest,server,endpoint;public,void,shutdown,time,timeout,synchronized,lock,if,started,return,log,info,shutting,down,rest,endpoint,completable,future,channel,future,new,completable,future,if,this,server,channel,null,this,server,channel,close,add,listener,finished,if,finished,is,success,channel,future,complete,null,else,channel,future,complete,exceptionally,finished,cause,server,channel,null,completable,future,group,future,new,completable,future,completable,future,child,group,future,new,completable,future,channel,future,then,run,if,bootstrap,null,if,bootstrap,group,null,bootstrap,group,shutdown,gracefully,0l,timeout,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,group,future,complete,null,else,group,future,complete,exceptionally,finished,cause,if,bootstrap,child,group,null,bootstrap,child,group,shutdown,gracefully,0l,timeout,to,milliseconds,time,unit,milliseconds,add,listener,finished,if,finished,is,success,child,group,future,complete,null,else,child,group,future,complete,exceptionally,finished,cause,bootstrap,null,else,group,future,complete,null,child,group,future,complete,null,try,completable,future,all,of,group,future,child,group,future,get,timeout,to,milliseconds,time,unit,milliseconds,log,info,rest,endpoint,shutdown,complete,catch,exception,e,log,warn,rest,endpoint,shutdown,failed,e,rest,address,null,started,false,try,log,info,cleaning,upload,directory,upload,dir,file,utils,clean,directory,upload,dir,to,file,catch,ioexception,e,log,warn,error,while,cleaning,upload,directory,upload,dir,e
RestServerEndpoint -> @Nullable 	public InetSocketAddress getServerAddress();1519052657;Returns the address on which this endpoint is accepting requests.__@return address on which this endpoint is accepting requests or null if none;@Nullable_	public InetSocketAddress getServerAddress() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			Channel server = this.serverChannel___			if (server != null) {_				try {_					return ((InetSocketAddress) server.localAddress())__				} catch (Exception e) {_					log.error("Cannot access local server address", e)__				}_			}__			return null__		}_	};returns,the,address,on,which,this,endpoint,is,accepting,requests,return,address,on,which,this,endpoint,is,accepting,requests,or,null,if,none;nullable,public,inet,socket,address,get,server,address,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,channel,server,this,server,channel,if,server,null,try,return,inet,socket,address,server,local,address,catch,exception,e,log,error,cannot,access,local,server,address,e,return,null
RestServerEndpoint -> @Nullable 	public InetSocketAddress getServerAddress();1519406530;Returns the address on which this endpoint is accepting requests.__@return address on which this endpoint is accepting requests or null if none;@Nullable_	public InetSocketAddress getServerAddress() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			Channel server = this.serverChannel___			if (server != null) {_				try {_					return ((InetSocketAddress) server.localAddress())__				} catch (Exception e) {_					log.error("Cannot access local server address", e)__				}_			}__			return null__		}_	};returns,the,address,on,which,this,endpoint,is,accepting,requests,return,address,on,which,this,endpoint,is,accepting,requests,or,null,if,none;nullable,public,inet,socket,address,get,server,address,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,channel,server,this,server,channel,if,server,null,try,return,inet,socket,address,server,local,address,catch,exception,e,log,error,cannot,access,local,server,address,e,return,null
RestServerEndpoint -> @Nullable 	public InetSocketAddress getServerAddress();1521016670;Returns the address on which this endpoint is accepting requests.__@return address on which this endpoint is accepting requests or null if none;@Nullable_	public InetSocketAddress getServerAddress() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			Channel server = this.serverChannel___			if (server != null) {_				try {_					return ((InetSocketAddress) server.localAddress())__				} catch (Exception e) {_					log.error("Cannot access local server address", e)__				}_			}__			return null__		}_	};returns,the,address,on,which,this,endpoint,is,accepting,requests,return,address,on,which,this,endpoint,is,accepting,requests,or,null,if,none;nullable,public,inet,socket,address,get,server,address,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,channel,server,this,server,channel,if,server,null,try,return,inet,socket,address,server,local,address,catch,exception,e,log,error,cannot,access,local,server,address,e,return,null
RestServerEndpoint -> @Nullable 	public InetSocketAddress getServerAddress();1521016671;Returns the address on which this endpoint is accepting requests.__@return address on which this endpoint is accepting requests or null if none;@Nullable_	public InetSocketAddress getServerAddress() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			Channel server = this.serverChannel___			if (server != null) {_				try {_					return ((InetSocketAddress) server.localAddress())__				} catch (Exception e) {_					log.error("Cannot access local server address", e)__				}_			}__			return null__		}_	};returns,the,address,on,which,this,endpoint,is,accepting,requests,return,address,on,which,this,endpoint,is,accepting,requests,or,null,if,none;nullable,public,inet,socket,address,get,server,address,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,channel,server,this,server,channel,if,server,null,try,return,inet,socket,address,server,local,address,catch,exception,e,log,error,cannot,access,local,server,address,e,return,null
RestServerEndpoint -> @Nullable 	public InetSocketAddress getServerAddress();1521016671;Returns the address on which this endpoint is accepting requests.__@return address on which this endpoint is accepting requests or null if none;@Nullable_	public InetSocketAddress getServerAddress() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			Channel server = this.serverChannel___			if (server != null) {_				try {_					return ((InetSocketAddress) server.localAddress())__				} catch (Exception e) {_					log.error("Cannot access local server address", e)__				}_			}__			return null__		}_	};returns,the,address,on,which,this,endpoint,is,accepting,requests,return,address,on,which,this,endpoint,is,accepting,requests,or,null,if,none;nullable,public,inet,socket,address,get,server,address,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,channel,server,this,server,channel,if,server,null,try,return,inet,socket,address,server,local,address,catch,exception,e,log,error,cannot,access,local,server,address,e,return,null
RestServerEndpoint -> @Nullable 	public InetSocketAddress getServerAddress();1521385094;Returns the address on which this endpoint is accepting requests.__@return address on which this endpoint is accepting requests or null if none;@Nullable_	public InetSocketAddress getServerAddress() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			Channel server = this.serverChannel___			if (server != null) {_				try {_					return ((InetSocketAddress) server.localAddress())__				} catch (Exception e) {_					log.error("Cannot access local server address", e)__				}_			}__			return null__		}_	};returns,the,address,on,which,this,endpoint,is,accepting,requests,return,address,on,which,this,endpoint,is,accepting,requests,or,null,if,none;nullable,public,inet,socket,address,get,server,address,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,channel,server,this,server,channel,if,server,null,try,return,inet,socket,address,server,local,address,catch,exception,e,log,error,cannot,access,local,server,address,e,return,null
RestServerEndpoint -> @Nullable 	public InetSocketAddress getServerAddress();1521804758;Returns the address on which this endpoint is accepting requests.__@return address on which this endpoint is accepting requests or null if none;@Nullable_	public InetSocketAddress getServerAddress() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			Channel server = this.serverChannel___			if (server != null) {_				try {_					return ((InetSocketAddress) server.localAddress())__				} catch (Exception e) {_					log.error("Cannot access local server address", e)__				}_			}__			return null__		}_	};returns,the,address,on,which,this,endpoint,is,accepting,requests,return,address,on,which,this,endpoint,is,accepting,requests,or,null,if,none;nullable,public,inet,socket,address,get,server,address,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,channel,server,this,server,channel,if,server,null,try,return,inet,socket,address,server,local,address,catch,exception,e,log,error,cannot,access,local,server,address,e,return,null
RestServerEndpoint -> @Nullable 	public InetSocketAddress getServerAddress();1521804758;Returns the address on which this endpoint is accepting requests.__@return address on which this endpoint is accepting requests or null if none;@Nullable_	public InetSocketAddress getServerAddress() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			Channel server = this.serverChannel___			if (server != null) {_				try {_					return ((InetSocketAddress) server.localAddress())__				} catch (Exception e) {_					log.error("Cannot access local server address", e)__				}_			}__			return null__		}_	};returns,the,address,on,which,this,endpoint,is,accepting,requests,return,address,on,which,this,endpoint,is,accepting,requests,or,null,if,none;nullable,public,inet,socket,address,get,server,address,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,channel,server,this,server,channel,if,server,null,try,return,inet,socket,address,server,local,address,catch,exception,e,log,error,cannot,access,local,server,address,e,return,null
RestServerEndpoint -> @Nullable 	public InetSocketAddress getServerAddress();1525904579;Returns the address on which this endpoint is accepting requests.__@return address on which this endpoint is accepting requests or null if none;@Nullable_	public InetSocketAddress getServerAddress() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			Channel server = this.serverChannel___			if (server != null) {_				try {_					return ((InetSocketAddress) server.localAddress())__				} catch (Exception e) {_					log.error("Cannot access local server address", e)__				}_			}__			return null__		}_	};returns,the,address,on,which,this,endpoint,is,accepting,requests,return,address,on,which,this,endpoint,is,accepting,requests,or,null,if,none;nullable,public,inet,socket,address,get,server,address,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,channel,server,this,server,channel,if,server,null,try,return,inet,socket,address,server,local,address,catch,exception,e,log,error,cannot,access,local,server,address,e,return,null
RestServerEndpoint -> @Nullable 	public InetSocketAddress getServerAddress();1527499265;Returns the address on which this endpoint is accepting requests.__@return address on which this endpoint is accepting requests or null if none;@Nullable_	public InetSocketAddress getServerAddress() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			Channel server = this.serverChannel___			if (server != null) {_				try {_					return ((InetSocketAddress) server.localAddress())__				} catch (Exception e) {_					log.error("Cannot access local server address", e)__				}_			}__			return null__		}_	};returns,the,address,on,which,this,endpoint,is,accepting,requests,return,address,on,which,this,endpoint,is,accepting,requests,or,null,if,none;nullable,public,inet,socket,address,get,server,address,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,channel,server,this,server,channel,if,server,null,try,return,inet,socket,address,server,local,address,catch,exception,e,log,error,cannot,access,local,server,address,e,return,null
RestServerEndpoint -> @Nullable 	public InetSocketAddress getServerAddress();1528876304;Returns the address on which this endpoint is accepting requests.__@return address on which this endpoint is accepting requests or null if none;@Nullable_	public InetSocketAddress getServerAddress() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			Channel server = this.serverChannel___			if (server != null) {_				try {_					return ((InetSocketAddress) server.localAddress())__				} catch (Exception e) {_					log.error("Cannot access local server address", e)__				}_			}__			return null__		}_	};returns,the,address,on,which,this,endpoint,is,accepting,requests,return,address,on,which,this,endpoint,is,accepting,requests,or,null,if,none;nullable,public,inet,socket,address,get,server,address,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,channel,server,this,server,channel,if,server,null,try,return,inet,socket,address,server,local,address,catch,exception,e,log,error,cannot,access,local,server,address,e,return,null
RestServerEndpoint -> @Nullable 	public InetSocketAddress getServerAddress();1534259541;Returns the address on which this endpoint is accepting requests.__@return address on which this endpoint is accepting requests or null if none;@Nullable_	public InetSocketAddress getServerAddress() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			Channel server = this.serverChannel___			if (server != null) {_				try {_					return ((InetSocketAddress) server.localAddress())__				} catch (Exception e) {_					log.error("Cannot access local server address", e)__				}_			}__			return null__		}_	};returns,the,address,on,which,this,endpoint,is,accepting,requests,return,address,on,which,this,endpoint,is,accepting,requests,or,null,if,none;nullable,public,inet,socket,address,get,server,address,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,channel,server,this,server,channel,if,server,null,try,return,inet,socket,address,server,local,address,catch,exception,e,log,error,cannot,access,local,server,address,e,return,null
RestServerEndpoint -> @Nullable 	public InetSocketAddress getServerAddress();1535963626;Returns the address on which this endpoint is accepting requests.__@return address on which this endpoint is accepting requests or null if none;@Nullable_	public InetSocketAddress getServerAddress() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			Channel server = this.serverChannel___			if (server != null) {_				try {_					return ((InetSocketAddress) server.localAddress())__				} catch (Exception e) {_					log.error("Cannot access local server address", e)__				}_			}__			return null__		}_	};returns,the,address,on,which,this,endpoint,is,accepting,requests,return,address,on,which,this,endpoint,is,accepting,requests,or,null,if,none;nullable,public,inet,socket,address,get,server,address,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,channel,server,this,server,channel,if,server,null,try,return,inet,socket,address,server,local,address,catch,exception,e,log,error,cannot,access,local,server,address,e,return,null
RestServerEndpoint -> @Nullable 	public InetSocketAddress getServerAddress();1536930104;Returns the address on which this endpoint is accepting requests.__@return address on which this endpoint is accepting requests or null if none;@Nullable_	public InetSocketAddress getServerAddress() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			Channel server = this.serverChannel___			if (server != null) {_				try {_					return ((InetSocketAddress) server.localAddress())__				} catch (Exception e) {_					log.error("Cannot access local server address", e)__				}_			}__			return null__		}_	};returns,the,address,on,which,this,endpoint,is,accepting,requests,return,address,on,which,this,endpoint,is,accepting,requests,or,null,if,none;nullable,public,inet,socket,address,get,server,address,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,channel,server,this,server,channel,if,server,null,try,return,inet,socket,address,server,local,address,catch,exception,e,log,error,cannot,access,local,server,address,e,return,null
RestServerEndpoint -> @Nullable 	public InetSocketAddress getServerAddress();1539170288;Returns the address on which this endpoint is accepting requests.__@return address on which this endpoint is accepting requests or null if none;@Nullable_	public InetSocketAddress getServerAddress() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			Channel server = this.serverChannel___			if (server != null) {_				try {_					return ((InetSocketAddress) server.localAddress())__				} catch (Exception e) {_					log.error("Cannot access local server address", e)__				}_			}__			return null__		}_	};returns,the,address,on,which,this,endpoint,is,accepting,requests,return,address,on,which,this,endpoint,is,accepting,requests,or,null,if,none;nullable,public,inet,socket,address,get,server,address,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,channel,server,this,server,channel,if,server,null,try,return,inet,socket,address,server,local,address,catch,exception,e,log,error,cannot,access,local,server,address,e,return,null
RestServerEndpoint -> @Nullable 	public InetSocketAddress getServerAddress();1539934386;Returns the address on which this endpoint is accepting requests.__@return address on which this endpoint is accepting requests or null if none;@Nullable_	public InetSocketAddress getServerAddress() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			Channel server = this.serverChannel___			if (server != null) {_				try {_					return ((InetSocketAddress) server.localAddress())__				} catch (Exception e) {_					log.error("Cannot access local server address", e)__				}_			}__			return null__		}_	};returns,the,address,on,which,this,endpoint,is,accepting,requests,return,address,on,which,this,endpoint,is,accepting,requests,or,null,if,none;nullable,public,inet,socket,address,get,server,address,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,channel,server,this,server,channel,if,server,null,try,return,inet,socket,address,server,local,address,catch,exception,e,log,error,cannot,access,local,server,address,e,return,null
RestServerEndpoint -> @Nullable 	public InetSocketAddress getServerAddress();1540215410;Returns the address on which this endpoint is accepting requests.__@return address on which this endpoint is accepting requests or null if none;@Nullable_	public InetSocketAddress getServerAddress() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			Channel server = this.serverChannel___			if (server != null) {_				try {_					return ((InetSocketAddress) server.localAddress())__				} catch (Exception e) {_					log.error("Cannot access local server address", e)__				}_			}__			return null__		}_	};returns,the,address,on,which,this,endpoint,is,accepting,requests,return,address,on,which,this,endpoint,is,accepting,requests,or,null,if,none;nullable,public,inet,socket,address,get,server,address,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,channel,server,this,server,channel,if,server,null,try,return,inet,socket,address,server,local,address,catch,exception,e,log,error,cannot,access,local,server,address,e,return,null
RestServerEndpoint -> @Nullable 	public InetSocketAddress getServerAddress();1545326469;Returns the address on which this endpoint is accepting requests.__@return address on which this endpoint is accepting requests or null if none;@Nullable_	public InetSocketAddress getServerAddress() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			Channel server = this.serverChannel___			if (server != null) {_				try {_					return ((InetSocketAddress) server.localAddress())__				} catch (Exception e) {_					log.error("Cannot access local server address", e)__				}_			}__			return null__		}_	};returns,the,address,on,which,this,endpoint,is,accepting,requests,return,address,on,which,this,endpoint,is,accepting,requests,or,null,if,none;nullable,public,inet,socket,address,get,server,address,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,channel,server,this,server,channel,if,server,null,try,return,inet,socket,address,server,local,address,catch,exception,e,log,error,cannot,access,local,server,address,e,return,null
RestServerEndpoint -> @Nullable 	public InetSocketAddress getServerAddress();1550222817;Returns the address on which this endpoint is accepting requests.__@return address on which this endpoint is accepting requests or null if none;@Nullable_	public InetSocketAddress getServerAddress() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			Channel server = this.serverChannel___			if (server != null) {_				try {_					return ((InetSocketAddress) server.localAddress())__				} catch (Exception e) {_					log.error("Cannot access local server address", e)__				}_			}__			return null__		}_	};returns,the,address,on,which,this,endpoint,is,accepting,requests,return,address,on,which,this,endpoint,is,accepting,requests,or,null,if,none;nullable,public,inet,socket,address,get,server,address,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,channel,server,this,server,channel,if,server,null,try,return,inet,socket,address,server,local,address,catch,exception,e,log,error,cannot,access,local,server,address,e,return,null
RestServerEndpoint -> protected abstract Collection<AbstractRestHandler<?, ?, ?, ?>> initializeHandlers()_;1505859747;This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint_implementation requires.;protected abstract Collection<AbstractRestHandler<?, ?, ?, ?>> initializeHandlers()_;this,method,is,called,at,the,beginning,of,link,start,to,setup,all,handlers,that,the,rest,server,endpoint,implementation,requires;protected,abstract,collection,abstract,rest,handler,initialize,handlers
RestServerEndpoint -> protected abstract Collection<AbstractRestHandler<?, ?, ?, ?>> initializeHandlers()_;1505860453;This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint_implementation requires.;protected abstract Collection<AbstractRestHandler<?, ?, ?, ?>> initializeHandlers()_;this,method,is,called,at,the,beginning,of,link,start,to,setup,all,handlers,that,the,rest,server,endpoint,implementation,requires;protected,abstract,collection,abstract,rest,handler,initialize,handlers
RestServerEndpoint -> protected abstract Collection<AbstractRestHandler<?, ?, ?, ?>> initializeHandlers()_;1505860691;This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint_implementation requires.;protected abstract Collection<AbstractRestHandler<?, ?, ?, ?>> initializeHandlers()_;this,method,is,called,at,the,beginning,of,link,start,to,setup,all,handlers,that,the,rest,server,endpoint,implementation,requires;protected,abstract,collection,abstract,rest,handler,initialize,handlers
RestServerEndpoint -> @VisibleForTesting 	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException;1518945174;Creates the upload dir if needed.;@VisibleForTesting_	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (!Files.exists(uploadDir)) {_			log.warn("Upload directory {} does not exist, or has been deleted externally. " +_				"Previously uploaded files are no longer available.", uploadDir)__			checkAndCreateUploadDir(uploadDir, log)__		}_	};creates,the,upload,dir,if,needed;visible,for,testing,static,void,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,log,warn,upload,directory,does,not,exist,or,has,been,deleted,externally,previously,uploaded,files,are,no,longer,available,upload,dir,check,and,create,upload,dir,upload,dir,log
RestServerEndpoint -> @VisibleForTesting 	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException;1519052657;Creates the upload dir if needed.;@VisibleForTesting_	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (!Files.exists(uploadDir)) {_			log.warn("Upload directory {} does not exist, or has been deleted externally. " +_				"Previously uploaded files are no longer available.", uploadDir)__			checkAndCreateUploadDir(uploadDir, log)__		}_	};creates,the,upload,dir,if,needed;visible,for,testing,static,void,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,log,warn,upload,directory,does,not,exist,or,has,been,deleted,externally,previously,uploaded,files,are,no,longer,available,upload,dir,check,and,create,upload,dir,upload,dir,log
RestServerEndpoint -> @VisibleForTesting 	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException;1519406530;Creates the upload dir if needed.;@VisibleForTesting_	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (!Files.exists(uploadDir)) {_			log.warn("Upload directory {} does not exist, or has been deleted externally. " +_				"Previously uploaded files are no longer available.", uploadDir)__			checkAndCreateUploadDir(uploadDir, log)__		}_	};creates,the,upload,dir,if,needed;visible,for,testing,static,void,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,log,warn,upload,directory,does,not,exist,or,has,been,deleted,externally,previously,uploaded,files,are,no,longer,available,upload,dir,check,and,create,upload,dir,upload,dir,log
RestServerEndpoint -> @VisibleForTesting 	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException;1521016670;Creates the upload dir if needed.;@VisibleForTesting_	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (!Files.exists(uploadDir)) {_			log.warn("Upload directory {} does not exist, or has been deleted externally. " +_				"Previously uploaded files are no longer available.", uploadDir)__			checkAndCreateUploadDir(uploadDir, log)__		}_	};creates,the,upload,dir,if,needed;visible,for,testing,static,void,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,log,warn,upload,directory,does,not,exist,or,has,been,deleted,externally,previously,uploaded,files,are,no,longer,available,upload,dir,check,and,create,upload,dir,upload,dir,log
RestServerEndpoint -> @VisibleForTesting 	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException;1521016671;Creates the upload dir if needed.;@VisibleForTesting_	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (!Files.exists(uploadDir)) {_			log.warn("Upload directory {} does not exist, or has been deleted externally. " +_				"Previously uploaded files are no longer available.", uploadDir)__			checkAndCreateUploadDir(uploadDir, log)__		}_	};creates,the,upload,dir,if,needed;visible,for,testing,static,void,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,log,warn,upload,directory,does,not,exist,or,has,been,deleted,externally,previously,uploaded,files,are,no,longer,available,upload,dir,check,and,create,upload,dir,upload,dir,log
RestServerEndpoint -> @VisibleForTesting 	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException;1521016671;Creates the upload dir if needed.;@VisibleForTesting_	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (!Files.exists(uploadDir)) {_			log.warn("Upload directory {} does not exist, or has been deleted externally. " +_				"Previously uploaded files are no longer available.", uploadDir)__			checkAndCreateUploadDir(uploadDir, log)__		}_	};creates,the,upload,dir,if,needed;visible,for,testing,static,void,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,log,warn,upload,directory,does,not,exist,or,has,been,deleted,externally,previously,uploaded,files,are,no,longer,available,upload,dir,check,and,create,upload,dir,upload,dir,log
RestServerEndpoint -> @VisibleForTesting 	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException;1521385094;Creates the upload dir if needed.;@VisibleForTesting_	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (!Files.exists(uploadDir)) {_			log.warn("Upload directory {} does not exist, or has been deleted externally. " +_				"Previously uploaded files are no longer available.", uploadDir)__			checkAndCreateUploadDir(uploadDir, log)__		}_	};creates,the,upload,dir,if,needed;visible,for,testing,static,void,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,log,warn,upload,directory,does,not,exist,or,has,been,deleted,externally,previously,uploaded,files,are,no,longer,available,upload,dir,check,and,create,upload,dir,upload,dir,log
RestServerEndpoint -> @VisibleForTesting 	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException;1521804758;Creates the upload dir if needed.;@VisibleForTesting_	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (!Files.exists(uploadDir)) {_			log.warn("Upload directory {} does not exist, or has been deleted externally. " +_				"Previously uploaded files are no longer available.", uploadDir)__			checkAndCreateUploadDir(uploadDir, log)__		}_	};creates,the,upload,dir,if,needed;visible,for,testing,static,void,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,log,warn,upload,directory,does,not,exist,or,has,been,deleted,externally,previously,uploaded,files,are,no,longer,available,upload,dir,check,and,create,upload,dir,upload,dir,log
RestServerEndpoint -> @VisibleForTesting 	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException;1521804758;Creates the upload dir if needed.;@VisibleForTesting_	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (!Files.exists(uploadDir)) {_			log.warn("Upload directory {} does not exist, or has been deleted externally. " +_				"Previously uploaded files are no longer available.", uploadDir)__			checkAndCreateUploadDir(uploadDir, log)__		}_	};creates,the,upload,dir,if,needed;visible,for,testing,static,void,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,log,warn,upload,directory,does,not,exist,or,has,been,deleted,externally,previously,uploaded,files,are,no,longer,available,upload,dir,check,and,create,upload,dir,upload,dir,log
RestServerEndpoint -> @VisibleForTesting 	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException;1525904579;Creates the upload dir if needed.;@VisibleForTesting_	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (!Files.exists(uploadDir)) {_			log.warn("Upload directory {} does not exist, or has been deleted externally. " +_				"Previously uploaded files are no longer available.", uploadDir)__			checkAndCreateUploadDir(uploadDir, log)__		}_	};creates,the,upload,dir,if,needed;visible,for,testing,static,void,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,log,warn,upload,directory,does,not,exist,or,has,been,deleted,externally,previously,uploaded,files,are,no,longer,available,upload,dir,check,and,create,upload,dir,upload,dir,log
RestServerEndpoint -> @VisibleForTesting 	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException;1527499265;Creates the upload dir if needed.;@VisibleForTesting_	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (!Files.exists(uploadDir)) {_			log.warn("Upload directory {} does not exist, or has been deleted externally. " +_				"Previously uploaded files are no longer available.", uploadDir)__			checkAndCreateUploadDir(uploadDir, log)__		}_	};creates,the,upload,dir,if,needed;visible,for,testing,static,void,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,log,warn,upload,directory,does,not,exist,or,has,been,deleted,externally,previously,uploaded,files,are,no,longer,available,upload,dir,check,and,create,upload,dir,upload,dir,log
RestServerEndpoint -> @VisibleForTesting 	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException;1528876304;Creates the upload dir if needed.;@VisibleForTesting_	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (!Files.exists(uploadDir)) {_			log.warn("Upload directory {} does not exist, or has been deleted externally. " +_				"Previously uploaded files are no longer available.", uploadDir)__			checkAndCreateUploadDir(uploadDir, log)__		}_	};creates,the,upload,dir,if,needed;visible,for,testing,static,void,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,log,warn,upload,directory,does,not,exist,or,has,been,deleted,externally,previously,uploaded,files,are,no,longer,available,upload,dir,check,and,create,upload,dir,upload,dir,log
RestServerEndpoint -> @VisibleForTesting 	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException;1534259541;Creates the upload dir if needed.;@VisibleForTesting_	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (!Files.exists(uploadDir)) {_			log.warn("Upload directory {} does not exist, or has been deleted externally. " +_				"Previously uploaded files are no longer available.", uploadDir)__			checkAndCreateUploadDir(uploadDir, log)__		}_	};creates,the,upload,dir,if,needed;visible,for,testing,static,void,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,log,warn,upload,directory,does,not,exist,or,has,been,deleted,externally,previously,uploaded,files,are,no,longer,available,upload,dir,check,and,create,upload,dir,upload,dir,log
RestServerEndpoint -> @VisibleForTesting 	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException;1535963626;Creates the upload dir if needed.;@VisibleForTesting_	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (!Files.exists(uploadDir)) {_			log.warn("Upload directory {} does not exist, or has been deleted externally. " +_				"Previously uploaded files are no longer available.", uploadDir)__			checkAndCreateUploadDir(uploadDir, log)__		}_	};creates,the,upload,dir,if,needed;visible,for,testing,static,void,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,log,warn,upload,directory,does,not,exist,or,has,been,deleted,externally,previously,uploaded,files,are,no,longer,available,upload,dir,check,and,create,upload,dir,upload,dir,log
RestServerEndpoint -> @VisibleForTesting 	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException;1536930104;Creates the upload dir if needed.;@VisibleForTesting_	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (!Files.exists(uploadDir)) {_			log.warn("Upload directory {} does not exist, or has been deleted externally. " +_				"Previously uploaded files are no longer available.", uploadDir)__			checkAndCreateUploadDir(uploadDir, log)__		}_	};creates,the,upload,dir,if,needed;visible,for,testing,static,void,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,log,warn,upload,directory,does,not,exist,or,has,been,deleted,externally,previously,uploaded,files,are,no,longer,available,upload,dir,check,and,create,upload,dir,upload,dir,log
RestServerEndpoint -> @VisibleForTesting 	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException;1539170288;Creates the upload dir if needed.;@VisibleForTesting_	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (!Files.exists(uploadDir)) {_			log.warn("Upload directory {} does not exist, or has been deleted externally. " +_				"Previously uploaded files are no longer available.", uploadDir)__			checkAndCreateUploadDir(uploadDir, log)__		}_	};creates,the,upload,dir,if,needed;visible,for,testing,static,void,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,log,warn,upload,directory,does,not,exist,or,has,been,deleted,externally,previously,uploaded,files,are,no,longer,available,upload,dir,check,and,create,upload,dir,upload,dir,log
RestServerEndpoint -> @VisibleForTesting 	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException;1539934386;Creates the upload dir if needed.;@VisibleForTesting_	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (!Files.exists(uploadDir)) {_			log.warn("Upload directory {} does not exist, or has been deleted externally. " +_				"Previously uploaded files are no longer available.", uploadDir)__			checkAndCreateUploadDir(uploadDir, log)__		}_	};creates,the,upload,dir,if,needed;visible,for,testing,static,void,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,log,warn,upload,directory,does,not,exist,or,has,been,deleted,externally,previously,uploaded,files,are,no,longer,available,upload,dir,check,and,create,upload,dir,upload,dir,log
RestServerEndpoint -> @VisibleForTesting 	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException;1540215410;Creates the upload dir if needed.;@VisibleForTesting_	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (!Files.exists(uploadDir)) {_			log.warn("Upload directory {} does not exist, or has been deleted externally. " +_				"Previously uploaded files are no longer available.", uploadDir)__			checkAndCreateUploadDir(uploadDir, log)__		}_	};creates,the,upload,dir,if,needed;visible,for,testing,static,void,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,log,warn,upload,directory,does,not,exist,or,has,been,deleted,externally,previously,uploaded,files,are,no,longer,available,upload,dir,check,and,create,upload,dir,upload,dir,log
RestServerEndpoint -> @VisibleForTesting 	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException;1545326469;Creates the upload dir if needed.;@VisibleForTesting_	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (!Files.exists(uploadDir)) {_			log.warn("Upload directory {} does not exist, or has been deleted externally. " +_				"Previously uploaded files are no longer available.", uploadDir)__			checkAndCreateUploadDir(uploadDir, log)__		}_	};creates,the,upload,dir,if,needed;visible,for,testing,static,void,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,log,warn,upload,directory,does,not,exist,or,has,been,deleted,externally,previously,uploaded,files,are,no,longer,available,upload,dir,check,and,create,upload,dir,upload,dir,log
RestServerEndpoint -> @VisibleForTesting 	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException;1550222817;Creates the upload dir if needed.;@VisibleForTesting_	static void createUploadDir(final Path uploadDir, final Logger log) throws IOException {_		if (!Files.exists(uploadDir)) {_			log.warn("Upload directory {} does not exist, or has been deleted externally. " +_				"Previously uploaded files are no longer available.", uploadDir)__			checkAndCreateUploadDir(uploadDir, log)__		}_	};creates,the,upload,dir,if,needed;visible,for,testing,static,void,create,upload,dir,final,path,upload,dir,final,logger,log,throws,ioexception,if,files,exists,upload,dir,log,warn,upload,directory,does,not,exist,or,has,been,deleted,externally,previously,uploaded,files,are,no,longer,available,upload,dir,check,and,create,upload,dir,upload,dir,log
RestServerEndpoint -> public String getRestAddress();1505860453;Returns the address of the REST server endpoint. Since the address is only known_after the endpoint is started, it is returned as a future which is completed_with the REST address at start up.__@return REST address of this endpoint;public String getRestAddress() {_		Preconditions.checkState(started, "The RestServerEndpoint has not been started yet.")__		return restAddress__	};returns,the,address,of,the,rest,server,endpoint,since,the,address,is,only,known,after,the,endpoint,is,started,it,is,returned,as,a,future,which,is,completed,with,the,rest,address,at,start,up,return,rest,address,of,this,endpoint;public,string,get,rest,address,preconditions,check,state,started,the,rest,server,endpoint,has,not,been,started,yet,return,rest,address
RestServerEndpoint -> public String getRestAddress();1505860691;Returns the address of the REST server endpoint. Since the address is only known_after the endpoint is started, it is returned as a future which is completed_with the REST address at start up.__@return REST address of this endpoint;public String getRestAddress() {_		Preconditions.checkState(started, "The RestServerEndpoint has not been started yet.")__		return restAddress__	};returns,the,address,of,the,rest,server,endpoint,since,the,address,is,only,known,after,the,endpoint,is,started,it,is,returned,as,a,future,which,is,completed,with,the,rest,address,at,start,up,return,rest,address,of,this,endpoint;public,string,get,rest,address,preconditions,check,state,started,the,rest,server,endpoint,has,not,been,started,yet,return,rest,address
RestServerEndpoint -> public String getRestAddress();1505896530;Returns the address of the REST server endpoint. Since the address is only known_after the endpoint is started, it is returned as a future which is completed_with the REST address at start up.__@return REST address of this endpoint;public String getRestAddress() {_		Preconditions.checkState(started, "The RestServerEndpoint has not been started yet.")__		return restAddress__	};returns,the,address,of,the,rest,server,endpoint,since,the,address,is,only,known,after,the,endpoint,is,started,it,is,returned,as,a,future,which,is,completed,with,the,rest,address,at,start,up,return,rest,address,of,this,endpoint;public,string,get,rest,address,preconditions,check,state,started,the,rest,server,endpoint,has,not,been,started,yet,return,rest,address
RestServerEndpoint -> public String getRestAddress();1506553599;Returns the address of the REST server endpoint. Since the address is only known_after the endpoint is started, it is returned as a future which is completed_with the REST address at start up.__@return REST address of this endpoint;public String getRestAddress() {_		Preconditions.checkState(started, "The RestServerEndpoint has not been started yet.")__		return restAddress__	};returns,the,address,of,the,rest,server,endpoint,since,the,address,is,only,known,after,the,endpoint,is,started,it,is,returned,as,a,future,which,is,completed,with,the,rest,address,at,start,up,return,rest,address,of,this,endpoint;public,string,get,rest,address,preconditions,check,state,started,the,rest,server,endpoint,has,not,been,started,yet,return,rest,address
RestServerEndpoint -> public String getRestAddress();1507569104;Returns the address of the REST server endpoint. Since the address is only known_after the endpoint is started, it is returned as a future which is completed_with the REST address at start up.__@return REST address of this endpoint;public String getRestAddress() {_		Preconditions.checkState(started, "The RestServerEndpoint has not been started yet.")__		return restAddress__	};returns,the,address,of,the,rest,server,endpoint,since,the,address,is,only,known,after,the,endpoint,is,started,it,is,returned,as,a,future,which,is,completed,with,the,rest,address,at,start,up,return,rest,address,of,this,endpoint;public,string,get,rest,address,preconditions,check,state,started,the,rest,server,endpoint,has,not,been,started,yet,return,rest,address
RestServerEndpoint -> public String getRestAddress();1510220918;Returns the address of the REST server endpoint. Since the address is only known_after the endpoint is started, it is returned as a future which is completed_with the REST address at start up.__@return REST address of this endpoint;public String getRestAddress() {_		Preconditions.checkState(started, "The RestServerEndpoint has not been started yet.")__		return restAddress__	};returns,the,address,of,the,rest,server,endpoint,since,the,address,is,only,known,after,the,endpoint,is,started,it,is,returned,as,a,future,which,is,completed,with,the,rest,address,at,start,up,return,rest,address,of,this,endpoint;public,string,get,rest,address,preconditions,check,state,started,the,rest,server,endpoint,has,not,been,started,yet,return,rest,address
RestServerEndpoint -> public String getRestAddress();1512650422;Returns the address of the REST server endpoint. Since the address is only known_after the endpoint is started, it is returned as a future which is completed_with the REST address at start up.__@return REST address of this endpoint;public String getRestAddress() {_		Preconditions.checkState(started, "The RestServerEndpoint has not been started yet.")__		return restAddress__	};returns,the,address,of,the,rest,server,endpoint,since,the,address,is,only,known,after,the,endpoint,is,started,it,is,returned,as,a,future,which,is,completed,with,the,rest,address,at,start,up,return,rest,address,of,this,endpoint;public,string,get,rest,address,preconditions,check,state,started,the,rest,server,endpoint,has,not,been,started,yet,return,rest,address
RestServerEndpoint -> public String getRestAddress();1516098457;Returns the address of the REST server endpoint. Since the address is only known_after the endpoint is started, it is returned as a future which is completed_with the REST address at start up.__@return REST address of this endpoint;public String getRestAddress() {_		Preconditions.checkState(started, "The RestServerEndpoint has not been started yet.")__		return restAddress__	};returns,the,address,of,the,rest,server,endpoint,since,the,address,is,only,known,after,the,endpoint,is,started,it,is,returned,as,a,future,which,is,completed,with,the,rest,address,at,start,up,return,rest,address,of,this,endpoint;public,string,get,rest,address,preconditions,check,state,started,the,rest,server,endpoint,has,not,been,started,yet,return,rest,address
RestServerEndpoint -> public String getRestAddress();1516971023;Returns the address of the REST server endpoint. Since the address is only known_after the endpoint is started, it is returned as a future which is completed_with the REST address at start up.__@return REST address of this endpoint;public String getRestAddress() {_		Preconditions.checkState(started, "The RestServerEndpoint has not been started yet.")__		return restAddress__	};returns,the,address,of,the,rest,server,endpoint,since,the,address,is,only,known,after,the,endpoint,is,started,it,is,returned,as,a,future,which,is,completed,with,the,rest,address,at,start,up,return,rest,address,of,this,endpoint;public,string,get,rest,address,preconditions,check,state,started,the,rest,server,endpoint,has,not,been,started,yet,return,rest,address
RestServerEndpoint -> public String getRestAddress();1516971023;Returns the address of the REST server endpoint.__@return REST address of this endpoint;public String getRestAddress() {_		Preconditions.checkState(started, "The RestServerEndpoint has not been started yet.")__		return restAddress__	};returns,the,address,of,the,rest,server,endpoint,return,rest,address,of,this,endpoint;public,string,get,rest,address,preconditions,check,state,started,the,rest,server,endpoint,has,not,been,started,yet,return,rest,address
RestServerEndpoint -> public String getRestAddress();1518680660;Returns the address of the REST server endpoint.__@return REST address of this endpoint;public String getRestAddress() {_		Preconditions.checkState(started, "The RestServerEndpoint has not been started yet.")__		return restAddress__	};returns,the,address,of,the,rest,server,endpoint,return,rest,address,of,this,endpoint;public,string,get,rest,address,preconditions,check,state,started,the,rest,server,endpoint,has,not,been,started,yet,return,rest,address
RestServerEndpoint -> public String getRestAddress();1518945174;Returns the address of the REST server endpoint.__@return REST address of this endpoint;public String getRestAddress() {_		Preconditions.checkState(started, "The RestServerEndpoint has not been started yet.")__		return restAddress__	};returns,the,address,of,the,rest,server,endpoint,return,rest,address,of,this,endpoint;public,string,get,rest,address,preconditions,check,state,started,the,rest,server,endpoint,has,not,been,started,yet,return,rest,address
RestServerEndpoint -> public String getRestAddress();1519052657;Returns the address of the REST server endpoint.__@return REST address of this endpoint;public String getRestAddress() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			return restAddress__		}_	};returns,the,address,of,the,rest,server,endpoint,return,rest,address,of,this,endpoint;public,string,get,rest,address,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,return,rest,address
RestServerEndpoint -> public String getRestAddress();1519406530;Returns the address of the REST server endpoint.__@return REST address of this endpoint;public String getRestAddress() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			return restAddress__		}_	};returns,the,address,of,the,rest,server,endpoint,return,rest,address,of,this,endpoint;public,string,get,rest,address,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,return,rest,address
RestServerEndpoint -> public String getRestAddress();1521016670;Returns the address of the REST server endpoint.__@return REST address of this endpoint;public String getRestAddress() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			return restAddress__		}_	};returns,the,address,of,the,rest,server,endpoint,return,rest,address,of,this,endpoint;public,string,get,rest,address,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,return,rest,address
RestServerEndpoint -> public String getRestAddress();1521016671;Returns the address of the REST server endpoint.__@return REST address of this endpoint;public String getRestAddress() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			return restAddress__		}_	};returns,the,address,of,the,rest,server,endpoint,return,rest,address,of,this,endpoint;public,string,get,rest,address,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,return,rest,address
RestServerEndpoint -> public String getRestAddress();1521016671;Returns the address of the REST server endpoint.__@return REST address of this endpoint;public String getRestAddress() {_		synchronized (lock) {_			Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.")__			return restAddress__		}_	};returns,the,address,of,the,rest,server,endpoint,return,rest,address,of,this,endpoint;public,string,get,rest,address,synchronized,lock,preconditions,check,state,state,state,created,the,rest,server,endpoint,has,not,been,started,yet,return,rest,address
