# id;timestamp;commentText;codeText;commentWords;codeWords
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1498493279;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1498580984;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1500977056;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1502714913;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1503412385;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1503573855;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1503580260;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1503581387;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1503588382;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1505768302;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1505861185;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1505921975;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1505984004;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1506005238;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1506346199;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1506510152;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1507284174;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1507673791;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1507738083;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1508840168;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1510061826;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1510699852;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1511543029;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1511975541;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1512136929;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1512567555;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1513261475;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1513706333;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1514829582;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1516197717;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1516368003;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1516641064;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1516797761;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1516896219;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1517300523;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1517425569;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1517911296;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1517920262;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1518093789;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1518194413;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1518393108;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1518522104;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1518524281;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1518531558;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1518532391;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1518534881;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1518539372;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1518606541;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1518689135;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1518716619;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1518718788;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1519299413;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1519320257;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1519390630;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1519408304;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1519931395;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1519999896;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1521033687;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1521049936;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1521224209;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1521641386;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1521810529;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1521816200;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1521816389;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1521817317;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1522130448;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1522136713;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1522230836;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1522849636;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1525374816;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1525934187;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1526300085;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1526311855;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1526561054;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1526997218;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1527029265;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1527094227;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1529603022;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1529915670;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1530791303;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1532289479;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1532293098;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1533374562;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1534937274;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1536826537;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1538403115;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message", t)__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,t,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1538764056;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message", t)__				}_			})__		} else {_			String errorMessage = "Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,t,else,string,error,message,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1538864611;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message")__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1542043300;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message", t)__				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,t,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1542304303;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message", t)__				}_			})__		} else {_			String errorMessage = "Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,t,else,string,error,message,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1543229263;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message", t)__				}_			})__		} else {_			String errorMessage = "Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,t,else,string,error,message,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1544094547;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message", t)__				}_			})__		} else {_			String errorMessage = "Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,t,else,string,error,message,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1547809055;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message", t)__				}_			})__		} else {_			String errorMessage = "Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,t,else,string,error,message,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1547809099;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message", t)__				}_			})__		} else {_			String errorMessage = "Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,t,else,string,error,message,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1547809385;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message", t)__				}_			})__		} else {_			String errorMessage = "Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,t,else,string,error,message,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1548086094;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message", t)__				}_			})__		} else {_			String errorMessage = "Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,t,else,string,error,message,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1548172161;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message", t)__				}_			})__		} else {_			String errorMessage = "Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,t,else,string,error,message,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1548172454;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message", t)__				}_			})__		} else {_			String errorMessage = "Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,t,else,string,error,message,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1548679824;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message", t)__				}_			})__		} else {_			String errorMessage = "Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,t,else,string,error,message,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1549036717;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message", t)__				}_			})__		} else {_			String errorMessage = "Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,t,else,string,error,message,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1549381698;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message", t)__				}_			})__		} else {_			String errorMessage = "Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,t,else,string,error,message,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1549533702;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message", t)__				}_			})__		} else {_			String errorMessage = "Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,t,else,string,error,message,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1549965236;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message", t)__				}_			})__		} else {_			String errorMessage = "Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,t,else,string,error,message,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1549983516;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message", t)__				}_			})__		} else {_			String errorMessage = "Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,t,else,string,error,message,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1550366933;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message", t)__				}_			})__		} else {_			String errorMessage = "Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,t,else,string,error,message,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1550405950;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message", t)__				}_			})__		} else {_			String errorMessage = "Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,t,else,string,error,message,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final TaskStateSnapshot checkpointState);1550572312;TODO: This method needs a leader session ID;@Override_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final TaskStateSnapshot checkpointState) {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = new AcknowledgeCheckpoint(_			jobID,_			executionAttemptID,_			checkpointId,_			checkpointMetrics,_			checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__				} catch (Throwable t) {_					log.warn("Error while processing checkpoint acknowledgement message", t)__				}_			})__		} else {_			String errorMessage = "Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,task,state,snapshot,checkpoint,state,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,t,else,string,error,message,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint(DeclineCheckpoint decline);1538764056;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(DeclineCheckpoint decline) {_		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			String errorMessage = "Received DeclineCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,decline,checkpoint,decline,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,string,error,message,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint(DeclineCheckpoint decline);1542043300;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(DeclineCheckpoint decline) {_		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,decline,checkpoint,decline,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint(DeclineCheckpoint decline);1542304303;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(DeclineCheckpoint decline) {_		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			String errorMessage = "Received DeclineCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,decline,checkpoint,decline,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,string,error,message,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint(DeclineCheckpoint decline);1543229263;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(DeclineCheckpoint decline) {_		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			String errorMessage = "Received DeclineCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,decline,checkpoint,decline,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,string,error,message,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint(DeclineCheckpoint decline);1544094547;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(DeclineCheckpoint decline) {_		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			String errorMessage = "Received DeclineCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,decline,checkpoint,decline,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,string,error,message,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint(DeclineCheckpoint decline);1547809055;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(DeclineCheckpoint decline) {_		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			String errorMessage = "Received DeclineCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,decline,checkpoint,decline,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,string,error,message,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint(DeclineCheckpoint decline);1547809099;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(DeclineCheckpoint decline) {_		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			String errorMessage = "Received DeclineCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,decline,checkpoint,decline,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,string,error,message,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint(DeclineCheckpoint decline);1547809385;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(DeclineCheckpoint decline) {_		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			String errorMessage = "Received DeclineCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,decline,checkpoint,decline,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,string,error,message,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint(DeclineCheckpoint decline);1548086094;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(DeclineCheckpoint decline) {_		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			String errorMessage = "Received DeclineCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,decline,checkpoint,decline,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,string,error,message,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint(DeclineCheckpoint decline);1548172161;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(DeclineCheckpoint decline) {_		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			String errorMessage = "Received DeclineCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,decline,checkpoint,decline,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,string,error,message,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint(DeclineCheckpoint decline);1548172454;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(DeclineCheckpoint decline) {_		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			String errorMessage = "Received DeclineCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,decline,checkpoint,decline,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,string,error,message,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint(DeclineCheckpoint decline);1548679824;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(DeclineCheckpoint decline) {_		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			String errorMessage = "Received DeclineCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,decline,checkpoint,decline,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,string,error,message,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint(DeclineCheckpoint decline);1549036717;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(DeclineCheckpoint decline) {_		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			String errorMessage = "Received DeclineCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,decline,checkpoint,decline,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,string,error,message,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint(DeclineCheckpoint decline);1549381698;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(DeclineCheckpoint decline) {_		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			String errorMessage = "Received DeclineCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,decline,checkpoint,decline,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,string,error,message,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint(DeclineCheckpoint decline);1549533702;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(DeclineCheckpoint decline) {_		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			String errorMessage = "Received DeclineCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,decline,checkpoint,decline,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,string,error,message,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint(DeclineCheckpoint decline);1549965236;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(DeclineCheckpoint decline) {_		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			String errorMessage = "Received DeclineCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,decline,checkpoint,decline,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,string,error,message,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint(DeclineCheckpoint decline);1549983516;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(DeclineCheckpoint decline) {_		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			String errorMessage = "Received DeclineCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,decline,checkpoint,decline,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,string,error,message,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint(DeclineCheckpoint decline);1550366933;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(DeclineCheckpoint decline) {_		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			String errorMessage = "Received DeclineCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,decline,checkpoint,decline,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,string,error,message,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint(DeclineCheckpoint decline);1550405950;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(DeclineCheckpoint decline) {_		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			String errorMessage = "Received DeclineCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,decline,checkpoint,decline,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,string,error,message,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint(DeclineCheckpoint decline);1550572312;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(DeclineCheckpoint decline) {_		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			String errorMessage = "Received DeclineCheckpoint message for job {} with no CheckpointCoordinator"__			if (executionGraph.getState() == JobStatus.RUNNING) {_				log.error(errorMessage, jobGraph.getJobID())__			} else {_				log.debug(errorMessage, jobGraph.getJobID())__			}_		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,decline,checkpoint,decline,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,string,error,message,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,if,execution,graph,get,state,job,status,running,log,error,error,message,job,graph,get,job,id,else,log,debug,error,message,job,graph,get,job,id
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1518718788;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		return slotPool.getTerminationFuture()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,return,slot,pool,get,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1519299413;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1519320257;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1519390630;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1519408304;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1519931395;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1519999896;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1521033687;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1521049936;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1521224209;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1521641386;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1521810529;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1521816200;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1521816389;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1521817317;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1522130448;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1522136713;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1522230836;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1522849636;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1525374816;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1525934187;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1526300085;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1526311855;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1526561054;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1526997218;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1527029265;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1527094227;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1529603022;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1529915670;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1530791303;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1532289479;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1532293098;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1533374562;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1534937274;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1536826537;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1538403115;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1538864611;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1542043300;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1542304303;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1543229263;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1544094547;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1547809055;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1547809099;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1547809385;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1548086094;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1548172161;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1548172454;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1548679824;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1549036717;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1549381698;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> postStop();1549965236;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> postStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,post,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1503573855;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		leaderSessionID = null___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,leader,session,id,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1503580260;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		leaderSessionID = null___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,leader,session,id,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1503588382;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(JobMasterId.INITIAL_JOB_MASTER_ID)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,job,master,id,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1505768302;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1505861185;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (Objects.equals(JobMasterId.INITIAL_JOB_MASTER_ID, getFencingToken())) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(JobMasterId.INITIAL_JOB_MASTER_ID)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,objects,equals,job,master,id,get,fencing,token,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,job,master,id,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1505921975;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1505984004;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1506005238;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1506346199;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1506510152;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1507284174;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1507673791;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1507738083;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1508840168;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1510061826;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1510699852;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1511543029;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1511975541;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1512136929;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1512567555;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1513261475;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1513706333;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1514829582;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1516197717;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1516368003;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1516641064;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1516797761;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1516896219;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1517425569;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1517911296;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1517920262;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1518093789;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1518194413;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1518393108;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1518522104;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1518524281;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1518532391;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Throwable cause);1518689135;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Throwable cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,throwable,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause,return,acknowledge,get
JobMaster -> public void init() throws JobSubmissionException;1473307213;Initializing the job execution environment, should be called before start. Any error occurred during_initialization will be treated as job submission failure.__@throws JobSubmissionException;public void init() throws JobSubmissionException {_		log.info("Initializing job {} ({}).", jobGraph.getName(), jobGraph.getJobID())___		try {_			_			_			_			try {_				libraryCacheManager.registerJob(jobGraph.getJobID(), jobGraph.getUserJarBlobKeys(),_					jobGraph.getClasspaths())__			} catch (Throwable t) {_				throw new JobSubmissionException(jobGraph.getJobID(),_					"Cannot set up the user code libraries: " + t.getMessage(), t)__			}__			userCodeLoader = libraryCacheManager.getClassLoader(jobGraph.getJobID())__			if (userCodeLoader == null) {_				throw new JobSubmissionException(jobGraph.getJobID(),_					"The user code class loader could not be initialized.")__			}__			if (jobGraph.getNumberOfVertices() == 0) {_				throw new JobSubmissionException(jobGraph.getJobID(), "The given job is empty")__			}__			final RestartStrategies.RestartStrategyConfiguration restartStrategyConfiguration =_				jobGraph.getSerializedExecutionConfig()_					.deserializeValue(userCodeLoader)_					.getRestartStrategy()__			if (restartStrategyConfiguration != null) {_				restartStrategy = RestartStrategyFactory.createRestartStrategy(restartStrategyConfiguration)__			} else {_				restartStrategy = restartStrategyFactory.createRestartStrategy()__			}__			log.info("Using restart strategy {} for {} ({}).", restartStrategy, jobGraph.getName(), jobGraph.getJobID())___			if (jobManagerMetricGroup != null) {_				jobMetrics = jobManagerMetricGroup.addJob(jobGraph)__			}_			if (jobMetrics == null) {_				jobMetrics = new UnregisteredMetricsGroup()__			}__			try {_				checkpointRecoveryFactory = highAvailabilityServices.getCheckpointRecoveryFactory()__			} catch (Exception e) {_				log.error("Could not get the checkpoint recovery factory.", e)__				throw new JobSubmissionException(jobGraph.getJobID(), "Could not get the checkpoint recovery factory.", e)__			}__		} catch (Throwable t) {_			log.error("Failed to initializing job {} ({})", jobGraph.getName(), jobGraph.getJobID(), t)___			libraryCacheManager.unregisterJob(jobGraph.getJobID())___			if (t instanceof JobSubmissionException) {_				throw (JobSubmissionException) t__			} else {_				throw new JobSubmissionException(jobGraph.getJobID(), "Failed to initialize job " +_					jobGraph.getName() + " (" + jobGraph.getJobID() + ")", t)__			}_		}_	};initializing,the,job,execution,environment,should,be,called,before,start,any,error,occurred,during,initialization,will,be,treated,as,job,submission,failure,throws,job,submission,exception;public,void,init,throws,job,submission,exception,log,info,initializing,job,job,graph,get,name,job,graph,get,job,id,try,try,library,cache,manager,register,job,job,graph,get,job,id,job,graph,get,user,jar,blob,keys,job,graph,get,classpaths,catch,throwable,t,throw,new,job,submission,exception,job,graph,get,job,id,cannot,set,up,the,user,code,libraries,t,get,message,t,user,code,loader,library,cache,manager,get,class,loader,job,graph,get,job,id,if,user,code,loader,null,throw,new,job,submission,exception,job,graph,get,job,id,the,user,code,class,loader,could,not,be,initialized,if,job,graph,get,number,of,vertices,0,throw,new,job,submission,exception,job,graph,get,job,id,the,given,job,is,empty,final,restart,strategies,restart,strategy,configuration,restart,strategy,configuration,job,graph,get,serialized,execution,config,deserialize,value,user,code,loader,get,restart,strategy,if,restart,strategy,configuration,null,restart,strategy,restart,strategy,factory,create,restart,strategy,restart,strategy,configuration,else,restart,strategy,restart,strategy,factory,create,restart,strategy,log,info,using,restart,strategy,for,restart,strategy,job,graph,get,name,job,graph,get,job,id,if,job,manager,metric,group,null,job,metrics,job,manager,metric,group,add,job,job,graph,if,job,metrics,null,job,metrics,new,unregistered,metrics,group,try,checkpoint,recovery,factory,high,availability,services,get,checkpoint,recovery,factory,catch,exception,e,log,error,could,not,get,the,checkpoint,recovery,factory,e,throw,new,job,submission,exception,job,graph,get,job,id,could,not,get,the,checkpoint,recovery,factory,e,catch,throwable,t,log,error,failed,to,initializing,job,job,graph,get,name,job,graph,get,job,id,t,library,cache,manager,unregister,job,job,graph,get,job,id,if,t,instanceof,job,submission,exception,throw,job,submission,exception,t,else,throw,new,job,submission,exception,job,graph,get,job,id,failed,to,initialize,job,job,graph,get,name,job,graph,get,job,id,t
JobMaster -> public void init() throws JobSubmissionException;1474453995;Initializing the job execution environment, should be called before start. Any error occurred during_initialization will be treated as job submission failure.__@throws JobSubmissionException;public void init() throws JobSubmissionException {_		log.info("Initializing job {} ({}).", jobGraph.getName(), jobGraph.getJobID())___		try {_			_			_			_			try {_				libraryCacheManager.registerJob(jobGraph.getJobID(), jobGraph.getUserJarBlobKeys(),_					jobGraph.getClasspaths())__			} catch (Throwable t) {_				throw new JobSubmissionException(jobGraph.getJobID(),_					"Cannot set up the user code libraries: " + t.getMessage(), t)__			}__			userCodeLoader = libraryCacheManager.getClassLoader(jobGraph.getJobID())__			if (userCodeLoader == null) {_				throw new JobSubmissionException(jobGraph.getJobID(),_					"The user code class loader could not be initialized.")__			}__			if (jobGraph.getNumberOfVertices() == 0) {_				throw new JobSubmissionException(jobGraph.getJobID(), "The given job is empty")__			}__			final RestartStrategies.RestartStrategyConfiguration restartStrategyConfiguration =_				jobGraph.getSerializedExecutionConfig()_					.deserializeValue(userCodeLoader)_					.getRestartStrategy()__			if (restartStrategyConfiguration != null) {_				restartStrategy = RestartStrategyFactory.createRestartStrategy(restartStrategyConfiguration)__			} else {_				restartStrategy = restartStrategyFactory.createRestartStrategy()__			}__			log.info("Using restart strategy {} for {} ({}).", restartStrategy, jobGraph.getName(), jobGraph.getJobID())___			if (jobManagerMetricGroup != null) {_				jobMetrics = jobManagerMetricGroup.addJob(jobGraph)__			}_			if (jobMetrics == null) {_				jobMetrics = new UnregisteredMetricsGroup()__			}__			try {_				checkpointRecoveryFactory = highAvailabilityServices.getCheckpointRecoveryFactory()__			} catch (Exception e) {_				log.error("Could not get the checkpoint recovery factory.", e)__				throw new JobSubmissionException(jobGraph.getJobID(), "Could not get the checkpoint recovery factory.", e)__			}__		} catch (Throwable t) {_			log.error("Failed to initializing job {} ({})", jobGraph.getName(), jobGraph.getJobID(), t)___			libraryCacheManager.unregisterJob(jobGraph.getJobID())___			if (t instanceof JobSubmissionException) {_				throw (JobSubmissionException) t__			} else {_				throw new JobSubmissionException(jobGraph.getJobID(), "Failed to initialize job " +_					jobGraph.getName() + " (" + jobGraph.getJobID() + ")", t)__			}_		}_	};initializing,the,job,execution,environment,should,be,called,before,start,any,error,occurred,during,initialization,will,be,treated,as,job,submission,failure,throws,job,submission,exception;public,void,init,throws,job,submission,exception,log,info,initializing,job,job,graph,get,name,job,graph,get,job,id,try,try,library,cache,manager,register,job,job,graph,get,job,id,job,graph,get,user,jar,blob,keys,job,graph,get,classpaths,catch,throwable,t,throw,new,job,submission,exception,job,graph,get,job,id,cannot,set,up,the,user,code,libraries,t,get,message,t,user,code,loader,library,cache,manager,get,class,loader,job,graph,get,job,id,if,user,code,loader,null,throw,new,job,submission,exception,job,graph,get,job,id,the,user,code,class,loader,could,not,be,initialized,if,job,graph,get,number,of,vertices,0,throw,new,job,submission,exception,job,graph,get,job,id,the,given,job,is,empty,final,restart,strategies,restart,strategy,configuration,restart,strategy,configuration,job,graph,get,serialized,execution,config,deserialize,value,user,code,loader,get,restart,strategy,if,restart,strategy,configuration,null,restart,strategy,restart,strategy,factory,create,restart,strategy,restart,strategy,configuration,else,restart,strategy,restart,strategy,factory,create,restart,strategy,log,info,using,restart,strategy,for,restart,strategy,job,graph,get,name,job,graph,get,job,id,if,job,manager,metric,group,null,job,metrics,job,manager,metric,group,add,job,job,graph,if,job,metrics,null,job,metrics,new,unregistered,metrics,group,try,checkpoint,recovery,factory,high,availability,services,get,checkpoint,recovery,factory,catch,exception,e,log,error,could,not,get,the,checkpoint,recovery,factory,e,throw,new,job,submission,exception,job,graph,get,job,id,could,not,get,the,checkpoint,recovery,factory,e,catch,throwable,t,log,error,failed,to,initializing,job,job,graph,get,name,job,graph,get,job,id,t,library,cache,manager,unregister,job,job,graph,get,job,id,if,t,instanceof,job,submission,exception,throw,job,submission,exception,t,else,throw,new,job,submission,exception,job,graph,get,job,id,failed,to,initialize,job,job,graph,get,name,job,graph,get,job,id,t
JobMaster -> public void init() throws JobSubmissionException;1474858756;Initializing the job execution environment, should be called before start. Any error occurred during_initialization will be treated as job submission failure.__@throws JobSubmissionException;public void init() throws JobSubmissionException {_		log.info("Initializing job {} ({}).", jobGraph.getName(), jobGraph.getJobID())___		try {_			_			_			_			try {_				libraryCacheManager.registerJob(jobGraph.getJobID(), jobGraph.getUserJarBlobKeys(),_					jobGraph.getClasspaths())__			} catch (Throwable t) {_				throw new JobSubmissionException(jobGraph.getJobID(),_					"Cannot set up the user code libraries: " + t.getMessage(), t)__			}__			userCodeLoader = libraryCacheManager.getClassLoader(jobGraph.getJobID())__			if (userCodeLoader == null) {_				throw new JobSubmissionException(jobGraph.getJobID(),_					"The user code class loader could not be initialized.")__			}__			if (jobGraph.getNumberOfVertices() == 0) {_				throw new JobSubmissionException(jobGraph.getJobID(), "The given job is empty")__			}__			final RestartStrategies.RestartStrategyConfiguration restartStrategyConfiguration =_				jobGraph.getSerializedExecutionConfig()_					.deserializeValue(userCodeLoader)_					.getRestartStrategy()__			if (restartStrategyConfiguration != null) {_				restartStrategy = RestartStrategyFactory.createRestartStrategy(restartStrategyConfiguration)__			}_			else {_				restartStrategy = restartStrategyFactory.createRestartStrategy()__			}__			log.info("Using restart strategy {} for {} ({}).", restartStrategy, jobGraph.getName(), jobGraph.getJobID())___			if (jobManagerMetricGroup != null) {_				jobMetrics = jobManagerMetricGroup.addJob(jobGraph)__			}_			if (jobMetrics == null) {_				jobMetrics = new UnregisteredMetricsGroup()__			}__			try {_				checkpointRecoveryFactory = highAvailabilityServices.getCheckpointRecoveryFactory()__			} catch (Exception e) {_				log.error("Could not get the checkpoint recovery factory.", e)__				throw new JobSubmissionException(jobGraph.getJobID(), "Could not get the checkpoint recovery factory.", e)__			}__			try {_				resourceManagerLeaderRetriever = highAvailabilityServices.getResourceManagerLeaderRetriever()__			} catch (Exception e) {_				log.error("Could not get the resource manager leader retriever.", e)__				throw new JobSubmissionException(jobGraph.getJobID(),_					"Could not get the resource manager leader retriever.", e)__			}_		} catch (Throwable t) {_			log.error("Failed to initializing job {} ({})", jobGraph.getName(), jobGraph.getJobID(), t)___			libraryCacheManager.unregisterJob(jobGraph.getJobID())___			if (t instanceof JobSubmissionException) {_				throw (JobSubmissionException) t__			}_			else {_				throw new JobSubmissionException(jobGraph.getJobID(), "Failed to initialize job " +_					jobGraph.getName() + " (" + jobGraph.getJobID() + ")", t)__			}_		}_	};initializing,the,job,execution,environment,should,be,called,before,start,any,error,occurred,during,initialization,will,be,treated,as,job,submission,failure,throws,job,submission,exception;public,void,init,throws,job,submission,exception,log,info,initializing,job,job,graph,get,name,job,graph,get,job,id,try,try,library,cache,manager,register,job,job,graph,get,job,id,job,graph,get,user,jar,blob,keys,job,graph,get,classpaths,catch,throwable,t,throw,new,job,submission,exception,job,graph,get,job,id,cannot,set,up,the,user,code,libraries,t,get,message,t,user,code,loader,library,cache,manager,get,class,loader,job,graph,get,job,id,if,user,code,loader,null,throw,new,job,submission,exception,job,graph,get,job,id,the,user,code,class,loader,could,not,be,initialized,if,job,graph,get,number,of,vertices,0,throw,new,job,submission,exception,job,graph,get,job,id,the,given,job,is,empty,final,restart,strategies,restart,strategy,configuration,restart,strategy,configuration,job,graph,get,serialized,execution,config,deserialize,value,user,code,loader,get,restart,strategy,if,restart,strategy,configuration,null,restart,strategy,restart,strategy,factory,create,restart,strategy,restart,strategy,configuration,else,restart,strategy,restart,strategy,factory,create,restart,strategy,log,info,using,restart,strategy,for,restart,strategy,job,graph,get,name,job,graph,get,job,id,if,job,manager,metric,group,null,job,metrics,job,manager,metric,group,add,job,job,graph,if,job,metrics,null,job,metrics,new,unregistered,metrics,group,try,checkpoint,recovery,factory,high,availability,services,get,checkpoint,recovery,factory,catch,exception,e,log,error,could,not,get,the,checkpoint,recovery,factory,e,throw,new,job,submission,exception,job,graph,get,job,id,could,not,get,the,checkpoint,recovery,factory,e,try,resource,manager,leader,retriever,high,availability,services,get,resource,manager,leader,retriever,catch,exception,e,log,error,could,not,get,the,resource,manager,leader,retriever,e,throw,new,job,submission,exception,job,graph,get,job,id,could,not,get,the,resource,manager,leader,retriever,e,catch,throwable,t,log,error,failed,to,initializing,job,job,graph,get,name,job,graph,get,job,id,t,library,cache,manager,unregister,job,job,graph,get,job,id,if,t,instanceof,job,submission,exception,throw,job,submission,exception,t,else,throw,new,job,submission,exception,job,graph,get,job,id,failed,to,initialize,job,job,graph,get,name,job,graph,get,job,id,t
JobMaster -> public void init() throws JobSubmissionException;1475066391;Initializing the job execution environment, should be called before start. Any error occurred during_initialization will be treated as job submission failure.__@throws JobSubmissionException;public void init() throws JobSubmissionException {_		log.info("Initializing job {} ({}).", jobGraph.getName(), jobGraph.getJobID())___		try {_			_			_			_			try {_				libraryCacheManager.registerJob(jobGraph.getJobID(), jobGraph.getUserJarBlobKeys(),_					jobGraph.getClasspaths())__			} catch (Throwable t) {_				throw new JobSubmissionException(jobGraph.getJobID(),_					"Cannot set up the user code libraries: " + t.getMessage(), t)__			}__			userCodeLoader = libraryCacheManager.getClassLoader(jobGraph.getJobID())__			if (userCodeLoader == null) {_				throw new JobSubmissionException(jobGraph.getJobID(),_					"The user code class loader could not be initialized.")__			}__			if (jobGraph.getNumberOfVertices() == 0) {_				throw new JobSubmissionException(jobGraph.getJobID(), "The given job is empty")__			}__			final RestartStrategies.RestartStrategyConfiguration restartStrategyConfiguration =_				jobGraph.getSerializedExecutionConfig()_					.deserializeValue(userCodeLoader)_					.getRestartStrategy()__			if (restartStrategyConfiguration != null) {_				restartStrategy = RestartStrategyFactory.createRestartStrategy(restartStrategyConfiguration)__			}_			else {_				restartStrategy = restartStrategyFactory.createRestartStrategy()__			}__			log.info("Using restart strategy {} for {} ({}).", restartStrategy, jobGraph.getName(), jobGraph.getJobID())___			if (jobManagerMetricGroup != null) {_				jobMetrics = jobManagerMetricGroup.addJob(jobGraph)__			}_			if (jobMetrics == null) {_				jobMetrics = new UnregisteredMetricsGroup()__			}__			try {_				checkpointRecoveryFactory = highAvailabilityServices.getCheckpointRecoveryFactory()__			} catch (Exception e) {_				log.error("Could not get the checkpoint recovery factory.", e)__				throw new JobSubmissionException(jobGraph.getJobID(), "Could not get the checkpoint recovery factory.", e)__			}__			try {_				resourceManagerLeaderRetriever = highAvailabilityServices.getResourceManagerLeaderRetriever()__			} catch (Exception e) {_				log.error("Could not get the resource manager leader retriever.", e)__				throw new JobSubmissionException(jobGraph.getJobID(),_					"Could not get the resource manager leader retriever.", e)__			}_		} catch (Throwable t) {_			log.error("Failed to initializing job {} ({})", jobGraph.getName(), jobGraph.getJobID(), t)___			libraryCacheManager.unregisterJob(jobGraph.getJobID())___			if (t instanceof JobSubmissionException) {_				throw (JobSubmissionException) t__			}_			else {_				throw new JobSubmissionException(jobGraph.getJobID(), "Failed to initialize job " +_					jobGraph.getName() + " (" + jobGraph.getJobID() + ")", t)__			}_		}_	};initializing,the,job,execution,environment,should,be,called,before,start,any,error,occurred,during,initialization,will,be,treated,as,job,submission,failure,throws,job,submission,exception;public,void,init,throws,job,submission,exception,log,info,initializing,job,job,graph,get,name,job,graph,get,job,id,try,try,library,cache,manager,register,job,job,graph,get,job,id,job,graph,get,user,jar,blob,keys,job,graph,get,classpaths,catch,throwable,t,throw,new,job,submission,exception,job,graph,get,job,id,cannot,set,up,the,user,code,libraries,t,get,message,t,user,code,loader,library,cache,manager,get,class,loader,job,graph,get,job,id,if,user,code,loader,null,throw,new,job,submission,exception,job,graph,get,job,id,the,user,code,class,loader,could,not,be,initialized,if,job,graph,get,number,of,vertices,0,throw,new,job,submission,exception,job,graph,get,job,id,the,given,job,is,empty,final,restart,strategies,restart,strategy,configuration,restart,strategy,configuration,job,graph,get,serialized,execution,config,deserialize,value,user,code,loader,get,restart,strategy,if,restart,strategy,configuration,null,restart,strategy,restart,strategy,factory,create,restart,strategy,restart,strategy,configuration,else,restart,strategy,restart,strategy,factory,create,restart,strategy,log,info,using,restart,strategy,for,restart,strategy,job,graph,get,name,job,graph,get,job,id,if,job,manager,metric,group,null,job,metrics,job,manager,metric,group,add,job,job,graph,if,job,metrics,null,job,metrics,new,unregistered,metrics,group,try,checkpoint,recovery,factory,high,availability,services,get,checkpoint,recovery,factory,catch,exception,e,log,error,could,not,get,the,checkpoint,recovery,factory,e,throw,new,job,submission,exception,job,graph,get,job,id,could,not,get,the,checkpoint,recovery,factory,e,try,resource,manager,leader,retriever,high,availability,services,get,resource,manager,leader,retriever,catch,exception,e,log,error,could,not,get,the,resource,manager,leader,retriever,e,throw,new,job,submission,exception,job,graph,get,job,id,could,not,get,the,resource,manager,leader,retriever,e,catch,throwable,t,log,error,failed,to,initializing,job,job,graph,get,name,job,graph,get,job,id,t,library,cache,manager,unregister,job,job,graph,get,job,id,if,t,instanceof,job,submission,exception,throw,job,submission,exception,t,else,throw,new,job,submission,exception,job,graph,get,job,id,failed,to,initialize,job,job,graph,get,name,job,graph,get,job,id,t
JobMaster -> public void init() throws JobSubmissionException;1475110587;Initializing the job execution environment, should be called before start. Any error occurred during_initialization will be treated as job submission failure.__@throws JobSubmissionException;public void init() throws JobSubmissionException {_		log.info("Initializing job {} ({}).", jobGraph.getName(), jobGraph.getJobID())___		try {_			_			_			_			try {_				libraryCacheManager.registerJob(jobGraph.getJobID(), jobGraph.getUserJarBlobKeys(),_					jobGraph.getClasspaths())__			} catch (Throwable t) {_				throw new JobSubmissionException(jobGraph.getJobID(),_					"Cannot set up the user code libraries: " + t.getMessage(), t)__			}__			userCodeLoader = libraryCacheManager.getClassLoader(jobGraph.getJobID())__			if (userCodeLoader == null) {_				throw new JobSubmissionException(jobGraph.getJobID(),_					"The user code class loader could not be initialized.")__			}__			if (jobGraph.getNumberOfVertices() == 0) {_				throw new JobSubmissionException(jobGraph.getJobID(), "The given job is empty")__			}__			final RestartStrategies.RestartStrategyConfiguration restartStrategyConfiguration =_				jobGraph.getSerializedExecutionConfig()_					.deserializeValue(userCodeLoader)_					.getRestartStrategy()__			if (restartStrategyConfiguration != null) {_				restartStrategy = RestartStrategyFactory.createRestartStrategy(restartStrategyConfiguration)__			}_			else {_				restartStrategy = restartStrategyFactory.createRestartStrategy()__			}__			log.info("Using restart strategy {} for {} ({}).", restartStrategy, jobGraph.getName(), jobGraph.getJobID())___			if (jobManagerMetricGroup != null) {_				jobMetrics = jobManagerMetricGroup.addJob(jobGraph)__			}_			if (jobMetrics == null) {_				jobMetrics = new UnregisteredMetricsGroup()__			}__			try {_				checkpointRecoveryFactory = highAvailabilityServices.getCheckpointRecoveryFactory()__			} catch (Exception e) {_				log.error("Could not get the checkpoint recovery factory.", e)__				throw new JobSubmissionException(jobGraph.getJobID(), "Could not get the checkpoint recovery factory.", e)__			}__			try {_				resourceManagerLeaderRetriever = highAvailabilityServices.getResourceManagerLeaderRetriever()__			} catch (Exception e) {_				log.error("Could not get the resource manager leader retriever.", e)__				throw new JobSubmissionException(jobGraph.getJobID(),_					"Could not get the resource manager leader retriever.", e)__			}_		} catch (Throwable t) {_			log.error("Failed to initializing job {} ({})", jobGraph.getName(), jobGraph.getJobID(), t)___			libraryCacheManager.unregisterJob(jobGraph.getJobID())___			if (t instanceof JobSubmissionException) {_				throw (JobSubmissionException) t__			}_			else {_				throw new JobSubmissionException(jobGraph.getJobID(), "Failed to initialize job " +_					jobGraph.getName() + " (" + jobGraph.getJobID() + ")", t)__			}_		}_	};initializing,the,job,execution,environment,should,be,called,before,start,any,error,occurred,during,initialization,will,be,treated,as,job,submission,failure,throws,job,submission,exception;public,void,init,throws,job,submission,exception,log,info,initializing,job,job,graph,get,name,job,graph,get,job,id,try,try,library,cache,manager,register,job,job,graph,get,job,id,job,graph,get,user,jar,blob,keys,job,graph,get,classpaths,catch,throwable,t,throw,new,job,submission,exception,job,graph,get,job,id,cannot,set,up,the,user,code,libraries,t,get,message,t,user,code,loader,library,cache,manager,get,class,loader,job,graph,get,job,id,if,user,code,loader,null,throw,new,job,submission,exception,job,graph,get,job,id,the,user,code,class,loader,could,not,be,initialized,if,job,graph,get,number,of,vertices,0,throw,new,job,submission,exception,job,graph,get,job,id,the,given,job,is,empty,final,restart,strategies,restart,strategy,configuration,restart,strategy,configuration,job,graph,get,serialized,execution,config,deserialize,value,user,code,loader,get,restart,strategy,if,restart,strategy,configuration,null,restart,strategy,restart,strategy,factory,create,restart,strategy,restart,strategy,configuration,else,restart,strategy,restart,strategy,factory,create,restart,strategy,log,info,using,restart,strategy,for,restart,strategy,job,graph,get,name,job,graph,get,job,id,if,job,manager,metric,group,null,job,metrics,job,manager,metric,group,add,job,job,graph,if,job,metrics,null,job,metrics,new,unregistered,metrics,group,try,checkpoint,recovery,factory,high,availability,services,get,checkpoint,recovery,factory,catch,exception,e,log,error,could,not,get,the,checkpoint,recovery,factory,e,throw,new,job,submission,exception,job,graph,get,job,id,could,not,get,the,checkpoint,recovery,factory,e,try,resource,manager,leader,retriever,high,availability,services,get,resource,manager,leader,retriever,catch,exception,e,log,error,could,not,get,the,resource,manager,leader,retriever,e,throw,new,job,submission,exception,job,graph,get,job,id,could,not,get,the,resource,manager,leader,retriever,e,catch,throwable,t,log,error,failed,to,initializing,job,job,graph,get,name,job,graph,get,job,id,t,library,cache,manager,unregister,job,job,graph,get,job,id,if,t,instanceof,job,submission,exception,throw,job,submission,exception,t,else,throw,new,job,submission,exception,job,graph,get,job,id,failed,to,initialize,job,job,graph,get,name,job,graph,get,job,id,t
JobMaster -> public void init() throws JobSubmissionException;1475593222;Initializing the job execution environment, should be called before start. Any error occurred during_initialization will be treated as job submission failure.__@throws JobSubmissionException;public void init() throws JobSubmissionException {_		log.info("Initializing job {} ({}).", jobGraph.getName(), jobGraph.getJobID())___		try {_			_			_			_			try {_				libraryCacheManager.registerJob(jobGraph.getJobID(), jobGraph.getUserJarBlobKeys(),_					jobGraph.getClasspaths())__			} catch (Throwable t) {_				throw new JobSubmissionException(jobGraph.getJobID(),_					"Cannot set up the user code libraries: " + t.getMessage(), t)__			}__			userCodeLoader = libraryCacheManager.getClassLoader(jobGraph.getJobID())__			if (userCodeLoader == null) {_				throw new JobSubmissionException(jobGraph.getJobID(),_					"The user code class loader could not be initialized.")__			}__			if (jobGraph.getNumberOfVertices() == 0) {_				throw new JobSubmissionException(jobGraph.getJobID(), "The given job is empty")__			}__			final RestartStrategies.RestartStrategyConfiguration restartStrategyConfiguration =_				jobGraph.getSerializedExecutionConfig()_					.deserializeValue(userCodeLoader)_					.getRestartStrategy()__			if (restartStrategyConfiguration != null) {_				restartStrategy = RestartStrategyFactory.createRestartStrategy(restartStrategyConfiguration)__			}_			else {_				restartStrategy = restartStrategyFactory.createRestartStrategy()__			}__			log.info("Using restart strategy {} for {} ({}).", restartStrategy, jobGraph.getName(), jobGraph.getJobID())___			if (jobManagerMetricGroup != null) {_				jobMetrics = jobManagerMetricGroup.addJob(jobGraph)__			}_			if (jobMetrics == null) {_				jobMetrics = new UnregisteredMetricsGroup()__			}__			try {_				checkpointRecoveryFactory = highAvailabilityServices.getCheckpointRecoveryFactory()__			} catch (Exception e) {_				log.error("Could not get the checkpoint recovery factory.", e)__				throw new JobSubmissionException(jobGraph.getJobID(), "Could not get the checkpoint recovery factory.", e)__			}__			try {_				resourceManagerLeaderRetriever = highAvailabilityServices.getResourceManagerLeaderRetriever()__			} catch (Exception e) {_				log.error("Could not get the resource manager leader retriever.", e)__				throw new JobSubmissionException(jobGraph.getJobID(),_					"Could not get the resource manager leader retriever.", e)__			}_		} catch (Throwable t) {_			log.error("Failed to initializing job {} ({})", jobGraph.getName(), jobGraph.getJobID(), t)___			libraryCacheManager.unregisterJob(jobGraph.getJobID())___			if (t instanceof JobSubmissionException) {_				throw (JobSubmissionException) t__			}_			else {_				throw new JobSubmissionException(jobGraph.getJobID(), "Failed to initialize job " +_					jobGraph.getName() + " (" + jobGraph.getJobID() + ")", t)__			}_		}_	};initializing,the,job,execution,environment,should,be,called,before,start,any,error,occurred,during,initialization,will,be,treated,as,job,submission,failure,throws,job,submission,exception;public,void,init,throws,job,submission,exception,log,info,initializing,job,job,graph,get,name,job,graph,get,job,id,try,try,library,cache,manager,register,job,job,graph,get,job,id,job,graph,get,user,jar,blob,keys,job,graph,get,classpaths,catch,throwable,t,throw,new,job,submission,exception,job,graph,get,job,id,cannot,set,up,the,user,code,libraries,t,get,message,t,user,code,loader,library,cache,manager,get,class,loader,job,graph,get,job,id,if,user,code,loader,null,throw,new,job,submission,exception,job,graph,get,job,id,the,user,code,class,loader,could,not,be,initialized,if,job,graph,get,number,of,vertices,0,throw,new,job,submission,exception,job,graph,get,job,id,the,given,job,is,empty,final,restart,strategies,restart,strategy,configuration,restart,strategy,configuration,job,graph,get,serialized,execution,config,deserialize,value,user,code,loader,get,restart,strategy,if,restart,strategy,configuration,null,restart,strategy,restart,strategy,factory,create,restart,strategy,restart,strategy,configuration,else,restart,strategy,restart,strategy,factory,create,restart,strategy,log,info,using,restart,strategy,for,restart,strategy,job,graph,get,name,job,graph,get,job,id,if,job,manager,metric,group,null,job,metrics,job,manager,metric,group,add,job,job,graph,if,job,metrics,null,job,metrics,new,unregistered,metrics,group,try,checkpoint,recovery,factory,high,availability,services,get,checkpoint,recovery,factory,catch,exception,e,log,error,could,not,get,the,checkpoint,recovery,factory,e,throw,new,job,submission,exception,job,graph,get,job,id,could,not,get,the,checkpoint,recovery,factory,e,try,resource,manager,leader,retriever,high,availability,services,get,resource,manager,leader,retriever,catch,exception,e,log,error,could,not,get,the,resource,manager,leader,retriever,e,throw,new,job,submission,exception,job,graph,get,job,id,could,not,get,the,resource,manager,leader,retriever,e,catch,throwable,t,log,error,failed,to,initializing,job,job,graph,get,name,job,graph,get,job,id,t,library,cache,manager,unregister,job,job,graph,get,job,id,if,t,instanceof,job,submission,exception,throw,job,submission,exception,t,else,throw,new,job,submission,exception,job,graph,get,job,id,failed,to,initialize,job,job,graph,get,name,job,graph,get,job,id,t
JobMaster -> private void disposeSavepoint(String savepointPath);1518534881;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException de) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, de)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,de,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,de
JobMaster -> private void disposeSavepoint(String savepointPath);1518539372;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1518716619;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1518718788;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1519299413;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1519320257;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1519390630;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1519408304;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1519931395;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1519999896;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1521033687;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1521049936;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1521224209;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1521641386;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1521810529;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1521816200;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1521816389;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1521817317;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1522130448;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1522136713;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1522230836;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1522849636;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1525374816;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1525934187;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1526300085;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1526311855;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1526561054;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1526997218;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1527029265;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1527094227;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1529603022;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1529915670;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1530791303;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1532289479;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1532293098;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1533374562;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1534937274;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1536826537;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1538403115;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1538764056;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1538864611;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1542043300;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1542304303;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1543229263;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1544094547;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1547809055;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1547809099;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1547809385;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1548086094;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1548172161;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1548172454;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1548679824;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1549036717;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1549381698;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1549533702;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1549965236;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1549983516;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1550366933;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1550405950;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> private void disposeSavepoint(String savepointPath);1550572312;Dispose the savepoint stored under the given path.__@param savepointPath path where the savepoint is stored;private void disposeSavepoint(String savepointPath) {_		try {_			_			Checkpoints.disposeSavepoint(_				savepointPath,_				jobMasterConfiguration.getConfiguration(),_				userCodeLoader,_				log)__		} catch (FlinkException | IOException e) {_			log.info("Could not dispose temporary rescaling savepoint under {}.", savepointPath, e)__		}_	};dispose,the,savepoint,stored,under,the,given,path,param,savepoint,path,path,where,the,savepoint,is,stored;private,void,dispose,savepoint,string,savepoint,path,try,checkpoints,dispose,savepoint,savepoint,path,job,master,configuration,get,configuration,user,code,loader,log,catch,flink,exception,ioexception,e,log,info,could,not,dispose,temporary,rescaling,savepoint,under,savepoint,path,e
JobMaster -> @Override 	public void shutDown();1475679726;Suspend the job and shutdown all other services including rpc.;@Override_	public void shutDown() {_		_		getSelf().suspendExecution(new Exception("JobManager is shutting down."))__		super.shutDown()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,shut,down,get,self,suspend,execution,new,exception,job,manager,is,shutting,down,super,shut,down
JobMaster -> @Override 	public void shutDown();1476307516;Suspend the job and shutdown all other services including rpc.;@Override_	public void shutDown() {_		_		getSelf().suspendExecution(new Exception("JobManager is shutting down."))__		super.shutDown()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,shut,down,get,self,suspend,execution,new,exception,job,manager,is,shutting,down,super,shut,down
JobMaster -> @Override 	public void shutDown();1476627638;Suspend the job and shutdown all other services including rpc.;@Override_	public void shutDown() {_		_		getSelf().suspendExecution(new Exception("JobManager is shutting down."))__		super.shutDown()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,shut,down,get,self,suspend,execution,new,exception,job,manager,is,shutting,down,super,shut,down
JobMaster -> @Override 	public void shutDown();1476630057;Suspend the job and shutdown all other services including rpc.;@Override_	public void shutDown() {_		_		getSelf().suspendExecution(new Exception("JobManager is shutting down."))__		super.shutDown()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,shut,down,get,self,suspend,execution,new,exception,job,manager,is,shutting,down,super,shut,down
JobMaster -> @Override 	public void shutDown();1476668326;Suspend the job and shutdown all other services including rpc.;@Override_	public void shutDown() {_		_		getSelf().suspendExecution(new Exception("JobManager is shutting down."))__		super.shutDown()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,shut,down,get,self,suspend,execution,new,exception,job,manager,is,shutting,down,super,shut,down
JobMaster -> @Override 	public void shutDown();1476699326;Suspend the job and shutdown all other services including rpc.;@Override_	public void shutDown() {_		_		getSelf().suspendExecution(new Exception("JobManager is shutting down."))__		super.shutDown()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,shut,down,get,self,suspend,execution,new,exception,job,manager,is,shutting,down,super,shut,down
JobMaster -> @Override 	public void shutDown();1476878971;Suspend the job and shutdown all other services including rpc.;@Override_	public void shutDown() {_		_		getSelf().suspendExecution(new Exception("JobManager is shutting down."))__		super.shutDown()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,shut,down,get,self,suspend,execution,new,exception,job,manager,is,shutting,down,super,shut,down
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState);1498493279;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState)_	{_		checkNotNull(taskExecutionState, "taskExecutionState")___		try {_			validateLeaderSessionId(leaderSessionID)__		} catch (LeaderIdMismatchException e) {_			return FutureUtils.completedExceptionally(e)__		}__		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,try,validate,leader,session,id,leader,session,id,catch,leader,id,mismatch,exception,e,return,future,utils,completed,exceptionally,e,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState);1498580984;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState)_	{_		checkNotNull(taskExecutionState, "taskExecutionState")___		try {_			validateLeaderSessionId(leaderSessionID)__		} catch (LeaderIdMismatchException e) {_			return FutureUtils.completedExceptionally(e)__		}__		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,try,validate,leader,session,id,leader,session,id,catch,leader,id,mismatch,exception,e,return,future,utils,completed,exceptionally,e,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState);1500977056;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState)_	{_		checkNotNull(taskExecutionState, "taskExecutionState")___		try {_			validateLeaderSessionId(leaderSessionID)__		} catch (LeaderIdMismatchException e) {_			return FutureUtils.completedExceptionally(e)__		}__		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,try,validate,leader,session,id,leader,session,id,catch,leader,id,mismatch,exception,e,return,future,utils,completed,exceptionally,e,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState);1502196227;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState)_	{_		checkNotNull(taskExecutionState, "taskExecutionState")___		try {_			validateLeaderSessionId(leaderSessionID)__		} catch (LeaderIdMismatchException e) {_			return FutureUtils.completedExceptionally(e)__		}__		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,try,validate,leader,session,id,leader,session,id,catch,leader,id,mismatch,exception,e,return,future,utils,completed,exceptionally,e,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState);1502714913;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState)_	{_		checkNotNull(taskExecutionState, "taskExecutionState")___		try {_			validateLeaderSessionId(leaderSessionID)__		} catch (LeaderIdMismatchException e) {_			return FutureUtils.completedExceptionally(e)__		}__		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,try,validate,leader,session,id,leader,session,id,catch,leader,id,mismatch,exception,e,return,future,utils,completed,exceptionally,e,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState);1503412385;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState)_	{_		checkNotNull(taskExecutionState, "taskExecutionState")___		try {_			validateLeaderSessionId(leaderSessionID)__		} catch (LeaderIdMismatchException e) {_			return FutureUtils.completedExceptionally(e)__		}__		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,try,validate,leader,session,id,leader,session,id,catch,leader,id,mismatch,exception,e,return,future,utils,completed,exceptionally,e,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState);1503573855;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState)_	{_		checkNotNull(taskExecutionState, "taskExecutionState")___		try {_			validateLeaderSessionId(leaderSessionID)__		} catch (LeaderIdMismatchException e) {_			return FutureUtils.completedExceptionally(e)__		}__		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,try,validate,leader,session,id,leader,session,id,catch,leader,id,mismatch,exception,e,return,future,utils,completed,exceptionally,e,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState);1503580260;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState)_	{_		checkNotNull(taskExecutionState, "taskExecutionState")___		try {_			validateLeaderSessionId(leaderSessionID)__		} catch (LeaderIdMismatchException e) {_			return FutureUtils.completedExceptionally(e)__		}__		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,try,validate,leader,session,id,leader,session,id,catch,leader,id,mismatch,exception,e,return,future,utils,completed,exceptionally,e,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState);1503581387;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState)_	{_		checkNotNull(taskExecutionState, "taskExecutionState")___		try {_			validateLeaderSessionId(leaderSessionID)__		} catch (LeaderIdMismatchException e) {_			return FutureUtils.completedExceptionally(e)__		}__		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,try,validate,leader,session,id,leader,session,id,catch,leader,id,mismatch,exception,e,return,future,utils,completed,exceptionally,e,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState) throws Exception;1475679726;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState) throws Exception_	{_		if (taskExecutionState == null) {_			throw new NullPointerException("TaskExecutionState must not be null.")__		}__		if (!this.leaderSessionID.equals(leaderSessionID)) {_			throw new Exception("Leader id not match, expected: " + this.leaderSessionID_					+ ", actual: " + leaderSessionID)__		}__		if (executionGraph.updateState(taskExecutionState)) {_			return Acknowledge.get()__		} else {_			throw new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found.")__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,throws,exception,if,task,execution,state,null,throw,new,null,pointer,exception,task,execution,state,must,not,be,null,if,this,leader,session,id,equals,leader,session,id,throw,new,exception,leader,id,not,match,expected,this,leader,session,id,actual,leader,session,id,if,execution,graph,update,state,task,execution,state,return,acknowledge,get,else,throw,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState) throws Exception;1476307516;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState) throws Exception_	{_		if (taskExecutionState == null) {_			throw new NullPointerException("TaskExecutionState must not be null.")__		}__		if (!this.leaderSessionID.equals(leaderSessionID)) {_			throw new Exception("Leader id not match, expected: " + this.leaderSessionID_					+ ", actual: " + leaderSessionID)__		}__		if (executionGraph.updateState(taskExecutionState)) {_			return Acknowledge.get()__		} else {_			throw new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found.")__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,throws,exception,if,task,execution,state,null,throw,new,null,pointer,exception,task,execution,state,must,not,be,null,if,this,leader,session,id,equals,leader,session,id,throw,new,exception,leader,id,not,match,expected,this,leader,session,id,actual,leader,session,id,if,execution,graph,update,state,task,execution,state,return,acknowledge,get,else,throw,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState) throws Exception;1476627638;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState) throws Exception_	{_		if (taskExecutionState == null) {_			throw new NullPointerException("TaskExecutionState must not be null.")__		}__		if (!this.leaderSessionID.equals(leaderSessionID)) {_			throw new Exception("Leader id not match, expected: " + this.leaderSessionID_					+ ", actual: " + leaderSessionID)__		}__		if (executionGraph.updateState(taskExecutionState)) {_			return Acknowledge.get()__		} else {_			throw new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found.")__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,throws,exception,if,task,execution,state,null,throw,new,null,pointer,exception,task,execution,state,must,not,be,null,if,this,leader,session,id,equals,leader,session,id,throw,new,exception,leader,id,not,match,expected,this,leader,session,id,actual,leader,session,id,if,execution,graph,update,state,task,execution,state,return,acknowledge,get,else,throw,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState) throws Exception;1476630057;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState) throws Exception_	{_		if (taskExecutionState == null) {_			throw new NullPointerException("TaskExecutionState must not be null.")__		}__		if (!this.leaderSessionID.equals(leaderSessionID)) {_			throw new Exception("Leader id not match, expected: " + this.leaderSessionID_					+ ", actual: " + leaderSessionID)__		}__		if (executionGraph.updateState(taskExecutionState)) {_			return Acknowledge.get()__		} else {_			throw new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found.")__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,throws,exception,if,task,execution,state,null,throw,new,null,pointer,exception,task,execution,state,must,not,be,null,if,this,leader,session,id,equals,leader,session,id,throw,new,exception,leader,id,not,match,expected,this,leader,session,id,actual,leader,session,id,if,execution,graph,update,state,task,execution,state,return,acknowledge,get,else,throw,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState) throws Exception;1476668326;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState) throws Exception_	{_		if (taskExecutionState == null) {_			throw new NullPointerException("TaskExecutionState must not be null.")__		}__		if (!this.leaderSessionID.equals(leaderSessionID)) {_			throw new Exception("Leader id not match, expected: " + this.leaderSessionID_					+ ", actual: " + leaderSessionID)__		}__		if (executionGraph.updateState(taskExecutionState)) {_			return Acknowledge.get()__		} else {_			throw new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found.")__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,throws,exception,if,task,execution,state,null,throw,new,null,pointer,exception,task,execution,state,must,not,be,null,if,this,leader,session,id,equals,leader,session,id,throw,new,exception,leader,id,not,match,expected,this,leader,session,id,actual,leader,session,id,if,execution,graph,update,state,task,execution,state,return,acknowledge,get,else,throw,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState) throws Exception;1476699326;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState) throws Exception_	{_		if (taskExecutionState == null) {_			throw new NullPointerException("TaskExecutionState must not be null.")__		}__		if (!this.leaderSessionID.equals(leaderSessionID)) {_			throw new Exception("Leader id not match, expected: " + this.leaderSessionID_					+ ", actual: " + leaderSessionID)__		}__		if (executionGraph.updateState(taskExecutionState)) {_			return Acknowledge.get()__		} else {_			throw new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found.")__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,throws,exception,if,task,execution,state,null,throw,new,null,pointer,exception,task,execution,state,must,not,be,null,if,this,leader,session,id,equals,leader,session,id,throw,new,exception,leader,id,not,match,expected,this,leader,session,id,actual,leader,session,id,if,execution,graph,update,state,task,execution,state,return,acknowledge,get,else,throw,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState) throws Exception;1476714136;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState) throws Exception_	{_		if (taskExecutionState == null) {_			throw new NullPointerException("TaskExecutionState must not be null.")__		}__		if (!this.leaderSessionID.equals(leaderSessionID)) {_			throw new Exception("Leader id not match, expected: " + this.leaderSessionID_					+ ", actual: " + leaderSessionID)__		}__		if (executionGraph.updateState(taskExecutionState)) {_			return Acknowledge.get()__		} else {_			throw new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found.")__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,throws,exception,if,task,execution,state,null,throw,new,null,pointer,exception,task,execution,state,must,not,be,null,if,this,leader,session,id,equals,leader,session,id,throw,new,exception,leader,id,not,match,expected,this,leader,session,id,actual,leader,session,id,if,execution,graph,update,state,task,execution,state,return,acknowledge,get,else,throw,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState) throws Exception;1476728818;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState) throws Exception_	{_		checkNotNull(taskExecutionState, "taskExecutionState")__		validateLeaderSessionId(leaderSessionID)___		if (executionGraph.updateState(taskExecutionState)) {_			return Acknowledge.get()__		} else {_			throw new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found.")__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,throws,exception,check,not,null,task,execution,state,task,execution,state,validate,leader,session,id,leader,session,id,if,execution,graph,update,state,task,execution,state,return,acknowledge,get,else,throw,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState) throws Exception;1476806580;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState) throws Exception_	{_		if (taskExecutionState == null) {_			throw new NullPointerException("TaskExecutionState must not be null.")__		}__		if (!this.leaderSessionID.equals(leaderSessionID)) {_			throw new Exception("Leader id not match, expected: " + this.leaderSessionID_					+ ", actual: " + leaderSessionID)__		}__		if (executionGraph.updateState(taskExecutionState)) {_			return Acknowledge.get()__		} else {_			throw new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found.")__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,throws,exception,if,task,execution,state,null,throw,new,null,pointer,exception,task,execution,state,must,not,be,null,if,this,leader,session,id,equals,leader,session,id,throw,new,exception,leader,id,not,match,expected,this,leader,session,id,actual,leader,session,id,if,execution,graph,update,state,task,execution,state,return,acknowledge,get,else,throw,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState) throws Exception;1476878971;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState) throws Exception_	{_		if (taskExecutionState == null) {_			throw new NullPointerException("TaskExecutionState must not be null.")__		}__		if (!this.leaderSessionID.equals(leaderSessionID)) {_			throw new Exception("Leader id not match, expected: " + this.leaderSessionID_					+ ", actual: " + leaderSessionID)__		}__		if (executionGraph.updateState(taskExecutionState)) {_			return Acknowledge.get()__		} else {_			throw new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found.")__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,throws,exception,if,task,execution,state,null,throw,new,null,pointer,exception,task,execution,state,must,not,be,null,if,this,leader,session,id,equals,leader,session,id,throw,new,exception,leader,id,not,match,expected,this,leader,session,id,actual,leader,session,id,if,execution,graph,update,state,task,execution,state,return,acknowledge,get,else,throw,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState) throws Exception;1477061494;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState) throws Exception_	{_		checkNotNull(taskExecutionState, "taskExecutionState")__		validateLeaderSessionId(leaderSessionID)___		if (executionGraph.updateState(taskExecutionState)) {_			return Acknowledge.get()__		} else {_			throw new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found.")__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,throws,exception,check,not,null,task,execution,state,task,execution,state,validate,leader,session,id,leader,session,id,if,execution,graph,update,state,task,execution,state,return,acknowledge,get,else,throw,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState) throws Exception;1477965803;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState) throws Exception_	{_		checkNotNull(taskExecutionState, "taskExecutionState")__		validateLeaderSessionId(leaderSessionID)___		if (executionGraph.updateState(taskExecutionState)) {_			return Acknowledge.get()__		} else {_			throw new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found.")__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,throws,exception,check,not,null,task,execution,state,task,execution,state,validate,leader,session,id,leader,session,id,if,execution,graph,update,state,task,execution,state,return,acknowledge,get,else,throw,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState) throws Exception;1484737699;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState) throws Exception_	{_		checkNotNull(taskExecutionState, "taskExecutionState")__		validateLeaderSessionId(leaderSessionID)___		if (executionGraph.updateState(taskExecutionState)) {_			return Acknowledge.get()__		} else {_			throw new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found.")__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,throws,exception,check,not,null,task,execution,state,task,execution,state,validate,leader,session,id,leader,session,id,if,execution,graph,update,state,task,execution,state,return,acknowledge,get,else,throw,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState) throws Exception;1486583506;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState) throws Exception_	{_		checkNotNull(taskExecutionState, "taskExecutionState")__		validateLeaderSessionId(leaderSessionID)___		if (executionGraph.updateState(taskExecutionState)) {_			return Acknowledge.get()__		} else {_			throw new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found.")__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,throws,exception,check,not,null,task,execution,state,task,execution,state,validate,leader,session,id,leader,session,id,if,execution,graph,update,state,task,execution,state,return,acknowledge,get,else,throw,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState) throws Exception;1486637985;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState) throws Exception_	{_		checkNotNull(taskExecutionState, "taskExecutionState")__		validateLeaderSessionId(leaderSessionID)___		if (executionGraph.updateState(taskExecutionState)) {_			return Acknowledge.get()__		} else {_			throw new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found.")__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,throws,exception,check,not,null,task,execution,state,task,execution,state,validate,leader,session,id,leader,session,id,if,execution,graph,update,state,task,execution,state,return,acknowledge,get,else,throw,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState) throws Exception;1487177560;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState) throws Exception_	{_		checkNotNull(taskExecutionState, "taskExecutionState")__		validateLeaderSessionId(leaderSessionID)___		if (executionGraph.updateState(taskExecutionState)) {_			return Acknowledge.get()__		} else {_			throw new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found.")__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,throws,exception,check,not,null,task,execution,state,task,execution,state,validate,leader,session,id,leader,session,id,if,execution,graph,update,state,task,execution,state,return,acknowledge,get,else,throw,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState) throws Exception;1488291647;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState) throws Exception_	{_		checkNotNull(taskExecutionState, "taskExecutionState")__		validateLeaderSessionId(leaderSessionID)___		if (executionGraph.updateState(taskExecutionState)) {_			return Acknowledge.get()__		} else {_			throw new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found.")__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,throws,exception,check,not,null,task,execution,state,task,execution,state,validate,leader,session,id,leader,session,id,if,execution,graph,update,state,task,execution,state,return,acknowledge,get,else,throw,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState) throws Exception;1488923142;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState) throws Exception_	{_		checkNotNull(taskExecutionState, "taskExecutionState")__		validateLeaderSessionId(leaderSessionID)___		if (executionGraph.updateState(taskExecutionState)) {_			return Acknowledge.get()__		} else {_			throw new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found.")__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,throws,exception,check,not,null,task,execution,state,task,execution,state,validate,leader,session,id,leader,session,id,if,execution,graph,update,state,task,execution,state,return,acknowledge,get,else,throw,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState) throws Exception;1490105415;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState) throws Exception_	{_		checkNotNull(taskExecutionState, "taskExecutionState")__		validateLeaderSessionId(leaderSessionID)___		if (executionGraph.updateState(taskExecutionState)) {_			return Acknowledge.get()__		} else {_			throw new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found.")__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,throws,exception,check,not,null,task,execution,state,task,execution,state,validate,leader,session,id,leader,session,id,if,execution,graph,update,state,task,execution,state,return,acknowledge,get,else,throw,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState) throws Exception;1490120014;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState) throws Exception_	{_		checkNotNull(taskExecutionState, "taskExecutionState")__		validateLeaderSessionId(leaderSessionID)___		if (executionGraph.updateState(taskExecutionState)) {_			return Acknowledge.get()__		} else {_			throw new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found.")__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,throws,exception,check,not,null,task,execution,state,task,execution,state,validate,leader,session,id,leader,session,id,if,execution,graph,update,state,task,execution,state,return,acknowledge,get,else,throw,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState) throws Exception;1490166753;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState) throws Exception_	{_		checkNotNull(taskExecutionState, "taskExecutionState")__		validateLeaderSessionId(leaderSessionID)___		if (executionGraph.updateState(taskExecutionState)) {_			return Acknowledge.get()__		} else {_			throw new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found.")__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,throws,exception,check,not,null,task,execution,state,task,execution,state,validate,leader,session,id,leader,session,id,if,execution,graph,update,state,task,execution,state,return,acknowledge,get,else,throw,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState) throws Exception;1490170142;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState) throws Exception_	{_		checkNotNull(taskExecutionState, "taskExecutionState")__		validateLeaderSessionId(leaderSessionID)___		if (executionGraph.updateState(taskExecutionState)) {_			return Acknowledge.get()__		} else {_			throw new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found.")__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,throws,exception,check,not,null,task,execution,state,task,execution,state,validate,leader,session,id,leader,session,id,if,execution,graph,update,state,task,execution,state,return,acknowledge,get,else,throw,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState) throws Exception;1490180625;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState) throws Exception_	{_		checkNotNull(taskExecutionState, "taskExecutionState")__		validateLeaderSessionId(leaderSessionID)___		if (executionGraph.updateState(taskExecutionState)) {_			return Acknowledge.get()__		} else {_			throw new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found.")__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,throws,exception,check,not,null,task,execution,state,task,execution,state,validate,leader,session,id,leader,session,id,if,execution,graph,update,state,task,execution,state,return,acknowledge,get,else,throw,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState) throws Exception;1490805029;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState) throws Exception_	{_		checkNotNull(taskExecutionState, "taskExecutionState")__		validateLeaderSessionId(leaderSessionID)___		if (executionGraph.updateState(taskExecutionState)) {_			return Acknowledge.get()__		} else {_			throw new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found.")__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,throws,exception,check,not,null,task,execution,state,task,execution,state,validate,leader,session,id,leader,session,id,if,execution,graph,update,state,task,execution,state,return,acknowledge,get,else,throw,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState) throws Exception;1501251235;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState) throws Exception_	{_		checkNotNull(taskExecutionState, "taskExecutionState")__		validateLeaderSessionId(leaderSessionID)___		if (executionGraph.updateState(taskExecutionState)) {_			return Acknowledge.get()__		} else {_			throw new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found.")__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,throws,exception,check,not,null,task,execution,state,task,execution,state,validate,leader,session,id,leader,session,id,if,execution,graph,update,state,task,execution,state,return,acknowledge,get,else,throw,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState) throws Exception;1501519642;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState) throws Exception_	{_		checkNotNull(taskExecutionState, "taskExecutionState")__		validateLeaderSessionId(leaderSessionID)___		if (executionGraph.updateState(taskExecutionState)) {_			return Acknowledge.get()__		} else {_			throw new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found.")__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,throws,exception,check,not,null,task,execution,state,task,execution,state,validate,leader,session,id,leader,session,id,if,execution,graph,update,state,task,execution,state,return,acknowledge,get,else,throw,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState) throws Exception;1501524690;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState) throws Exception_	{_		checkNotNull(taskExecutionState, "taskExecutionState")__		validateLeaderSessionId(leaderSessionID)___		if (executionGraph.updateState(taskExecutionState)) {_			return Acknowledge.get()__		} else {_			throw new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found.")__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,throws,exception,check,not,null,task,execution,state,task,execution,state,validate,leader,session,id,leader,session,id,if,execution,graph,update,state,task,execution,state,return,acknowledge,get,else,throw,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState) throws Exception;1501580028;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState) throws Exception_	{_		checkNotNull(taskExecutionState, "taskExecutionState")__		validateLeaderSessionId(leaderSessionID)___		if (executionGraph.updateState(taskExecutionState)) {_			return Acknowledge.get()__		} else {_			throw new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found.")__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,throws,exception,check,not,null,task,execution,state,task,execution,state,validate,leader,session,id,leader,session,id,if,execution,graph,update,state,task,execution,state,return,acknowledge,get,else,throw,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState( 			final UUID leaderSessionID, 			final TaskExecutionState taskExecutionState) throws Exception;1502035001;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(_			final UUID leaderSessionID,_			final TaskExecutionState taskExecutionState) throws Exception_	{_		checkNotNull(taskExecutionState, "taskExecutionState")__		validateLeaderSessionId(leaderSessionID)___		if (executionGraph.updateState(taskExecutionState)) {_			return Acknowledge.get()__		} else {_			throw new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found.")__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,final,uuid,leader,session,id,final,task,execution,state,task,execution,state,throws,exception,check,not,null,task,execution,state,task,execution,state,validate,leader,session,id,leader,session,id,if,execution,graph,update,state,task,execution,state,return,acknowledge,get,else,throw,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> public void start();1472481329;----------------------------------------------------------------------------------------------;public void start() {_		super.start()___		_		registerAtElectionService()__	};;public,void,start,super,start,register,at,election,service
JobMaster -> public void start();1472481329;Initialization methods;public void start() {_		super.start()___		_		registerAtElectionService()__	};initialization,methods;public,void,start,super,start,register,at,election,service
JobMaster -> public void start();1472481329;----------------------------------------------------------------------------------------------;public void start() {_		super.start()___		_		registerAtElectionService()__	};;public,void,start,super,start,register,at,election,service
JobMaster -> public void start();1474471581;----------------------------------------------------------------------------------------------;public void start() {_		super.start()___		_		registerAtElectionService()__	};;public,void,start,super,start,register,at,election,service
JobMaster -> public void start();1474471581;Initialization methods;public void start() {_		super.start()___		_		registerAtElectionService()__	};initialization,methods;public,void,start,super,start,register,at,election,service
JobMaster -> public void start();1474471581;----------------------------------------------------------------------------------------------;public void start() {_		super.start()___		_		registerAtElectionService()__	};;public,void,start,super,start,register,at,election,service
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1503573855;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsync(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1503580260;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsync(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1503588382;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1505768302;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1505861185;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1505921975;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1505984004;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1506005238;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1506346199;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1506510152;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1507284174;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1507673791;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1507738083;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1508840168;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1510061826;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1510699852;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1511543029;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1511975541;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1512136929;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1512567555;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1513261475;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1513706333;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1514829582;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1516197717;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1516368003;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1516641064;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1516797761;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1516896219;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1517425569;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1517911296;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1517920262;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1518093789;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1518194413;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1518393108;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1518522104;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1518524281;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1518532391;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout);1518689135;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Throwable cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,throwable,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> @RpcMethod 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1476728818;TODO: This method needs a leader session ID;@RpcMethod_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1477061494;TODO: This method needs a leader session ID;@RpcMethod_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1477965803;TODO: This method needs a leader session ID;@RpcMethod_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1484737699;TODO: This method needs a leader session ID;@RpcMethod_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1486583506;TODO: This method needs a leader session ID;@RpcMethod_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1486637985;TODO: This method needs a leader session ID;@RpcMethod_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1487177560;TODO: This method needs a leader session ID;@RpcMethod_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1488291647;TODO: This method needs a leader session ID;@RpcMethod_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1488923142;TODO: This method needs a leader session ID;@RpcMethod_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1490105415;TODO: This method needs a leader session ID;@RpcMethod_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1490120014;TODO: This method needs a leader session ID;@RpcMethod_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1490166753;TODO: This method needs a leader session ID;@RpcMethod_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1490170142;TODO: This method needs a leader session ID;@RpcMethod_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1490180625;TODO: This method needs a leader session ID;@RpcMethod_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1490805029;TODO: This method needs a leader session ID;@RpcMethod_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1501251235;TODO: This method needs a leader session ID;@RpcMethod_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1501519642;TODO: This method needs a leader session ID;@RpcMethod_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1501524690;TODO: This method needs a leader session ID;@RpcMethod_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1501580028;TODO: This method needs a leader session ID;@RpcMethod_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1502035001;TODO: This method needs a leader session ID;@RpcMethod_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void registerAtResourceManager(final String address);1472481329;Triggers the registration of the job master at the resource manager.__@param address Address of the resource manager;@RpcMethod_	public void registerAtResourceManager(final String address) {_		_	};triggers,the,registration,of,the,job,master,at,the,resource,manager,param,address,address,of,the,resource,manager;rpc,method,public,void,register,at,resource,manager,final,string,address
JobMaster -> @RpcMethod 	public void registerAtResourceManager(final String address);1473307213;Triggers the registration of the job master at the resource manager.__@param address Address of the resource manager;@RpcMethod_	public void registerAtResourceManager(final String address) {_		_	};triggers,the,registration,of,the,job,master,at,the,resource,manager,param,address,address,of,the,resource,manager;rpc,method,public,void,register,at,resource,manager,final,string,address
JobMaster -> @RpcMethod 	public void registerAtResourceManager(final String address);1474453995;Triggers the registration of the job master at the resource manager.__@param address Address of the resource manager;@RpcMethod_	public void registerAtResourceManager(final String address) {_		_	};triggers,the,registration,of,the,job,master,at,the,resource,manager,param,address,address,of,the,resource,manager;rpc,method,public,void,register,at,resource,manager,final,string,address
JobMaster -> @RpcMethod 	public void registerAtResourceManager(final String address);1474471581;Triggers the registration of the job master at the resource manager.__@param address Address of the resource manager;@RpcMethod_	public void registerAtResourceManager(final String address) {_		_	};triggers,the,registration,of,the,job,master,at,the,resource,manager,param,address,address,of,the,resource,manager;rpc,method,public,void,register,at,resource,manager,final,string,address
JobMaster -> private static List<ExecutionJobVertex> getExecutionJobVertexWithId( 		final ExecutionGraph executionGraph, final List<JobVertexID> vertexIDs) 		throws JobExecutionException;1473307213;Converts JobVertexIDs to corresponding ExecutionJobVertexes__@param executionGraph The execution graph that holds the relationship_@param vertexIDs      The vertexIDs need to be converted_@return The corresponding ExecutionJobVertexes_@throws JobExecutionException;private static List<ExecutionJobVertex> getExecutionJobVertexWithId(_		final ExecutionGraph executionGraph, final List<JobVertexID> vertexIDs)_		throws JobExecutionException_	{_		final List<ExecutionJobVertex> ret = new ArrayList<>(vertexIDs.size())__		for (JobVertexID vertexID : vertexIDs) {_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(vertexID)__			if (executionJobVertex == null) {_				throw new JobExecutionException(executionGraph.getJobID(),_					"The snapshot checkpointing settings refer to non-existent vertex " + vertexID)__			}_			ret.add(executionJobVertex)__		}_		return ret__	};converts,job,vertex,ids,to,corresponding,execution,job,vertexes,param,execution,graph,the,execution,graph,that,holds,the,relationship,param,vertex,ids,the,vertex,ids,need,to,be,converted,return,the,corresponding,execution,job,vertexes,throws,job,execution,exception;private,static,list,execution,job,vertex,get,execution,job,vertex,with,id,final,execution,graph,execution,graph,final,list,job,vertex,id,vertex,ids,throws,job,execution,exception,final,list,execution,job,vertex,ret,new,array,list,vertex,ids,size,for,job,vertex,id,vertex,id,vertex,ids,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,vertex,id,if,execution,job,vertex,null,throw,new,job,execution,exception,execution,graph,get,job,id,the,snapshot,checkpointing,settings,refer,to,non,existent,vertex,vertex,id,ret,add,execution,job,vertex,return,ret
JobMaster -> private static List<ExecutionJobVertex> getExecutionJobVertexWithId( 		final ExecutionGraph executionGraph, final List<JobVertexID> vertexIDs) 		throws JobExecutionException;1474858756;Converts JobVertexIDs to corresponding ExecutionJobVertexes__@param executionGraph The execution graph that holds the relationship_@param vertexIDs      The vertexIDs need to be converted_@return The corresponding ExecutionJobVertexes_@throws JobExecutionException;private static List<ExecutionJobVertex> getExecutionJobVertexWithId(_		final ExecutionGraph executionGraph, final List<JobVertexID> vertexIDs)_		throws JobExecutionException_	{_		final List<ExecutionJobVertex> ret = new ArrayList<>(vertexIDs.size())__		for (JobVertexID vertexID : vertexIDs) {_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(vertexID)__			if (executionJobVertex == null) {_				throw new JobExecutionException(executionGraph.getJobID(),_					"The snapshot checkpointing settings refer to non-existent vertex " + vertexID)__			}_			ret.add(executionJobVertex)__		}_		return ret__	};converts,job,vertex,ids,to,corresponding,execution,job,vertexes,param,execution,graph,the,execution,graph,that,holds,the,relationship,param,vertex,ids,the,vertex,ids,need,to,be,converted,return,the,corresponding,execution,job,vertexes,throws,job,execution,exception;private,static,list,execution,job,vertex,get,execution,job,vertex,with,id,final,execution,graph,execution,graph,final,list,job,vertex,id,vertex,ids,throws,job,execution,exception,final,list,execution,job,vertex,ret,new,array,list,vertex,ids,size,for,job,vertex,id,vertex,id,vertex,ids,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,vertex,id,if,execution,job,vertex,null,throw,new,job,execution,exception,execution,graph,get,job,id,the,snapshot,checkpointing,settings,refer,to,non,existent,vertex,vertex,id,ret,add,execution,job,vertex,return,ret
JobMaster -> private static List<ExecutionJobVertex> getExecutionJobVertexWithId( 		final ExecutionGraph executionGraph, final List<JobVertexID> vertexIDs) 		throws JobExecutionException;1475066391;Converts JobVertexIDs to corresponding ExecutionJobVertexes__@param executionGraph The execution graph that holds the relationship_@param vertexIDs      The vertexIDs need to be converted_@return The corresponding ExecutionJobVertexes_@throws JobExecutionException;private static List<ExecutionJobVertex> getExecutionJobVertexWithId(_		final ExecutionGraph executionGraph, final List<JobVertexID> vertexIDs)_		throws JobExecutionException_	{_		final List<ExecutionJobVertex> ret = new ArrayList<>(vertexIDs.size())__		for (JobVertexID vertexID : vertexIDs) {_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(vertexID)__			if (executionJobVertex == null) {_				throw new JobExecutionException(executionGraph.getJobID(),_					"The snapshot checkpointing settings refer to non-existent vertex " + vertexID)__			}_			ret.add(executionJobVertex)__		}_		return ret__	};converts,job,vertex,ids,to,corresponding,execution,job,vertexes,param,execution,graph,the,execution,graph,that,holds,the,relationship,param,vertex,ids,the,vertex,ids,need,to,be,converted,return,the,corresponding,execution,job,vertexes,throws,job,execution,exception;private,static,list,execution,job,vertex,get,execution,job,vertex,with,id,final,execution,graph,execution,graph,final,list,job,vertex,id,vertex,ids,throws,job,execution,exception,final,list,execution,job,vertex,ret,new,array,list,vertex,ids,size,for,job,vertex,id,vertex,id,vertex,ids,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,vertex,id,if,execution,job,vertex,null,throw,new,job,execution,exception,execution,graph,get,job,id,the,snapshot,checkpointing,settings,refer,to,non,existent,vertex,vertex,id,ret,add,execution,job,vertex,return,ret
JobMaster -> private static List<ExecutionJobVertex> getExecutionJobVertexWithId( 		final ExecutionGraph executionGraph, final List<JobVertexID> vertexIDs) 		throws JobExecutionException;1475110587;Converts JobVertexIDs to corresponding ExecutionJobVertexes__@param executionGraph The execution graph that holds the relationship_@param vertexIDs      The vertexIDs need to be converted_@return The corresponding ExecutionJobVertexes_@throws JobExecutionException;private static List<ExecutionJobVertex> getExecutionJobVertexWithId(_		final ExecutionGraph executionGraph, final List<JobVertexID> vertexIDs)_		throws JobExecutionException_	{_		final List<ExecutionJobVertex> ret = new ArrayList<>(vertexIDs.size())__		for (JobVertexID vertexID : vertexIDs) {_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(vertexID)__			if (executionJobVertex == null) {_				throw new JobExecutionException(executionGraph.getJobID(),_					"The snapshot checkpointing settings refer to non-existent vertex " + vertexID)__			}_			ret.add(executionJobVertex)__		}_		return ret__	};converts,job,vertex,ids,to,corresponding,execution,job,vertexes,param,execution,graph,the,execution,graph,that,holds,the,relationship,param,vertex,ids,the,vertex,ids,need,to,be,converted,return,the,corresponding,execution,job,vertexes,throws,job,execution,exception;private,static,list,execution,job,vertex,get,execution,job,vertex,with,id,final,execution,graph,execution,graph,final,list,job,vertex,id,vertex,ids,throws,job,execution,exception,final,list,execution,job,vertex,ret,new,array,list,vertex,ids,size,for,job,vertex,id,vertex,id,vertex,ids,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,vertex,id,if,execution,job,vertex,null,throw,new,job,execution,exception,execution,graph,get,job,id,the,snapshot,checkpointing,settings,refer,to,non,existent,vertex,vertex,id,ret,add,execution,job,vertex,return,ret
JobMaster -> private static List<ExecutionJobVertex> getExecutionJobVertexWithId( 		final ExecutionGraph executionGraph, final List<JobVertexID> vertexIDs) 		throws JobExecutionException;1475593222;Converts JobVertexIDs to corresponding ExecutionJobVertexes__@param executionGraph The execution graph that holds the relationship_@param vertexIDs      The vertexIDs need to be converted_@return The corresponding ExecutionJobVertexes_@throws JobExecutionException;private static List<ExecutionJobVertex> getExecutionJobVertexWithId(_		final ExecutionGraph executionGraph, final List<JobVertexID> vertexIDs)_		throws JobExecutionException_	{_		final List<ExecutionJobVertex> ret = new ArrayList<>(vertexIDs.size())__		for (JobVertexID vertexID : vertexIDs) {_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(vertexID)__			if (executionJobVertex == null) {_				throw new JobExecutionException(executionGraph.getJobID(),_					"The snapshot checkpointing settings refer to non-existent vertex " + vertexID)__			}_			ret.add(executionJobVertex)__		}_		return ret__	};converts,job,vertex,ids,to,corresponding,execution,job,vertexes,param,execution,graph,the,execution,graph,that,holds,the,relationship,param,vertex,ids,the,vertex,ids,need,to,be,converted,return,the,corresponding,execution,job,vertexes,throws,job,execution,exception;private,static,list,execution,job,vertex,get,execution,job,vertex,with,id,final,execution,graph,execution,graph,final,list,job,vertex,id,vertex,ids,throws,job,execution,exception,final,list,execution,job,vertex,ret,new,array,list,vertex,ids,size,for,job,vertex,id,vertex,id,vertex,ids,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,vertex,id,if,execution,job,vertex,null,throw,new,job,execution,exception,execution,graph,get,job,id,the,snapshot,checkpointing,settings,refer,to,non,existent,vertex,vertex,id,ret,add,execution,job,vertex,return,ret
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1517300523;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1518531558;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1518534881;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1518539372;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1518606541;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1518716619;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1518718788;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1519299413;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1519320257;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1519390630;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1519408304;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1519931395;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1519999896;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1521033687;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1521049936;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1521224209;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1521641386;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1521810529;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1521816200;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1521816389;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1521817317;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1522130448;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1522136713;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1522230836;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1522849636;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1525374816;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1525934187;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1526300085;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1526311855;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1526561054;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1526997218;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1527029265;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1527094227;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1529603022;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1529915670;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1530791303;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1532289479;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1532293098;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1533374562;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1534937274;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1536826537;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1538403115;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1538764056;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPool.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1538864611;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1542043300;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1542304303;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1544094547;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1547809055;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1547809099;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1547809385;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1548172161;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1548172454;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1548679824;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1550366933;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPool.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1550405950;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__			resourceManagerAddress = null__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPool.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,resource,manager,address,null,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> private Acknowledge suspendExecution(final Exception cause);1550572312;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private Acknowledge suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return Acknowledge.get()__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__			resourceManagerAddress = null__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		slotPool.suspend()___		_		closeResourceManagerConnection(cause)___		return Acknowledge.get()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,acknowledge,get,set,fencing,token,null,try,resource,manager,leader,retriever,stop,resource,manager,address,null,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,slot,pool,suspend,close,resource,manager,connection,cause,return,acknowledge,get
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState(final TaskExecutionState taskExecutionState) throws ExecutionGraphException;1475066391;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(final TaskExecutionState taskExecutionState) throws ExecutionGraphException {_		if (taskExecutionState == null) {_			throw new NullPointerException("TaskExecutionState must not be null.")__		}__		if (executionGraph.updateState(taskExecutionState)) {_			return Acknowledge.get()__		} else {_			throw new ExecutionGraphException("The execution attempt " +_				taskExecutionState.getID() + " was not found.")__		}__	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,throws,execution,graph,exception,if,task,execution,state,null,throw,new,null,pointer,exception,task,execution,state,must,not,be,null,if,execution,graph,update,state,task,execution,state,return,acknowledge,get,else,throw,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState(final TaskExecutionState taskExecutionState) throws ExecutionGraphException;1475593222;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(final TaskExecutionState taskExecutionState) throws ExecutionGraphException {_		if (taskExecutionState == null) {_			throw new NullPointerException("TaskExecutionState must not be null.")__		}__		if (executionGraph.updateState(taskExecutionState)) {_			return Acknowledge.get()__		} else {_			throw new ExecutionGraphException("The execution attempt " +_				taskExecutionState.getID() + " was not found.")__		}__	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,throws,execution,graph,exception,if,task,execution,state,null,throw,new,null,pointer,exception,task,execution,state,must,not,be,null,if,execution,graph,update,state,task,execution,state,return,acknowledge,get,else,throw,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public void suspendExecution(final Throwable cause);1498493279;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;@Override_	public void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		leaderSessionID = null___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		stop()___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;override,public,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,leader,session,id,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,stop,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause
JobMaster -> @Override 	public void suspendExecution(final Throwable cause);1498580984;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;@Override_	public void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		leaderSessionID = null___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		stop()___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;override,public,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,leader,session,id,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,stop,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause
JobMaster -> @Override 	public void suspendExecution(final Throwable cause);1500977056;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;@Override_	public void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		leaderSessionID = null___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		stop()___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;override,public,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,leader,session,id,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,stop,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause
JobMaster -> @Override 	public void suspendExecution(final Throwable cause);1502196227;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;@Override_	public void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		leaderSessionID = null___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		stop()___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;override,public,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,leader,session,id,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,stop,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause
JobMaster -> public void revokeJobMasterLeadership();1472481329;Stop the execution when the leadership is revoked.;public void revokeJobMasterLeadership() {_		runAsync(new Runnable() {_			@Override_			public void run() {_				log.info("JobManager {} was revoked leadership.", getAddress())___				_				cancelAndClearEverything(new Exception("JobManager is no longer the leader."))___				leaderSessionID = null__			}_		})__	};stop,the,execution,when,the,leadership,is,revoked;public,void,revoke,job,master,leadership,run,async,new,runnable,override,public,void,run,log,info,job,manager,was,revoked,leadership,get,address,cancel,and,clear,everything,new,exception,job,manager,is,no,longer,the,leader,leader,session,id,null
JobMaster -> public void revokeJobMasterLeadership();1474471581;Stop the execution when the leadership is revoked.;public void revokeJobMasterLeadership() {_		runAsync(new Runnable() {_			@Override_			public void run() {_				log.info("JobManager {} was revoked leadership.", getAddress())___				_				cancelAndClearEverything(new Exception("JobManager is no longer the leader."))___				leaderSessionID = null__			}_		})__	};stop,the,execution,when,the,leadership,is,revoked;public,void,revoke,job,master,leadership,run,async,new,runnable,override,public,void,run,log,info,job,manager,was,revoked,leadership,get,address,cancel,and,clear,everything,new,exception,job,manager,is,no,longer,the,leader,leader,session,id,null
JobMaster -> @RpcMethod 	public void startJob(final UUID leaderSessionID);1474858756;Start to run the job, runtime data structures like ExecutionGraph will be constructed now and checkpoint_being recovered. After this, we will begin to schedule the job.;@RpcMethod_	public void startJob(final UUID leaderSessionID) {_		log.info("Starting job {} ({}) with leaderId {}.", jobGraph.getName(), jobGraph.getJobID(), leaderSessionID)___		try {_			if (executionGraph != null) {_				executionGraph = new ExecutionGraph(_						executionContext,_						executionContext,_						jobGraph.getJobID(),_						jobGraph.getName(),_						jobGraph.getJobConfiguration(),_						jobGraph.getSerializedExecutionConfig(),_						timeout,_						restartStrategy,_						jobGraph.getUserJarBlobKeys(),_						jobGraph.getClasspaths(),_						userCodeLoader,_						jobMetrics)__			} else {_				_			}__			executionGraph.setScheduleMode(jobGraph.getScheduleMode())__			executionGraph.setQueuedSchedulingAllowed(jobGraph.getAllowQueuedScheduling())___			try {_				executionGraph.setJsonPlan(JsonPlanGenerator.generatePlan(jobGraph))__			} catch (Exception e) {_				log.warn("Cannot create JSON plan for job {} ({})", jobGraph.getJobID(), jobGraph.getName(), e)__				executionGraph.setJsonPlan("{}")__			}__			_			_			if (log.isDebugEnabled()) {_				log.debug("Running initialization on master for job {} ({}).", jobGraph.getJobID(), jobGraph.getName())__			}_			for (JobVertex vertex : jobGraph.getVertices()) {_				final String executableClass = vertex.getInvokableClassName()__				if (executableClass == null || executableClass.length() == 0) {_					throw new JobExecutionException(jobGraph.getJobID(),_						"The vertex " + vertex.getID() + " (" + vertex.getName() + ") has no invokable class.")__				}_				if (vertex.getParallelism() == ExecutionConfig.PARALLELISM_AUTO_MAX) {_					vertex.setParallelism(scheduler.getTotalNumberOfSlots())__				}__				try {_					vertex.initializeOnMaster(userCodeLoader)__				} catch (Throwable t) {_					throw new JobExecutionException(jobGraph.getJobID(),_						"Cannot initialize task '" + vertex.getName() + "': " + t.getMessage(), t)__				}_			}__			_			final List<JobVertex> sortedTopology = jobGraph.getVerticesSortedTopologicallyFromSources()__			if (log.isDebugEnabled()) {_				log.debug("Adding {} vertices from job graph {} ({}).", sortedTopology.size(),_					jobGraph.getJobID(), jobGraph.getName())__			}_			executionGraph.attachJobGraph(sortedTopology)___			if (log.isDebugEnabled()) {_				log.debug("Successfully created execution graph from job graph {} ({}).",_					jobGraph.getJobID(), jobGraph.getName())__			}__			final JobSnapshottingSettings snapshotSettings = jobGraph.getSnapshotSettings()__			if (snapshotSettings != null) {_				List<ExecutionJobVertex> triggerVertices = getExecutionJobVertexWithId(_					executionGraph, snapshotSettings.getVerticesToTrigger())___				List<ExecutionJobVertex> ackVertices = getExecutionJobVertexWithId(_					executionGraph, snapshotSettings.getVerticesToAcknowledge())___				List<ExecutionJobVertex> confirmVertices = getExecutionJobVertexWithId(_					executionGraph, snapshotSettings.getVerticesToConfirm())___				CompletedCheckpointStore completedCheckpoints = checkpointRecoveryFactory.createCheckpointStore(_					jobGraph.getJobID(), userCodeLoader)___				CheckpointIDCounter checkpointIdCounter = checkpointRecoveryFactory.createCheckpointIDCounter(_					jobGraph.getJobID())___				_				boolean isStatsDisabled = configuration.getBoolean(_					ConfigConstants.JOB_MANAGER_WEB_CHECKPOINTS_DISABLE,_					ConfigConstants.DEFAULT_JOB_MANAGER_WEB_CHECKPOINTS_DISABLE)___				final CheckpointStatsTracker checkpointStatsTracker__				if (isStatsDisabled) {_					checkpointStatsTracker = new DisabledCheckpointStatsTracker()__				}_				else {_					int historySize = configuration.getInteger(_						ConfigConstants.JOB_MANAGER_WEB_CHECKPOINTS_HISTORY_SIZE,_						ConfigConstants.DEFAULT_JOB_MANAGER_WEB_CHECKPOINTS_HISTORY_SIZE)__					checkpointStatsTracker = new SimpleCheckpointStatsTracker(historySize, ackVertices, jobMetrics)__				}__				String externalizedCheckpointsDir = configuration.getString(_						ConfigConstants.CHECKPOINTS_DIRECTORY_KEY, null)___				executionGraph.enableSnapshotCheckpointing(_					snapshotSettings.getCheckpointInterval(),_					snapshotSettings.getCheckpointTimeout(),_					snapshotSettings.getMinPauseBetweenCheckpoints(),_					snapshotSettings.getMaxConcurrentCheckpoints(),_					snapshotSettings.getExternalizedCheckpointSettings(),_					triggerVertices,_					ackVertices,_					confirmVertices,_					checkpointIdCounter,_					completedCheckpoints,_					externalizedCheckpointsDir,_					checkpointStatsTracker)__			}__			__			__			__			_			resourceManagerLeaderRetriever.start(new ResourceManagerLeaderListener())__		} catch (Throwable t) {_			log.error("Failed to start job {} ({})", jobGraph.getName(), jobGraph.getJobID(), t)___			executionGraph.fail(t)__			executionGraph = null___			final Throwable rt__			if (t instanceof JobExecutionException) {_				rt = (JobExecutionException) t__			}_			else {_				rt = new JobExecutionException(jobGraph.getJobID(),_					"Failed to start job " + jobGraph.getJobID() + " (" + jobGraph.getName() + ")", t)__			}__			__			jobCompletionActions.jobFailed(rt)__			return__		}__		_		executionContext.execute(new Runnable() {_			@Override_			public void run() {_				if (executionGraph != null) {_					try {_						executionGraph.scheduleForExecution(scheduler)__					} catch (Throwable t) {_						executionGraph.fail(t)__					}_				}_			}_		})__	};start,to,run,the,job,runtime,data,structures,like,execution,graph,will,be,constructed,now,and,checkpoint,being,recovered,after,this,we,will,begin,to,schedule,the,job;rpc,method,public,void,start,job,final,uuid,leader,session,id,log,info,starting,job,with,leader,id,job,graph,get,name,job,graph,get,job,id,leader,session,id,try,if,execution,graph,null,execution,graph,new,execution,graph,execution,context,execution,context,job,graph,get,job,id,job,graph,get,name,job,graph,get,job,configuration,job,graph,get,serialized,execution,config,timeout,restart,strategy,job,graph,get,user,jar,blob,keys,job,graph,get,classpaths,user,code,loader,job,metrics,else,execution,graph,set,schedule,mode,job,graph,get,schedule,mode,execution,graph,set,queued,scheduling,allowed,job,graph,get,allow,queued,scheduling,try,execution,graph,set,json,plan,json,plan,generator,generate,plan,job,graph,catch,exception,e,log,warn,cannot,create,json,plan,for,job,job,graph,get,job,id,job,graph,get,name,e,execution,graph,set,json,plan,if,log,is,debug,enabled,log,debug,running,initialization,on,master,for,job,job,graph,get,job,id,job,graph,get,name,for,job,vertex,vertex,job,graph,get,vertices,final,string,executable,class,vertex,get,invokable,class,name,if,executable,class,null,executable,class,length,0,throw,new,job,execution,exception,job,graph,get,job,id,the,vertex,vertex,get,id,vertex,get,name,has,no,invokable,class,if,vertex,get,parallelism,execution,config,vertex,set,parallelism,scheduler,get,total,number,of,slots,try,vertex,initialize,on,master,user,code,loader,catch,throwable,t,throw,new,job,execution,exception,job,graph,get,job,id,cannot,initialize,task,vertex,get,name,t,get,message,t,final,list,job,vertex,sorted,topology,job,graph,get,vertices,sorted,topologically,from,sources,if,log,is,debug,enabled,log,debug,adding,vertices,from,job,graph,sorted,topology,size,job,graph,get,job,id,job,graph,get,name,execution,graph,attach,job,graph,sorted,topology,if,log,is,debug,enabled,log,debug,successfully,created,execution,graph,from,job,graph,job,graph,get,job,id,job,graph,get,name,final,job,snapshotting,settings,snapshot,settings,job,graph,get,snapshot,settings,if,snapshot,settings,null,list,execution,job,vertex,trigger,vertices,get,execution,job,vertex,with,id,execution,graph,snapshot,settings,get,vertices,to,trigger,list,execution,job,vertex,ack,vertices,get,execution,job,vertex,with,id,execution,graph,snapshot,settings,get,vertices,to,acknowledge,list,execution,job,vertex,confirm,vertices,get,execution,job,vertex,with,id,execution,graph,snapshot,settings,get,vertices,to,confirm,completed,checkpoint,store,completed,checkpoints,checkpoint,recovery,factory,create,checkpoint,store,job,graph,get,job,id,user,code,loader,checkpoint,idcounter,checkpoint,id,counter,checkpoint,recovery,factory,create,checkpoint,idcounter,job,graph,get,job,id,boolean,is,stats,disabled,configuration,get,boolean,config,constants,config,constants,final,checkpoint,stats,tracker,checkpoint,stats,tracker,if,is,stats,disabled,checkpoint,stats,tracker,new,disabled,checkpoint,stats,tracker,else,int,history,size,configuration,get,integer,config,constants,config,constants,checkpoint,stats,tracker,new,simple,checkpoint,stats,tracker,history,size,ack,vertices,job,metrics,string,externalized,checkpoints,dir,configuration,get,string,config,constants,null,execution,graph,enable,snapshot,checkpointing,snapshot,settings,get,checkpoint,interval,snapshot,settings,get,checkpoint,timeout,snapshot,settings,get,min,pause,between,checkpoints,snapshot,settings,get,max,concurrent,checkpoints,snapshot,settings,get,externalized,checkpoint,settings,trigger,vertices,ack,vertices,confirm,vertices,checkpoint,id,counter,completed,checkpoints,externalized,checkpoints,dir,checkpoint,stats,tracker,resource,manager,leader,retriever,start,new,resource,manager,leader,listener,catch,throwable,t,log,error,failed,to,start,job,job,graph,get,name,job,graph,get,job,id,t,execution,graph,fail,t,execution,graph,null,final,throwable,rt,if,t,instanceof,job,execution,exception,rt,job,execution,exception,t,else,rt,new,job,execution,exception,job,graph,get,job,id,failed,to,start,job,job,graph,get,job,id,job,graph,get,name,t,job,completion,actions,job,failed,rt,return,execution,context,execute,new,runnable,override,public,void,run,if,execution,graph,null,try,execution,graph,schedule,for,execution,scheduler,catch,throwable,t,execution,graph,fail,t
JobMaster -> @RpcMethod 	public void startJob(final UUID leaderSessionID);1475066391;Start to run the job, runtime data structures like ExecutionGraph will be constructed now and checkpoint_being recovered. After this, we will begin to schedule the job.;@RpcMethod_	public void startJob(final UUID leaderSessionID) {_		log.info("Starting job {} ({}) with leaderId {}.", jobGraph.getName(), jobGraph.getJobID(), leaderSessionID)___		this.leaderSessionID = leaderSessionID___		try {_			if (executionGraph != null) {_				executionGraph = new ExecutionGraph(_						executionContext,_						executionContext,_						jobGraph.getJobID(),_						jobGraph.getName(),_						jobGraph.getJobConfiguration(),_						jobGraph.getSerializedExecutionConfig(),_						timeout,_						restartStrategy,_						jobGraph.getUserJarBlobKeys(),_						jobGraph.getClasspaths(),_						userCodeLoader,_						jobMetrics)__			} else {_				_			}__			executionGraph.setScheduleMode(jobGraph.getScheduleMode())__			executionGraph.setQueuedSchedulingAllowed(jobGraph.getAllowQueuedScheduling())___			try {_				executionGraph.setJsonPlan(JsonPlanGenerator.generatePlan(jobGraph))__			} catch (Exception e) {_				log.warn("Cannot create JSON plan for job {} ({})", jobGraph.getJobID(), jobGraph.getName(), e)__				executionGraph.setJsonPlan("{}")__			}__			_			_			if (log.isDebugEnabled()) {_				log.debug("Running initialization on master for job {} ({}).", jobGraph.getJobID(), jobGraph.getName())__			}_			for (JobVertex vertex : jobGraph.getVertices()) {_				final String executableClass = vertex.getInvokableClassName()__				if (executableClass == null || executableClass.length() == 0) {_					throw new JobExecutionException(jobGraph.getJobID(),_						"The vertex " + vertex.getID() + " (" + vertex.getName() + ") has no invokable class.")__				}_				if (vertex.getParallelism() == ExecutionConfig.PARALLELISM_AUTO_MAX) {_					vertex.setParallelism(scheduler.getTotalNumberOfSlots())__				}__				try {_					vertex.initializeOnMaster(userCodeLoader)__				} catch (Throwable t) {_					throw new JobExecutionException(jobGraph.getJobID(),_						"Cannot initialize task '" + vertex.getName() + "': " + t.getMessage(), t)__				}_			}__			_			final List<JobVertex> sortedTopology = jobGraph.getVerticesSortedTopologicallyFromSources()__			if (log.isDebugEnabled()) {_				log.debug("Adding {} vertices from job graph {} ({}).", sortedTopology.size(),_					jobGraph.getJobID(), jobGraph.getName())__			}_			executionGraph.attachJobGraph(sortedTopology)___			if (log.isDebugEnabled()) {_				log.debug("Successfully created execution graph from job graph {} ({}).",_					jobGraph.getJobID(), jobGraph.getName())__			}__			final JobSnapshottingSettings snapshotSettings = jobGraph.getSnapshotSettings()__			if (snapshotSettings != null) {_				List<ExecutionJobVertex> triggerVertices = getExecutionJobVertexWithId(_					executionGraph, snapshotSettings.getVerticesToTrigger())___				List<ExecutionJobVertex> ackVertices = getExecutionJobVertexWithId(_					executionGraph, snapshotSettings.getVerticesToAcknowledge())___				List<ExecutionJobVertex> confirmVertices = getExecutionJobVertexWithId(_					executionGraph, snapshotSettings.getVerticesToConfirm())___				CompletedCheckpointStore completedCheckpoints = checkpointRecoveryFactory.createCheckpointStore(_					jobGraph.getJobID(), userCodeLoader)___				CheckpointIDCounter checkpointIdCounter = checkpointRecoveryFactory.createCheckpointIDCounter(_					jobGraph.getJobID())___				_				boolean isStatsDisabled = configuration.getBoolean(_					ConfigConstants.JOB_MANAGER_WEB_CHECKPOINTS_DISABLE,_					ConfigConstants.DEFAULT_JOB_MANAGER_WEB_CHECKPOINTS_DISABLE)___				final CheckpointStatsTracker checkpointStatsTracker__				if (isStatsDisabled) {_					checkpointStatsTracker = new DisabledCheckpointStatsTracker()__				}_				else {_					int historySize = configuration.getInteger(_						ConfigConstants.JOB_MANAGER_WEB_CHECKPOINTS_HISTORY_SIZE,_						ConfigConstants.DEFAULT_JOB_MANAGER_WEB_CHECKPOINTS_HISTORY_SIZE)__					checkpointStatsTracker = new SimpleCheckpointStatsTracker(historySize, ackVertices, jobMetrics)__				}__				String externalizedCheckpointsDir = configuration.getString(_						ConfigConstants.CHECKPOINTS_DIRECTORY_KEY, null)___				executionGraph.enableSnapshotCheckpointing(_					snapshotSettings.getCheckpointInterval(),_					snapshotSettings.getCheckpointTimeout(),_					snapshotSettings.getMinPauseBetweenCheckpoints(),_					snapshotSettings.getMaxConcurrentCheckpoints(),_					snapshotSettings.getExternalizedCheckpointSettings(),_					triggerVertices,_					ackVertices,_					confirmVertices,_					checkpointIdCounter,_					completedCheckpoints,_					externalizedCheckpointsDir,_					checkpointStatsTracker)__			}__			__			__			__			_			resourceManagerLeaderRetriever.start(new ResourceManagerLeaderListener())__		} catch (Throwable t) {_			log.error("Failed to start job {} ({})", jobGraph.getName(), jobGraph.getJobID(), t)___			executionGraph.fail(t)__			executionGraph = null___			final Throwable rt__			if (t instanceof JobExecutionException) {_				rt = (JobExecutionException) t__			}_			else {_				rt = new JobExecutionException(jobGraph.getJobID(),_					"Failed to start job " + jobGraph.getJobID() + " (" + jobGraph.getName() + ")", t)__			}__			__			jobCompletionActions.jobFailed(rt)__			return__		}__		_		executionContext.execute(new Runnable() {_			@Override_			public void run() {_				if (executionGraph != null) {_					try {_						executionGraph.scheduleForExecution(scheduler)__					} catch (Throwable t) {_						executionGraph.fail(t)__					}_				}_			}_		})__	};start,to,run,the,job,runtime,data,structures,like,execution,graph,will,be,constructed,now,and,checkpoint,being,recovered,after,this,we,will,begin,to,schedule,the,job;rpc,method,public,void,start,job,final,uuid,leader,session,id,log,info,starting,job,with,leader,id,job,graph,get,name,job,graph,get,job,id,leader,session,id,this,leader,session,id,leader,session,id,try,if,execution,graph,null,execution,graph,new,execution,graph,execution,context,execution,context,job,graph,get,job,id,job,graph,get,name,job,graph,get,job,configuration,job,graph,get,serialized,execution,config,timeout,restart,strategy,job,graph,get,user,jar,blob,keys,job,graph,get,classpaths,user,code,loader,job,metrics,else,execution,graph,set,schedule,mode,job,graph,get,schedule,mode,execution,graph,set,queued,scheduling,allowed,job,graph,get,allow,queued,scheduling,try,execution,graph,set,json,plan,json,plan,generator,generate,plan,job,graph,catch,exception,e,log,warn,cannot,create,json,plan,for,job,job,graph,get,job,id,job,graph,get,name,e,execution,graph,set,json,plan,if,log,is,debug,enabled,log,debug,running,initialization,on,master,for,job,job,graph,get,job,id,job,graph,get,name,for,job,vertex,vertex,job,graph,get,vertices,final,string,executable,class,vertex,get,invokable,class,name,if,executable,class,null,executable,class,length,0,throw,new,job,execution,exception,job,graph,get,job,id,the,vertex,vertex,get,id,vertex,get,name,has,no,invokable,class,if,vertex,get,parallelism,execution,config,vertex,set,parallelism,scheduler,get,total,number,of,slots,try,vertex,initialize,on,master,user,code,loader,catch,throwable,t,throw,new,job,execution,exception,job,graph,get,job,id,cannot,initialize,task,vertex,get,name,t,get,message,t,final,list,job,vertex,sorted,topology,job,graph,get,vertices,sorted,topologically,from,sources,if,log,is,debug,enabled,log,debug,adding,vertices,from,job,graph,sorted,topology,size,job,graph,get,job,id,job,graph,get,name,execution,graph,attach,job,graph,sorted,topology,if,log,is,debug,enabled,log,debug,successfully,created,execution,graph,from,job,graph,job,graph,get,job,id,job,graph,get,name,final,job,snapshotting,settings,snapshot,settings,job,graph,get,snapshot,settings,if,snapshot,settings,null,list,execution,job,vertex,trigger,vertices,get,execution,job,vertex,with,id,execution,graph,snapshot,settings,get,vertices,to,trigger,list,execution,job,vertex,ack,vertices,get,execution,job,vertex,with,id,execution,graph,snapshot,settings,get,vertices,to,acknowledge,list,execution,job,vertex,confirm,vertices,get,execution,job,vertex,with,id,execution,graph,snapshot,settings,get,vertices,to,confirm,completed,checkpoint,store,completed,checkpoints,checkpoint,recovery,factory,create,checkpoint,store,job,graph,get,job,id,user,code,loader,checkpoint,idcounter,checkpoint,id,counter,checkpoint,recovery,factory,create,checkpoint,idcounter,job,graph,get,job,id,boolean,is,stats,disabled,configuration,get,boolean,config,constants,config,constants,final,checkpoint,stats,tracker,checkpoint,stats,tracker,if,is,stats,disabled,checkpoint,stats,tracker,new,disabled,checkpoint,stats,tracker,else,int,history,size,configuration,get,integer,config,constants,config,constants,checkpoint,stats,tracker,new,simple,checkpoint,stats,tracker,history,size,ack,vertices,job,metrics,string,externalized,checkpoints,dir,configuration,get,string,config,constants,null,execution,graph,enable,snapshot,checkpointing,snapshot,settings,get,checkpoint,interval,snapshot,settings,get,checkpoint,timeout,snapshot,settings,get,min,pause,between,checkpoints,snapshot,settings,get,max,concurrent,checkpoints,snapshot,settings,get,externalized,checkpoint,settings,trigger,vertices,ack,vertices,confirm,vertices,checkpoint,id,counter,completed,checkpoints,externalized,checkpoints,dir,checkpoint,stats,tracker,resource,manager,leader,retriever,start,new,resource,manager,leader,listener,catch,throwable,t,log,error,failed,to,start,job,job,graph,get,name,job,graph,get,job,id,t,execution,graph,fail,t,execution,graph,null,final,throwable,rt,if,t,instanceof,job,execution,exception,rt,job,execution,exception,t,else,rt,new,job,execution,exception,job,graph,get,job,id,failed,to,start,job,job,graph,get,job,id,job,graph,get,name,t,job,completion,actions,job,failed,rt,return,execution,context,execute,new,runnable,override,public,void,run,if,execution,graph,null,try,execution,graph,schedule,for,execution,scheduler,catch,throwable,t,execution,graph,fail,t
JobMaster -> @RpcMethod 	public void startJob(final UUID leaderSessionID);1475110587;Start to run the job, runtime data structures like ExecutionGraph will be constructed now and checkpoint_being recovered. After this, we will begin to schedule the job.;@RpcMethod_	public void startJob(final UUID leaderSessionID) {_		log.info("Starting job {} ({}) with leaderId {}.", jobGraph.getName(), jobGraph.getJobID(), leaderSessionID)___		try {_			if (executionGraph != null) {_				executionGraph = new ExecutionGraph(_						executionContext,_						executionContext,_						jobGraph.getJobID(),_						jobGraph.getName(),_						jobGraph.getJobConfiguration(),_						jobGraph.getSerializedExecutionConfig(),_						timeout,_						restartStrategy,_						jobGraph.getUserJarBlobKeys(),_						jobGraph.getClasspaths(),_						userCodeLoader,_						jobMetrics)__			} else {_				_			}__			executionGraph.setScheduleMode(jobGraph.getScheduleMode())__			executionGraph.setQueuedSchedulingAllowed(jobGraph.getAllowQueuedScheduling())___			try {_				executionGraph.setJsonPlan(JsonPlanGenerator.generatePlan(jobGraph))__			} catch (Exception e) {_				log.warn("Cannot create JSON plan for job {} ({})", jobGraph.getJobID(), jobGraph.getName(), e)__				executionGraph.setJsonPlan("{}")__			}__			_			_			if (log.isDebugEnabled()) {_				log.debug("Running initialization on master for job {} ({}).", jobGraph.getJobID(), jobGraph.getName())__			}_			for (JobVertex vertex : jobGraph.getVertices()) {_				final String executableClass = vertex.getInvokableClassName()__				if (executableClass == null || executableClass.length() == 0) {_					throw new JobExecutionException(jobGraph.getJobID(),_						"The vertex " + vertex.getID() + " (" + vertex.getName() + ") has no invokable class.")__				}_				if (vertex.getParallelism() == ExecutionConfig.PARALLELISM_AUTO_MAX) {_					vertex.setParallelism(scheduler.getTotalNumberOfSlots())__				}__				try {_					vertex.initializeOnMaster(userCodeLoader)__				} catch (Throwable t) {_					throw new JobExecutionException(jobGraph.getJobID(),_						"Cannot initialize task '" + vertex.getName() + "': " + t.getMessage(), t)__				}_			}__			_			final List<JobVertex> sortedTopology = jobGraph.getVerticesSortedTopologicallyFromSources()__			if (log.isDebugEnabled()) {_				log.debug("Adding {} vertices from job graph {} ({}).", sortedTopology.size(),_					jobGraph.getJobID(), jobGraph.getName())__			}_			executionGraph.attachJobGraph(sortedTopology)___			if (log.isDebugEnabled()) {_				log.debug("Successfully created execution graph from job graph {} ({}).",_					jobGraph.getJobID(), jobGraph.getName())__			}__			final JobSnapshottingSettings snapshotSettings = jobGraph.getSnapshotSettings()__			if (snapshotSettings != null) {_				List<ExecutionJobVertex> triggerVertices = getExecutionJobVertexWithId(_					executionGraph, snapshotSettings.getVerticesToTrigger())___				List<ExecutionJobVertex> ackVertices = getExecutionJobVertexWithId(_					executionGraph, snapshotSettings.getVerticesToAcknowledge())___				List<ExecutionJobVertex> confirmVertices = getExecutionJobVertexWithId(_					executionGraph, snapshotSettings.getVerticesToConfirm())___				CompletedCheckpointStore completedCheckpoints = checkpointRecoveryFactory.createCheckpointStore(_					jobGraph.getJobID(), userCodeLoader)___				CheckpointIDCounter checkpointIdCounter = checkpointRecoveryFactory.createCheckpointIDCounter(_					jobGraph.getJobID())___				_				boolean isStatsDisabled = configuration.getBoolean(_					ConfigConstants.JOB_MANAGER_WEB_CHECKPOINTS_DISABLE,_					ConfigConstants.DEFAULT_JOB_MANAGER_WEB_CHECKPOINTS_DISABLE)___				final CheckpointStatsTracker checkpointStatsTracker__				if (isStatsDisabled) {_					checkpointStatsTracker = new DisabledCheckpointStatsTracker()__				}_				else {_					int historySize = configuration.getInteger(_						ConfigConstants.JOB_MANAGER_WEB_CHECKPOINTS_HISTORY_SIZE,_						ConfigConstants.DEFAULT_JOB_MANAGER_WEB_CHECKPOINTS_HISTORY_SIZE)__					checkpointStatsTracker = new SimpleCheckpointStatsTracker(historySize, ackVertices, jobMetrics)__				}__				String externalizedCheckpointsDir = configuration.getString(_						ConfigConstants.CHECKPOINTS_DIRECTORY_KEY, null)___				executionGraph.enableSnapshotCheckpointing(_					snapshotSettings.getCheckpointInterval(),_					snapshotSettings.getCheckpointTimeout(),_					snapshotSettings.getMinPauseBetweenCheckpoints(),_					snapshotSettings.getMaxConcurrentCheckpoints(),_					snapshotSettings.getExternalizedCheckpointSettings(),_					triggerVertices,_					ackVertices,_					confirmVertices,_					checkpointIdCounter,_					completedCheckpoints,_					externalizedCheckpointsDir,_					checkpointStatsTracker)__			}__			__			__			__			_			resourceManagerLeaderRetriever.start(new ResourceManagerLeaderListener())__		} catch (Throwable t) {_			log.error("Failed to start job {} ({})", jobGraph.getName(), jobGraph.getJobID(), t)___			executionGraph.fail(t)__			executionGraph = null___			final Throwable rt__			if (t instanceof JobExecutionException) {_				rt = (JobExecutionException) t__			}_			else {_				rt = new JobExecutionException(jobGraph.getJobID(),_					"Failed to start job " + jobGraph.getJobID() + " (" + jobGraph.getName() + ")", t)__			}__			__			jobCompletionActions.jobFailed(rt)__			return__		}__		_		executionContext.execute(new Runnable() {_			@Override_			public void run() {_				if (executionGraph != null) {_					try {_						executionGraph.scheduleForExecution(scheduler)__					} catch (Throwable t) {_						executionGraph.fail(t)__					}_				}_			}_		})__	};start,to,run,the,job,runtime,data,structures,like,execution,graph,will,be,constructed,now,and,checkpoint,being,recovered,after,this,we,will,begin,to,schedule,the,job;rpc,method,public,void,start,job,final,uuid,leader,session,id,log,info,starting,job,with,leader,id,job,graph,get,name,job,graph,get,job,id,leader,session,id,try,if,execution,graph,null,execution,graph,new,execution,graph,execution,context,execution,context,job,graph,get,job,id,job,graph,get,name,job,graph,get,job,configuration,job,graph,get,serialized,execution,config,timeout,restart,strategy,job,graph,get,user,jar,blob,keys,job,graph,get,classpaths,user,code,loader,job,metrics,else,execution,graph,set,schedule,mode,job,graph,get,schedule,mode,execution,graph,set,queued,scheduling,allowed,job,graph,get,allow,queued,scheduling,try,execution,graph,set,json,plan,json,plan,generator,generate,plan,job,graph,catch,exception,e,log,warn,cannot,create,json,plan,for,job,job,graph,get,job,id,job,graph,get,name,e,execution,graph,set,json,plan,if,log,is,debug,enabled,log,debug,running,initialization,on,master,for,job,job,graph,get,job,id,job,graph,get,name,for,job,vertex,vertex,job,graph,get,vertices,final,string,executable,class,vertex,get,invokable,class,name,if,executable,class,null,executable,class,length,0,throw,new,job,execution,exception,job,graph,get,job,id,the,vertex,vertex,get,id,vertex,get,name,has,no,invokable,class,if,vertex,get,parallelism,execution,config,vertex,set,parallelism,scheduler,get,total,number,of,slots,try,vertex,initialize,on,master,user,code,loader,catch,throwable,t,throw,new,job,execution,exception,job,graph,get,job,id,cannot,initialize,task,vertex,get,name,t,get,message,t,final,list,job,vertex,sorted,topology,job,graph,get,vertices,sorted,topologically,from,sources,if,log,is,debug,enabled,log,debug,adding,vertices,from,job,graph,sorted,topology,size,job,graph,get,job,id,job,graph,get,name,execution,graph,attach,job,graph,sorted,topology,if,log,is,debug,enabled,log,debug,successfully,created,execution,graph,from,job,graph,job,graph,get,job,id,job,graph,get,name,final,job,snapshotting,settings,snapshot,settings,job,graph,get,snapshot,settings,if,snapshot,settings,null,list,execution,job,vertex,trigger,vertices,get,execution,job,vertex,with,id,execution,graph,snapshot,settings,get,vertices,to,trigger,list,execution,job,vertex,ack,vertices,get,execution,job,vertex,with,id,execution,graph,snapshot,settings,get,vertices,to,acknowledge,list,execution,job,vertex,confirm,vertices,get,execution,job,vertex,with,id,execution,graph,snapshot,settings,get,vertices,to,confirm,completed,checkpoint,store,completed,checkpoints,checkpoint,recovery,factory,create,checkpoint,store,job,graph,get,job,id,user,code,loader,checkpoint,idcounter,checkpoint,id,counter,checkpoint,recovery,factory,create,checkpoint,idcounter,job,graph,get,job,id,boolean,is,stats,disabled,configuration,get,boolean,config,constants,config,constants,final,checkpoint,stats,tracker,checkpoint,stats,tracker,if,is,stats,disabled,checkpoint,stats,tracker,new,disabled,checkpoint,stats,tracker,else,int,history,size,configuration,get,integer,config,constants,config,constants,checkpoint,stats,tracker,new,simple,checkpoint,stats,tracker,history,size,ack,vertices,job,metrics,string,externalized,checkpoints,dir,configuration,get,string,config,constants,null,execution,graph,enable,snapshot,checkpointing,snapshot,settings,get,checkpoint,interval,snapshot,settings,get,checkpoint,timeout,snapshot,settings,get,min,pause,between,checkpoints,snapshot,settings,get,max,concurrent,checkpoints,snapshot,settings,get,externalized,checkpoint,settings,trigger,vertices,ack,vertices,confirm,vertices,checkpoint,id,counter,completed,checkpoints,externalized,checkpoints,dir,checkpoint,stats,tracker,resource,manager,leader,retriever,start,new,resource,manager,leader,listener,catch,throwable,t,log,error,failed,to,start,job,job,graph,get,name,job,graph,get,job,id,t,execution,graph,fail,t,execution,graph,null,final,throwable,rt,if,t,instanceof,job,execution,exception,rt,job,execution,exception,t,else,rt,new,job,execution,exception,job,graph,get,job,id,failed,to,start,job,job,graph,get,job,id,job,graph,get,name,t,job,completion,actions,job,failed,rt,return,execution,context,execute,new,runnable,override,public,void,run,if,execution,graph,null,try,execution,graph,schedule,for,execution,scheduler,catch,throwable,t,execution,graph,fail,t
JobMaster -> @RpcMethod 	public void startJob(final UUID leaderSessionID);1475593222;Start to run the job, runtime data structures like ExecutionGraph will be constructed now and checkpoint_being recovered. After this, we will begin to schedule the job.;@RpcMethod_	public void startJob(final UUID leaderSessionID) {_		log.info("Starting job {} ({}) with leaderId {}.", jobGraph.getName(), jobGraph.getJobID(), leaderSessionID)___		this.leaderSessionID = leaderSessionID___		try {_			if (executionGraph != null) {_				executionGraph = new ExecutionGraph(_						executionContext,_						executionContext,_						jobGraph.getJobID(),_						jobGraph.getName(),_						jobGraph.getJobConfiguration(),_						jobGraph.getSerializedExecutionConfig(),_						timeout,_						restartStrategy,_						jobGraph.getUserJarBlobKeys(),_						jobGraph.getClasspaths(),_						userCodeLoader,_						jobMetrics)__			} else {_				_			}__			executionGraph.setScheduleMode(jobGraph.getScheduleMode())__			executionGraph.setQueuedSchedulingAllowed(jobGraph.getAllowQueuedScheduling())___			try {_				executionGraph.setJsonPlan(JsonPlanGenerator.generatePlan(jobGraph))__			} catch (Exception e) {_				log.warn("Cannot create JSON plan for job {} ({})", jobGraph.getJobID(), jobGraph.getName(), e)__				executionGraph.setJsonPlan("{}")__			}__			_			_			if (log.isDebugEnabled()) {_				log.debug("Running initialization on master for job {} ({}).", jobGraph.getJobID(), jobGraph.getName())__			}_			for (JobVertex vertex : jobGraph.getVertices()) {_				final String executableClass = vertex.getInvokableClassName()__				if (executableClass == null || executableClass.length() == 0) {_					throw new JobExecutionException(jobGraph.getJobID(),_						"The vertex " + vertex.getID() + " (" + vertex.getName() + ") has no invokable class.")__				}_				if (vertex.getParallelism() == ExecutionConfig.PARALLELISM_AUTO_MAX) {_					vertex.setParallelism(scheduler.getTotalNumberOfSlots())__				}__				try {_					vertex.initializeOnMaster(userCodeLoader)__				} catch (Throwable t) {_					throw new JobExecutionException(jobGraph.getJobID(),_						"Cannot initialize task '" + vertex.getName() + "': " + t.getMessage(), t)__				}_			}__			_			final List<JobVertex> sortedTopology = jobGraph.getVerticesSortedTopologicallyFromSources()__			if (log.isDebugEnabled()) {_				log.debug("Adding {} vertices from job graph {} ({}).", sortedTopology.size(),_					jobGraph.getJobID(), jobGraph.getName())__			}_			executionGraph.attachJobGraph(sortedTopology)___			if (log.isDebugEnabled()) {_				log.debug("Successfully created execution graph from job graph {} ({}).",_					jobGraph.getJobID(), jobGraph.getName())__			}__			final JobSnapshottingSettings snapshotSettings = jobGraph.getSnapshotSettings()__			if (snapshotSettings != null) {_				List<ExecutionJobVertex> triggerVertices = getExecutionJobVertexWithId(_					executionGraph, snapshotSettings.getVerticesToTrigger())___				List<ExecutionJobVertex> ackVertices = getExecutionJobVertexWithId(_					executionGraph, snapshotSettings.getVerticesToAcknowledge())___				List<ExecutionJobVertex> confirmVertices = getExecutionJobVertexWithId(_					executionGraph, snapshotSettings.getVerticesToConfirm())___				CompletedCheckpointStore completedCheckpoints = checkpointRecoveryFactory.createCheckpointStore(_					jobGraph.getJobID(), userCodeLoader)___				CheckpointIDCounter checkpointIdCounter = checkpointRecoveryFactory.createCheckpointIDCounter(_					jobGraph.getJobID())___				_				boolean isStatsDisabled = configuration.getBoolean(_					ConfigConstants.JOB_MANAGER_WEB_CHECKPOINTS_DISABLE,_					ConfigConstants.DEFAULT_JOB_MANAGER_WEB_CHECKPOINTS_DISABLE)___				final CheckpointStatsTracker checkpointStatsTracker__				if (isStatsDisabled) {_					checkpointStatsTracker = new DisabledCheckpointStatsTracker()__				}_				else {_					int historySize = configuration.getInteger(_						ConfigConstants.JOB_MANAGER_WEB_CHECKPOINTS_HISTORY_SIZE,_						ConfigConstants.DEFAULT_JOB_MANAGER_WEB_CHECKPOINTS_HISTORY_SIZE)__					checkpointStatsTracker = new SimpleCheckpointStatsTracker(historySize, ackVertices, jobMetrics)__				}__				String externalizedCheckpointsDir = configuration.getString(_						ConfigConstants.CHECKPOINTS_DIRECTORY_KEY, null)___				executionGraph.enableSnapshotCheckpointing(_					snapshotSettings.getCheckpointInterval(),_					snapshotSettings.getCheckpointTimeout(),_					snapshotSettings.getMinPauseBetweenCheckpoints(),_					snapshotSettings.getMaxConcurrentCheckpoints(),_					snapshotSettings.getExternalizedCheckpointSettings(),_					triggerVertices,_					ackVertices,_					confirmVertices,_					checkpointIdCounter,_					completedCheckpoints,_					externalizedCheckpointsDir,_					checkpointStatsTracker)__			}__			__			__			__			_			resourceManagerLeaderRetriever.start(new ResourceManagerLeaderListener())__		} catch (Throwable t) {_			log.error("Failed to start job {} ({})", jobGraph.getName(), jobGraph.getJobID(), t)___			executionGraph.fail(t)__			executionGraph = null___			final Throwable rt__			if (t instanceof JobExecutionException) {_				rt = (JobExecutionException) t__			}_			else {_				rt = new JobExecutionException(jobGraph.getJobID(),_					"Failed to start job " + jobGraph.getJobID() + " (" + jobGraph.getName() + ")", t)__			}__			__			jobCompletionActions.jobFailed(rt)__			return__		}__		_		executionContext.execute(new Runnable() {_			@Override_			public void run() {_				if (executionGraph != null) {_					try {_						executionGraph.scheduleForExecution(scheduler)__					} catch (Throwable t) {_						executionGraph.fail(t)__					}_				}_			}_		})__	};start,to,run,the,job,runtime,data,structures,like,execution,graph,will,be,constructed,now,and,checkpoint,being,recovered,after,this,we,will,begin,to,schedule,the,job;rpc,method,public,void,start,job,final,uuid,leader,session,id,log,info,starting,job,with,leader,id,job,graph,get,name,job,graph,get,job,id,leader,session,id,this,leader,session,id,leader,session,id,try,if,execution,graph,null,execution,graph,new,execution,graph,execution,context,execution,context,job,graph,get,job,id,job,graph,get,name,job,graph,get,job,configuration,job,graph,get,serialized,execution,config,timeout,restart,strategy,job,graph,get,user,jar,blob,keys,job,graph,get,classpaths,user,code,loader,job,metrics,else,execution,graph,set,schedule,mode,job,graph,get,schedule,mode,execution,graph,set,queued,scheduling,allowed,job,graph,get,allow,queued,scheduling,try,execution,graph,set,json,plan,json,plan,generator,generate,plan,job,graph,catch,exception,e,log,warn,cannot,create,json,plan,for,job,job,graph,get,job,id,job,graph,get,name,e,execution,graph,set,json,plan,if,log,is,debug,enabled,log,debug,running,initialization,on,master,for,job,job,graph,get,job,id,job,graph,get,name,for,job,vertex,vertex,job,graph,get,vertices,final,string,executable,class,vertex,get,invokable,class,name,if,executable,class,null,executable,class,length,0,throw,new,job,execution,exception,job,graph,get,job,id,the,vertex,vertex,get,id,vertex,get,name,has,no,invokable,class,if,vertex,get,parallelism,execution,config,vertex,set,parallelism,scheduler,get,total,number,of,slots,try,vertex,initialize,on,master,user,code,loader,catch,throwable,t,throw,new,job,execution,exception,job,graph,get,job,id,cannot,initialize,task,vertex,get,name,t,get,message,t,final,list,job,vertex,sorted,topology,job,graph,get,vertices,sorted,topologically,from,sources,if,log,is,debug,enabled,log,debug,adding,vertices,from,job,graph,sorted,topology,size,job,graph,get,job,id,job,graph,get,name,execution,graph,attach,job,graph,sorted,topology,if,log,is,debug,enabled,log,debug,successfully,created,execution,graph,from,job,graph,job,graph,get,job,id,job,graph,get,name,final,job,snapshotting,settings,snapshot,settings,job,graph,get,snapshot,settings,if,snapshot,settings,null,list,execution,job,vertex,trigger,vertices,get,execution,job,vertex,with,id,execution,graph,snapshot,settings,get,vertices,to,trigger,list,execution,job,vertex,ack,vertices,get,execution,job,vertex,with,id,execution,graph,snapshot,settings,get,vertices,to,acknowledge,list,execution,job,vertex,confirm,vertices,get,execution,job,vertex,with,id,execution,graph,snapshot,settings,get,vertices,to,confirm,completed,checkpoint,store,completed,checkpoints,checkpoint,recovery,factory,create,checkpoint,store,job,graph,get,job,id,user,code,loader,checkpoint,idcounter,checkpoint,id,counter,checkpoint,recovery,factory,create,checkpoint,idcounter,job,graph,get,job,id,boolean,is,stats,disabled,configuration,get,boolean,config,constants,config,constants,final,checkpoint,stats,tracker,checkpoint,stats,tracker,if,is,stats,disabled,checkpoint,stats,tracker,new,disabled,checkpoint,stats,tracker,else,int,history,size,configuration,get,integer,config,constants,config,constants,checkpoint,stats,tracker,new,simple,checkpoint,stats,tracker,history,size,ack,vertices,job,metrics,string,externalized,checkpoints,dir,configuration,get,string,config,constants,null,execution,graph,enable,snapshot,checkpointing,snapshot,settings,get,checkpoint,interval,snapshot,settings,get,checkpoint,timeout,snapshot,settings,get,min,pause,between,checkpoints,snapshot,settings,get,max,concurrent,checkpoints,snapshot,settings,get,externalized,checkpoint,settings,trigger,vertices,ack,vertices,confirm,vertices,checkpoint,id,counter,completed,checkpoints,externalized,checkpoints,dir,checkpoint,stats,tracker,resource,manager,leader,retriever,start,new,resource,manager,leader,listener,catch,throwable,t,log,error,failed,to,start,job,job,graph,get,name,job,graph,get,job,id,t,execution,graph,fail,t,execution,graph,null,final,throwable,rt,if,t,instanceof,job,execution,exception,rt,job,execution,exception,t,else,rt,new,job,execution,exception,job,graph,get,job,id,failed,to,start,job,job,graph,get,job,id,job,graph,get,name,t,job,completion,actions,job,failed,rt,return,execution,context,execute,new,runnable,override,public,void,run,if,execution,graph,null,try,execution,graph,schedule,for,execution,scheduler,catch,throwable,t,execution,graph,fail,t
JobMaster -> private void jobStatusChanged(final JobStatus newJobStatus, long timestamp, final Throwable error);1474858756;TODO - wrap this as StatusListenerMessenger's callback with rpc main thread;private void jobStatusChanged(final JobStatus newJobStatus, long timestamp, final Throwable error) {_		final JobID jobID = executionGraph.getJobID()__		final String jobName = executionGraph.getJobName()__		log.info("Status of job {} ({}) changed to {}.", jobID, jobName, newJobStatus, error)___		if (newJobStatus.isGloballyTerminalState()) {_			__			__			if (newJobStatus == JobStatus.FINISHED) {_				try {_					final Map<String, SerializedValue<Object>> accumulatorResults =_						executionGraph.getAccumulatorsSerialized()__					final SerializedJobExecutionResult result = new SerializedJobExecutionResult(_						jobID, 0, accumulatorResults _					)__					jobCompletionActions.jobFinished(result.toJobExecutionResult(userCodeLoader))__				} catch (Exception e) {_					log.error("Cannot fetch final accumulators for job {} ({})", jobName, jobID, e)__					final JobExecutionException exception = new JobExecutionException(_						jobID, "Failed to retrieve accumulator results.", e)__					_					jobCompletionActions.jobFailed(exception)__				}_			}_			else if (newJobStatus == JobStatus.CANCELED) {_				final Throwable unpackedError = SerializedThrowable.get(error, userCodeLoader)__				final JobExecutionException exception = new JobExecutionException(_					jobID, "Job was cancelled.", unpackedError)__				_				jobCompletionActions.jobFailed(exception)__			}_			else if (newJobStatus == JobStatus.FAILED) {_				final Throwable unpackedError = SerializedThrowable.get(error, userCodeLoader)__				final JobExecutionException exception = new JobExecutionException(_					jobID, "Job execution failed.", unpackedError)__				_				jobCompletionActions.jobFailed(exception)__			}_			else {_				final JobExecutionException exception = new JobExecutionException(_					jobID, newJobStatus + " is not a terminal state.")__				_				jobCompletionActions.jobFailed(exception)__				throw new RuntimeException(exception)__			}_		}_	};todo,wrap,this,as,status,listener,messenger,s,callback,with,rpc,main,thread;private,void,job,status,changed,final,job,status,new,job,status,long,timestamp,final,throwable,error,final,job,id,job,id,execution,graph,get,job,id,final,string,job,name,execution,graph,get,job,name,log,info,status,of,job,changed,to,job,id,job,name,new,job,status,error,if,new,job,status,is,globally,terminal,state,if,new,job,status,job,status,finished,try,final,map,string,serialized,value,object,accumulator,results,execution,graph,get,accumulators,serialized,final,serialized,job,execution,result,result,new,serialized,job,execution,result,job,id,0,accumulator,results,job,completion,actions,job,finished,result,to,job,execution,result,user,code,loader,catch,exception,e,log,error,cannot,fetch,final,accumulators,for,job,job,name,job,id,e,final,job,execution,exception,exception,new,job,execution,exception,job,id,failed,to,retrieve,accumulator,results,e,job,completion,actions,job,failed,exception,else,if,new,job,status,job,status,canceled,final,throwable,unpacked,error,serialized,throwable,get,error,user,code,loader,final,job,execution,exception,exception,new,job,execution,exception,job,id,job,was,cancelled,unpacked,error,job,completion,actions,job,failed,exception,else,if,new,job,status,job,status,failed,final,throwable,unpacked,error,serialized,throwable,get,error,user,code,loader,final,job,execution,exception,exception,new,job,execution,exception,job,id,job,execution,failed,unpacked,error,job,completion,actions,job,failed,exception,else,final,job,execution,exception,exception,new,job,execution,exception,job,id,new,job,status,is,not,a,terminal,state,job,completion,actions,job,failed,exception,throw,new,runtime,exception,exception
JobMaster -> private void jobStatusChanged(final JobStatus newJobStatus, long timestamp, final Throwable error);1475066391;TODO - wrap this as StatusListenerMessenger's callback with rpc main thread;private void jobStatusChanged(final JobStatus newJobStatus, long timestamp, final Throwable error) {_		final JobID jobID = executionGraph.getJobID()__		final String jobName = executionGraph.getJobName()__		log.info("Status of job {} ({}) changed to {}.", jobID, jobName, newJobStatus, error)___		if (newJobStatus.isGloballyTerminalState()) {_			__			__			if (newJobStatus == JobStatus.FINISHED) {_				try {_					final Map<String, SerializedValue<Object>> accumulatorResults =_						executionGraph.getAccumulatorsSerialized()__					final SerializedJobExecutionResult result = new SerializedJobExecutionResult(_						jobID, 0, accumulatorResults _					)__					jobCompletionActions.jobFinished(result.toJobExecutionResult(userCodeLoader))__				} catch (Exception e) {_					log.error("Cannot fetch final accumulators for job {} ({})", jobName, jobID, e)__					final JobExecutionException exception = new JobExecutionException(_						jobID, "Failed to retrieve accumulator results.", e)__					_					jobCompletionActions.jobFailed(exception)__				}_			}_			else if (newJobStatus == JobStatus.CANCELED) {_				final Throwable unpackedError = SerializedThrowable.get(error, userCodeLoader)__				final JobExecutionException exception = new JobExecutionException(_					jobID, "Job was cancelled.", unpackedError)__				_				jobCompletionActions.jobFailed(exception)__			}_			else if (newJobStatus == JobStatus.FAILED) {_				final Throwable unpackedError = SerializedThrowable.get(error, userCodeLoader)__				final JobExecutionException exception = new JobExecutionException(_					jobID, "Job execution failed.", unpackedError)__				_				jobCompletionActions.jobFailed(exception)__			}_			else {_				final JobExecutionException exception = new JobExecutionException(_					jobID, newJobStatus + " is not a terminal state.")__				_				jobCompletionActions.jobFailed(exception)__				throw new RuntimeException(exception)__			}_		}_	};todo,wrap,this,as,status,listener,messenger,s,callback,with,rpc,main,thread;private,void,job,status,changed,final,job,status,new,job,status,long,timestamp,final,throwable,error,final,job,id,job,id,execution,graph,get,job,id,final,string,job,name,execution,graph,get,job,name,log,info,status,of,job,changed,to,job,id,job,name,new,job,status,error,if,new,job,status,is,globally,terminal,state,if,new,job,status,job,status,finished,try,final,map,string,serialized,value,object,accumulator,results,execution,graph,get,accumulators,serialized,final,serialized,job,execution,result,result,new,serialized,job,execution,result,job,id,0,accumulator,results,job,completion,actions,job,finished,result,to,job,execution,result,user,code,loader,catch,exception,e,log,error,cannot,fetch,final,accumulators,for,job,job,name,job,id,e,final,job,execution,exception,exception,new,job,execution,exception,job,id,failed,to,retrieve,accumulator,results,e,job,completion,actions,job,failed,exception,else,if,new,job,status,job,status,canceled,final,throwable,unpacked,error,serialized,throwable,get,error,user,code,loader,final,job,execution,exception,exception,new,job,execution,exception,job,id,job,was,cancelled,unpacked,error,job,completion,actions,job,failed,exception,else,if,new,job,status,job,status,failed,final,throwable,unpacked,error,serialized,throwable,get,error,user,code,loader,final,job,execution,exception,exception,new,job,execution,exception,job,id,job,execution,failed,unpacked,error,job,completion,actions,job,failed,exception,else,final,job,execution,exception,exception,new,job,execution,exception,job,id,new,job,status,is,not,a,terminal,state,job,completion,actions,job,failed,exception,throw,new,runtime,exception,exception
JobMaster -> private void jobStatusChanged(final JobStatus newJobStatus, long timestamp, final Throwable error);1475593222;TODO - wrap this as StatusListenerMessenger's callback with rpc main thread;private void jobStatusChanged(final JobStatus newJobStatus, long timestamp, final Throwable error) {_		final JobID jobID = executionGraph.getJobID()__		final String jobName = executionGraph.getJobName()__		log.info("Status of job {} ({}) changed to {}.", jobID, jobName, newJobStatus, error)___		if (newJobStatus.isGloballyTerminalState()) {_			__			__			if (newJobStatus == JobStatus.FINISHED) {_				try {_					final Map<String, SerializedValue<Object>> accumulatorResults =_						executionGraph.getAccumulatorsSerialized()__					final SerializedJobExecutionResult result = new SerializedJobExecutionResult(_						jobID, 0, accumulatorResults _					)__					jobCompletionActions.jobFinished(result.toJobExecutionResult(userCodeLoader))__				} catch (Exception e) {_					log.error("Cannot fetch final accumulators for job {} ({})", jobName, jobID, e)__					final JobExecutionException exception = new JobExecutionException(_						jobID, "Failed to retrieve accumulator results.", e)__					_					jobCompletionActions.jobFailed(exception)__				}_			}_			else if (newJobStatus == JobStatus.CANCELED) {_				final Throwable unpackedError = SerializedThrowable.get(error, userCodeLoader)__				final JobExecutionException exception = new JobExecutionException(_					jobID, "Job was cancelled.", unpackedError)__				_				jobCompletionActions.jobFailed(exception)__			}_			else if (newJobStatus == JobStatus.FAILED) {_				final Throwable unpackedError = SerializedThrowable.get(error, userCodeLoader)__				final JobExecutionException exception = new JobExecutionException(_					jobID, "Job execution failed.", unpackedError)__				_				jobCompletionActions.jobFailed(exception)__			}_			else {_				final JobExecutionException exception = new JobExecutionException(_					jobID, newJobStatus + " is not a terminal state.")__				_				jobCompletionActions.jobFailed(exception)__				throw new RuntimeException(exception)__			}_		}_	};todo,wrap,this,as,status,listener,messenger,s,callback,with,rpc,main,thread;private,void,job,status,changed,final,job,status,new,job,status,long,timestamp,final,throwable,error,final,job,id,job,id,execution,graph,get,job,id,final,string,job,name,execution,graph,get,job,name,log,info,status,of,job,changed,to,job,id,job,name,new,job,status,error,if,new,job,status,is,globally,terminal,state,if,new,job,status,job,status,finished,try,final,map,string,serialized,value,object,accumulator,results,execution,graph,get,accumulators,serialized,final,serialized,job,execution,result,result,new,serialized,job,execution,result,job,id,0,accumulator,results,job,completion,actions,job,finished,result,to,job,execution,result,user,code,loader,catch,exception,e,log,error,cannot,fetch,final,accumulators,for,job,job,name,job,id,e,final,job,execution,exception,exception,new,job,execution,exception,job,id,failed,to,retrieve,accumulator,results,e,job,completion,actions,job,failed,exception,else,if,new,job,status,job,status,canceled,final,throwable,unpacked,error,serialized,throwable,get,error,user,code,loader,final,job,execution,exception,exception,new,job,execution,exception,job,id,job,was,cancelled,unpacked,error,job,completion,actions,job,failed,exception,else,if,new,job,status,job,status,failed,final,throwable,unpacked,error,serialized,throwable,get,error,user,code,loader,final,job,execution,exception,exception,new,job,execution,exception,job,id,job,execution,failed,unpacked,error,job,completion,actions,job,failed,exception,else,final,job,execution,exception,exception,new,job,execution,exception,job,id,new,job,status,is,not,a,terminal,state,job,completion,actions,job,failed,exception,throw,new,runtime,exception,exception
JobMaster -> @RpcMethod 	public void suspendExecution(final Throwable cause);1475679726;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;@RpcMethod_	public void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		((StartStoppable) getSelf()).stop()___		leaderSessionID = null__		executionGraph.suspend(cause)___		_		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Exception e) {_			log.warn("Failed to stop resource manager leader retriever when suspending.")__		}_		closeResourceManagerConnection()___		__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;rpc,method,public,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,start,stoppable,get,self,stop,leader,session,id,null,execution,graph,suspend,cause,try,resource,manager,leader,retriever,stop,catch,exception,e,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,close,resource,manager,connection
JobMaster -> @RpcMethod 	public void suspendExecution(final Throwable cause);1476307516;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;@RpcMethod_	public void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		((StartStoppable) getSelf()).stop()___		leaderSessionID = null__		executionGraph.suspend(cause)___		_		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Exception e) {_			log.warn("Failed to stop resource manager leader retriever when suspending.")__		}_		closeResourceManagerConnection()___		__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;rpc,method,public,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,start,stoppable,get,self,stop,leader,session,id,null,execution,graph,suspend,cause,try,resource,manager,leader,retriever,stop,catch,exception,e,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,close,resource,manager,connection
JobMaster -> @RpcMethod 	public void suspendExecution(final Throwable cause);1476627638;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;@RpcMethod_	public void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		((StartStoppable) getSelf()).stop()___		leaderSessionID = null__		slotPool.setJobManagerLeaderId(null)__		executionGraph.suspend(cause)___		_		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Exception e) {_			log.warn("Failed to stop resource manager leader retriever when suspending.")__		}_		closeResourceManagerConnection()___		__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;rpc,method,public,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,start,stoppable,get,self,stop,leader,session,id,null,slot,pool,set,job,manager,leader,id,null,execution,graph,suspend,cause,try,resource,manager,leader,retriever,stop,catch,exception,e,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,close,resource,manager,connection
JobMaster -> @RpcMethod 	public void suspendExecution(final Throwable cause);1476630057;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;@RpcMethod_	public void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		((StartStoppable) getSelf()).stop()___		leaderSessionID = null__		slotPool.setJobManagerLeaderId(null)__		executionGraph.suspend(cause)___		_		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Exception e) {_			log.warn("Failed to stop resource manager leader retriever when suspending.")__		}_		closeResourceManagerConnection()___		for (ResourceID taskManagerId : registeredTaskManagers.keySet()) {_			slotPool.releaseResource(taskManagerId)__		}_		registeredTaskManagers.clear()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;rpc,method,public,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,start,stoppable,get,self,stop,leader,session,id,null,slot,pool,set,job,manager,leader,id,null,execution,graph,suspend,cause,try,resource,manager,leader,retriever,stop,catch,exception,e,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,close,resource,manager,connection,for,resource,id,task,manager,id,registered,task,managers,key,set,slot,pool,release,resource,task,manager,id,registered,task,managers,clear
JobMaster -> @RpcMethod 	public void suspendExecution(final Throwable cause);1476668326;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;@RpcMethod_	public void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		((StartStoppable) getSelf()).stop()___		leaderSessionID = null__		slotPool.setJobManagerLeaderId(null)__		executionGraph.suspend(cause)___		_		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Exception e) {_			log.warn("Failed to stop resource manager leader retriever when suspending.")__		}_		closeResourceManagerConnection()___		for (ResourceID taskManagerId : registeredTaskManagers.keySet()) {_			slotPool.releaseResource(taskManagerId)__		}_		registeredTaskManagers.clear()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;rpc,method,public,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,start,stoppable,get,self,stop,leader,session,id,null,slot,pool,set,job,manager,leader,id,null,execution,graph,suspend,cause,try,resource,manager,leader,retriever,stop,catch,exception,e,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,close,resource,manager,connection,for,resource,id,task,manager,id,registered,task,managers,key,set,slot,pool,release,resource,task,manager,id,registered,task,managers,clear
JobMaster -> @RpcMethod 	public void suspendExecution(final Throwable cause);1476699326;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;@RpcMethod_	public void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		((StartStoppable) getSelf()).stop()___		leaderSessionID = null__		slotPool.setJobManagerLeaderId(null)__		executionGraph.suspend(cause)___		_		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Exception e) {_			log.warn("Failed to stop resource manager leader retriever when suspending.")__		}_		closeResourceManagerConnection()___		for (ResourceID taskManagerId : registeredTaskManagers.keySet()) {_			slotPool.releaseResource(taskManagerId)__		}_		registeredTaskManagers.clear()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;rpc,method,public,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,start,stoppable,get,self,stop,leader,session,id,null,slot,pool,set,job,manager,leader,id,null,execution,graph,suspend,cause,try,resource,manager,leader,retriever,stop,catch,exception,e,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,close,resource,manager,connection,for,resource,id,task,manager,id,registered,task,managers,key,set,slot,pool,release,resource,task,manager,id,registered,task,managers,clear
JobMaster -> @RpcMethod 	public void suspendExecution(final Throwable cause);1476714136;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;@RpcMethod_	public void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		((StartStoppable) getSelf()).stop()___		leaderSessionID = null__		slotPool.setJobManagerLeaderId(null)__		executionGraph.suspend(cause)___		_		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Exception e) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", e)__		}_		closeResourceManagerConnection()___		for (ResourceID taskManagerId : registeredTaskManagers.keySet()) {_			slotPool.releaseResource(taskManagerId)__		}_		registeredTaskManagers.clear()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;rpc,method,public,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,start,stoppable,get,self,stop,leader,session,id,null,slot,pool,set,job,manager,leader,id,null,execution,graph,suspend,cause,try,resource,manager,leader,retriever,stop,catch,exception,e,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,e,close,resource,manager,connection,for,resource,id,task,manager,id,registered,task,managers,key,set,slot,pool,release,resource,task,manager,id,registered,task,managers,clear
JobMaster -> @RpcMethod 	public void suspendExecution(final Throwable cause);1476728818;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;@RpcMethod_	public void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		((StartStoppable) getSelf()).stop()___		leaderSessionID = null__		slotPool.setJobManagerLeaderId(null)__		executionGraph.suspend(cause)___		_		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Exception e) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", e)__		}_		closeResourceManagerConnection()___		_		_		for (ResourceID taskManagerId : registeredTaskManagers.keySet()) {_			slotPool.releaseResource(taskManagerId)__		}_		registeredTaskManagers.clear()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;rpc,method,public,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,start,stoppable,get,self,stop,leader,session,id,null,slot,pool,set,job,manager,leader,id,null,execution,graph,suspend,cause,try,resource,manager,leader,retriever,stop,catch,exception,e,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,e,close,resource,manager,connection,for,resource,id,task,manager,id,registered,task,managers,key,set,slot,pool,release,resource,task,manager,id,registered,task,managers,clear
JobMaster -> @RpcMethod 	public void suspendExecution(final Throwable cause);1476806580;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;@RpcMethod_	public void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		((StartStoppable) getSelf()).stop()___		leaderSessionID = null__		slotPool.setJobManagerLeaderId(null)__		executionGraph.suspend(cause)___		_		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Exception e) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", e)__		}_		closeResourceManagerConnection()___		for (ResourceID taskManagerId : registeredTaskManagers.keySet()) {_			slotPool.releaseResource(taskManagerId)__		}_		registeredTaskManagers.clear()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;rpc,method,public,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,start,stoppable,get,self,stop,leader,session,id,null,slot,pool,set,job,manager,leader,id,null,execution,graph,suspend,cause,try,resource,manager,leader,retriever,stop,catch,exception,e,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,e,close,resource,manager,connection,for,resource,id,task,manager,id,registered,task,managers,key,set,slot,pool,release,resource,task,manager,id,registered,task,managers,clear
JobMaster -> @RpcMethod 	public void suspendExecution(final Throwable cause);1476878971;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;@RpcMethod_	public void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		((StartStoppable) getSelf()).stop()___		leaderSessionID = null__		slotPool.setJobManagerLeaderId(null)__		executionGraph.suspend(cause)___		_		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Exception e) {_			log.warn("Failed to stop resource manager leader retriever when suspending.")__		}_		closeResourceManagerConnection()___		for (ResourceID taskManagerId : registeredTaskManagers.keySet()) {_			slotPool.releaseResource(taskManagerId)__		}_		registeredTaskManagers.clear()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;rpc,method,public,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,start,stoppable,get,self,stop,leader,session,id,null,slot,pool,set,job,manager,leader,id,null,execution,graph,suspend,cause,try,resource,manager,leader,retriever,stop,catch,exception,e,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,close,resource,manager,connection,for,resource,id,task,manager,id,registered,task,managers,key,set,slot,pool,release,resource,task,manager,id,registered,task,managers,clear
JobMaster -> @RpcMethod 	public void suspendExecution(final Throwable cause);1477061494;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;@RpcMethod_	public void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		leaderSessionID = null___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		((StartStoppable) getSelf()).stop()___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;rpc,method,public,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,leader,session,id,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,start,stoppable,get,self,stop,slot,pool,gateway,suspend,close,resource,manager,connection
JobMaster -> @RpcMethod 	public void suspendExecution(final Throwable cause);1477965803;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;@RpcMethod_	public void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		leaderSessionID = null___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		((StartStoppable) getSelf()).stop()___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;rpc,method,public,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,leader,session,id,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,start,stoppable,get,self,stop,slot,pool,gateway,suspend,close,resource,manager,connection
JobMaster -> @RpcMethod 	public void suspendExecution(final Throwable cause);1484737699;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;@RpcMethod_	public void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		leaderSessionID = null___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		((StartStoppable) getSelf()).stop()___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;rpc,method,public,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,leader,session,id,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,start,stoppable,get,self,stop,slot,pool,gateway,suspend,close,resource,manager,connection
JobMaster -> @RpcMethod 	public void suspendExecution(final Throwable cause);1486583506;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;@RpcMethod_	public void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		leaderSessionID = null___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		((StartStoppable) getSelf()).stop()___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;rpc,method,public,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,leader,session,id,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,start,stoppable,get,self,stop,slot,pool,gateway,suspend,close,resource,manager,connection
JobMaster -> @RpcMethod 	public void suspendExecution(final Throwable cause);1486637985;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;@RpcMethod_	public void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		leaderSessionID = null___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		((StartStoppable) getSelf()).stop()___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;rpc,method,public,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,leader,session,id,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,start,stoppable,get,self,stop,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause
JobMaster -> @RpcMethod 	public void suspendExecution(final Throwable cause);1487177560;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;@RpcMethod_	public void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		leaderSessionID = null___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		((StartStoppable) getSelf()).stop()___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;rpc,method,public,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,leader,session,id,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,start,stoppable,get,self,stop,slot,pool,gateway,suspend,close,resource,manager,connection
JobMaster -> @RpcMethod 	public void suspendExecution(final Throwable cause);1488291647;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;@RpcMethod_	public void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		leaderSessionID = null___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		((StartStoppable) getSelf()).stop()___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;rpc,method,public,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,leader,session,id,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,start,stoppable,get,self,stop,slot,pool,gateway,suspend,close,resource,manager,connection
JobMaster -> @RpcMethod 	public void suspendExecution(final Throwable cause);1488923142;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;@RpcMethod_	public void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		leaderSessionID = null___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		((StartStoppable) getSelf()).stop()___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;rpc,method,public,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,leader,session,id,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,start,stoppable,get,self,stop,slot,pool,gateway,suspend,close,resource,manager,connection
JobMaster -> @RpcMethod 	public void suspendExecution(final Throwable cause);1490105415;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;@RpcMethod_	public void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		leaderSessionID = null___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		((StartStoppable) getSelf()).stop()___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;rpc,method,public,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,leader,session,id,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,start,stoppable,get,self,stop,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause
JobMaster -> @RpcMethod 	public void suspendExecution(final Throwable cause);1490120014;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;@RpcMethod_	public void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		leaderSessionID = null___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		((StartStoppable) getSelf()).stop()___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;rpc,method,public,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,leader,session,id,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,start,stoppable,get,self,stop,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause
JobMaster -> @RpcMethod 	public void suspendExecution(final Throwable cause);1490166753;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;@RpcMethod_	public void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		leaderSessionID = null___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		((StartStoppable) getSelf()).stop()___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;rpc,method,public,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,leader,session,id,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,start,stoppable,get,self,stop,slot,pool,gateway,suspend,close,resource,manager,connection
JobMaster -> @RpcMethod 	public void suspendExecution(final Throwable cause);1490170142;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;@RpcMethod_	public void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		leaderSessionID = null___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		((StartStoppable) getSelf()).stop()___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;rpc,method,public,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,leader,session,id,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,start,stoppable,get,self,stop,slot,pool,gateway,suspend,close,resource,manager,connection
JobMaster -> @RpcMethod 	public void suspendExecution(final Throwable cause);1490180625;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;@RpcMethod_	public void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		leaderSessionID = null___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		((StartStoppable) getSelf()).stop()___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;rpc,method,public,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,leader,session,id,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,start,stoppable,get,self,stop,slot,pool,gateway,suspend,close,resource,manager,connection
JobMaster -> @RpcMethod 	public void suspendExecution(final Throwable cause);1490805029;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;@RpcMethod_	public void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		leaderSessionID = null___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		((StartStoppable) getSelf()).stop()___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;rpc,method,public,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,leader,session,id,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,start,stoppable,get,self,stop,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause
JobMaster -> @RpcMethod 	public void suspendExecution(final Throwable cause);1501251235;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;@RpcMethod_	public void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		leaderSessionID = null___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		((StartStoppable) getSelf()).stop()___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;rpc,method,public,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,leader,session,id,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,start,stoppable,get,self,stop,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause
JobMaster -> @RpcMethod 	public void suspendExecution(final Throwable cause);1501519642;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;@RpcMethod_	public void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		leaderSessionID = null___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		((StartStoppable) getSelf()).stop()___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;rpc,method,public,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,leader,session,id,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,start,stoppable,get,self,stop,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause
JobMaster -> @RpcMethod 	public void suspendExecution(final Throwable cause);1501524690;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;@RpcMethod_	public void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		leaderSessionID = null___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		((StartStoppable) getSelf()).stop()___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;rpc,method,public,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,leader,session,id,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,start,stoppable,get,self,stop,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause
JobMaster -> @RpcMethod 	public void suspendExecution(final Throwable cause);1501580028;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;@RpcMethod_	public void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		leaderSessionID = null___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		((StartStoppable) getSelf()).stop()___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;rpc,method,public,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,leader,session,id,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,start,stoppable,get,self,stop,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause
JobMaster -> @RpcMethod 	public void suspendExecution(final Throwable cause);1502035001;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;@RpcMethod_	public void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		leaderSessionID = null___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		((StartStoppable) getSelf()).stop()___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;rpc,method,public,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,leader,session,id,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,start,stoppable,get,self,stop,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1517300523;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1518531558;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1518534881;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1518539372;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1518606541;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1518716619;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1518718788;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1519299413;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1519320257;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1519390630;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1519408304;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1519931395;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1519999896;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1521033687;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1521049936;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1521224209;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1521641386;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1521810529;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1521816200;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1521816389;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1521817317;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1522130448;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1522136713;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1522230836;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1522849636;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1525374816;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1525934187;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1526300085;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1526311855;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1526561054;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1526997218;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1527029265;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1527094227;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1529603022;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1529915670;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1530791303;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1532289479;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1532293098;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1533374562;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1534937274;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1536826537;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1538403115;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1538864611;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1542043300;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1542304303;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1544094547;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1547809055;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1547809099;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1547809385;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1548172161;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout);1548679824;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId, Time)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@param timeout for this operation_@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause, final Time timeout) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), timeout)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,time,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,param,timeout,for,this,operation,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,final,time,timeout,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,timeout,stop,return,suspend,future
JobMaster -> private CompletableFuture<Acknowledge> suspendExecution(final Exception cause);1543229263;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private CompletableFuture<Acknowledge> suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return CompletableFuture.completedFuture(null)__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		CompletableFuture<Acknowledge> slotPoolSuspendFuture = slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return slotPoolSuspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,completable,future,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,completable,future,completed,future,null,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,completable,future,acknowledge,slot,pool,suspend,future,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,slot,pool,suspend,future
JobMaster -> private CompletableFuture<Acknowledge> suspendExecution(final Exception cause);1548086094;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private CompletableFuture<Acknowledge> suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return CompletableFuture.completedFuture(null)__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		CompletableFuture<Acknowledge> slotPoolSuspendFuture = slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return slotPoolSuspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,completable,future,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,completable,future,completed,future,null,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,completable,future,acknowledge,slot,pool,suspend,future,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,slot,pool,suspend,future
JobMaster -> private CompletableFuture<Acknowledge> suspendExecution(final Exception cause);1549036717;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private CompletableFuture<Acknowledge> suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return CompletableFuture.completedFuture(null)__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		CompletableFuture<Acknowledge> slotPoolSuspendFuture = slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return slotPoolSuspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,completable,future,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,completable,future,completed,future,null,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,completable,future,acknowledge,slot,pool,suspend,future,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,slot,pool,suspend,future
JobMaster -> private CompletableFuture<Acknowledge> suspendExecution(final Exception cause);1549381698;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private CompletableFuture<Acknowledge> suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return CompletableFuture.completedFuture(null)__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		CompletableFuture<Acknowledge> slotPoolSuspendFuture = slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return slotPoolSuspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,completable,future,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,completable,future,completed,future,null,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,completable,future,acknowledge,slot,pool,suspend,future,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,slot,pool,suspend,future
JobMaster -> private CompletableFuture<Acknowledge> suspendExecution(final Exception cause);1549533702;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private CompletableFuture<Acknowledge> suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return CompletableFuture.completedFuture(null)__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		CompletableFuture<Acknowledge> slotPoolSuspendFuture = slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return slotPoolSuspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,completable,future,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,completable,future,completed,future,null,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,completable,future,acknowledge,slot,pool,suspend,future,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,slot,pool,suspend,future
JobMaster -> private CompletableFuture<Acknowledge> suspendExecution(final Exception cause);1549965236;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private CompletableFuture<Acknowledge> suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return CompletableFuture.completedFuture(null)__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		CompletableFuture<Acknowledge> slotPoolSuspendFuture = slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return slotPoolSuspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,completable,future,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,completable,future,completed,future,null,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,completable,future,acknowledge,slot,pool,suspend,future,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,slot,pool,suspend,future
JobMaster -> private CompletableFuture<Acknowledge> suspendExecution(final Exception cause);1549983516;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private CompletableFuture<Acknowledge> suspendExecution(final Exception cause) {_		validateRunsInMainThread()___		if (getFencingToken() == null) {_			log.debug("Job has already been suspended or shutdown.")__			return CompletableFuture.completedFuture(null)__		}__		_		setFencingToken(null)___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		suspendAndClearExecutionGraphFields(cause)___		_		CompletableFuture<Acknowledge> slotPoolSuspendFuture = slotPoolGateway.suspend()___		_		closeResourceManagerConnection(cause)___		return slotPoolSuspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,completable,future,acknowledge,suspend,execution,final,exception,cause,validate,runs,in,main,thread,if,get,fencing,token,null,log,debug,job,has,already,been,suspended,or,shutdown,return,completable,future,completed,future,null,set,fencing,token,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,suspend,and,clear,execution,graph,fields,cause,completable,future,acknowledge,slot,pool,suspend,future,slot,pool,gateway,suspend,close,resource,manager,connection,cause,return,slot,pool,suspend,future
JobMaster -> public void onJobMasterElectionError(final Exception exception);1472481329;Handles error occurring in the leader election service__@param exception Exception thrown in the leader election service;public void onJobMasterElectionError(final Exception exception) {_		runAsync(new Runnable() {_			@Override_			public void run() {_				log.error("Received an error from the LeaderElectionService.", exception)___				_				cancelAndClearEverything(exception)___				leaderSessionID = null__			}_		})___	};handles,error,occurring,in,the,leader,election,service,param,exception,exception,thrown,in,the,leader,election,service;public,void,on,job,master,election,error,final,exception,exception,run,async,new,runnable,override,public,void,run,log,error,received,an,error,from,the,leader,election,service,exception,cancel,and,clear,everything,exception,leader,session,id,null
JobMaster -> public void onJobMasterElectionError(final Exception exception);1474471581;Handles error occurring in the leader election service__@param exception Exception thrown in the leader election service;public void onJobMasterElectionError(final Exception exception) {_		runAsync(new Runnable() {_			@Override_			public void run() {_				log.error("Received an error from the LeaderElectionService.", exception)___				_				cancelAndClearEverything(exception)___				leaderSessionID = null__			}_		})___	};handles,error,occurring,in,the,leader,election,service,param,exception,exception,thrown,in,the,leader,election,service;public,void,on,job,master,election,error,final,exception,exception,run,async,new,runnable,override,public,void,run,log,error,received,an,error,from,the,leader,election,service,exception,cancel,and,clear,everything,exception,leader,session,id,null
JobMaster -> public void suspend(final Throwable cause);1502714913;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended.;public void suspend(final Throwable cause) {_		runAsync(() -> suspendExecution(cause))__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended;public,void,suspend,final,throwable,cause,run,async,suspend,execution,cause
JobMaster -> public void suspend(final Throwable cause);1503412385;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended.;public void suspend(final Throwable cause) {_		runAsync(() -> suspendExecution(cause))__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended;public,void,suspend,final,throwable,cause,run,async,suspend,execution,cause
JobMaster -> public void suspend(final Throwable cause);1503581387;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended.;public void suspend(final Throwable cause) {_		runAsync(() -> suspendExecution(cause))__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended;public,void,suspend,final,throwable,cause,run,async,suspend,execution,cause
JobMaster -> @RpcMethod 	public void suspendJob(final Throwable cause);1473307213;Suspending job, all the running tasks will be cancelled, and runtime data will be cleared.__@param cause The reason of why this job been suspended.;@RpcMethod_	public void suspendJob(final Throwable cause) {_		if (executionGraph != null) {_			executionGraph.suspend(cause)__			executionGraph = null__		}_	};suspending,job,all,the,running,tasks,will,be,cancelled,and,runtime,data,will,be,cleared,param,cause,the,reason,of,why,this,job,been,suspended;rpc,method,public,void,suspend,job,final,throwable,cause,if,execution,graph,null,execution,graph,suspend,cause,execution,graph,null
JobMaster -> @RpcMethod 	public void suspendJob(final Throwable cause);1474453995;Suspending job, all the running tasks will be cancelled, and runtime data will be cleared.__@param cause The reason of why this job been suspended.;@RpcMethod_	public void suspendJob(final Throwable cause) {_		if (executionGraph != null) {_			executionGraph.suspend(cause)__			executionGraph = null__		}_	};suspending,job,all,the,running,tasks,will,be,cancelled,and,runtime,data,will,be,cleared,param,cause,the,reason,of,why,this,job,been,suspended;rpc,method,public,void,suspend,job,final,throwable,cause,if,execution,graph,null,execution,graph,suspend,cause,execution,graph,null
JobMaster -> @RpcMethod 	public void suspendJob(final Throwable cause);1474858756;Suspending job, all the running tasks will be cancelled, and runtime data will be cleared.__@param cause The reason of why this job been suspended.;@RpcMethod_	public void suspendJob(final Throwable cause) {_		leaderSessionID = null___		if (executionGraph != null) {_			executionGraph.suspend(cause)__			executionGraph = null__		}__		disposeCommunicationWithResourceManager()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,runtime,data,will,be,cleared,param,cause,the,reason,of,why,this,job,been,suspended;rpc,method,public,void,suspend,job,final,throwable,cause,leader,session,id,null,if,execution,graph,null,execution,graph,suspend,cause,execution,graph,null,dispose,communication,with,resource,manager
JobMaster -> @RpcMethod 	public void suspendJob(final Throwable cause);1475066391;Suspending job, all the running tasks will be cancelled, and runtime data will be cleared.__@param cause The reason of why this job been suspended.;@RpcMethod_	public void suspendJob(final Throwable cause) {_		leaderSessionID = null___		if (executionGraph != null) {_			executionGraph.suspend(cause)__			executionGraph = null__		}__		disposeCommunicationWithResourceManager()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,runtime,data,will,be,cleared,param,cause,the,reason,of,why,this,job,been,suspended;rpc,method,public,void,suspend,job,final,throwable,cause,leader,session,id,null,if,execution,graph,null,execution,graph,suspend,cause,execution,graph,null,dispose,communication,with,resource,manager
JobMaster -> @RpcMethod 	public void suspendJob(final Throwable cause);1475110587;Suspending job, all the running tasks will be cancelled, and runtime data will be cleared.__@param cause The reason of why this job been suspended.;@RpcMethod_	public void suspendJob(final Throwable cause) {_		leaderSessionID = null___		if (executionGraph != null) {_			executionGraph.suspend(cause)__			executionGraph = null__		}__		disposeCommunicationWithResourceManager()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,runtime,data,will,be,cleared,param,cause,the,reason,of,why,this,job,been,suspended;rpc,method,public,void,suspend,job,final,throwable,cause,leader,session,id,null,if,execution,graph,null,execution,graph,suspend,cause,execution,graph,null,dispose,communication,with,resource,manager
JobMaster -> @RpcMethod 	public void suspendJob(final Throwable cause);1475593222;Suspending job, all the running tasks will be cancelled, and runtime data will be cleared.__@param cause The reason of why this job been suspended.;@RpcMethod_	public void suspendJob(final Throwable cause) {_		leaderSessionID = null___		if (executionGraph != null) {_			executionGraph.suspend(cause)__			executionGraph = null__		}__		disposeCommunicationWithResourceManager()__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,runtime,data,will,be,cleared,param,cause,the,reason,of,why,this,job,been,suspended;rpc,method,public,void,suspend,job,final,throwable,cause,leader,session,id,null,if,execution,graph,null,execution,graph,suspend,cause,execution,graph,null,dispose,communication,with,resource,manager
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId) throws Exception;1538764056;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), RpcUtils.INF_TIMEOUT)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,rpc,utils
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId) throws Exception;1543229263;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), RpcUtils.INF_TIMEOUT)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,rpc,utils
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId) throws Exception;1548086094;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), RpcUtils.INF_TIMEOUT)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,rpc,utils
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId) throws Exception;1548172454;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), RpcUtils.INF_TIMEOUT)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,rpc,utils
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId) throws Exception;1549036717;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), RpcUtils.INF_TIMEOUT)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,rpc,utils
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId) throws Exception;1549381698;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), RpcUtils.INF_TIMEOUT)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,rpc,utils
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId) throws Exception;1549533702;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), RpcUtils.INF_TIMEOUT)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,rpc,utils
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId) throws Exception;1549965236;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), RpcUtils.INF_TIMEOUT)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,rpc,utils
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId) throws Exception;1549983516;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), RpcUtils.INF_TIMEOUT)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,rpc,utils
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId) throws Exception;1550366933;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), RpcUtils.INF_TIMEOUT)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,rpc,utils
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId) throws Exception;1550405950;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), RpcUtils.INF_TIMEOUT)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,rpc,utils
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId) throws Exception;1550572312;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), RpcUtils.INF_TIMEOUT)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,rpc,utils
JobMaster -> public void start(final UUID leaderSessionID);1475679726;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {_			super.start()___			log.info("Starting JobManager for job {} ({})", jobGraph.getName(), jobGraph.getJobID())__			getSelf().startJobExecution()__		} else {_			log.warn("Job already started with leaderId {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,if,compare,and,set,this,null,leader,session,id,super,start,log,info,starting,job,manager,for,job,job,graph,get,name,job,graph,get,job,id,get,self,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> public void start(final UUID leaderSessionID);1476307516;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {_			super.start()___			log.info("Starting JobManager for job {} ({})", jobGraph.getName(), jobGraph.getJobID())__			getSelf().startJobExecution()__		} else {_			log.warn("Job already started with leaderId {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,if,compare,and,set,this,null,leader,session,id,super,start,log,info,starting,job,manager,for,job,job,graph,get,name,job,graph,get,job,id,get,self,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> public void start(final UUID leaderSessionID);1476627638;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {_			super.start()___			slotPool.setJobManagerLeaderId(leaderSessionID)__			log.info("Starting JobManager for job {} ({})", jobGraph.getName(), jobGraph.getJobID())__			getSelf().startJobExecution()__		} else {_			log.warn("Job already started with leaderId {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,if,compare,and,set,this,null,leader,session,id,super,start,slot,pool,set,job,manager,leader,id,leader,session,id,log,info,starting,job,manager,for,job,job,graph,get,name,job,graph,get,job,id,get,self,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> public void start(final UUID leaderSessionID);1476630057;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {_			super.start()___			slotPool.setJobManagerLeaderId(leaderSessionID)__			log.info("Starting JobManager for job {} ({})", jobGraph.getName(), jobGraph.getJobID())__			getSelf().startJobExecution()__		} else {_			log.warn("Job already started with leaderId {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,if,compare,and,set,this,null,leader,session,id,super,start,slot,pool,set,job,manager,leader,id,leader,session,id,log,info,starting,job,manager,for,job,job,graph,get,name,job,graph,get,job,id,get,self,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> public void start(final UUID leaderSessionID);1476668326;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {_			super.start()___			slotPool.setJobManagerLeaderId(leaderSessionID)__			log.info("Starting JobManager for job {} ({})", jobGraph.getName(), jobGraph.getJobID())__			getSelf().startJobExecution()__		} else {_			log.warn("Job already started with leaderId {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,if,compare,and,set,this,null,leader,session,id,super,start,slot,pool,set,job,manager,leader,id,leader,session,id,log,info,starting,job,manager,for,job,job,graph,get,name,job,graph,get,job,id,get,self,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> public void start(final UUID leaderSessionID);1476699326;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {_			super.start()___			slotPool.setJobManagerLeaderId(leaderSessionID)__			log.info("Starting JobManager for job {} ({})", jobGraph.getName(), jobGraph.getJobID())__			getSelf().startJobExecution()__		} else {_			log.warn("Job already started with leaderId {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,if,compare,and,set,this,null,leader,session,id,super,start,slot,pool,set,job,manager,leader,id,leader,session,id,log,info,starting,job,manager,for,job,job,graph,get,name,job,graph,get,job,id,get,self,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> public void start(final UUID leaderSessionID);1476878971;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {_			super.start()___			slotPool.setJobManagerLeaderId(leaderSessionID)__			log.info("Starting JobManager for job {} ({})", jobGraph.getName(), jobGraph.getJobID())__			getSelf().startJobExecution()__		} else {_			log.warn("Job already started with leaderId {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,if,compare,and,set,this,null,leader,session,id,super,start,slot,pool,set,job,manager,leader,id,leader,session,id,log,info,starting,job,manager,for,job,job,graph,get,name,job,graph,get,job,id,get,self,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1519408304;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1519931395;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1519999896;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1521033687;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1521049936;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1521224209;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1521641386;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1521810529;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1521816200;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1521816389;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1521817317;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1522130448;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1522136713;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1522230836;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1522849636;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1525374816;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1525934187;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1526300085;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1526311855;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1526561054;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1526997218;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1527029265;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1527094227;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1529603022;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1529915670;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1530791303;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1532289479;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1532293098;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1533374562;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1534937274;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1536826537;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1538403115;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1538764056;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1538864611;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1542043300;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1542304303;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1543229263;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1544094547;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1547809055;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1547809099;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1547809385;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1548086094;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1548172161;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1548172454;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1548679824;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1549036717;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1549381698;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1549533702;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1549965236;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1549983516;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1550366933;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1550405950;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private CompletableFuture<String> getJobModificationSavepoint(Time timeout);1550572312;Takes an internal savepoint for job modification purposes. If the savepoint was not successful because_not all tasks were running, it returns the last successful modification savepoint.__@param timeout for the operation_@return Future which is completed with the savepoint path or the last successful modification savepoint if the_former was not successful;private CompletableFuture<String> getJobModificationSavepoint(Time timeout) {_		return triggerSavepoint(_			null,_			false,_			timeout)_			.handleAsync(_				(String savepointPath, Throwable throwable) -> {_					if (throwable != null) {_						final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable)__						if (strippedThrowable instanceof CheckpointTriggerException) {_							final CheckpointTriggerException checkpointTriggerException = (CheckpointTriggerException) strippedThrowable___							if (checkpointTriggerException.getCheckpointDeclineReason() == CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING) {_								return lastInternalSavepoint__							} else {_								throw new CompletionException(checkpointTriggerException)__							}_						} else {_							throw new CompletionException(strippedThrowable)__						}_					} else {_						final String savepointToDispose = lastInternalSavepoint__						lastInternalSavepoint = savepointPath___						if (savepointToDispose != null) {_							_							CompletableFuture.runAsync(_								() -> disposeSavepoint(savepointToDispose),_								scheduledExecutorService)__						}__						return lastInternalSavepoint__					}_				},_				getMainThreadExecutor())__	};takes,an,internal,savepoint,for,job,modification,purposes,if,the,savepoint,was,not,successful,because,not,all,tasks,were,running,it,returns,the,last,successful,modification,savepoint,param,timeout,for,the,operation,return,future,which,is,completed,with,the,savepoint,path,or,the,last,successful,modification,savepoint,if,the,former,was,not,successful;private,completable,future,string,get,job,modification,savepoint,time,timeout,return,trigger,savepoint,null,false,timeout,handle,async,string,savepoint,path,throwable,throwable,if,throwable,null,final,throwable,stripped,throwable,exception,utils,strip,completion,exception,throwable,if,stripped,throwable,instanceof,checkpoint,trigger,exception,final,checkpoint,trigger,exception,checkpoint,trigger,exception,checkpoint,trigger,exception,stripped,throwable,if,checkpoint,trigger,exception,get,checkpoint,decline,reason,checkpoint,decline,reason,return,last,internal,savepoint,else,throw,new,completion,exception,checkpoint,trigger,exception,else,throw,new,completion,exception,stripped,throwable,else,final,string,savepoint,to,dispose,last,internal,savepoint,last,internal,savepoint,savepoint,path,if,savepoint,to,dispose,null,completable,future,run,async,dispose,savepoint,savepoint,to,dispose,scheduled,executor,service,return,last,internal,savepoint,get,main,thread,executor
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1519408304;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.acceptWithException(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,with,exception,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1519931395;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.acceptWithException(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,with,exception,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1519999896;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.acceptWithException(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,with,exception,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1521033687;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.acceptWithException(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,with,exception,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1521049936;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.acceptWithException(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,with,exception,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1521224209;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.acceptWithException(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,with,exception,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1521641386;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.acceptWithException(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,with,exception,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1521810529;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.acceptWithException(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,with,exception,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1521816200;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.acceptWithException(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,with,exception,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1521816389;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.acceptWithException(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,with,exception,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1521817317;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.acceptWithException(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,with,exception,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1522130448;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.acceptWithException(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,with,exception,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1522136713;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.acceptWithException(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,with,exception,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1522230836;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.acceptWithException(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,with,exception,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1522849636;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.acceptWithException(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,with,exception,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1525374816;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.acceptWithException(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,with,exception,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1525934187;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.acceptWithException(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,with,exception,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1526300085;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.acceptWithException(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,with,exception,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1526311855;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.acceptWithException(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,with,exception,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1526561054;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.acceptWithException(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,with,exception,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1526997218;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.acceptWithException(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,with,exception,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1527029265;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.acceptWithException(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,with,exception,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1527094227;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.acceptWithException(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,with,exception,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1529603022;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.acceptWithException(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,with,exception,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1529915670;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.acceptWithException(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,with,exception,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1530791303;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.acceptWithException(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,with,exception,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1532289479;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.acceptWithException(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,with,exception,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1532293098;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.accept(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1533374562;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.acceptWithException(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,with,exception,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1534937274;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.acceptWithException(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,with,exception,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1536826537;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.accept(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1538403115;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.accept(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1538764056;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.accept(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1538864611;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.accept(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1542043300;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.accept(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1542304303;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.accept(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1543229263;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.accept(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1544094547;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.accept(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1547809055;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.accept(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1547809099;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.accept(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1547809385;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.accept(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1548086094;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.accept(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1548172161;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.accept(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1548172454;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.accept(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1548679824;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.accept(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1549036717;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.accept(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1549381698;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.accept(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1549533702;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.accept(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1549965236;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.accept(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1549983516;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.accept(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1550366933;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.accept(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1550405950;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.accept(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,job,vertex,new,parallelism
JobMaster -> private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException;1550572312;Rescales the given operators of the {@link JobGraph} of this {@link JobMaster} with respect to given_parallelism and {@link RescalingBehaviour}.__@param operators to rescale_@param newParallelism new parallelism for these operators_@param rescalingBehaviour of the rescaling operation_@throws FlinkException if the {@link JobGraph} could not be rescaled;private void rescaleJobGraph(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour) throws FlinkException {_		for (JobVertexID jobVertexId : operators) {_			final JobVertex jobVertex = jobGraph.findVertexByID(jobVertexId)___			_			final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId)___			if (executionJobVertex != null) {_				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism())__			}__			rescalingBehaviour.accept(jobVertex, newParallelism)__		}_	};rescales,the,given,operators,of,the,link,job,graph,of,this,link,job,master,with,respect,to,given,parallelism,and,link,rescaling,behaviour,param,operators,to,rescale,param,new,parallelism,new,parallelism,for,these,operators,param,rescaling,behaviour,of,the,rescaling,operation,throws,flink,exception,if,the,link,job,graph,could,not,be,rescaled;private,void,rescale,job,graph,collection,job,vertex,id,operators,int,new,parallelism,rescaling,behaviour,rescaling,behaviour,throws,flink,exception,for,job,vertex,id,job,vertex,id,operators,final,job,vertex,job,vertex,job,graph,find,vertex,by,id,job,vertex,id,final,execution,job,vertex,execution,job,vertex,execution,graph,get,job,vertex,job,vertex,id,if,execution,job,vertex,null,job,vertex,set,max,parallelism,execution,job,vertex,get,max,parallelism,rescaling,behaviour,accept,job,vertex,new,parallelism
JobMaster -> private void cancelAndClearEverything(Throwable cause);1472481329;Cancel the current job and notify all listeners the job's cancellation.__@param cause Cause for the cancelling.;private void cancelAndClearEverything(Throwable cause) {_		_	};cancel,the,current,job,and,notify,all,listeners,the,job,s,cancellation,param,cause,cause,for,the,cancelling;private,void,cancel,and,clear,everything,throwable,cause
JobMaster -> private void cancelAndClearEverything(Throwable cause);1474471581;Cancel the current job and notify all listeners the job's cancellation.__@param cause Cause for the cancelling.;private void cancelAndClearEverything(Throwable cause) {_		_	};cancel,the,current,job,and,notify,all,listeners,the,job,s,cancellation,param,cause,cause,for,the,cancelling;private,void,cancel,and,clear,everything,throwable,cause
JobMaster -> @RpcMethod 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final SubtaskState checkpointState) throws CheckpointException;1484737699;TODO: This method needs a leader session ID;@RpcMethod_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final SubtaskState checkpointState) throws CheckpointException {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,subtask,state,checkpoint,state,throws,checkpoint,exception,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final SubtaskState checkpointState) throws CheckpointException;1486637985;TODO: This method needs a leader session ID;@RpcMethod_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final SubtaskState checkpointState) throws CheckpointException {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,subtask,state,checkpoint,state,throws,checkpoint,exception,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final SubtaskState checkpointState) throws CheckpointException;1487177560;TODO: This method needs a leader session ID;@RpcMethod_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final SubtaskState checkpointState) throws CheckpointException {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,subtask,state,checkpoint,state,throws,checkpoint,exception,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final SubtaskState checkpointState) throws CheckpointException;1488291647;TODO: This method needs a leader session ID;@RpcMethod_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final SubtaskState checkpointState) throws CheckpointException {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,subtask,state,checkpoint,state,throws,checkpoint,exception,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final SubtaskState checkpointState) throws CheckpointException;1488923142;TODO: This method needs a leader session ID;@RpcMethod_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final SubtaskState checkpointState) throws CheckpointException {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,subtask,state,checkpoint,state,throws,checkpoint,exception,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final SubtaskState checkpointState) throws CheckpointException;1490105415;TODO: This method needs a leader session ID;@RpcMethod_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final SubtaskState checkpointState) throws CheckpointException {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,subtask,state,checkpoint,state,throws,checkpoint,exception,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final SubtaskState checkpointState) throws CheckpointException;1490120014;TODO: This method needs a leader session ID;@RpcMethod_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final SubtaskState checkpointState) throws CheckpointException {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,subtask,state,checkpoint,state,throws,checkpoint,exception,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final SubtaskState checkpointState) throws CheckpointException;1490166753;TODO: This method needs a leader session ID;@RpcMethod_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final SubtaskState checkpointState) throws CheckpointException {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,subtask,state,checkpoint,state,throws,checkpoint,exception,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final SubtaskState checkpointState) throws CheckpointException;1490170142;TODO: This method needs a leader session ID;@RpcMethod_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final SubtaskState checkpointState) throws CheckpointException {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,subtask,state,checkpoint,state,throws,checkpoint,exception,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final SubtaskState checkpointState) throws CheckpointException;1490180625;TODO: This method needs a leader session ID;@RpcMethod_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final SubtaskState checkpointState) throws CheckpointException {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,subtask,state,checkpoint,state,throws,checkpoint,exception,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final SubtaskState checkpointState) throws CheckpointException;1490805029;TODO: This method needs a leader session ID;@RpcMethod_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final SubtaskState checkpointState) throws CheckpointException {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,subtask,state,checkpoint,state,throws,checkpoint,exception,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final SubtaskState checkpointState) throws CheckpointException;1501251235;TODO: This method needs a leader session ID;@RpcMethod_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final SubtaskState checkpointState) throws CheckpointException {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,subtask,state,checkpoint,state,throws,checkpoint,exception,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final SubtaskState checkpointState) throws CheckpointException;1501519642;TODO: This method needs a leader session ID;@RpcMethod_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final SubtaskState checkpointState) throws CheckpointException {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,subtask,state,checkpoint,state,throws,checkpoint,exception,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final SubtaskState checkpointState) throws CheckpointException;1501524690;TODO: This method needs a leader session ID;@RpcMethod_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final SubtaskState checkpointState) throws CheckpointException {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,subtask,state,checkpoint,state,throws,checkpoint,exception,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final SubtaskState checkpointState) throws CheckpointException;1501580028;TODO: This method needs a leader session ID;@RpcMethod_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final SubtaskState checkpointState) throws CheckpointException {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,subtask,state,checkpoint,state,throws,checkpoint,exception,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final CheckpointMetrics checkpointMetrics, 			final SubtaskState checkpointState) throws CheckpointException;1502035001;TODO: This method needs a leader session ID;@RpcMethod_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final CheckpointMetrics checkpointMetrics,_			final SubtaskState checkpointState) throws CheckpointException {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointId, checkpointMetrics, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,checkpoint,metrics,checkpoint,metrics,final,subtask,state,checkpoint,state,throws,checkpoint,exception,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,id,checkpoint,metrics,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> public CompletableFuture<Acknowledge> start(final UUID leaderSessionID, final Time timeout) throws Exception;1503573855;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job._@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final UUID leaderSessionID, final Time timeout) throws Exception {_		_		super.start()___		return callAsync(() -> startJobExecution(leaderSessionID), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,uuid,leader,session,id,final,time,timeout,throws,exception,super,start,return,call,async,start,job,execution,leader,session,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final UUID leaderSessionID, final Time timeout) throws Exception;1503580260;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job._@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final UUID leaderSessionID, final Time timeout) throws Exception {_		_		super.start()___		return callAsync(() -> startJobExecution(leaderSessionID), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,uuid,leader,session,id,final,time,timeout,throws,exception,super,start,return,call,async,start,job,execution,leader,session,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause);1538764056;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(_				() -> suspendExecution(cause),_				RpcUtils.INF_TIMEOUT)___		return suspendFuture.whenComplete((acknowledge, throwable) -> stop())__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,rpc,utils,return,suspend,future,when,complete,acknowledge,throwable,stop
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause);1543229263;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(_				() -> suspendExecution(cause),_				RpcUtils.INF_TIMEOUT)_			.thenCompose(Function.identity())___		return suspendFuture.whenComplete((acknowledge, throwable) -> stop())__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,rpc,utils,then,compose,function,identity,return,suspend,future,when,complete,acknowledge,throwable,stop
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause);1548086094;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(_				() -> suspendExecution(cause),_				RpcUtils.INF_TIMEOUT)_			.thenCompose(Function.identity())___		return suspendFuture.whenComplete((acknowledge, throwable) -> stop())__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,rpc,utils,then,compose,function,identity,return,suspend,future,when,complete,acknowledge,throwable,stop
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause);1548172454;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(() -> suspendExecution(cause), RpcUtils.INF_TIMEOUT)___		stop()___		return suspendFuture__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,rpc,utils,stop,return,suspend,future
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause);1549036717;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(_				() -> suspendExecution(cause),_				RpcUtils.INF_TIMEOUT)_			.thenCompose(Function.identity())___		return suspendFuture.whenComplete((acknowledge, throwable) -> stop())__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,rpc,utils,then,compose,function,identity,return,suspend,future,when,complete,acknowledge,throwable,stop
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause);1549381698;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(_				() -> suspendExecution(cause),_				RpcUtils.INF_TIMEOUT)_			.thenCompose(Function.identity())___		return suspendFuture.whenComplete((acknowledge, throwable) -> stop())__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,rpc,utils,then,compose,function,identity,return,suspend,future,when,complete,acknowledge,throwable,stop
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause);1549533702;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(_				() -> suspendExecution(cause),_				RpcUtils.INF_TIMEOUT)_			.thenCompose(Function.identity())___		return suspendFuture.whenComplete((acknowledge, throwable) -> stop())__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,rpc,utils,then,compose,function,identity,return,suspend,future,when,complete,acknowledge,throwable,stop
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause);1549965236;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(_				() -> suspendExecution(cause),_				RpcUtils.INF_TIMEOUT)_			.thenCompose(Function.identity())___		return suspendFuture.whenComplete((acknowledge, throwable) -> stop())__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,rpc,utils,then,compose,function,identity,return,suspend,future,when,complete,acknowledge,throwable,stop
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause);1549983516;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(_				() -> suspendExecution(cause),_				RpcUtils.INF_TIMEOUT)_			.thenCompose(Function.identity())___		return suspendFuture.whenComplete((acknowledge, throwable) -> stop())__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,rpc,utils,then,compose,function,identity,return,suspend,future,when,complete,acknowledge,throwable,stop
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause);1550366933;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(_				() -> suspendExecution(cause),_				RpcUtils.INF_TIMEOUT)___		return suspendFuture.whenComplete((acknowledge, throwable) -> stop())__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,rpc,utils,return,suspend,future,when,complete,acknowledge,throwable,stop
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause);1550405950;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(_				() -> suspendExecution(cause),_				RpcUtils.INF_TIMEOUT)___		return suspendFuture.whenComplete((acknowledge, throwable) -> stop())__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,rpc,utils,return,suspend,future,when,complete,acknowledge,throwable,stop
JobMaster -> public CompletableFuture<Acknowledge> suspend(final Exception cause);1550572312;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(JobMasterId)} method once we take the leadership back again.__<p>This method is executed asynchronously__@param cause The reason of why this job been suspended._@return Future acknowledge indicating that the job has been suspended. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> suspend(final Exception cause) {_		CompletableFuture<Acknowledge> suspendFuture = callAsyncWithoutFencing(_				() -> suspendExecution(cause),_				RpcUtils.INF_TIMEOUT)___		return suspendFuture.whenComplete((acknowledge, throwable) -> stop())__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,job,master,id,method,once,we,take,the,leadership,back,again,p,this,method,is,executed,asynchronously,param,cause,the,reason,of,why,this,job,been,suspended,return,future,acknowledge,indicating,that,the,job,has,been,suspended,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,suspend,final,exception,cause,completable,future,acknowledge,suspend,future,call,async,without,fencing,suspend,execution,cause,rpc,utils,return,suspend,future,when,complete,acknowledge,throwable,stop
JobMaster -> @Override 	public void shutDown() throws Exception;1476714136;Suspend the job and shutdown all other services including rpc.;@Override_	public void shutDown() throws Exception {_		_		getSelf().suspendExecution(new Exception("JobManager is shutting down."))__		super.shutDown()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,shut,down,throws,exception,get,self,suspend,execution,new,exception,job,manager,is,shutting,down,super,shut,down
JobMaster -> @Override 	public void shutDown() throws Exception;1476728818;Suspend the job and shutdown all other services including rpc.;@Override_	public void shutDown() throws Exception {_		_		getSelf().suspendExecution(new Exception("JobManager is shutting down."))__		super.shutDown()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,shut,down,throws,exception,get,self,suspend,execution,new,exception,job,manager,is,shutting,down,super,shut,down
JobMaster -> @Override 	public void shutDown() throws Exception;1476806580;Suspend the job and shutdown all other services including rpc.;@Override_	public void shutDown() throws Exception {_		_		getSelf().suspendExecution(new Exception("JobManager is shutting down."))__		super.shutDown()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,shut,down,throws,exception,get,self,suspend,execution,new,exception,job,manager,is,shutting,down,super,shut,down
JobMaster -> @Override 	public void shutDown() throws Exception;1477061494;Suspend the job and shutdown all other services including rpc.;@Override_	public void shutDown() throws Exception {_		_		getSelf().suspendExecution(new Exception("JobManager is shutting down."))__		super.shutDown()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,shut,down,throws,exception,get,self,suspend,execution,new,exception,job,manager,is,shutting,down,super,shut,down
JobMaster -> @Override 	public void shutDown() throws Exception;1477965803;Suspend the job and shutdown all other services including rpc.;@Override_	public void shutDown() throws Exception {_		_		getSelf().suspendExecution(new Exception("JobManager is shutting down."))__		super.shutDown()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,shut,down,throws,exception,get,self,suspend,execution,new,exception,job,manager,is,shutting,down,super,shut,down
JobMaster -> @Override 	public void shutDown() throws Exception;1484737699;Suspend the job and shutdown all other services including rpc.;@Override_	public void shutDown() throws Exception {_		_		heartbeatManager.stop()__		getSelf().suspendExecution(new Exception("JobManager is shutting down."))__		super.shutDown()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,shut,down,throws,exception,heartbeat,manager,stop,get,self,suspend,execution,new,exception,job,manager,is,shutting,down,super,shut,down
JobMaster -> @Override 	public void shutDown() throws Exception;1486583506;Suspend the job and shutdown all other services including rpc.;@Override_	public void shutDown() throws Exception {_		_		getSelf().suspendExecution(new Exception("JobManager is shutting down."))__		super.shutDown()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,shut,down,throws,exception,get,self,suspend,execution,new,exception,job,manager,is,shutting,down,super,shut,down
JobMaster -> @Override 	public void shutDown() throws Exception;1486637985;Suspend the job and shutdown all other services including rpc.;@Override_	public void shutDown() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		getSelf().suspendExecution(new Exception("JobManager is shutting down."))__		super.shutDown()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,shut,down,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,get,self,suspend,execution,new,exception,job,manager,is,shutting,down,super,shut,down
JobMaster -> @Override 	public void shutDown() throws Exception;1487177560;Suspend the job and shutdown all other services including rpc.;@Override_	public void shutDown() throws Exception {_		_		getSelf().suspendExecution(new Exception("JobManager is shutting down."))__		super.shutDown()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,shut,down,throws,exception,get,self,suspend,execution,new,exception,job,manager,is,shutting,down,super,shut,down
JobMaster -> @Override 	public void shutDown() throws Exception;1488291647;Suspend the job and shutdown all other services including rpc.;@Override_	public void shutDown() throws Exception {_		_		getSelf().suspendExecution(new Exception("JobManager is shutting down."))__		super.shutDown()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,shut,down,throws,exception,get,self,suspend,execution,new,exception,job,manager,is,shutting,down,super,shut,down
JobMaster -> @Override 	public void shutDown() throws Exception;1488923142;Suspend the job and shutdown all other services including rpc.;@Override_	public void shutDown() throws Exception {_		heartbeatManager.stop()___		_		getSelf().suspendExecution(new Exception("JobManager is shutting down."))__		super.shutDown()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,shut,down,throws,exception,heartbeat,manager,stop,get,self,suspend,execution,new,exception,job,manager,is,shutting,down,super,shut,down
JobMaster -> @Override 	public void shutDown() throws Exception;1490105415;Suspend the job and shutdown all other services including rpc.;@Override_	public void shutDown() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		getSelf().suspendExecution(new Exception("JobManager is shutting down."))__		super.shutDown()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,shut,down,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,get,self,suspend,execution,new,exception,job,manager,is,shutting,down,super,shut,down
JobMaster -> @Override 	public void shutDown() throws Exception;1490120014;Suspend the job and shutdown all other services including rpc.;@Override_	public void shutDown() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		getSelf().suspendExecution(new Exception("JobManager is shutting down."))__		super.shutDown()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,shut,down,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,get,self,suspend,execution,new,exception,job,manager,is,shutting,down,super,shut,down
JobMaster -> @Override 	public void shutDown() throws Exception;1490166753;Suspend the job and shutdown all other services including rpc.;@Override_	public void shutDown() throws Exception {_		heartbeatManager.stop()___		_		getSelf().suspendExecution(new Exception("JobManager is shutting down."))__		super.shutDown()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,shut,down,throws,exception,heartbeat,manager,stop,get,self,suspend,execution,new,exception,job,manager,is,shutting,down,super,shut,down
JobMaster -> @Override 	public void shutDown() throws Exception;1490170142;Suspend the job and shutdown all other services including rpc.;@Override_	public void shutDown() throws Exception {_		heartbeatManager.stop()___		_		getSelf().suspendExecution(new Exception("JobManager is shutting down."))__		super.shutDown()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,shut,down,throws,exception,heartbeat,manager,stop,get,self,suspend,execution,new,exception,job,manager,is,shutting,down,super,shut,down
JobMaster -> @Override 	public void shutDown() throws Exception;1490180625;Suspend the job and shutdown all other services including rpc.;@Override_	public void shutDown() throws Exception {_		heartbeatManager.stop()___		_		getSelf().suspendExecution(new Exception("JobManager is shutting down."))__		super.shutDown()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,shut,down,throws,exception,heartbeat,manager,stop,get,self,suspend,execution,new,exception,job,manager,is,shutting,down,super,shut,down
JobMaster -> @Override 	public void shutDown() throws Exception;1490805029;Suspend the job and shutdown all other services including rpc.;@Override_	public void shutDown() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		getSelf().suspendExecution(new Exception("JobManager is shutting down."))__		super.shutDown()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,shut,down,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,get,self,suspend,execution,new,exception,job,manager,is,shutting,down,super,shut,down
JobMaster -> @RpcMethod 	public void startJob();1473307213;Start to run the job, runtime data structures like ExecutionGraph will be constructed now and checkpoint_being recovered. After this, we will begin to schedule the job.;@RpcMethod_	public void startJob() {_		log.info("Starting job {} ({}).", jobGraph.getName(), jobGraph.getJobID())___		if (executionGraph != null) {_			executionGraph = new ExecutionGraph(_				ExecutionContext$.MODULE$.fromExecutor(executionContext),_				jobGraph.getJobID(),_				jobGraph.getName(),_				jobGraph.getJobConfiguration(),_				jobGraph.getSerializedExecutionConfig(),_				new FiniteDuration(timeout.getSize(), timeout.getUnit()),_				restartStrategy,_				jobGraph.getUserJarBlobKeys(),_				jobGraph.getClasspaths(),_				userCodeLoader,_				jobMetrics)__		} else {_			_		}__		try {_			executionGraph.setScheduleMode(jobGraph.getScheduleMode())__			executionGraph.setQueuedSchedulingAllowed(jobGraph.getAllowQueuedScheduling())___			try {_				executionGraph.setJsonPlan(JsonPlanGenerator.generatePlan(jobGraph))__			} catch (Exception e) {_				log.warn("Cannot create JSON plan for job {} ({})", jobGraph.getJobID(), jobGraph.getName(), e)__				executionGraph.setJsonPlan("{}")__			}__			_			_			if (log.isDebugEnabled()) {_				log.debug("Running initialization on master for job {} ({}).", jobGraph.getJobID(), jobGraph.getName())__			}_			for (JobVertex vertex : jobGraph.getVertices()) {_				final String executableClass = vertex.getInvokableClassName()__				if (executableClass == null || executableClass.length() == 0) {_					throw new JobExecutionException(jobGraph.getJobID(),_						"The vertex " + vertex.getID() + " (" + vertex.getName() + ") has no invokable class.")__				}_				if (vertex.getParallelism() == ExecutionConfig.PARALLELISM_AUTO_MAX) {_					vertex.setParallelism(scheduler.getTotalNumberOfSlots())__				}__				try {_					vertex.initializeOnMaster(userCodeLoader)__				} catch (Throwable t) {_					throw new JobExecutionException(jobGraph.getJobID(),_						"Cannot initialize task '" + vertex.getName() + "': " + t.getMessage(), t)__				}_			}__			_			final List<JobVertex> sortedTopology = jobGraph.getVerticesSortedTopologicallyFromSources()__			if (log.isDebugEnabled()) {_				log.debug("Adding {} vertices from job graph {} ({}).", sortedTopology.size(),_					jobGraph.getJobID(), jobGraph.getName())__			}_			executionGraph.attachJobGraph(sortedTopology)___			if (log.isDebugEnabled()) {_				log.debug("Successfully created execution graph from job graph {} ({}).",_					jobGraph.getJobID(), jobGraph.getName())__			}__			final JobSnapshottingSettings snapshotSettings = jobGraph.getSnapshotSettings()__			if (snapshotSettings != null) {_				List<ExecutionJobVertex> triggerVertices = getExecutionJobVertexWithId(_					executionGraph, snapshotSettings.getVerticesToTrigger())___				List<ExecutionJobVertex> ackVertices = getExecutionJobVertexWithId(_					executionGraph, snapshotSettings.getVerticesToAcknowledge())___				List<ExecutionJobVertex> confirmVertices = getExecutionJobVertexWithId(_					executionGraph, snapshotSettings.getVerticesToConfirm())___				CompletedCheckpointStore completedCheckpoints = checkpointRecoveryFactory.createCheckpointStore(_					jobGraph.getJobID(), userCodeLoader)___				CheckpointIDCounter checkpointIdCounter = checkpointRecoveryFactory.createCheckpointIDCounter(_					jobGraph.getJobID())___				_				boolean isStatsDisabled = configuration.getBoolean(_					ConfigConstants.JOB_MANAGER_WEB_CHECKPOINTS_DISABLE,_					ConfigConstants.DEFAULT_JOB_MANAGER_WEB_CHECKPOINTS_DISABLE)___				final CheckpointStatsTracker checkpointStatsTracker__				if (isStatsDisabled) {_					checkpointStatsTracker = new DisabledCheckpointStatsTracker()__				} else {_					int historySize = configuration.getInteger(_						ConfigConstants.JOB_MANAGER_WEB_CHECKPOINTS_HISTORY_SIZE,_						ConfigConstants.DEFAULT_JOB_MANAGER_WEB_CHECKPOINTS_HISTORY_SIZE)__					checkpointStatsTracker = new SimpleCheckpointStatsTracker(historySize, ackVertices, jobMetrics)__				}__				executionGraph.enableSnapshotCheckpointing(_					snapshotSettings.getCheckpointInterval(),_					snapshotSettings.getCheckpointTimeout(),_					snapshotSettings.getMinPauseBetweenCheckpoints(),_					snapshotSettings.getMaxConcurrentCheckpoints(),_					triggerVertices,_					ackVertices,_					confirmVertices,_					checkpointIdCounter,_					completedCheckpoints,_					savepointStore,_					checkpointStatsTracker)__			}__			__			__			__		} catch (Throwable t) {_			log.error("Failed to start job {} ({})", jobGraph.getName(), jobGraph.getJobID(), t)___			executionGraph.fail(t)__			executionGraph = null___			final Throwable rt__			if (t instanceof JobExecutionException) {_				rt = (JobExecutionException) t__			} else {_				rt = new JobExecutionException(jobGraph.getJobID(),_					"Failed to start job " + jobGraph.getJobID() + " (" + jobGraph.getName() + ")", t)__			}__			__			jobCompletionActions.jobFailed(rt)__			return__		}__		_		executionContext.execute(new Runnable() {_			@Override_			public void run() {_				if (executionGraph != null) {_					try {_						executionGraph.scheduleForExecution(scheduler)__					} catch (Throwable t) {_						executionGraph.fail(t)__					}_				}_			}_		})__	};start,to,run,the,job,runtime,data,structures,like,execution,graph,will,be,constructed,now,and,checkpoint,being,recovered,after,this,we,will,begin,to,schedule,the,job;rpc,method,public,void,start,job,log,info,starting,job,job,graph,get,name,job,graph,get,job,id,if,execution,graph,null,execution,graph,new,execution,graph,execution,context,module,from,executor,execution,context,job,graph,get,job,id,job,graph,get,name,job,graph,get,job,configuration,job,graph,get,serialized,execution,config,new,finite,duration,timeout,get,size,timeout,get,unit,restart,strategy,job,graph,get,user,jar,blob,keys,job,graph,get,classpaths,user,code,loader,job,metrics,else,try,execution,graph,set,schedule,mode,job,graph,get,schedule,mode,execution,graph,set,queued,scheduling,allowed,job,graph,get,allow,queued,scheduling,try,execution,graph,set,json,plan,json,plan,generator,generate,plan,job,graph,catch,exception,e,log,warn,cannot,create,json,plan,for,job,job,graph,get,job,id,job,graph,get,name,e,execution,graph,set,json,plan,if,log,is,debug,enabled,log,debug,running,initialization,on,master,for,job,job,graph,get,job,id,job,graph,get,name,for,job,vertex,vertex,job,graph,get,vertices,final,string,executable,class,vertex,get,invokable,class,name,if,executable,class,null,executable,class,length,0,throw,new,job,execution,exception,job,graph,get,job,id,the,vertex,vertex,get,id,vertex,get,name,has,no,invokable,class,if,vertex,get,parallelism,execution,config,vertex,set,parallelism,scheduler,get,total,number,of,slots,try,vertex,initialize,on,master,user,code,loader,catch,throwable,t,throw,new,job,execution,exception,job,graph,get,job,id,cannot,initialize,task,vertex,get,name,t,get,message,t,final,list,job,vertex,sorted,topology,job,graph,get,vertices,sorted,topologically,from,sources,if,log,is,debug,enabled,log,debug,adding,vertices,from,job,graph,sorted,topology,size,job,graph,get,job,id,job,graph,get,name,execution,graph,attach,job,graph,sorted,topology,if,log,is,debug,enabled,log,debug,successfully,created,execution,graph,from,job,graph,job,graph,get,job,id,job,graph,get,name,final,job,snapshotting,settings,snapshot,settings,job,graph,get,snapshot,settings,if,snapshot,settings,null,list,execution,job,vertex,trigger,vertices,get,execution,job,vertex,with,id,execution,graph,snapshot,settings,get,vertices,to,trigger,list,execution,job,vertex,ack,vertices,get,execution,job,vertex,with,id,execution,graph,snapshot,settings,get,vertices,to,acknowledge,list,execution,job,vertex,confirm,vertices,get,execution,job,vertex,with,id,execution,graph,snapshot,settings,get,vertices,to,confirm,completed,checkpoint,store,completed,checkpoints,checkpoint,recovery,factory,create,checkpoint,store,job,graph,get,job,id,user,code,loader,checkpoint,idcounter,checkpoint,id,counter,checkpoint,recovery,factory,create,checkpoint,idcounter,job,graph,get,job,id,boolean,is,stats,disabled,configuration,get,boolean,config,constants,config,constants,final,checkpoint,stats,tracker,checkpoint,stats,tracker,if,is,stats,disabled,checkpoint,stats,tracker,new,disabled,checkpoint,stats,tracker,else,int,history,size,configuration,get,integer,config,constants,config,constants,checkpoint,stats,tracker,new,simple,checkpoint,stats,tracker,history,size,ack,vertices,job,metrics,execution,graph,enable,snapshot,checkpointing,snapshot,settings,get,checkpoint,interval,snapshot,settings,get,checkpoint,timeout,snapshot,settings,get,min,pause,between,checkpoints,snapshot,settings,get,max,concurrent,checkpoints,trigger,vertices,ack,vertices,confirm,vertices,checkpoint,id,counter,completed,checkpoints,savepoint,store,checkpoint,stats,tracker,catch,throwable,t,log,error,failed,to,start,job,job,graph,get,name,job,graph,get,job,id,t,execution,graph,fail,t,execution,graph,null,final,throwable,rt,if,t,instanceof,job,execution,exception,rt,job,execution,exception,t,else,rt,new,job,execution,exception,job,graph,get,job,id,failed,to,start,job,job,graph,get,job,id,job,graph,get,name,t,job,completion,actions,job,failed,rt,return,execution,context,execute,new,runnable,override,public,void,run,if,execution,graph,null,try,execution,graph,schedule,for,execution,scheduler,catch,throwable,t,execution,graph,fail,t
JobMaster -> @RpcMethod 	public void startJob();1474453995;Start to run the job, runtime data structures like ExecutionGraph will be constructed now and checkpoint_being recovered. After this, we will begin to schedule the job.;@RpcMethod_	public void startJob() {_		log.info("Starting job {} ({}).", jobGraph.getName(), jobGraph.getJobID())___		try {_			if (executionGraph != null) {_				executionGraph = new ExecutionGraph(_						executionContext,_						executionContext,_						jobGraph.getJobID(),_						jobGraph.getName(),_						jobGraph.getJobConfiguration(),_						jobGraph.getSerializedExecutionConfig(),_						timeout,_						restartStrategy,_						jobGraph.getUserJarBlobKeys(),_						jobGraph.getClasspaths(),_						userCodeLoader,_						jobMetrics)__			} else {_				_			}__			executionGraph.setScheduleMode(jobGraph.getScheduleMode())__			executionGraph.setQueuedSchedulingAllowed(jobGraph.getAllowQueuedScheduling())___			try {_				executionGraph.setJsonPlan(JsonPlanGenerator.generatePlan(jobGraph))__			} catch (Exception e) {_				log.warn("Cannot create JSON plan for job {} ({})", jobGraph.getJobID(), jobGraph.getName(), e)__				executionGraph.setJsonPlan("{}")__			}__			_			_			if (log.isDebugEnabled()) {_				log.debug("Running initialization on master for job {} ({}).", jobGraph.getJobID(), jobGraph.getName())__			}_			for (JobVertex vertex : jobGraph.getVertices()) {_				final String executableClass = vertex.getInvokableClassName()__				if (executableClass == null || executableClass.length() == 0) {_					throw new JobExecutionException(jobGraph.getJobID(),_						"The vertex " + vertex.getID() + " (" + vertex.getName() + ") has no invokable class.")__				}_				if (vertex.getParallelism() == ExecutionConfig.PARALLELISM_AUTO_MAX) {_					vertex.setParallelism(scheduler.getTotalNumberOfSlots())__				}__				try {_					vertex.initializeOnMaster(userCodeLoader)__				} catch (Throwable t) {_					throw new JobExecutionException(jobGraph.getJobID(),_						"Cannot initialize task '" + vertex.getName() + "': " + t.getMessage(), t)__				}_			}__			_			final List<JobVertex> sortedTopology = jobGraph.getVerticesSortedTopologicallyFromSources()__			if (log.isDebugEnabled()) {_				log.debug("Adding {} vertices from job graph {} ({}).", sortedTopology.size(),_					jobGraph.getJobID(), jobGraph.getName())__			}_			executionGraph.attachJobGraph(sortedTopology)___			if (log.isDebugEnabled()) {_				log.debug("Successfully created execution graph from job graph {} ({}).",_					jobGraph.getJobID(), jobGraph.getName())__			}__			final JobSnapshottingSettings snapshotSettings = jobGraph.getSnapshotSettings()__			if (snapshotSettings != null) {_				List<ExecutionJobVertex> triggerVertices = getExecutionJobVertexWithId(_					executionGraph, snapshotSettings.getVerticesToTrigger())___				List<ExecutionJobVertex> ackVertices = getExecutionJobVertexWithId(_					executionGraph, snapshotSettings.getVerticesToAcknowledge())___				List<ExecutionJobVertex> confirmVertices = getExecutionJobVertexWithId(_					executionGraph, snapshotSettings.getVerticesToConfirm())___				CompletedCheckpointStore completedCheckpoints = checkpointRecoveryFactory.createCheckpointStore(_					jobGraph.getJobID(), userCodeLoader)___				CheckpointIDCounter checkpointIdCounter = checkpointRecoveryFactory.createCheckpointIDCounter(_					jobGraph.getJobID())___				_				boolean isStatsDisabled = configuration.getBoolean(_					ConfigConstants.JOB_MANAGER_WEB_CHECKPOINTS_DISABLE,_					ConfigConstants.DEFAULT_JOB_MANAGER_WEB_CHECKPOINTS_DISABLE)___				final CheckpointStatsTracker checkpointStatsTracker__				if (isStatsDisabled) {_					checkpointStatsTracker = new DisabledCheckpointStatsTracker()__				} else {_					int historySize = configuration.getInteger(_						ConfigConstants.JOB_MANAGER_WEB_CHECKPOINTS_HISTORY_SIZE,_						ConfigConstants.DEFAULT_JOB_MANAGER_WEB_CHECKPOINTS_HISTORY_SIZE)__					checkpointStatsTracker = new SimpleCheckpointStatsTracker(historySize, ackVertices, jobMetrics)__				}__				String externalizedCheckpointsDir = configuration.getString(_						ConfigConstants.CHECKPOINTS_DIRECTORY_KEY, null)___				executionGraph.enableSnapshotCheckpointing(_					snapshotSettings.getCheckpointInterval(),_					snapshotSettings.getCheckpointTimeout(),_					snapshotSettings.getMinPauseBetweenCheckpoints(),_					snapshotSettings.getMaxConcurrentCheckpoints(),_					snapshotSettings.getExternalizedCheckpointSettings(),_					triggerVertices,_					ackVertices,_					confirmVertices,_					checkpointIdCounter,_					completedCheckpoints,_					externalizedCheckpointsDir,_					checkpointStatsTracker)__			}__			__			__			__		} catch (Throwable t) {_			log.error("Failed to start job {} ({})", jobGraph.getName(), jobGraph.getJobID(), t)___			executionGraph.fail(t)__			executionGraph = null___			final Throwable rt__			if (t instanceof JobExecutionException) {_				rt = (JobExecutionException) t__			} else {_				rt = new JobExecutionException(jobGraph.getJobID(),_					"Failed to start job " + jobGraph.getJobID() + " (" + jobGraph.getName() + ")", t)__			}__			__			jobCompletionActions.jobFailed(rt)__			return__		}__		_		executionContext.execute(new Runnable() {_			@Override_			public void run() {_				if (executionGraph != null) {_					try {_						executionGraph.scheduleForExecution(scheduler)__					} catch (Throwable t) {_						executionGraph.fail(t)__					}_				}_			}_		})__	};start,to,run,the,job,runtime,data,structures,like,execution,graph,will,be,constructed,now,and,checkpoint,being,recovered,after,this,we,will,begin,to,schedule,the,job;rpc,method,public,void,start,job,log,info,starting,job,job,graph,get,name,job,graph,get,job,id,try,if,execution,graph,null,execution,graph,new,execution,graph,execution,context,execution,context,job,graph,get,job,id,job,graph,get,name,job,graph,get,job,configuration,job,graph,get,serialized,execution,config,timeout,restart,strategy,job,graph,get,user,jar,blob,keys,job,graph,get,classpaths,user,code,loader,job,metrics,else,execution,graph,set,schedule,mode,job,graph,get,schedule,mode,execution,graph,set,queued,scheduling,allowed,job,graph,get,allow,queued,scheduling,try,execution,graph,set,json,plan,json,plan,generator,generate,plan,job,graph,catch,exception,e,log,warn,cannot,create,json,plan,for,job,job,graph,get,job,id,job,graph,get,name,e,execution,graph,set,json,plan,if,log,is,debug,enabled,log,debug,running,initialization,on,master,for,job,job,graph,get,job,id,job,graph,get,name,for,job,vertex,vertex,job,graph,get,vertices,final,string,executable,class,vertex,get,invokable,class,name,if,executable,class,null,executable,class,length,0,throw,new,job,execution,exception,job,graph,get,job,id,the,vertex,vertex,get,id,vertex,get,name,has,no,invokable,class,if,vertex,get,parallelism,execution,config,vertex,set,parallelism,scheduler,get,total,number,of,slots,try,vertex,initialize,on,master,user,code,loader,catch,throwable,t,throw,new,job,execution,exception,job,graph,get,job,id,cannot,initialize,task,vertex,get,name,t,get,message,t,final,list,job,vertex,sorted,topology,job,graph,get,vertices,sorted,topologically,from,sources,if,log,is,debug,enabled,log,debug,adding,vertices,from,job,graph,sorted,topology,size,job,graph,get,job,id,job,graph,get,name,execution,graph,attach,job,graph,sorted,topology,if,log,is,debug,enabled,log,debug,successfully,created,execution,graph,from,job,graph,job,graph,get,job,id,job,graph,get,name,final,job,snapshotting,settings,snapshot,settings,job,graph,get,snapshot,settings,if,snapshot,settings,null,list,execution,job,vertex,trigger,vertices,get,execution,job,vertex,with,id,execution,graph,snapshot,settings,get,vertices,to,trigger,list,execution,job,vertex,ack,vertices,get,execution,job,vertex,with,id,execution,graph,snapshot,settings,get,vertices,to,acknowledge,list,execution,job,vertex,confirm,vertices,get,execution,job,vertex,with,id,execution,graph,snapshot,settings,get,vertices,to,confirm,completed,checkpoint,store,completed,checkpoints,checkpoint,recovery,factory,create,checkpoint,store,job,graph,get,job,id,user,code,loader,checkpoint,idcounter,checkpoint,id,counter,checkpoint,recovery,factory,create,checkpoint,idcounter,job,graph,get,job,id,boolean,is,stats,disabled,configuration,get,boolean,config,constants,config,constants,final,checkpoint,stats,tracker,checkpoint,stats,tracker,if,is,stats,disabled,checkpoint,stats,tracker,new,disabled,checkpoint,stats,tracker,else,int,history,size,configuration,get,integer,config,constants,config,constants,checkpoint,stats,tracker,new,simple,checkpoint,stats,tracker,history,size,ack,vertices,job,metrics,string,externalized,checkpoints,dir,configuration,get,string,config,constants,null,execution,graph,enable,snapshot,checkpointing,snapshot,settings,get,checkpoint,interval,snapshot,settings,get,checkpoint,timeout,snapshot,settings,get,min,pause,between,checkpoints,snapshot,settings,get,max,concurrent,checkpoints,snapshot,settings,get,externalized,checkpoint,settings,trigger,vertices,ack,vertices,confirm,vertices,checkpoint,id,counter,completed,checkpoints,externalized,checkpoints,dir,checkpoint,stats,tracker,catch,throwable,t,log,error,failed,to,start,job,job,graph,get,name,job,graph,get,job,id,t,execution,graph,fail,t,execution,graph,null,final,throwable,rt,if,t,instanceof,job,execution,exception,rt,job,execution,exception,t,else,rt,new,job,execution,exception,job,graph,get,job,id,failed,to,start,job,job,graph,get,job,id,job,graph,get,name,t,job,completion,actions,job,failed,rt,return,execution,context,execute,new,runnable,override,public,void,run,if,execution,graph,null,try,execution,graph,schedule,for,execution,scheduler,catch,throwable,t,execution,graph,fail,t
JobMaster -> public JobMaster( 		JobGraph jobGraph, 		Configuration configuration, 		RpcService rpcService, 		HighAvailabilityServices highAvailabilityService);1472481329;The JM's Constructor__@param jobGraph The representation of the job's execution plan_@param configuration The job's configuration_@param rpcService The RPC service at which the JM serves_@param highAvailabilityService The cluster's HA service from the JM can elect and retrieve leaders.;public JobMaster(_		JobGraph jobGraph,_		Configuration configuration,_		RpcService rpcService,_		HighAvailabilityServices highAvailabilityService) {__		super(rpcService)___		this.jobGraph = Preconditions.checkNotNull(jobGraph)__		this.jobID = Preconditions.checkNotNull(jobGraph.getJobID())___		this.configuration = Preconditions.checkNotNull(configuration)___		this.highAvailabilityServices = Preconditions.checkNotNull(highAvailabilityService)__	};the,jm,s,constructor,param,job,graph,the,representation,of,the,job,s,execution,plan,param,configuration,the,job,s,configuration,param,rpc,service,the,rpc,service,at,which,the,jm,serves,param,high,availability,service,the,cluster,s,ha,service,from,the,jm,can,elect,and,retrieve,leaders;public,job,master,job,graph,job,graph,configuration,configuration,rpc,service,rpc,service,high,availability,services,high,availability,service,super,rpc,service,this,job,graph,preconditions,check,not,null,job,graph,this,job,id,preconditions,check,not,null,job,graph,get,job,id,this,configuration,preconditions,check,not,null,configuration,this,high,availability,services,preconditions,check,not,null,high,availability,service
JobMaster -> public JobMaster( 		JobGraph jobGraph, 		Configuration configuration, 		RpcService rpcService, 		HighAvailabilityServices highAvailabilityService);1474471581;The JM's Constructor__@param jobGraph The representation of the job's execution plan_@param configuration The job's configuration_@param rpcService The RPC service at which the JM serves_@param highAvailabilityService The cluster's HA service from the JM can elect and retrieve leaders.;public JobMaster(_		JobGraph jobGraph,_		Configuration configuration,_		RpcService rpcService,_		HighAvailabilityServices highAvailabilityService) {__		super(rpcService)___		this.jobGraph = Preconditions.checkNotNull(jobGraph)__		this.jobID = Preconditions.checkNotNull(jobGraph.getJobID())___		this.configuration = Preconditions.checkNotNull(configuration)___		this.highAvailabilityServices = Preconditions.checkNotNull(highAvailabilityService)__	};the,jm,s,constructor,param,job,graph,the,representation,of,the,job,s,execution,plan,param,configuration,the,job,s,configuration,param,rpc,service,the,rpc,service,at,which,the,jm,serves,param,high,availability,service,the,cluster,s,ha,service,from,the,jm,can,elect,and,retrieve,leaders;public,job,master,job,graph,job,graph,configuration,configuration,rpc,service,rpc,service,high,availability,services,high,availability,service,super,rpc,service,this,job,graph,preconditions,check,not,null,job,graph,this,job,id,preconditions,check,not,null,job,graph,get,job,id,this,configuration,preconditions,check,not,null,configuration,this,high,availability,services,preconditions,check,not,null,high,availability,service
JobMaster -> private void registerAtElectionService();1472481329;Retrieves the election service and contend for the leadership.;private void registerAtElectionService() {_		try {_			leaderElectionService = highAvailabilityServices.getJobMasterLeaderElectionService(jobID)__			leaderElectionService.start(new JobMasterLeaderContender())__		} catch (Exception e) {_			throw new RuntimeException("Fail to register at the election of JobMaster", e)__		}_	};retrieves,the,election,service,and,contend,for,the,leadership;private,void,register,at,election,service,try,leader,election,service,high,availability,services,get,job,master,leader,election,service,job,id,leader,election,service,start,new,job,master,leader,contender,catch,exception,e,throw,new,runtime,exception,fail,to,register,at,the,election,of,job,master,e
JobMaster -> private void registerAtElectionService();1474471581;Retrieves the election service and contend for the leadership.;private void registerAtElectionService() {_		try {_			leaderElectionService = highAvailabilityServices.getJobMasterLeaderElectionService(jobID)__			leaderElectionService.start(new JobMasterLeaderContender())__		} catch (Exception e) {_			throw new RuntimeException("Fail to register at the election of JobMaster", e)__		}_	};retrieves,the,election,service,and,contend,for,the,leadership;private,void,register,at,election,service,try,leader,election,service,high,availability,services,get,job,master,leader,election,service,job,id,leader,election,service,start,new,job,master,leader,contender,catch,exception,e,throw,new,runtime,exception,fail,to,register,at,the,election,of,job,master,e
JobMaster -> @Override 	public CompletableFuture<Void> onStop();1538764056;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> onStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.close()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		return FutureUtils.completeAll(Collections.singletonList(disposeInternalSavepointFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,on,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,close,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,return,future,utils,complete,all,collections,singleton,list,dispose,internal,savepoint,future
JobMaster -> @Override 	public CompletableFuture<Void> onStop();1549533702;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> onStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.getTerminationFuture()___		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,on,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,final,completable,future,void,slot,pool,termination,future,slot,pool,get,termination,future,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> onStop();1549983516;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> onStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		final CompletableFuture<Void> slotPoolTerminationFuture = slotPool.closeAsync()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		return FutureUtils.completeAll(Arrays.asList(disposeInternalSavepointFuture, slotPoolTerminationFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,on,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,final,completable,future,void,slot,pool,termination,future,slot,pool,close,async,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,return,future,utils,complete,all,arrays,as,list,dispose,internal,savepoint,future,slot,pool,termination,future
JobMaster -> @Override 	public CompletableFuture<Void> onStop();1550366933;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> onStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.close()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		return FutureUtils.completeAll(Collections.singletonList(disposeInternalSavepointFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,on,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,close,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,return,future,utils,complete,all,collections,singleton,list,dispose,internal,savepoint,future
JobMaster -> @Override 	public CompletableFuture<Void> onStop();1550405950;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> onStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.close()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		return FutureUtils.completeAll(Collections.singletonList(disposeInternalSavepointFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,on,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,close,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,return,future,utils,complete,all,collections,singleton,list,dispose,internal,savepoint,future
JobMaster -> @Override 	public CompletableFuture<Void> onStop();1550572312;Suspend the job and shutdown all other services including rpc.;@Override_	public CompletableFuture<Void> onStop() {_		log.info("Stopping the JobMaster for job {}({}).", jobGraph.getName(), jobGraph.getJobID())___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.close()___		final CompletableFuture<Void> disposeInternalSavepointFuture___		if (lastInternalSavepoint != null) {_			disposeInternalSavepointFuture = CompletableFuture.runAsync(() -> disposeSavepoint(lastInternalSavepoint))__		} else {_			disposeInternalSavepointFuture = CompletableFuture.completedFuture(null)__		}__		return FutureUtils.completeAll(Collections.singletonList(disposeInternalSavepointFuture))__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,completable,future,void,on,stop,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,close,final,completable,future,void,dispose,internal,savepoint,future,if,last,internal,savepoint,null,dispose,internal,savepoint,future,completable,future,run,async,dispose,savepoint,last,internal,savepoint,else,dispose,internal,savepoint,future,completable,future,completed,future,null,return,future,utils,complete,all,collections,singleton,list,dispose,internal,savepoint,future
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1519408304;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1519931395;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1519999896;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1521033687;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1521049936;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1521224209;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1521641386;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1521810529;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1521816200;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1521816389;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1521817317;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1522130448;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1522136713;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1522230836;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1522849636;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1525374816;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1525934187;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1526300085;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1526311855;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1526561054;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1526997218;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1527029265;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1527094227;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1529603022;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1529915670;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1530791303;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1532289479;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1532293098;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1533374562;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1534937274;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1536826537;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1538403115;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1538764056;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1538864611;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1542043300;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1542304303;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1543229263;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1544094547;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1547809055;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1547809099;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1547809385;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1548086094;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1548172161;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1548172454;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1548679824;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1549036717;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1549381698;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1549533702;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1549965236;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1549983516;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1550366933;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1550405950;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture);1550572312;Restore the given {@link ExecutionGraph} from the rescaling savepoint. If the {@link ExecutionGraph} could_be restored, then this savepoint will be recorded as the latest successful modification savepoint. A previous_savepoint will be disposed. If the rescaling savepoint is empty, the job will be restored from the initially_provided savepoint.__@param newExecutionGraph to restore_@param savepointFuture containing the path to the internal modification savepoint_@return Future which is completed with the restored {@link ExecutionGraph};private CompletableFuture<ExecutionGraph> restoreExecutionGraphFromRescalingSavepoint(ExecutionGraph newExecutionGraph, CompletableFuture<String> savepointFuture) {_		return savepointFuture_			.thenApplyAsync(_				(@Nullable String savepointPath) -> {_					if (savepointPath != null) {_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, SavepointRestoreSettings.forPath(savepointPath, false))__						} catch (Exception e) {_							final String message = String.format("Could not restore from temporary rescaling savepoint. This might indicate " +_									"that the savepoint %s got corrupted. Deleting this savepoint as a precaution.",_								savepointPath)___							log.info(message)___							CompletableFuture_								.runAsync(_									() -> {_										if (savepointPath.equals(lastInternalSavepoint)) {_											lastInternalSavepoint = null__										}_									},_									getMainThreadExecutor())_								.thenRunAsync(_									() -> disposeSavepoint(savepointPath),_									scheduledExecutorService)___							throw new CompletionException(new JobModificationException(message, e))__						}_					} else {_						_						try {_							tryRestoreExecutionGraphFromSavepoint(newExecutionGraph, jobGraph.getSavepointRestoreSettings())__						} catch (Exception e) {_							final String message = String.format("Could not restore from initial savepoint. This might indicate " +_								"that the savepoint %s got corrupted.", jobGraph.getSavepointRestoreSettings().getRestorePath())___							log.info(message)___							throw new CompletionException(new JobModificationException(message, e))__						}_					}__					return newExecutionGraph__				}, scheduledExecutorService)__	};restore,the,given,link,execution,graph,from,the,rescaling,savepoint,if,the,link,execution,graph,could,be,restored,then,this,savepoint,will,be,recorded,as,the,latest,successful,modification,savepoint,a,previous,savepoint,will,be,disposed,if,the,rescaling,savepoint,is,empty,the,job,will,be,restored,from,the,initially,provided,savepoint,param,new,execution,graph,to,restore,param,savepoint,future,containing,the,path,to,the,internal,modification,savepoint,return,future,which,is,completed,with,the,restored,link,execution,graph;private,completable,future,execution,graph,restore,execution,graph,from,rescaling,savepoint,execution,graph,new,execution,graph,completable,future,string,savepoint,future,return,savepoint,future,then,apply,async,nullable,string,savepoint,path,if,savepoint,path,null,try,try,restore,execution,graph,from,savepoint,new,execution,graph,savepoint,restore,settings,for,path,savepoint,path,false,catch,exception,e,final,string,message,string,format,could,not,restore,from,temporary,rescaling,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,deleting,this,savepoint,as,a,precaution,savepoint,path,log,info,message,completable,future,run,async,if,savepoint,path,equals,last,internal,savepoint,last,internal,savepoint,null,get,main,thread,executor,then,run,async,dispose,savepoint,savepoint,path,scheduled,executor,service,throw,new,completion,exception,new,job,modification,exception,message,e,else,try,try,restore,execution,graph,from,savepoint,new,execution,graph,job,graph,get,savepoint,restore,settings,catch,exception,e,final,string,message,string,format,could,not,restore,from,initial,savepoint,this,might,indicate,that,the,savepoint,s,got,corrupted,job,graph,get,savepoint,restore,settings,get,restore,path,log,info,message,throw,new,completion,exception,new,job,modification,exception,message,e,return,new,execution,graph,scheduled,executor,service
JobMaster -> public void grantJobMasterLeadership(final UUID newLeaderSessionID);1472481329;Start the execution when the leadership is granted.__@param newLeaderSessionID The identifier of the new leadership session;public void grantJobMasterLeadership(final UUID newLeaderSessionID) {_		runAsync(new Runnable() {_			@Override_			public void run() {_				log.info("JobManager {} grants leadership with session id {}.", getAddress(), newLeaderSessionID)___				_				_				leaderSessionID = newLeaderSessionID__				leaderElectionService.confirmLeaderSessionID(newLeaderSessionID)___				_			}_		})__	};start,the,execution,when,the,leadership,is,granted,param,new,leader,session,id,the,identifier,of,the,new,leadership,session;public,void,grant,job,master,leadership,final,uuid,new,leader,session,id,run,async,new,runnable,override,public,void,run,log,info,job,manager,grants,leadership,with,session,id,get,address,new,leader,session,id,leader,session,id,new,leader,session,id,leader,election,service,confirm,leader,session,id,new,leader,session,id
JobMaster -> public void grantJobMasterLeadership(final UUID newLeaderSessionID);1474471581;Start the execution when the leadership is granted.__@param newLeaderSessionID The identifier of the new leadership session;public void grantJobMasterLeadership(final UUID newLeaderSessionID) {_		runAsync(new Runnable() {_			@Override_			public void run() {_				log.info("JobManager {} grants leadership with session id {}.", getAddress(), newLeaderSessionID)___				_				_				leaderSessionID = newLeaderSessionID__				leaderElectionService.confirmLeaderSessionID(newLeaderSessionID)___				_			}_		})__	};start,the,execution,when,the,leadership,is,granted,param,new,leader,session,id,the,identifier,of,the,new,leadership,session;public,void,grant,job,master,leadership,final,uuid,new,leader,session,id,run,async,new,runnable,override,public,void,run,log,info,job,manager,grants,leadership,with,session,id,get,address,new,leader,session,id,leader,session,id,new,leader,session,id,leader,election,service,confirm,leader,session,id,new,leader,session,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1498493279;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1498580984;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1500977056;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1502196227;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1502714913;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1503412385;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1503573855;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1503580260;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1503581387;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1503588382;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1505768302;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1505861185;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1505921975;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1505984004;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1506005238;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1506346199;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1506510152;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1507284174;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1507673791;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1507738083;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1508840168;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1510061826;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1510699852;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1511543029;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1511975541;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1512136929;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1512567555;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason)_	{_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1513261475;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1513706333;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1514829582;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1516197717;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1516368003;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1516641064;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1516797761;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1516896219;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1517300523;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1517425569;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1517911296;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1517920262;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1518093789;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1518194413;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1518393108;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1518522104;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1518524281;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1518531558;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1518532391;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1518534881;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1518539372;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1518606541;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1518689135;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveDeclineMessage(decline)__					} catch (Exception e) {_						log.error("Error in CheckpointCoordinator while processing {}", decline, e)__					}_				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1518716619;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1518718788;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1519299413;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1519320257;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1519390630;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1519408304;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1519931395;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1519999896;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1521033687;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1521049936;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1521224209;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1521641386;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1521810529;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1521816200;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1521816389;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1521817317;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1522130448;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1522136713;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1522230836;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1522849636;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1525374816;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1525934187;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1526300085;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1526311855;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1526561054;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1526997218;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1527029265;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1527094227;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1529603022;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1529915670;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1530791303;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1532289479;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1532293098;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1533374562;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1534937274;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1536826537;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1538403115;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void declineCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointID, 			final Throwable reason);1538864611;TODO: This method needs a leader session ID;@Override_	public void declineCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointID,_			final Throwable reason) {_		final DeclineCheckpoint decline = new DeclineCheckpoint(_				jobID, executionAttemptID, checkpointID, reason)__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()___		if (checkpointCoordinator != null) {_			getRpcService().execute(() -> {_				try {_					checkpointCoordinator.receiveDeclineMessage(decline)__				} catch (Exception e) {_					log.error("Error in CheckpointCoordinator while processing {}", decline, e)__				}_			})__		} else {_			log.error("Received DeclineCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;override,public,void,decline,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,throwable,reason,final,decline,checkpoint,decline,new,decline,checkpoint,job,id,execution,attempt,id,checkpoint,id,reason,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,if,checkpoint,coordinator,null,get,rpc,service,execute,try,checkpoint,coordinator,receive,decline,message,decline,catch,exception,e,log,error,error,in,checkpoint,coordinator,while,processing,decline,e,else,log,error,received,decline,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1503588382;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1505768302;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1505861185;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1505921975;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1505984004;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1506005238;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1506346199;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1506510152;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1507284174;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1507673791;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1507738083;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1508840168;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1510061826;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1510699852;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1511543029;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1511975541;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1512136929;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1512567555;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1513261475;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1513706333;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1514829582;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1516197717;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1516368003;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1516641064;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1516797761;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1516896219;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1517300523;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1517425569;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1517911296;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1517920262;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1518093789;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1518194413;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1518393108;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1518522104;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1518524281;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1518531558;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1518532391;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1518534881;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1518539372;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1518606541;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1518689135;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1518716619;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1518718788;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1519299413;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1519320257;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1519390630;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1519408304;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1519931395;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1519999896;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1521033687;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1521049936;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1521224209;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1521641386;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1521810529;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1521816200;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1521816389;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1521817317;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1522130448;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1522136713;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1522230836;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1522849636;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1525374816;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1525934187;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1526300085;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1526311855;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1526561054;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1526997218;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1527029265;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1527094227;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1529603022;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1529915670;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1530791303;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1532289479;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1532293098;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1533374562;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1534937274;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1536826537;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1538403115;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1538864611;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1542043300;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1542304303;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1544094547;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1547809055;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1547809099;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1547809385;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1548172161;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception;1548679824;Start the rpc service and begin to run the job.__@param newJobMasterId The necessary fencing token to run the job_@param timeout for the operation_@return Future acknowledge if the job could be started. Otherwise the future contains an exception;public CompletableFuture<Acknowledge> start(final JobMasterId newJobMasterId, final Time timeout) throws Exception {_		_		super.start()___		return callAsyncWithoutFencing(() -> startJobExecution(newJobMasterId), timeout)__	};start,the,rpc,service,and,begin,to,run,the,job,param,new,job,master,id,the,necessary,fencing,token,to,run,the,job,param,timeout,for,the,operation,return,future,acknowledge,if,the,job,could,be,started,otherwise,the,future,contains,an,exception;public,completable,future,acknowledge,start,final,job,master,id,new,job,master,id,final,time,timeout,throws,exception,super,start,return,call,async,without,fencing,start,job,execution,new,job,master,id,timeout
JobMaster -> @RpcMethod 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final CheckpointMetaData checkpointInfo, 			final SubtaskState checkpointState) throws CheckpointException;1476728818;TODO: This method needs a leader session ID;@RpcMethod_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final CheckpointMetaData checkpointInfo,_			final SubtaskState checkpointState) throws CheckpointException {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointInfo, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,checkpoint,meta,data,checkpoint,info,final,subtask,state,checkpoint,state,throws,checkpoint,exception,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,info,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final CheckpointMetaData checkpointInfo, 			final SubtaskState checkpointState) throws CheckpointException;1477061494;TODO: This method needs a leader session ID;@RpcMethod_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final CheckpointMetaData checkpointInfo,_			final SubtaskState checkpointState) throws CheckpointException {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointInfo, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,checkpoint,meta,data,checkpoint,info,final,subtask,state,checkpoint,state,throws,checkpoint,exception,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,info,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final CheckpointMetaData checkpointInfo, 			final SubtaskState checkpointState) throws CheckpointException;1477965803;TODO: This method needs a leader session ID;@RpcMethod_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final CheckpointMetaData checkpointInfo,_			final SubtaskState checkpointState) throws CheckpointException {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointInfo, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,checkpoint,meta,data,checkpoint,info,final,subtask,state,checkpoint,state,throws,checkpoint,exception,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,info,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @RpcMethod 	public void acknowledgeCheckpoint( 			final JobID jobID, 			final ExecutionAttemptID executionAttemptID, 			final CheckpointMetaData checkpointInfo, 			final SubtaskState checkpointState) throws CheckpointException;1486583506;TODO: This method needs a leader session ID;@RpcMethod_	public void acknowledgeCheckpoint(_			final JobID jobID,_			final ExecutionAttemptID executionAttemptID,_			final CheckpointMetaData checkpointInfo,_			final SubtaskState checkpointState) throws CheckpointException {__		final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator()__		final AcknowledgeCheckpoint ackMessage = _				new AcknowledgeCheckpoint(jobID, executionAttemptID, checkpointInfo, checkpointState)___		if (checkpointCoordinator != null) {_			getRpcService().execute(new Runnable() {_				@Override_				public void run() {_					try {_						checkpointCoordinator.receiveAcknowledgeMessage(ackMessage)__					} catch (Throwable t) {_						log.warn("Error while processing checkpoint acknowledgement message")__					}_				}_			})__		} else {_			log.error("Received AcknowledgeCheckpoint message for job {} with no CheckpointCoordinator",_					jobGraph.getJobID())__		}_	};todo,this,method,needs,a,leader,session,id;rpc,method,public,void,acknowledge,checkpoint,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,checkpoint,meta,data,checkpoint,info,final,subtask,state,checkpoint,state,throws,checkpoint,exception,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,get,checkpoint,coordinator,final,acknowledge,checkpoint,ack,message,new,acknowledge,checkpoint,job,id,execution,attempt,id,checkpoint,info,checkpoint,state,if,checkpoint,coordinator,null,get,rpc,service,execute,new,runnable,override,public,void,run,try,checkpoint,coordinator,receive,acknowledge,message,ack,message,catch,throwable,t,log,warn,error,while,processing,checkpoint,acknowledgement,message,else,log,error,received,acknowledge,checkpoint,message,for,job,with,no,checkpoint,coordinator,job,graph,get,job,id
JobMaster -> @Override 	public void postStop() throws Exception;1498493279;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		super.postStop()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,super,post,stop
JobMaster -> @Override 	public void postStop() throws Exception;1498580984;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		super.postStop()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,super,post,stop
JobMaster -> @Override 	public void postStop() throws Exception;1500977056;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		super.postStop()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,super,post,stop
JobMaster -> @Override 	public void postStop() throws Exception;1501251235;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		super.postStop()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,super,post,stop
JobMaster -> @Override 	public void postStop() throws Exception;1501519642;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		super.postStop()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,super,post,stop
JobMaster -> @Override 	public void postStop() throws Exception;1501524690;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		super.postStop()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,super,post,stop
JobMaster -> @Override 	public void postStop() throws Exception;1501580028;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		super.postStop()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,super,post,stop
JobMaster -> @Override 	public void postStop() throws Exception;1502035001;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		super.postStop()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,super,post,stop
JobMaster -> @Override 	public void postStop() throws Exception;1502196227;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		super.postStop()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,super,post,stop
JobMaster -> @Override 	public void postStop() throws Exception;1502714913;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		super.postStop()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,super,post,stop
JobMaster -> @Override 	public void postStop() throws Exception;1503412385;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		super.postStop()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,super,post,stop
JobMaster -> @Override 	public void postStop() throws Exception;1503573855;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		super.postStop()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,super,post,stop
JobMaster -> @Override 	public void postStop() throws Exception;1503580260;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		super.postStop()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,super,post,stop
JobMaster -> @Override 	public void postStop() throws Exception;1503581387;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		super.postStop()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,super,post,stop
JobMaster -> @Override 	public void postStop() throws Exception;1503588382;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		super.postStop()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,super,post,stop
JobMaster -> @Override 	public void postStop() throws Exception;1505768302;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		super.postStop()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,super,post,stop
JobMaster -> @Override 	public void postStop() throws Exception;1505861185;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		super.postStop()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,super,post,stop
JobMaster -> @Override 	public void postStop() throws Exception;1505921975;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		super.postStop()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,super,post,stop
JobMaster -> @Override 	public void postStop() throws Exception;1505984004;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		super.postStop()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,super,post,stop
JobMaster -> @Override 	public void postStop() throws Exception;1506005238;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		super.postStop()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,super,post,stop
JobMaster -> @Override 	public void postStop() throws Exception;1506346199;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		super.postStop()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,super,post,stop
JobMaster -> @Override 	public void postStop() throws Exception;1506510152;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		super.postStop()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,super,post,stop
JobMaster -> @Override 	public void postStop() throws Exception;1507284174;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		super.postStop()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,super,post,stop
JobMaster -> @Override 	public void postStop() throws Exception;1507673791;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		super.postStop()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,super,post,stop
JobMaster -> @Override 	public void postStop() throws Exception;1507738083;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		super.postStop()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,super,post,stop
JobMaster -> @Override 	public void postStop() throws Exception;1508840168;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		super.postStop()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,super,post,stop
JobMaster -> @Override 	public void postStop() throws Exception;1510061826;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		super.postStop()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,super,post,stop
JobMaster -> @Override 	public void postStop() throws Exception;1510699852;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		super.postStop()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,super,post,stop
JobMaster -> @Override 	public void postStop() throws Exception;1511543029;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		super.postStop()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,super,post,stop
JobMaster -> @Override 	public void postStop() throws Exception;1511975541;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		super.postStop()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,super,post,stop
JobMaster -> @Override 	public void postStop() throws Exception;1512136929;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		log.info("Stopping the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		_		slotPool.shutDown()__		CompletableFuture<Boolean> terminationFuture = slotPool.getTerminationFuture()___		Exception exception = null___		_		try {_			terminationFuture.get(rpcTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (Exception e) {_			exception = e__		}__		try {_			super.postStop()__		} catch (Exception e) {_			exception = ExceptionUtils.firstOrSuppressed(e, exception)__		}__		if (exception != null) {_			throw exception__		}__		log.info("Stopped the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,slot,pool,shut,down,completable,future,boolean,termination,future,slot,pool,get,termination,future,exception,exception,null,try,termination,future,get,rpc,timeout,to,milliseconds,time,unit,milliseconds,catch,exception,e,exception,e,try,super,post,stop,catch,exception,e,exception,exception,utils,first,or,suppressed,e,exception,if,exception,null,throw,exception,log,info,stopped,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id
JobMaster -> @Override 	public void postStop() throws Exception;1512567555;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		super.postStop()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,super,post,stop
JobMaster -> @Override 	public void postStop() throws Exception;1513261475;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		super.postStop()__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,super,post,stop
JobMaster -> @Override 	public void postStop() throws Exception;1513706333;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		log.info("Stopping the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		_		slotPool.shutDown()__		CompletableFuture<Boolean> terminationFuture = slotPool.getTerminationFuture()___		Exception exception = null___		_		try {_			terminationFuture.get(rpcTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (Exception e) {_			exception = e__		}__		try {_			super.postStop()__		} catch (Exception e) {_			exception = ExceptionUtils.firstOrSuppressed(e, exception)__		}__		if (exception != null) {_			throw exception__		}__		log.info("Stopped the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,slot,pool,shut,down,completable,future,boolean,termination,future,slot,pool,get,termination,future,exception,exception,null,try,termination,future,get,rpc,timeout,to,milliseconds,time,unit,milliseconds,catch,exception,e,exception,e,try,super,post,stop,catch,exception,e,exception,exception,utils,first,or,suppressed,e,exception,if,exception,null,throw,exception,log,info,stopped,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id
JobMaster -> @Override 	public void postStop() throws Exception;1514829582;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		log.info("Stopping the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		_		slotPool.shutDown()__		CompletableFuture<Boolean> terminationFuture = slotPool.getTerminationFuture()___		Exception exception = null___		_		try {_			terminationFuture.get(rpcTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (Exception e) {_			exception = e__		}__		try {_			super.postStop()__		} catch (Exception e) {_			exception = ExceptionUtils.firstOrSuppressed(e, exception)__		}__		if (exception != null) {_			throw exception__		}__		log.info("Stopped the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,slot,pool,shut,down,completable,future,boolean,termination,future,slot,pool,get,termination,future,exception,exception,null,try,termination,future,get,rpc,timeout,to,milliseconds,time,unit,milliseconds,catch,exception,e,exception,e,try,super,post,stop,catch,exception,e,exception,exception,utils,first,or,suppressed,e,exception,if,exception,null,throw,exception,log,info,stopped,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id
JobMaster -> @Override 	public void postStop() throws Exception;1516197717;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		log.info("Stopping the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		_		slotPool.shutDown()__		CompletableFuture<Boolean> terminationFuture = slotPool.getTerminationFuture()___		Exception exception = null___		_		try {_			terminationFuture.get(rpcTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (Exception e) {_			exception = e__		}__		try {_			super.postStop()__		} catch (Exception e) {_			exception = ExceptionUtils.firstOrSuppressed(e, exception)__		}__		if (exception != null) {_			throw exception__		}__		log.info("Stopped the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,slot,pool,shut,down,completable,future,boolean,termination,future,slot,pool,get,termination,future,exception,exception,null,try,termination,future,get,rpc,timeout,to,milliseconds,time,unit,milliseconds,catch,exception,e,exception,e,try,super,post,stop,catch,exception,e,exception,exception,utils,first,or,suppressed,e,exception,if,exception,null,throw,exception,log,info,stopped,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id
JobMaster -> @Override 	public void postStop() throws Exception;1516368003;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		log.info("Stopping the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		_		slotPool.shutDown()__		CompletableFuture<Boolean> terminationFuture = slotPool.getTerminationFuture()___		Exception exception = null___		_		try {_			terminationFuture.get(rpcTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (Exception e) {_			exception = e__		}__		try {_			super.postStop()__		} catch (Exception e) {_			exception = ExceptionUtils.firstOrSuppressed(e, exception)__		}__		if (exception != null) {_			throw exception__		}__		log.info("Stopped the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,slot,pool,shut,down,completable,future,boolean,termination,future,slot,pool,get,termination,future,exception,exception,null,try,termination,future,get,rpc,timeout,to,milliseconds,time,unit,milliseconds,catch,exception,e,exception,e,try,super,post,stop,catch,exception,e,exception,exception,utils,first,or,suppressed,e,exception,if,exception,null,throw,exception,log,info,stopped,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id
JobMaster -> @Override 	public void postStop() throws Exception;1516641064;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		log.info("Stopping the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		_		slotPool.shutDown()__		CompletableFuture<Boolean> terminationFuture = slotPool.getTerminationFuture()___		Exception exception = null___		_		try {_			terminationFuture.get(rpcTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (Exception e) {_			exception = e__		}__		try {_			super.postStop()__		} catch (Exception e) {_			exception = ExceptionUtils.firstOrSuppressed(e, exception)__		}__		if (exception != null) {_			throw exception__		}__		log.info("Stopped the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,slot,pool,shut,down,completable,future,boolean,termination,future,slot,pool,get,termination,future,exception,exception,null,try,termination,future,get,rpc,timeout,to,milliseconds,time,unit,milliseconds,catch,exception,e,exception,e,try,super,post,stop,catch,exception,e,exception,exception,utils,first,or,suppressed,e,exception,if,exception,null,throw,exception,log,info,stopped,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id
JobMaster -> @Override 	public void postStop() throws Exception;1516797761;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		log.info("Stopping the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		_		slotPool.shutDown()__		CompletableFuture<Boolean> terminationFuture = slotPool.getTerminationFuture()___		Exception exception = null___		_		try {_			terminationFuture.get(rpcTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (Exception e) {_			exception = e__		}__		try {_			super.postStop()__		} catch (Exception e) {_			exception = ExceptionUtils.firstOrSuppressed(e, exception)__		}__		if (exception != null) {_			throw exception__		}__		log.info("Stopped the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,slot,pool,shut,down,completable,future,boolean,termination,future,slot,pool,get,termination,future,exception,exception,null,try,termination,future,get,rpc,timeout,to,milliseconds,time,unit,milliseconds,catch,exception,e,exception,e,try,super,post,stop,catch,exception,e,exception,exception,utils,first,or,suppressed,e,exception,if,exception,null,throw,exception,log,info,stopped,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id
JobMaster -> @Override 	public void postStop() throws Exception;1516896219;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		log.info("Stopping the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		_		slotPool.shutDown()__		CompletableFuture<Boolean> terminationFuture = slotPool.getTerminationFuture()___		Exception exception = null___		_		try {_			terminationFuture.get(rpcTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (Exception e) {_			exception = e__		}__		try {_			super.postStop()__		} catch (Exception e) {_			exception = ExceptionUtils.firstOrSuppressed(e, exception)__		}__		if (exception != null) {_			throw exception__		}__		log.info("Stopped the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,slot,pool,shut,down,completable,future,boolean,termination,future,slot,pool,get,termination,future,exception,exception,null,try,termination,future,get,rpc,timeout,to,milliseconds,time,unit,milliseconds,catch,exception,e,exception,e,try,super,post,stop,catch,exception,e,exception,exception,utils,first,or,suppressed,e,exception,if,exception,null,throw,exception,log,info,stopped,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id
JobMaster -> @Override 	public void postStop() throws Exception;1517300523;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		log.info("Stopping the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()__		CompletableFuture<Boolean> terminationFuture = slotPool.getTerminationFuture()___		Exception exception = null___		_		try {_			terminationFuture.get(rpcTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (Exception e) {_			exception = e__		}__		try {_			super.postStop()__		} catch (Exception e) {_			exception = ExceptionUtils.firstOrSuppressed(e, exception)__		}__		if (exception != null) {_			throw exception__		}__		log.info("Stopped the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,completable,future,boolean,termination,future,slot,pool,get,termination,future,exception,exception,null,try,termination,future,get,rpc,timeout,to,milliseconds,time,unit,milliseconds,catch,exception,e,exception,e,try,super,post,stop,catch,exception,e,exception,exception,utils,first,or,suppressed,e,exception,if,exception,null,throw,exception,log,info,stopped,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id
JobMaster -> @Override 	public void postStop() throws Exception;1517425569;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		log.info("Stopping the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		_		slotPool.shutDown()__		CompletableFuture<Boolean> terminationFuture = slotPool.getTerminationFuture()___		Exception exception = null___		_		try {_			terminationFuture.get(rpcTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (Exception e) {_			exception = e__		}__		try {_			super.postStop()__		} catch (Exception e) {_			exception = ExceptionUtils.firstOrSuppressed(e, exception)__		}__		if (exception != null) {_			throw exception__		}__		log.info("Stopped the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,slot,pool,shut,down,completable,future,boolean,termination,future,slot,pool,get,termination,future,exception,exception,null,try,termination,future,get,rpc,timeout,to,milliseconds,time,unit,milliseconds,catch,exception,e,exception,e,try,super,post,stop,catch,exception,e,exception,exception,utils,first,or,suppressed,e,exception,if,exception,null,throw,exception,log,info,stopped,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id
JobMaster -> @Override 	public void postStop() throws Exception;1517911296;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		log.info("Stopping the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		_		slotPool.shutDown()__		CompletableFuture<Boolean> terminationFuture = slotPool.getTerminationFuture()___		Exception exception = null___		_		try {_			terminationFuture.get(rpcTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (Exception e) {_			exception = e__		}__		try {_			super.postStop()__		} catch (Exception e) {_			exception = ExceptionUtils.firstOrSuppressed(e, exception)__		}__		if (exception != null) {_			throw exception__		}__		log.info("Stopped the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,slot,pool,shut,down,completable,future,boolean,termination,future,slot,pool,get,termination,future,exception,exception,null,try,termination,future,get,rpc,timeout,to,milliseconds,time,unit,milliseconds,catch,exception,e,exception,e,try,super,post,stop,catch,exception,e,exception,exception,utils,first,or,suppressed,e,exception,if,exception,null,throw,exception,log,info,stopped,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id
JobMaster -> @Override 	public void postStop() throws Exception;1517920262;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		log.info("Stopping the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		_		slotPool.shutDown()__		CompletableFuture<Boolean> terminationFuture = slotPool.getTerminationFuture()___		Exception exception = null___		_		try {_			terminationFuture.get(rpcTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (Exception e) {_			exception = e__		}__		try {_			super.postStop()__		} catch (Exception e) {_			exception = ExceptionUtils.firstOrSuppressed(e, exception)__		}__		if (exception != null) {_			throw exception__		}__		log.info("Stopped the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,slot,pool,shut,down,completable,future,boolean,termination,future,slot,pool,get,termination,future,exception,exception,null,try,termination,future,get,rpc,timeout,to,milliseconds,time,unit,milliseconds,catch,exception,e,exception,e,try,super,post,stop,catch,exception,e,exception,exception,utils,first,or,suppressed,e,exception,if,exception,null,throw,exception,log,info,stopped,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id
JobMaster -> @Override 	public void postStop() throws Exception;1518093789;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		log.info("Stopping the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		_		slotPool.shutDown()__		CompletableFuture<Boolean> terminationFuture = slotPool.getTerminationFuture()___		Exception exception = null___		_		try {_			terminationFuture.get(rpcTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (Exception e) {_			exception = e__		}__		try {_			super.postStop()__		} catch (Exception e) {_			exception = ExceptionUtils.firstOrSuppressed(e, exception)__		}__		if (exception != null) {_			throw exception__		}__		log.info("Stopped the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,slot,pool,shut,down,completable,future,boolean,termination,future,slot,pool,get,termination,future,exception,exception,null,try,termination,future,get,rpc,timeout,to,milliseconds,time,unit,milliseconds,catch,exception,e,exception,e,try,super,post,stop,catch,exception,e,exception,exception,utils,first,or,suppressed,e,exception,if,exception,null,throw,exception,log,info,stopped,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id
JobMaster -> @Override 	public void postStop() throws Exception;1518194413;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		log.info("Stopping the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		_		slotPool.shutDown()__		CompletableFuture<Boolean> terminationFuture = slotPool.getTerminationFuture()___		Exception exception = null___		_		try {_			terminationFuture.get(rpcTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (Exception e) {_			exception = e__		}__		try {_			super.postStop()__		} catch (Exception e) {_			exception = ExceptionUtils.firstOrSuppressed(e, exception)__		}__		if (exception != null) {_			throw exception__		}__		log.info("Stopped the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,slot,pool,shut,down,completable,future,boolean,termination,future,slot,pool,get,termination,future,exception,exception,null,try,termination,future,get,rpc,timeout,to,milliseconds,time,unit,milliseconds,catch,exception,e,exception,e,try,super,post,stop,catch,exception,e,exception,exception,utils,first,or,suppressed,e,exception,if,exception,null,throw,exception,log,info,stopped,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id
JobMaster -> @Override 	public void postStop() throws Exception;1518393108;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		log.info("Stopping the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		_		slotPool.shutDown()__		CompletableFuture<Boolean> terminationFuture = slotPool.getTerminationFuture()___		Exception exception = null___		_		try {_			terminationFuture.get(rpcTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (Exception e) {_			exception = e__		}__		try {_			super.postStop()__		} catch (Exception e) {_			exception = ExceptionUtils.firstOrSuppressed(e, exception)__		}__		if (exception != null) {_			throw exception__		}__		log.info("Stopped the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,slot,pool,shut,down,completable,future,boolean,termination,future,slot,pool,get,termination,future,exception,exception,null,try,termination,future,get,rpc,timeout,to,milliseconds,time,unit,milliseconds,catch,exception,e,exception,e,try,super,post,stop,catch,exception,e,exception,exception,utils,first,or,suppressed,e,exception,if,exception,null,throw,exception,log,info,stopped,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id
JobMaster -> @Override 	public void postStop() throws Exception;1518522104;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		log.info("Stopping the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		_		slotPool.shutDown()__		CompletableFuture<Boolean> terminationFuture = slotPool.getTerminationFuture()___		Exception exception = null___		_		try {_			terminationFuture.get(rpcTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (Exception e) {_			exception = e__		}__		try {_			super.postStop()__		} catch (Exception e) {_			exception = ExceptionUtils.firstOrSuppressed(e, exception)__		}__		if (exception != null) {_			throw exception__		}__		log.info("Stopped the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,slot,pool,shut,down,completable,future,boolean,termination,future,slot,pool,get,termination,future,exception,exception,null,try,termination,future,get,rpc,timeout,to,milliseconds,time,unit,milliseconds,catch,exception,e,exception,e,try,super,post,stop,catch,exception,e,exception,exception,utils,first,or,suppressed,e,exception,if,exception,null,throw,exception,log,info,stopped,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id
JobMaster -> @Override 	public void postStop() throws Exception;1518524281;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		log.info("Stopping the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		_		slotPool.shutDown()__		CompletableFuture<Boolean> terminationFuture = slotPool.getTerminationFuture()___		Exception exception = null___		_		try {_			terminationFuture.get(rpcTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (Exception e) {_			exception = e__		}__		try {_			super.postStop()__		} catch (Exception e) {_			exception = ExceptionUtils.firstOrSuppressed(e, exception)__		}__		if (exception != null) {_			throw exception__		}__		log.info("Stopped the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,slot,pool,shut,down,completable,future,boolean,termination,future,slot,pool,get,termination,future,exception,exception,null,try,termination,future,get,rpc,timeout,to,milliseconds,time,unit,milliseconds,catch,exception,e,exception,e,try,super,post,stop,catch,exception,e,exception,exception,utils,first,or,suppressed,e,exception,if,exception,null,throw,exception,log,info,stopped,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id
JobMaster -> @Override 	public void postStop() throws Exception;1518531558;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		log.info("Stopping the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()__		CompletableFuture<Boolean> terminationFuture = slotPool.getTerminationFuture()___		Exception exception = null___		_		try {_			terminationFuture.get(rpcTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (Exception e) {_			exception = e__		}__		try {_			super.postStop()__		} catch (Exception e) {_			exception = ExceptionUtils.firstOrSuppressed(e, exception)__		}__		if (exception != null) {_			throw exception__		}__		log.info("Stopped the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,completable,future,boolean,termination,future,slot,pool,get,termination,future,exception,exception,null,try,termination,future,get,rpc,timeout,to,milliseconds,time,unit,milliseconds,catch,exception,e,exception,e,try,super,post,stop,catch,exception,e,exception,exception,utils,first,or,suppressed,e,exception,if,exception,null,throw,exception,log,info,stopped,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id
JobMaster -> @Override 	public void postStop() throws Exception;1518532391;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		log.info("Stopping the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		_		slotPool.shutDown()__		CompletableFuture<Boolean> terminationFuture = slotPool.getTerminationFuture()___		Exception exception = null___		_		try {_			terminationFuture.get(rpcTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (Exception e) {_			exception = e__		}__		try {_			super.postStop()__		} catch (Exception e) {_			exception = ExceptionUtils.firstOrSuppressed(e, exception)__		}__		if (exception != null) {_			throw exception__		}__		log.info("Stopped the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,slot,pool,shut,down,completable,future,boolean,termination,future,slot,pool,get,termination,future,exception,exception,null,try,termination,future,get,rpc,timeout,to,milliseconds,time,unit,milliseconds,catch,exception,e,exception,e,try,super,post,stop,catch,exception,e,exception,exception,utils,first,or,suppressed,e,exception,if,exception,null,throw,exception,log,info,stopped,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id
JobMaster -> @Override 	public void postStop() throws Exception;1518534881;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		log.info("Stopping the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()__		CompletableFuture<Boolean> terminationFuture = slotPool.getTerminationFuture()___		Exception exception = null___		_		try {_			terminationFuture.get(rpcTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (Exception e) {_			exception = e__		}__		try {_			super.postStop()__		} catch (Exception e) {_			exception = ExceptionUtils.firstOrSuppressed(e, exception)__		}__		if (exception != null) {_			throw exception__		}__		log.info("Stopped the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,completable,future,boolean,termination,future,slot,pool,get,termination,future,exception,exception,null,try,termination,future,get,rpc,timeout,to,milliseconds,time,unit,milliseconds,catch,exception,e,exception,e,try,super,post,stop,catch,exception,e,exception,exception,utils,first,or,suppressed,e,exception,if,exception,null,throw,exception,log,info,stopped,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id
JobMaster -> @Override 	public void postStop() throws Exception;1518539372;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		log.info("Stopping the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()__		CompletableFuture<Boolean> terminationFuture = slotPool.getTerminationFuture()___		Exception exception = null___		_		try {_			terminationFuture.get(rpcTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (Exception e) {_			exception = e__		}__		try {_			super.postStop()__		} catch (Exception e) {_			exception = ExceptionUtils.firstOrSuppressed(e, exception)__		}__		if (exception != null) {_			throw exception__		}__		log.info("Stopped the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,completable,future,boolean,termination,future,slot,pool,get,termination,future,exception,exception,null,try,termination,future,get,rpc,timeout,to,milliseconds,time,unit,milliseconds,catch,exception,e,exception,e,try,super,post,stop,catch,exception,e,exception,exception,utils,first,or,suppressed,e,exception,if,exception,null,throw,exception,log,info,stopped,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id
JobMaster -> @Override 	public void postStop() throws Exception;1518606541;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		log.info("Stopping the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()__		CompletableFuture<Boolean> terminationFuture = slotPool.getTerminationFuture()___		Exception exception = null___		_		try {_			terminationFuture.get(rpcTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (Exception e) {_			exception = e__		}__		try {_			super.postStop()__		} catch (Exception e) {_			exception = ExceptionUtils.firstOrSuppressed(e, exception)__		}__		if (exception != null) {_			throw exception__		}__		log.info("Stopped the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,completable,future,boolean,termination,future,slot,pool,get,termination,future,exception,exception,null,try,termination,future,get,rpc,timeout,to,milliseconds,time,unit,milliseconds,catch,exception,e,exception,e,try,super,post,stop,catch,exception,e,exception,exception,utils,first,or,suppressed,e,exception,if,exception,null,throw,exception,log,info,stopped,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id
JobMaster -> @Override 	public void postStop() throws Exception;1518689135;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		log.info("Stopping the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new Exception("JobManager is shutting down."))___		_		slotPool.shutDown()__		CompletableFuture<Boolean> terminationFuture = slotPool.getTerminationFuture()___		Exception exception = null___		_		try {_			terminationFuture.get(rpcTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (Exception e) {_			exception = e__		}__		try {_			super.postStop()__		} catch (Exception e) {_			exception = ExceptionUtils.firstOrSuppressed(e, exception)__		}__		if (exception != null) {_			throw exception__		}__		log.info("Stopped the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,exception,job,manager,is,shutting,down,slot,pool,shut,down,completable,future,boolean,termination,future,slot,pool,get,termination,future,exception,exception,null,try,termination,future,get,rpc,timeout,to,milliseconds,time,unit,milliseconds,catch,exception,e,exception,e,try,super,post,stop,catch,exception,e,exception,exception,utils,first,or,suppressed,e,exception,if,exception,null,throw,exception,log,info,stopped,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id
JobMaster -> @Override 	public void postStop() throws Exception;1518716619;Suspend the job and shutdown all other services including rpc.;@Override_	public void postStop() throws Exception {_		log.info("Stopping the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")___		_		final Set<ResourceID> taskManagerResourceIds = new HashSet<>(registeredTaskManagers.keySet())__		final FlinkException cause = new FlinkException("Stopping JobMaster for job " + jobGraph.getName() +_			'(' + jobGraph.getJobID() + ").")___		for (ResourceID taskManagerResourceId : taskManagerResourceIds) {_			disconnectTaskManager(taskManagerResourceId, cause)__		}__		taskManagerHeartbeatManager.stop()__		resourceManagerHeartbeatManager.stop()___		_		suspendExecution(new FlinkException("JobManager is shutting down."))___		_		slotPool.shutDown()__		CompletableFuture<Void> terminationFuture = slotPool.getTerminationFuture()___		Exception exception = null___		_		try {_			terminationFuture.get(rpcTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (Exception e) {_			exception = e__		}__		try {_			super.postStop()__		} catch (Exception e) {_			exception = ExceptionUtils.firstOrSuppressed(e, exception)__		}__		if (exception != null) {_			throw exception__		}__		log.info("Stopped the JobMaster for job " + jobGraph.getName() + '(' + jobGraph.getJobID() + ").")__	};suspend,the,job,and,shutdown,all,other,services,including,rpc;override,public,void,post,stop,throws,exception,log,info,stopping,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id,final,set,resource,id,task,manager,resource,ids,new,hash,set,registered,task,managers,key,set,final,flink,exception,cause,new,flink,exception,stopping,job,master,for,job,job,graph,get,name,job,graph,get,job,id,for,resource,id,task,manager,resource,id,task,manager,resource,ids,disconnect,task,manager,task,manager,resource,id,cause,task,manager,heartbeat,manager,stop,resource,manager,heartbeat,manager,stop,suspend,execution,new,flink,exception,job,manager,is,shutting,down,slot,pool,shut,down,completable,future,void,termination,future,slot,pool,get,termination,future,exception,exception,null,try,termination,future,get,rpc,timeout,to,milliseconds,time,unit,milliseconds,catch,exception,e,exception,e,try,super,post,stop,catch,exception,e,exception,exception,utils,first,or,suppressed,e,exception,if,exception,null,throw,exception,log,info,stopped,the,job,master,for,job,job,graph,get,name,job,graph,get,job,id
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1503588382;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState)_	{_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1505768302;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState)_	{_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1505861185;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState)_	{_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1505921975;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState)_	{_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1505984004;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState)_	{_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1506005238;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState)_	{_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1506346199;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState)_	{_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1506510152;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState)_	{_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1507284174;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState)_	{_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1507673791;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState)_	{_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1507738083;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState)_	{_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1508840168;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState)_	{_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1510061826;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState)_	{_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1510699852;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1511543029;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1511975541;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1512136929;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1512567555;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState)_	{_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1513261475;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1513706333;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1514829582;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1516197717;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1516368003;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1516641064;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1516797761;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1516896219;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1517300523;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1517425569;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1517911296;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1517920262;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1518093789;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1518194413;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1518393108;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1518522104;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1518524281;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1518531558;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1518532391;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1518534881;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1518539372;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1518606541;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1518689135;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1518716619;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1518718788;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1519299413;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1519320257;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1519390630;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1519408304;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1519931395;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1519999896;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1521033687;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1521049936;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1521224209;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1521641386;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1521810529;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1521816200;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1521816389;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1521817317;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1522130448;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1522136713;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1522230836;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1522849636;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1525374816;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1525934187;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1526300085;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1526311855;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1526561054;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1526997218;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1527029265;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1527094227;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1529603022;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1529915670;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1530791303;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1532289479;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1532293098;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1533374562;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1534937274;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1536826537;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1538403115;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1538764056;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1538864611;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1542043300;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1542304303;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1543229263;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1544094547;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1547809055;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1547809099;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1547809385;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1548086094;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1548172161;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1548172454;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1548679824;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1549036717;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1549381698;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1549533702;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1549965236;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1549983516;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1550366933;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1550405950;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @Override 	public CompletableFuture<Acknowledge> updateTaskExecutionState( 			final TaskExecutionState taskExecutionState);1550572312;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@Override_	public CompletableFuture<Acknowledge> updateTaskExecutionState(_			final TaskExecutionState taskExecutionState) {_		checkNotNull(taskExecutionState, "taskExecutionState")___		if (executionGraph.updateState(taskExecutionState)) {_			return CompletableFuture.completedFuture(Acknowledge.get())__		} else {_			return FutureUtils.completedExceptionally(_				new ExecutionGraphException("The execution attempt " +_					taskExecutionState.getID() + " was not found."))__		}_	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;override,public,completable,future,acknowledge,update,task,execution,state,final,task,execution,state,task,execution,state,check,not,null,task,execution,state,task,execution,state,if,execution,graph,update,state,task,execution,state,return,completable,future,completed,future,acknowledge,get,else,return,future,utils,completed,exceptionally,new,execution,graph,exception,the,execution,attempt,task,execution,state,get,id,was,not,found
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState(TaskExecutionState taskExecutionState);1472481329;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(TaskExecutionState taskExecutionState) {_		System.out.println("TaskExecutionState: " + taskExecutionState)__		return Acknowledge.get()__	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,task,execution,state,task,execution,state,system,out,println,task,execution,state,task,execution,state,return,acknowledge,get
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState(TaskExecutionState taskExecutionState);1473307213;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(TaskExecutionState taskExecutionState) {_		System.out.println("TaskExecutionState: " + taskExecutionState)__		return Acknowledge.get()__	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,task,execution,state,task,execution,state,system,out,println,task,execution,state,task,execution,state,return,acknowledge,get
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState(TaskExecutionState taskExecutionState);1474453995;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(TaskExecutionState taskExecutionState) {_		System.out.println("TaskExecutionState: " + taskExecutionState)__		return Acknowledge.get()__	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,task,execution,state,task,execution,state,system,out,println,task,execution,state,task,execution,state,return,acknowledge,get
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState(TaskExecutionState taskExecutionState);1474471581;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(TaskExecutionState taskExecutionState) {_		System.out.println("TaskExecutionState: " + taskExecutionState)__		return Acknowledge.get()__	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,task,execution,state,task,execution,state,system,out,println,task,execution,state,task,execution,state,return,acknowledge,get
JobMaster -> @RpcMethod 	public Acknowledge updateTaskExecutionState(TaskExecutionState taskExecutionState);1475110587;Updates the task execution state for a given task.__@param taskExecutionState New task execution state for a given task_@return Acknowledge the task execution state update;@RpcMethod_	public Acknowledge updateTaskExecutionState(TaskExecutionState taskExecutionState) {_		System.out.println("TaskExecutionState: " + taskExecutionState)__		return Acknowledge.get()__	};updates,the,task,execution,state,for,a,given,task,param,task,execution,state,new,task,execution,state,for,a,given,task,return,acknowledge,the,task,execution,state,update;rpc,method,public,acknowledge,update,task,execution,state,task,execution,state,task,execution,state,system,out,println,task,execution,state,task,execution,state,return,acknowledge,get
JobMaster -> public void start(final UUID leaderSessionID) throws Exception;1476714136;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) throws Exception {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {_			super.start()___			slotPool.setJobManagerLeaderId(leaderSessionID)__			log.info("Starting JobManager for job {} ({})", jobGraph.getName(), jobGraph.getJobID())__			getSelf().startJobExecution()__		} else {_			log.warn("Job already started with leaderId {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,throws,exception,if,compare,and,set,this,null,leader,session,id,super,start,slot,pool,set,job,manager,leader,id,leader,session,id,log,info,starting,job,manager,for,job,job,graph,get,name,job,graph,get,job,id,get,self,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> public void start(final UUID leaderSessionID) throws Exception;1476728818;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) throws Exception {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {__			_			slotPool.setJobManagerLeaderId(leaderSessionID)___			_			super.start()___			log.info("JobManager started as leader {} for job {}", leaderSessionID, jobGraph.getJobID())__			getSelf().startJobExecution()__		}_		else {_			log.warn("Job already started with leader ID {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,throws,exception,if,compare,and,set,this,null,leader,session,id,slot,pool,set,job,manager,leader,id,leader,session,id,super,start,log,info,job,manager,started,as,leader,for,job,leader,session,id,job,graph,get,job,id,get,self,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> public void start(final UUID leaderSessionID) throws Exception;1476806580;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) throws Exception {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {_			super.start()___			slotPool.setJobManagerLeaderId(leaderSessionID)__			log.info("Starting JobManager for job {} ({})", jobGraph.getName(), jobGraph.getJobID())__			getSelf().startJobExecution()__		} else {_			log.warn("Job already started with leaderId {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,throws,exception,if,compare,and,set,this,null,leader,session,id,super,start,slot,pool,set,job,manager,leader,id,leader,session,id,log,info,starting,job,manager,for,job,job,graph,get,name,job,graph,get,job,id,get,self,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> public void start(final UUID leaderSessionID) throws Exception;1477061494;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) throws Exception {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {_			_			super.start()___			log.info("JobManager started as leader {} for job {}", leaderSessionID, jobGraph.getJobID())__			getSelf().startJobExecution()__		}_		else {_			log.warn("Job already started with leader ID {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,throws,exception,if,compare,and,set,this,null,leader,session,id,super,start,log,info,job,manager,started,as,leader,for,job,leader,session,id,job,graph,get,job,id,get,self,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> public void start(final UUID leaderSessionID) throws Exception;1477965803;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) throws Exception {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {_			_			super.start()___			log.info("JobManager started as leader {} for job {}", leaderSessionID, jobGraph.getJobID())__			getSelf().startJobExecution()__		}_		else {_			log.warn("Job already started with leader ID {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,throws,exception,if,compare,and,set,this,null,leader,session,id,super,start,log,info,job,manager,started,as,leader,for,job,leader,session,id,job,graph,get,job,id,get,self,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> public void start(final UUID leaderSessionID) throws Exception;1484737699;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) throws Exception {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {_			_			super.start()___			heartbeatManager.start(new HeartbeatListener<Void, Void>() {_				@Override_				public void notifyHeartbeatTimeout(ResourceID resourceID) {_					log.info("Notify heartbeat timeout with task manager {}", resourceID)__					heartbeatManager.unmonitorTarget(resourceID)___					getSelf().disconnectTaskManager(resourceID)__				}__				@Override_				public void reportPayload(ResourceID resourceID, Void payload) {_					_				}__				@Override_				public Future<Void> retrievePayload() {_					_					return null__				}_			})___			log.info("JobManager started as leader {} for job {}", leaderSessionID, jobGraph.getJobID())__			getSelf().startJobExecution()__		}_		else {_			log.warn("Job already started with leader ID {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,throws,exception,if,compare,and,set,this,null,leader,session,id,super,start,heartbeat,manager,start,new,heartbeat,listener,void,void,override,public,void,notify,heartbeat,timeout,resource,id,resource,id,log,info,notify,heartbeat,timeout,with,task,manager,resource,id,heartbeat,manager,unmonitor,target,resource,id,get,self,disconnect,task,manager,resource,id,override,public,void,report,payload,resource,id,resource,id,void,payload,override,public,future,void,retrieve,payload,return,null,log,info,job,manager,started,as,leader,for,job,leader,session,id,job,graph,get,job,id,get,self,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> public void start(final UUID leaderSessionID) throws Exception;1486583506;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) throws Exception {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {_			_			super.start()___			log.info("JobManager started as leader {} for job {}", leaderSessionID, jobGraph.getJobID())__			getSelf().startJobExecution()__		}_		else {_			log.warn("Job already started with leader ID {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,throws,exception,if,compare,and,set,this,null,leader,session,id,super,start,log,info,job,manager,started,as,leader,for,job,leader,session,id,job,graph,get,job,id,get,self,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> public void start(final UUID leaderSessionID) throws Exception;1486637985;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) throws Exception {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {_			_			super.start()___			log.info("JobManager started as leader {} for job {}", leaderSessionID, jobGraph.getJobID())__			getSelf().startJobExecution()__		}_		else {_			log.warn("Job already started with leader ID {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,throws,exception,if,compare,and,set,this,null,leader,session,id,super,start,log,info,job,manager,started,as,leader,for,job,leader,session,id,job,graph,get,job,id,get,self,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> public void start(final UUID leaderSessionID) throws Exception;1487177560;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) throws Exception {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {_			_			super.start()___			log.info("JobManager started as leader {} for job {}", leaderSessionID, jobGraph.getJobID())__			getSelf().startJobExecution()__		}_		else {_			log.warn("Job already started with leader ID {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,throws,exception,if,compare,and,set,this,null,leader,session,id,super,start,log,info,job,manager,started,as,leader,for,job,leader,session,id,job,graph,get,job,id,get,self,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> public void start(final UUID leaderSessionID) throws Exception;1488291647;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) throws Exception {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {_			_			super.start()___			log.info("JobManager started as leader {} for job {}", leaderSessionID, jobGraph.getJobID())__			getSelf().startJobExecution()__		}_		else {_			log.warn("Job already started with leader ID {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,throws,exception,if,compare,and,set,this,null,leader,session,id,super,start,log,info,job,manager,started,as,leader,for,job,leader,session,id,job,graph,get,job,id,get,self,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> public void start(final UUID leaderSessionID) throws Exception;1488923142;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) throws Exception {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {_			_			super.start()___			log.info("JobManager started as leader {} for job {}", leaderSessionID, jobGraph.getJobID())__			getSelf().startJobExecution()__		}_		else {_			log.warn("Job already started with leader ID {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,throws,exception,if,compare,and,set,this,null,leader,session,id,super,start,log,info,job,manager,started,as,leader,for,job,leader,session,id,job,graph,get,job,id,get,self,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> public void start(final UUID leaderSessionID) throws Exception;1490105415;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) throws Exception {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {_			_			super.start()___			log.info("JobManager started as leader {} for job {}", leaderSessionID, jobGraph.getJobID())__			getSelf().startJobExecution()__		}_		else {_			log.warn("Job already started with leader ID {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,throws,exception,if,compare,and,set,this,null,leader,session,id,super,start,log,info,job,manager,started,as,leader,for,job,leader,session,id,job,graph,get,job,id,get,self,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> public void start(final UUID leaderSessionID) throws Exception;1490120014;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) throws Exception {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {_			_			super.start()___			log.info("JobManager started as leader {} for job {}", leaderSessionID, jobGraph.getJobID())__			getSelf().startJobExecution()__		}_		else {_			log.warn("Job already started with leader ID {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,throws,exception,if,compare,and,set,this,null,leader,session,id,super,start,log,info,job,manager,started,as,leader,for,job,leader,session,id,job,graph,get,job,id,get,self,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> public void start(final UUID leaderSessionID) throws Exception;1490166753;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) throws Exception {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {_			_			super.start()___			log.info("JobManager started as leader {} for job {}", leaderSessionID, jobGraph.getJobID())__			getSelf().startJobExecution()__		}_		else {_			log.warn("Job already started with leader ID {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,throws,exception,if,compare,and,set,this,null,leader,session,id,super,start,log,info,job,manager,started,as,leader,for,job,leader,session,id,job,graph,get,job,id,get,self,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> public void start(final UUID leaderSessionID) throws Exception;1490170142;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) throws Exception {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {_			_			super.start()___			log.info("JobManager started as leader {} for job {}", leaderSessionID, jobGraph.getJobID())__			getSelf().startJobExecution()__		}_		else {_			log.warn("Job already started with leader ID {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,throws,exception,if,compare,and,set,this,null,leader,session,id,super,start,log,info,job,manager,started,as,leader,for,job,leader,session,id,job,graph,get,job,id,get,self,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> public void start(final UUID leaderSessionID) throws Exception;1490180625;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) throws Exception {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {_			_			super.start()___			log.info("JobManager started as leader {} for job {}", leaderSessionID, jobGraph.getJobID())__			getSelf().startJobExecution()__		}_		else {_			log.warn("Job already started with leader ID {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,throws,exception,if,compare,and,set,this,null,leader,session,id,super,start,log,info,job,manager,started,as,leader,for,job,leader,session,id,job,graph,get,job,id,get,self,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> public void start(final UUID leaderSessionID) throws Exception;1490805029;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) throws Exception {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {_			_			super.start()___			log.info("JobManager started as leader {} for job {}", leaderSessionID, jobGraph.getJobID())__			getSelf().startJobExecution()__		}_		else {_			log.warn("Job already started with leader ID {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,throws,exception,if,compare,and,set,this,null,leader,session,id,super,start,log,info,job,manager,started,as,leader,for,job,leader,session,id,job,graph,get,job,id,get,self,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> public void start(final UUID leaderSessionID) throws Exception;1498493279;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) throws Exception {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {_			_			super.start()___			log.info("JobManager started as leader {} for job {}", leaderSessionID, jobGraph.getJobID())__			selfGateway.startJobExecution()__		}_		else {_			log.warn("Job already started with leader ID {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,throws,exception,if,compare,and,set,this,null,leader,session,id,super,start,log,info,job,manager,started,as,leader,for,job,leader,session,id,job,graph,get,job,id,self,gateway,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> public void start(final UUID leaderSessionID) throws Exception;1498580984;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) throws Exception {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {_			_			super.start()___			log.info("JobManager started as leader {} for job {}", leaderSessionID, jobGraph.getJobID())__			selfGateway.startJobExecution()__		}_		else {_			log.warn("Job already started with leader ID {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,throws,exception,if,compare,and,set,this,null,leader,session,id,super,start,log,info,job,manager,started,as,leader,for,job,leader,session,id,job,graph,get,job,id,self,gateway,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> public void start(final UUID leaderSessionID) throws Exception;1500977056;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) throws Exception {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {_			_			super.start()___			log.info("JobManager started as leader {} for job {}", leaderSessionID, jobGraph.getJobID())__			selfGateway.startJobExecution()__		}_		else {_			log.warn("Job already started with leader ID {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,throws,exception,if,compare,and,set,this,null,leader,session,id,super,start,log,info,job,manager,started,as,leader,for,job,leader,session,id,job,graph,get,job,id,self,gateway,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> public void start(final UUID leaderSessionID) throws Exception;1501251235;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) throws Exception {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {_			_			super.start()___			log.info("JobManager started as leader {} for job {}", leaderSessionID, jobGraph.getJobID())__			getSelf().startJobExecution()__		}_		else {_			log.warn("Job already started with leader ID {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,throws,exception,if,compare,and,set,this,null,leader,session,id,super,start,log,info,job,manager,started,as,leader,for,job,leader,session,id,job,graph,get,job,id,get,self,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> public void start(final UUID leaderSessionID) throws Exception;1501519642;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) throws Exception {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {_			_			super.start()___			log.info("JobManager started as leader {} for job {}", leaderSessionID, jobGraph.getJobID())__			getSelf().startJobExecution()__		}_		else {_			log.warn("Job already started with leader ID {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,throws,exception,if,compare,and,set,this,null,leader,session,id,super,start,log,info,job,manager,started,as,leader,for,job,leader,session,id,job,graph,get,job,id,get,self,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> public void start(final UUID leaderSessionID) throws Exception;1501524690;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) throws Exception {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {_			_			super.start()___			log.info("JobManager started as leader {} for job {}", leaderSessionID, jobGraph.getJobID())__			getSelf().startJobExecution()__		}_		else {_			log.warn("Job already started with leader ID {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,throws,exception,if,compare,and,set,this,null,leader,session,id,super,start,log,info,job,manager,started,as,leader,for,job,leader,session,id,job,graph,get,job,id,get,self,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> public void start(final UUID leaderSessionID) throws Exception;1501580028;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) throws Exception {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {_			_			super.start()___			log.info("JobManager started as leader {} for job {}", leaderSessionID, jobGraph.getJobID())__			getSelf().startJobExecution()__		}_		else {_			log.warn("Job already started with leader ID {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,throws,exception,if,compare,and,set,this,null,leader,session,id,super,start,log,info,job,manager,started,as,leader,for,job,leader,session,id,job,graph,get,job,id,get,self,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> public void start(final UUID leaderSessionID) throws Exception;1502035001;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) throws Exception {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {_			_			super.start()___			log.info("JobManager started as leader {} for job {}", leaderSessionID, jobGraph.getJobID())__			getSelf().startJobExecution()__		}_		else {_			log.warn("Job already started with leader ID {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,throws,exception,if,compare,and,set,this,null,leader,session,id,super,start,log,info,job,manager,started,as,leader,for,job,leader,session,id,job,graph,get,job,id,get,self,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> public void start(final UUID leaderSessionID) throws Exception;1502196227;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) throws Exception {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {_			_			super.start()___			log.info("JobManager started as leader {} for job {}", leaderSessionID, jobGraph.getJobID())__			selfGateway.startJobExecution()__		}_		else {_			log.warn("Job already started with leader ID {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,throws,exception,if,compare,and,set,this,null,leader,session,id,super,start,log,info,job,manager,started,as,leader,for,job,leader,session,id,job,graph,get,job,id,self,gateway,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> public void start(final UUID leaderSessionID) throws Exception;1502714913;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) throws Exception {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {_			_			super.start()___			log.info("JobManager started as leader {} for job {}", leaderSessionID, jobGraph.getJobID())__			runAsync(this::startJobExecution)__		}_		else {_			log.warn("Job already started with leader ID {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,throws,exception,if,compare,and,set,this,null,leader,session,id,super,start,log,info,job,manager,started,as,leader,for,job,leader,session,id,job,graph,get,job,id,run,async,this,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> public void start(final UUID leaderSessionID) throws Exception;1503412385;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) throws Exception {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {_			_			super.start()___			log.info("JobManager started as leader {} for job {}", leaderSessionID, jobGraph.getJobID())__			runAsync(this::startJobExecution)__		}_		else {_			log.warn("Job already started with leader ID {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,throws,exception,if,compare,and,set,this,null,leader,session,id,super,start,log,info,job,manager,started,as,leader,for,job,leader,session,id,job,graph,get,job,id,run,async,this,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> public void start(final UUID leaderSessionID) throws Exception;1503581387;Start the rpc service and begin to run the job.__@param leaderSessionID The necessary leader id for running the job.;public void start(final UUID leaderSessionID) throws Exception {_		if (LEADER_ID_UPDATER.compareAndSet(this, null, leaderSessionID)) {_			_			super.start()___			log.info("JobManager started as leader {} for job {}", leaderSessionID, jobGraph.getJobID())__			runAsync(this::startJobExecution)__		}_		else {_			log.warn("Job already started with leader ID {}, ignoring this start request.", leaderSessionID)__		}_	};start,the,rpc,service,and,begin,to,run,the,job,param,leader,session,id,the,necessary,leader,id,for,running,the,job;public,void,start,final,uuid,leader,session,id,throws,exception,if,compare,and,set,this,null,leader,session,id,super,start,log,info,job,manager,started,as,leader,for,job,leader,session,id,job,graph,get,job,id,run,async,this,start,job,execution,else,log,warn,job,already,started,with,leader,id,ignoring,this,start,request,leader,session,id
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1519299413;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1519320257;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1519390630;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1519408304;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1519931395;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1519999896;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1521033687;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1521049936;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1521224209;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1521641386;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1521810529;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1521816200;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1521816389;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1521817317;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1522130448;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1522136713;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1522230836;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1522849636;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1525374816;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1525934187;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1526300085;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1526311855;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1526561054;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1526997218;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1527029265;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1527094227;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1529603022;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1529915670;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1530791303;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1532289479;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1532293098;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1533374562;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1534937274;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1536826537;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1538403115;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1538764056;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1538864611;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1542043300;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1542304303;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1543229263;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1544094547;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1547809055;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1547809099;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1547809385;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1548086094;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1548172161;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1548172454;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1548679824;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1549036717;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1549381698;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1549533702;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1549965236;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1549983516;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1550366933;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1550405950;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception;1550572312;Tries to restore the given {@link ExecutionGraph} from the provided {@link SavepointRestoreSettings}.__@param executionGraphToRestore {@link ExecutionGraph} which is supposed to be restored_@param savepointRestoreSettings {@link SavepointRestoreSettings} containing information about the savepoint to restore from_@throws Exception if the {@link ExecutionGraph} could not be restored;private void tryRestoreExecutionGraphFromSavepoint(ExecutionGraph executionGraphToRestore, SavepointRestoreSettings savepointRestoreSettings) throws Exception {_		if (savepointRestoreSettings.restoreSavepoint()) {_			final CheckpointCoordinator checkpointCoordinator = executionGraphToRestore.getCheckpointCoordinator()__			if (checkpointCoordinator != null) {_				checkpointCoordinator.restoreSavepoint(_					savepointRestoreSettings.getRestorePath(),_					savepointRestoreSettings.allowNonRestoredState(),_					executionGraphToRestore.getAllVertices(),_					userCodeLoader)__			}_		}_	};tries,to,restore,the,given,link,execution,graph,from,the,provided,link,savepoint,restore,settings,param,execution,graph,to,restore,link,execution,graph,which,is,supposed,to,be,restored,param,savepoint,restore,settings,link,savepoint,restore,settings,containing,information,about,the,savepoint,to,restore,from,throws,exception,if,the,link,execution,graph,could,not,be,restored;private,void,try,restore,execution,graph,from,savepoint,execution,graph,execution,graph,to,restore,savepoint,restore,settings,savepoint,restore,settings,throws,exception,if,savepoint,restore,settings,restore,savepoint,final,checkpoint,coordinator,checkpoint,coordinator,execution,graph,to,restore,get,checkpoint,coordinator,if,checkpoint,coordinator,null,checkpoint,coordinator,restore,savepoint,savepoint,restore,settings,get,restore,path,savepoint,restore,settings,allow,non,restored,state,execution,graph,to,restore,get,all,vertices,user,code,loader
JobMaster -> private void scheduleExecutionGraph();1518534881;Schedules the execution of the current {@link ExecutionGraph}.;private void scheduleExecutionGraph() {_		try {_			executionGraph.scheduleForExecution()__		}_		catch (Throwable t) {_			executionGraph.failGlobal(t)__		}_	};schedules,the,execution,of,the,current,link,execution,graph;private,void,schedule,execution,graph,try,execution,graph,schedule,for,execution,catch,throwable,t,execution,graph,fail,global,t
JobMaster -> private void scheduleExecutionGraph();1518539372;Schedules the execution of the current {@link ExecutionGraph}.;private void scheduleExecutionGraph() {_		try {_			executionGraph.scheduleForExecution()__		}_		catch (Throwable t) {_			executionGraph.failGlobal(t)__		}_	};schedules,the,execution,of,the,current,link,execution,graph;private,void,schedule,execution,graph,try,execution,graph,schedule,for,execution,catch,throwable,t,execution,graph,fail,global,t
JobMaster -> private void scheduleExecutionGraph();1518716619;Schedules the execution of the current {@link ExecutionGraph}.;private void scheduleExecutionGraph() {_		try {_			executionGraph.scheduleForExecution()__		}_		catch (Throwable t) {_			executionGraph.failGlobal(t)__		}_	};schedules,the,execution,of,the,current,link,execution,graph;private,void,schedule,execution,graph,try,execution,graph,schedule,for,execution,catch,throwable,t,execution,graph,fail,global,t
JobMaster -> private void scheduleExecutionGraph();1518718788;Schedules the execution of the current {@link ExecutionGraph}.;private void scheduleExecutionGraph() {_		try {_			executionGraph.scheduleForExecution()__		}_		catch (Throwable t) {_			executionGraph.failGlobal(t)__		}_	};schedules,the,execution,of,the,current,link,execution,graph;private,void,schedule,execution,graph,try,execution,graph,schedule,for,execution,catch,throwable,t,execution,graph,fail,global,t
JobMaster -> private void scheduleExecutionGraph();1519299413;Schedules the execution of the current {@link ExecutionGraph}.;private void scheduleExecutionGraph() {_		try {_			executionGraph.scheduleForExecution()__		}_		catch (Throwable t) {_			executionGraph.failGlobal(t)__		}_	};schedules,the,execution,of,the,current,link,execution,graph;private,void,schedule,execution,graph,try,execution,graph,schedule,for,execution,catch,throwable,t,execution,graph,fail,global,t
JobMaster -> private void scheduleExecutionGraph();1519320257;Schedules the execution of the current {@link ExecutionGraph}.;private void scheduleExecutionGraph() {_		try {_			executionGraph.scheduleForExecution()__		}_		catch (Throwable t) {_			executionGraph.failGlobal(t)__		}_	};schedules,the,execution,of,the,current,link,execution,graph;private,void,schedule,execution,graph,try,execution,graph,schedule,for,execution,catch,throwable,t,execution,graph,fail,global,t
JobMaster -> private void scheduleExecutionGraph();1519390630;Schedules the execution of the current {@link ExecutionGraph}.;private void scheduleExecutionGraph() {_		try {_			executionGraph.scheduleForExecution()__		}_		catch (Throwable t) {_			executionGraph.failGlobal(t)__		}_	};schedules,the,execution,of,the,current,link,execution,graph;private,void,schedule,execution,graph,try,execution,graph,schedule,for,execution,catch,throwable,t,execution,graph,fail,global,t
JobMaster -> private void scheduleExecutionGraph();1519408304;Schedules the execution of the current {@link ExecutionGraph}.;private void scheduleExecutionGraph() {_		try {_			executionGraph.scheduleForExecution()__		}_		catch (Throwable t) {_			executionGraph.failGlobal(t)__		}_	};schedules,the,execution,of,the,current,link,execution,graph;private,void,schedule,execution,graph,try,execution,graph,schedule,for,execution,catch,throwable,t,execution,graph,fail,global,t
JobMaster -> private void scheduleExecutionGraph();1519931395;Schedules the execution of the current {@link ExecutionGraph}.;private void scheduleExecutionGraph() {_		try {_			executionGraph.scheduleForExecution()__		}_		catch (Throwable t) {_			executionGraph.failGlobal(t)__		}_	};schedules,the,execution,of,the,current,link,execution,graph;private,void,schedule,execution,graph,try,execution,graph,schedule,for,execution,catch,throwable,t,execution,graph,fail,global,t
JobMaster -> private void scheduleExecutionGraph();1519999896;Schedules the execution of the current {@link ExecutionGraph}.;private void scheduleExecutionGraph() {_		try {_			executionGraph.scheduleForExecution()__		}_		catch (Throwable t) {_			executionGraph.failGlobal(t)__		}_	};schedules,the,execution,of,the,current,link,execution,graph;private,void,schedule,execution,graph,try,execution,graph,schedule,for,execution,catch,throwable,t,execution,graph,fail,global,t
JobMaster -> private void scheduleExecutionGraph();1521033687;Schedules the execution of the current {@link ExecutionGraph}.;private void scheduleExecutionGraph() {_		try {_			executionGraph.scheduleForExecution()__		}_		catch (Throwable t) {_			executionGraph.failGlobal(t)__		}_	};schedules,the,execution,of,the,current,link,execution,graph;private,void,schedule,execution,graph,try,execution,graph,schedule,for,execution,catch,throwable,t,execution,graph,fail,global,t
JobMaster -> private void scheduleExecutionGraph();1521049936;Schedules the execution of the current {@link ExecutionGraph}.;private void scheduleExecutionGraph() {_		try {_			executionGraph.scheduleForExecution()__		}_		catch (Throwable t) {_			executionGraph.failGlobal(t)__		}_	};schedules,the,execution,of,the,current,link,execution,graph;private,void,schedule,execution,graph,try,execution,graph,schedule,for,execution,catch,throwable,t,execution,graph,fail,global,t
JobMaster -> private void scheduleExecutionGraph();1521224209;Schedules the execution of the current {@link ExecutionGraph}.;private void scheduleExecutionGraph() {_		try {_			executionGraph.scheduleForExecution()__		}_		catch (Throwable t) {_			executionGraph.failGlobal(t)__		}_	};schedules,the,execution,of,the,current,link,execution,graph;private,void,schedule,execution,graph,try,execution,graph,schedule,for,execution,catch,throwable,t,execution,graph,fail,global,t
JobMaster -> private void scheduleExecutionGraph();1521641386;Schedules the execution of the current {@link ExecutionGraph}.;private void scheduleExecutionGraph() {_		try {_			executionGraph.scheduleForExecution()__		}_		catch (Throwable t) {_			executionGraph.failGlobal(t)__		}_	};schedules,the,execution,of,the,current,link,execution,graph;private,void,schedule,execution,graph,try,execution,graph,schedule,for,execution,catch,throwable,t,execution,graph,fail,global,t
JobMaster -> private void scheduleExecutionGraph();1521810529;Schedules the execution of the current {@link ExecutionGraph}.;private void scheduleExecutionGraph() {_		try {_			executionGraph.scheduleForExecution()__		}_		catch (Throwable t) {_			executionGraph.failGlobal(t)__		}_	};schedules,the,execution,of,the,current,link,execution,graph;private,void,schedule,execution,graph,try,execution,graph,schedule,for,execution,catch,throwable,t,execution,graph,fail,global,t
JobMaster -> private void suspendExecution(final Throwable cause);1502714913;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		leaderSessionID = null___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		stop()___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,leader,session,id,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,stop,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause
JobMaster -> private void suspendExecution(final Throwable cause);1503412385;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		leaderSessionID = null___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		stop()___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,leader,session,id,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,stop,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause
JobMaster -> private void suspendExecution(final Throwable cause);1503581387;Suspending job, all the running tasks will be cancelled, and communication with other components_will be disposed.__<p>Mostly job is suspended because of the leadership has been revoked, one can be restart this job by_calling the {@link #start(UUID)} method once we take the leadership back again.__@param cause The reason of why this job been suspended.;private void suspendExecution(final Throwable cause) {_		if (leaderSessionID == null) {_			log.debug("Job has already been suspended or shutdown.")__			return__		}__		_		leaderSessionID = null___		try {_			resourceManagerLeaderRetriever.stop()__		} catch (Throwable t) {_			log.warn("Failed to stop resource manager leader retriever when suspending.", t)__		}__		_		executionGraph.suspend(cause)___		_		stop()___		_		slotPoolGateway.suspend()___		_		closeResourceManagerConnection(new Exception("Execution was suspended.", cause))__	};suspending,job,all,the,running,tasks,will,be,cancelled,and,communication,with,other,components,will,be,disposed,p,mostly,job,is,suspended,because,of,the,leadership,has,been,revoked,one,can,be,restart,this,job,by,calling,the,link,start,uuid,method,once,we,take,the,leadership,back,again,param,cause,the,reason,of,why,this,job,been,suspended;private,void,suspend,execution,final,throwable,cause,if,leader,session,id,null,log,debug,job,has,already,been,suspended,or,shutdown,return,leader,session,id,null,try,resource,manager,leader,retriever,stop,catch,throwable,t,log,warn,failed,to,stop,resource,manager,leader,retriever,when,suspending,t,execution,graph,suspend,cause,stop,slot,pool,gateway,suspend,close,resource,manager,connection,new,exception,execution,was,suspended,cause
