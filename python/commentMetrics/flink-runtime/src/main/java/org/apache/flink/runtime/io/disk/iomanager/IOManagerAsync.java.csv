# id;timestamp;commentText;codeText;commentWords;codeWords
IOManagerAsync -> WriterThread -> protected void shutdown();1415702894;Shuts the thread down. This operation does not wait for all pending requests to be served, halts the thread_immediately. All buffers of pending requests are handed back to their channel writers and an exception is_reported to them, declaring their request queue as closed.;protected void shutdown() {_			synchronized (this) {_				if (alive) {_					alive = false__					requestQueue.close()__					interrupt()__				}__				try {_					join(1000)__				}_				catch (InterruptedException e) {}_				_				_				IOException ioex = new IOException("IO-Manager has been closed.")__					_				while (!this.requestQueue.isEmpty()) {_					WriteRequest request = this.requestQueue.poll()__					if (request != null) {_						try {_							request.requestDone(ioex)__						}_						catch (Throwable t) {_							IOManagerAsync.LOG.error("The handler of the request complete callback threw an exception"_									+ (t.getMessage() == null ? "." : ": " + t.getMessage()), t)__						}_					}_				}_			}_		};shuts,the,thread,down,this,operation,does,not,wait,for,all,pending,requests,to,be,served,halts,the,thread,immediately,all,buffers,of,pending,requests,are,handed,back,to,their,channel,writers,and,an,exception,is,reported,to,them,declaring,their,request,queue,as,closed;protected,void,shutdown,synchronized,this,if,alive,alive,false,request,queue,close,interrupt,try,join,1000,catch,interrupted,exception,e,ioexception,ioex,new,ioexception,io,manager,has,been,closed,while,this,request,queue,is,empty,write,request,request,this,request,queue,poll,if,request,null,try,request,request,done,ioex,catch,throwable,t,iomanager,async,log,error,the,handler,of,the,request,complete,callback,threw,an,exception,t,get,message,null,t,get,message,t
IOManagerAsync -> WriterThread -> protected void shutdown();1421050512;Shuts the thread down. This operation does not wait for all pending requests to be served, halts the thread_immediately. All buffers of pending requests are handed back to their channel writers and an exception is_reported to them, declaring their request queue as closed.;protected void shutdown() {_			synchronized (this) {_				if (alive) {_					alive = false__					requestQueue.close()__					interrupt()__				}__				try {_					join(1000)__				}_				catch (InterruptedException e) {}_				_				_				IOException ioex = new IOException("IO-Manager has been closed.")__					_				while (!this.requestQueue.isEmpty()) {_					WriteRequest request = this.requestQueue.poll()__					if (request != null) {_						try {_							request.requestDone(ioex)__						}_						catch (Throwable t) {_							IOManagerAsync.LOG.error("The handler of the request complete callback threw an exception"_									+ (t.getMessage() == null ? "." : ": " + t.getMessage()), t)__						}_					}_				}_			}_		};shuts,the,thread,down,this,operation,does,not,wait,for,all,pending,requests,to,be,served,halts,the,thread,immediately,all,buffers,of,pending,requests,are,handed,back,to,their,channel,writers,and,an,exception,is,reported,to,them,declaring,their,request,queue,as,closed;protected,void,shutdown,synchronized,this,if,alive,alive,false,request,queue,close,interrupt,try,join,1000,catch,interrupted,exception,e,ioexception,ioex,new,ioexception,io,manager,has,been,closed,while,this,request,queue,is,empty,write,request,request,this,request,queue,poll,if,request,null,try,request,request,done,ioex,catch,throwable,t,iomanager,async,log,error,the,handler,of,the,request,complete,callback,threw,an,exception,t,get,message,null,t,get,message,t
IOManagerAsync -> WriterThread -> protected void shutdown();1421838095;Shuts the thread down. This operation does not wait for all pending requests to be served, halts the thread_immediately. All buffers of pending requests are handed back to their channel writers and an exception is_reported to them, declaring their request queue as closed.;protected void shutdown() {_			synchronized (this) {_				if (alive) {_					alive = false__					requestQueue.close()__					interrupt()__				}__				try {_					join(1000)__				}_				catch (InterruptedException e) {}_				_				_				IOException ioex = new IOException("IO-Manager has been closed.")__					_				while (!this.requestQueue.isEmpty()) {_					WriteRequest request = this.requestQueue.poll()__					if (request != null) {_						try {_							request.requestDone(ioex)__						}_						catch (Throwable t) {_							IOManagerAsync.LOG.error("The handler of the request complete callback threw an exception"_									+ (t.getMessage() == null ? "." : ": " + t.getMessage()), t)__						}_					}_				}_			}_		};shuts,the,thread,down,this,operation,does,not,wait,for,all,pending,requests,to,be,served,halts,the,thread,immediately,all,buffers,of,pending,requests,are,handed,back,to,their,channel,writers,and,an,exception,is,reported,to,them,declaring,their,request,queue,as,closed;protected,void,shutdown,synchronized,this,if,alive,alive,false,request,queue,close,interrupt,try,join,1000,catch,interrupted,exception,e,ioexception,ioex,new,ioexception,io,manager,has,been,closed,while,this,request,queue,is,empty,write,request,request,this,request,queue,poll,if,request,null,try,request,request,done,ioex,catch,throwable,t,iomanager,async,log,error,the,handler,of,the,request,complete,callback,threw,an,exception,t,get,message,null,t,get,message,t
IOManagerAsync -> WriterThread -> protected void shutdown();1424338528;Shuts the thread down. This operation does not wait for all pending requests to be served, halts the thread_immediately. All buffers of pending requests are handed back to their channel writers and an exception is_reported to them, declaring their request queue as closed.;protected void shutdown() {_			synchronized (this) {_				if (alive) {_					alive = false__					requestQueue.close()__					interrupt()__				}__				try {_					join(1000)__				}_				catch (InterruptedException e) {}_				_				_				IOException ioex = new IOException("IO-Manager has been closed.")__					_				while (!this.requestQueue.isEmpty()) {_					WriteRequest request = this.requestQueue.poll()__					if (request != null) {_						try {_							request.requestDone(ioex)__						}_						catch (Throwable t) {_							IOManagerAsync.LOG.error("The handler of the request complete callback threw an exception"_									+ (t.getMessage() == null ? "." : ": " + t.getMessage()), t)__						}_					}_				}_			}_		};shuts,the,thread,down,this,operation,does,not,wait,for,all,pending,requests,to,be,served,halts,the,thread,immediately,all,buffers,of,pending,requests,are,handed,back,to,their,channel,writers,and,an,exception,is,reported,to,them,declaring,their,request,queue,as,closed;protected,void,shutdown,synchronized,this,if,alive,alive,false,request,queue,close,interrupt,try,join,1000,catch,interrupted,exception,e,ioexception,ioex,new,ioexception,io,manager,has,been,closed,while,this,request,queue,is,empty,write,request,request,this,request,queue,poll,if,request,null,try,request,request,done,ioex,catch,throwable,t,iomanager,async,log,error,the,handler,of,the,request,complete,callback,threw,an,exception,t,get,message,null,t,get,message,t
IOManagerAsync -> WriterThread -> protected void shutdown();1426697080;Shuts the thread down. This operation does not wait for all pending requests to be served, halts the thread_immediately. All buffers of pending requests are handed back to their channel writers and an exception is_reported to them, declaring their request queue as closed.;protected void shutdown() {_			synchronized (this) {_				if (alive) {_					alive = false__					requestQueue.close()__					interrupt()__				}__				try {_					join(1000)__				}_				catch (InterruptedException e) {}_				_				_				IOException ioex = new IOException("IO-Manager has been closed.")__					_				while (!this.requestQueue.isEmpty()) {_					WriteRequest request = this.requestQueue.poll()__					if (request != null) {_						try {_							request.requestDone(ioex)__						}_						catch (Throwable t) {_							IOManagerAsync.LOG.error("The handler of the request complete callback threw an exception"_									+ (t.getMessage() == null ? "." : ": " + t.getMessage()), t)__						}_					}_				}_			}_		};shuts,the,thread,down,this,operation,does,not,wait,for,all,pending,requests,to,be,served,halts,the,thread,immediately,all,buffers,of,pending,requests,are,handed,back,to,their,channel,writers,and,an,exception,is,reported,to,them,declaring,their,request,queue,as,closed;protected,void,shutdown,synchronized,this,if,alive,alive,false,request,queue,close,interrupt,try,join,1000,catch,interrupted,exception,e,ioexception,ioex,new,ioexception,io,manager,has,been,closed,while,this,request,queue,is,empty,write,request,request,this,request,queue,poll,if,request,null,try,request,request,done,ioex,catch,throwable,t,iomanager,async,log,error,the,handler,of,the,request,complete,callback,threw,an,exception,t,get,message,null,t,get,message,t
IOManagerAsync -> WriterThread -> protected void shutdown();1427820865;Shuts the thread down. This operation does not wait for all pending requests to be served, halts the thread_immediately. All buffers of pending requests are handed back to their channel writers and an exception is_reported to them, declaring their request queue as closed.;protected void shutdown() {_			synchronized (this) {_				if (alive) {_					alive = false__					requestQueue.close()__					interrupt()__				}__				try {_					join(1000)__				}_				catch (InterruptedException e) {}_				_				_				IOException ioex = new IOException("IO-Manager has been closed.")__					_				while (!this.requestQueue.isEmpty()) {_					WriteRequest request = this.requestQueue.poll()__					if (request != null) {_						try {_							request.requestDone(ioex)__						}_						catch (Throwable t) {_							IOManagerAsync.LOG.error("The handler of the request complete callback threw an exception"_									+ (t.getMessage() == null ? "." : ": " + t.getMessage()), t)__						}_					}_				}_			}_		};shuts,the,thread,down,this,operation,does,not,wait,for,all,pending,requests,to,be,served,halts,the,thread,immediately,all,buffers,of,pending,requests,are,handed,back,to,their,channel,writers,and,an,exception,is,reported,to,them,declaring,their,request,queue,as,closed;protected,void,shutdown,synchronized,this,if,alive,alive,false,request,queue,close,interrupt,try,join,1000,catch,interrupted,exception,e,ioexception,ioex,new,ioexception,io,manager,has,been,closed,while,this,request,queue,is,empty,write,request,request,this,request,queue,poll,if,request,null,try,request,request,done,ioex,catch,throwable,t,iomanager,async,log,error,the,handler,of,the,request,complete,callback,threw,an,exception,t,get,message,null,t,get,message,t
IOManagerAsync -> WriterThread -> protected void shutdown();1441195974;Shuts the thread down. This operation does not wait for all pending requests to be served, halts the thread_immediately. All buffers of pending requests are handed back to their channel writers and an exception is_reported to them, declaring their request queue as closed.;protected void shutdown() {_			synchronized (this) {_				if (alive) {_					alive = false__					requestQueue.close()__					interrupt()__				}__				try {_					join(1000)__				}_				catch (InterruptedException ignored) {}_				_				_				IOException ioex = new IOException("IO-Manager has been closed.")__					_				while (!this.requestQueue.isEmpty()) {_					WriteRequest request = this.requestQueue.poll()__					if (request != null) {_						try {_							request.requestDone(ioex)__						}_						catch (Throwable t) {_							IOManagerAsync.LOG.error("The handler of the request complete callback threw an exception"_									+ (t.getMessage() == null ? "." : ": " + t.getMessage()), t)__						}_					}_				}_			}_		};shuts,the,thread,down,this,operation,does,not,wait,for,all,pending,requests,to,be,served,halts,the,thread,immediately,all,buffers,of,pending,requests,are,handed,back,to,their,channel,writers,and,an,exception,is,reported,to,them,declaring,their,request,queue,as,closed;protected,void,shutdown,synchronized,this,if,alive,alive,false,request,queue,close,interrupt,try,join,1000,catch,interrupted,exception,ignored,ioexception,ioex,new,ioexception,io,manager,has,been,closed,while,this,request,queue,is,empty,write,request,request,this,request,queue,poll,if,request,null,try,request,request,done,ioex,catch,throwable,t,iomanager,async,log,error,the,handler,of,the,request,complete,callback,threw,an,exception,t,get,message,null,t,get,message,t
IOManagerAsync -> WriterThread -> protected void shutdown();1465991918;Shuts the thread down. This operation does not wait for all pending requests to be served, halts the thread_immediately. All buffers of pending requests are handed back to their channel writers and an exception is_reported to them, declaring their request queue as closed.;protected void shutdown() {_			synchronized (this) {_				if (alive) {_					alive = false__					requestQueue.close()__					interrupt()__				}__				try {_					join(1000)__				}_				catch (InterruptedException ignored) {}_				_				_				IOException ioex = new IOException("IO-Manager has been closed.")__					_				while (!this.requestQueue.isEmpty()) {_					WriteRequest request = this.requestQueue.poll()__					if (request != null) {_						try {_							request.requestDone(ioex)__						}_						catch (Throwable t) {_							IOManagerAsync.LOG.error("The handler of the request complete callback threw an exception"_									+ (t.getMessage() == null ? "." : ": " + t.getMessage()), t)__						}_					}_				}_			}_		};shuts,the,thread,down,this,operation,does,not,wait,for,all,pending,requests,to,be,served,halts,the,thread,immediately,all,buffers,of,pending,requests,are,handed,back,to,their,channel,writers,and,an,exception,is,reported,to,them,declaring,their,request,queue,as,closed;protected,void,shutdown,synchronized,this,if,alive,alive,false,request,queue,close,interrupt,try,join,1000,catch,interrupted,exception,ignored,ioexception,ioex,new,ioexception,io,manager,has,been,closed,while,this,request,queue,is,empty,write,request,request,this,request,queue,poll,if,request,null,try,request,request,done,ioex,catch,throwable,t,iomanager,async,log,error,the,handler,of,the,request,complete,callback,threw,an,exception,t,get,message,null,t,get,message,t
IOManagerAsync -> WriterThread -> protected void shutdown();1519567828;Shuts the thread down. This operation does not wait for all pending requests to be served, halts the thread_immediately. All buffers of pending requests are handed back to their channel writers and an exception is_reported to them, declaring their request queue as closed.;protected void shutdown() {_			synchronized (this) {_				if (alive) {_					alive = false__					requestQueue.close()__					interrupt()__				}__				try {_					join(1000)__				}_				catch (InterruptedException ignored) {}_				_				_				IOException ioex = new IOException("IO-Manager has been closed.")__					_				while (!this.requestQueue.isEmpty()) {_					WriteRequest request = this.requestQueue.poll()__					if (request != null) {_						try {_							request.requestDone(ioex)__						}_						catch (Throwable t) {_							IOManagerAsync.LOG.error("The handler of the request complete callback threw an exception"_									+ (t.getMessage() == null ? "." : ": " + t.getMessage()), t)__						}_					}_				}_			}_		};shuts,the,thread,down,this,operation,does,not,wait,for,all,pending,requests,to,be,served,halts,the,thread,immediately,all,buffers,of,pending,requests,are,handed,back,to,their,channel,writers,and,an,exception,is,reported,to,them,declaring,their,request,queue,as,closed;protected,void,shutdown,synchronized,this,if,alive,alive,false,request,queue,close,interrupt,try,join,1000,catch,interrupted,exception,ignored,ioexception,ioex,new,ioexception,io,manager,has,been,closed,while,this,request,queue,is,empty,write,request,request,this,request,queue,poll,if,request,null,try,request,request,done,ioex,catch,throwable,t,iomanager,async,log,error,the,handler,of,the,request,complete,callback,threw,an,exception,t,get,message,null,t,get,message,t
IOManagerAsync -> WriterThread -> protected void shutdown();1550673194;Shuts the thread down. This operation does not wait for all pending requests to be served, halts the thread_immediately. All buffers of pending requests are handed back to their channel writers and an exception is_reported to them, declaring their request queue as closed.;protected void shutdown() {_			synchronized (this) {_				if (alive) {_					alive = false__					requestQueue.close()__					interrupt()__				}__				try {_					join(1000)__				}_				catch (InterruptedException ignored) {}_				_				_				IOException ioex = new IOException("IO-Manager has been closed.")__					_				while (!this.requestQueue.isEmpty()) {_					WriteRequest request = this.requestQueue.poll()__					if (request != null) {_						try {_							request.requestDone(ioex)__						}_						catch (Throwable t) {_							IOManagerAsync.LOG.error("The handler of the request complete callback threw an exception"_									+ (t.getMessage() == null ? "." : ": " + t.getMessage()), t)__						}_					}_				}_			}_		};shuts,the,thread,down,this,operation,does,not,wait,for,all,pending,requests,to,be,served,halts,the,thread,immediately,all,buffers,of,pending,requests,are,handed,back,to,their,channel,writers,and,an,exception,is,reported,to,them,declaring,their,request,queue,as,closed;protected,void,shutdown,synchronized,this,if,alive,alive,false,request,queue,close,interrupt,try,join,1000,catch,interrupted,exception,ignored,ioexception,ioex,new,ioexception,io,manager,has,been,closed,while,this,request,queue,is,empty,write,request,request,this,request,queue,poll,if,request,null,try,request,request,done,ioex,catch,throwable,t,iomanager,async,log,error,the,handler,of,the,request,complete,callback,threw,an,exception,t,get,message,null,t,get,message,t
IOManagerAsync -> public IOManagerAsync();1415702894;Constructs a new asynchronous I/O manger, writing files to the system 's temp directory.;public IOManagerAsync() {_		this(EnvironmentInformation.getTemporaryFileDirectory())__	};constructs,a,new,asynchronous,i,o,manger,writing,files,to,the,system,s,temp,directory;public,iomanager,async,this,environment,information,get,temporary,file,directory
IOManagerAsync -> public IOManagerAsync();1421050512;Constructs a new asynchronous I/O manger, writing files to the system 's temp directory.;public IOManagerAsync() {_		this(EnvironmentInformation.getTemporaryFileDirectory())__	};constructs,a,new,asynchronous,i,o,manger,writing,files,to,the,system,s,temp,directory;public,iomanager,async,this,environment,information,get,temporary,file,directory
IOManagerAsync -> public IOManagerAsync();1421838095;Constructs a new asynchronous I/O manger, writing files to the system 's temp directory.;public IOManagerAsync() {_		this(EnvironmentInformation.getTemporaryFileDirectory())__	};constructs,a,new,asynchronous,i,o,manger,writing,files,to,the,system,s,temp,directory;public,iomanager,async,this,environment,information,get,temporary,file,directory
IOManagerAsync -> public IOManagerAsync();1424338528;Constructs a new asynchronous I/O manger, writing files to the system 's temp directory.;public IOManagerAsync() {_		this(EnvironmentInformation.getTemporaryFileDirectory())__	};constructs,a,new,asynchronous,i,o,manger,writing,files,to,the,system,s,temp,directory;public,iomanager,async,this,environment,information,get,temporary,file,directory
IOManagerAsync -> public IOManagerAsync();1426697080;Constructs a new asynchronous I/O manger, writing files to the system 's temp directory.;public IOManagerAsync() {_		this(EnvironmentInformation.getTemporaryFileDirectory())__	};constructs,a,new,asynchronous,i,o,manger,writing,files,to,the,system,s,temp,directory;public,iomanager,async,this,environment,information,get,temporary,file,directory
IOManagerAsync -> public IOManagerAsync();1427820865;Constructs a new asynchronous I/O manger, writing files to the system 's temp directory.;public IOManagerAsync() {_		this(EnvironmentInformation.getTemporaryFileDirectory())__	};constructs,a,new,asynchronous,i,o,manger,writing,files,to,the,system,s,temp,directory;public,iomanager,async,this,environment,information,get,temporary,file,directory
IOManagerAsync -> public IOManagerAsync();1441195974;Constructs a new asynchronous I/O manger, writing files to the system 's temp directory.;public IOManagerAsync() {_		this(EnvironmentInformation.getTemporaryFileDirectory())__	};constructs,a,new,asynchronous,i,o,manger,writing,files,to,the,system,s,temp,directory;public,iomanager,async,this,environment,information,get,temporary,file,directory
IOManagerAsync -> public IOManagerAsync();1465991918;Constructs a new asynchronous I/O manger, writing files to the system 's temp directory.;public IOManagerAsync() {_		this(EnvironmentInformation.getTemporaryFileDirectory())__	};constructs,a,new,asynchronous,i,o,manger,writing,files,to,the,system,s,temp,directory;public,iomanager,async,this,environment,information,get,temporary,file,directory
IOManagerAsync -> public IOManagerAsync();1519567828;Constructs a new asynchronous I/O manger, writing files to the system 's temp directory.;public IOManagerAsync() {_		this(EnvironmentInformation.getTemporaryFileDirectory())__	};constructs,a,new,asynchronous,i,o,manger,writing,files,to,the,system,s,temp,directory;public,iomanager,async,this,environment,information,get,temporary,file,directory
IOManagerAsync -> public IOManagerAsync();1550673194;Constructs a new asynchronous I/O manager, writing files to the system 's temp directory.;public IOManagerAsync() {_		this(EnvironmentInformation.getTemporaryFileDirectory())__	};constructs,a,new,asynchronous,i,o,manager,writing,files,to,the,system,s,temp,directory;public,iomanager,async,this,environment,information,get,temporary,file,directory
IOManagerAsync -> @Override 	public BlockChannelReader createBlockChannelReader(FileIOChannel.ID channelID, 										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException;1415702894;Creates a block channel reader that reads blocks from the given channel. The reader reads asynchronously,_such that a read request is accepted, carried out at some (close) point in time, and the full segment_is pushed to the given queue.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the full buffers into._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;@Override_	public BlockChannelReader createBlockChannelReader(FileIOChannel.ID channelID,_										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_	{_		Preconditions.checkState(!shutdown, "I/O-Manger is closed.")__		return new AsynchronousBlockReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, returnQueue)__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,reads,asynchronously,such,that,a,read,request,is,accepted,carried,out,at,some,close,point,in,time,and,the,full,segment,is,pushed,to,the,given,queue,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,full,buffers,into,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;override,public,block,channel,reader,create,block,channel,reader,file,iochannel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception,preconditions,check,state,shutdown,i,o,manger,is,closed,return,new,asynchronous,block,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,return,queue
IOManagerAsync -> @Override 	public BlockChannelReader createBlockChannelReader(FileIOChannel.ID channelID, 										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException;1421050512;Creates a block channel reader that reads blocks from the given channel. The reader reads asynchronously,_such that a read request is accepted, carried out at some (close) point in time, and the full segment_is pushed to the given queue.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the full buffers into._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;@Override_	public BlockChannelReader createBlockChannelReader(FileIOChannel.ID channelID,_										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_	{_		checkState(!shutdown, "I/O-Manger is closed.")__		return new AsynchronousBlockReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, returnQueue)__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,reads,asynchronously,such,that,a,read,request,is,accepted,carried,out,at,some,close,point,in,time,and,the,full,segment,is,pushed,to,the,given,queue,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,full,buffers,into,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;override,public,block,channel,reader,create,block,channel,reader,file,iochannel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception,check,state,shutdown,i,o,manger,is,closed,return,new,asynchronous,block,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,return,queue
IOManagerAsync -> @Override 	public BlockChannelReader createBlockChannelReader(FileIOChannel.ID channelID, 										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException;1421838095;Creates a block channel reader that reads blocks from the given channel. The reader reads asynchronously,_such that a read request is accepted, carried out at some (close) point in time, and the full segment_is pushed to the given queue.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the full buffers into._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;@Override_	public BlockChannelReader createBlockChannelReader(FileIOChannel.ID channelID,_										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_	{_		checkState(!shutdown, "I/O-Manger is closed.")__		return new AsynchronousBlockReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, returnQueue)__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,reads,asynchronously,such,that,a,read,request,is,accepted,carried,out,at,some,close,point,in,time,and,the,full,segment,is,pushed,to,the,given,queue,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,full,buffers,into,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;override,public,block,channel,reader,create,block,channel,reader,file,iochannel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception,check,state,shutdown,i,o,manger,is,closed,return,new,asynchronous,block,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,return,queue
IOManagerAsync -> @Override 	public BlockChannelReader createBlockChannelReader(FileIOChannel.ID channelID, 										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException;1424338528;Creates a block channel reader that reads blocks from the given channel. The reader reads asynchronously,_such that a read request is accepted, carried out at some (close) point in time, and the full segment_is pushed to the given queue.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the full buffers into._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;@Override_	public BlockChannelReader createBlockChannelReader(FileIOChannel.ID channelID,_										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_	{_		checkState(!isShutdown.get(), "I/O-Manger is shut down.")__		return new AsynchronousBlockReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, returnQueue)__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,reads,asynchronously,such,that,a,read,request,is,accepted,carried,out,at,some,close,point,in,time,and,the,full,segment,is,pushed,to,the,given,queue,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,full,buffers,into,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;override,public,block,channel,reader,create,block,channel,reader,file,iochannel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception,check,state,is,shutdown,get,i,o,manger,is,shut,down,return,new,asynchronous,block,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,return,queue
IOManagerAsync -> @Override 	public BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID, 										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException;1426697080;Creates a block channel reader that reads blocks from the given channel. The reader reads asynchronously,_such that a read request is accepted, carried out at some (close) point in time, and the full segment_is pushed to the given queue.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the full buffers into._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;@Override_	public BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID,_										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_	{_		checkState(!isShutdown.get(), "I/O-Manger is shut down.")__		return new AsynchronousBlockReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, returnQueue)__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,reads,asynchronously,such,that,a,read,request,is,accepted,carried,out,at,some,close,point,in,time,and,the,full,segment,is,pushed,to,the,given,queue,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,full,buffers,into,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;override,public,block,channel,reader,memory,segment,create,block,channel,reader,file,iochannel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception,check,state,is,shutdown,get,i,o,manger,is,shut,down,return,new,asynchronous,block,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,return,queue
IOManagerAsync -> @Override 	public BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID, 										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException;1427820865;Creates a block channel reader that reads blocks from the given channel. The reader reads asynchronously,_such that a read request is accepted, carried out at some (close) point in time, and the full segment_is pushed to the given queue.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the full buffers into._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;@Override_	public BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID,_										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_	{_		checkState(!isShutdown.get(), "I/O-Manger is shut down.")__		return new AsynchronousBlockReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, returnQueue)__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,reads,asynchronously,such,that,a,read,request,is,accepted,carried,out,at,some,close,point,in,time,and,the,full,segment,is,pushed,to,the,given,queue,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,full,buffers,into,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;override,public,block,channel,reader,memory,segment,create,block,channel,reader,file,iochannel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception,check,state,is,shutdown,get,i,o,manger,is,shut,down,return,new,asynchronous,block,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,return,queue
IOManagerAsync -> @Override 	public BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID, 										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException;1441195974;Creates a block channel reader that reads blocks from the given channel. The reader reads asynchronously,_such that a read request is accepted, carried out at some (close) point in time, and the full segment_is pushed to the given queue.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the full buffers into._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;@Override_	public BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID,_										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_	{_		checkState(!isShutdown.get(), "I/O-Manger is shut down.")__		return new AsynchronousBlockReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, returnQueue)__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,reads,asynchronously,such,that,a,read,request,is,accepted,carried,out,at,some,close,point,in,time,and,the,full,segment,is,pushed,to,the,given,queue,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,full,buffers,into,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;override,public,block,channel,reader,memory,segment,create,block,channel,reader,file,iochannel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception,check,state,is,shutdown,get,i,o,manger,is,shut,down,return,new,asynchronous,block,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,return,queue
IOManagerAsync -> @Override 	public BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID, 										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException;1465991918;Creates a block channel reader that reads blocks from the given channel. The reader reads asynchronously,_such that a read request is accepted, carried out at some (close) point in time, and the full segment_is pushed to the given queue.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the full buffers into._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;@Override_	public BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID,_										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_	{_		checkState(!isShutdown.get(), "I/O-Manger is shut down.")__		return new AsynchronousBlockReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, returnQueue)__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,reads,asynchronously,such,that,a,read,request,is,accepted,carried,out,at,some,close,point,in,time,and,the,full,segment,is,pushed,to,the,given,queue,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,full,buffers,into,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;override,public,block,channel,reader,memory,segment,create,block,channel,reader,file,iochannel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception,check,state,is,shutdown,get,i,o,manger,is,shut,down,return,new,asynchronous,block,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,return,queue
IOManagerAsync -> @Override 	public BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID, 										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException;1519567828;Creates a block channel reader that reads blocks from the given channel. The reader reads asynchronously,_such that a read request is accepted, carried out at some (close) point in time, and the full segment_is pushed to the given queue.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the full buffers into._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;@Override_	public BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID,_										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_	{_		checkState(!isShutdown.get(), "I/O-Manger is shut down.")__		return new AsynchronousBlockReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, returnQueue)__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,reads,asynchronously,such,that,a,read,request,is,accepted,carried,out,at,some,close,point,in,time,and,the,full,segment,is,pushed,to,the,given,queue,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,full,buffers,into,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;override,public,block,channel,reader,memory,segment,create,block,channel,reader,file,iochannel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception,check,state,is,shutdown,get,i,o,manger,is,shut,down,return,new,asynchronous,block,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,return,queue
IOManagerAsync -> @Override 	public BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID, 										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException;1550673194;Creates a block channel reader that reads blocks from the given channel. The reader reads asynchronously,_such that a read request is accepted, carried out at some (close) point in time, and the full segment_is pushed to the given queue.__@param channelID The descriptor for the channel to write to._@param returnQueue The queue to put the full buffers into._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;@Override_	public BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID,_										LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException_	{_		checkState(!isShutdown.get(), "I/O-Manager is shut down.")__		return new AsynchronousBlockReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, returnQueue)__	};creates,a,block,channel,reader,that,reads,blocks,from,the,given,channel,the,reader,reads,asynchronously,such,that,a,read,request,is,accepted,carried,out,at,some,close,point,in,time,and,the,full,segment,is,pushed,to,the,given,queue,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,return,queue,the,queue,to,put,the,full,buffers,into,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;override,public,block,channel,reader,memory,segment,create,block,channel,reader,file,iochannel,id,channel,id,linked,blocking,queue,memory,segment,return,queue,throws,ioexception,check,state,is,shutdown,get,i,o,manager,is,shut,down,return,new,asynchronous,block,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,return,queue
IOManagerAsync -> @Override 	public void shutdown();1415702894;Close method. Shuts down the reader and writer threads immediately, not waiting for their_pending requests to be served. This method waits until the threads have actually ceased their_operation.;@Override_	public void shutdown() {_		synchronized (shutdownLock) {_			if (shutdown) {_				return__			}_			_			shutdown = true__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Shutting down I/O manager.")__			}__			_			__			for (WriterThread wt : writers) {_				try {_					wt.shutdown()__				}_				catch (Throwable t) {_					LOG.error("Error while shutting down IO Manager writer thread.", t)__				}_			}_			for (ReaderThread rt : readers) {_				try {_					rt.shutdown()__				}_				catch (Throwable t) {_					LOG.error("Error while shutting down IO Manager reader thread.", t)__				}_			}_			try {_				for (WriterThread wt : writers) {_					wt.join()__				}_				for (ReaderThread rt : readers) {_					rt.join()__				}_			}_			catch (InterruptedException iex) {}_		}_	};close,method,shuts,down,the,reader,and,writer,threads,immediately,not,waiting,for,their,pending,requests,to,be,served,this,method,waits,until,the,threads,have,actually,ceased,their,operation;override,public,void,shutdown,synchronized,shutdown,lock,if,shutdown,return,shutdown,true,if,log,is,debug,enabled,log,debug,shutting,down,i,o,manager,for,writer,thread,wt,writers,try,wt,shutdown,catch,throwable,t,log,error,error,while,shutting,down,io,manager,writer,thread,t,for,reader,thread,rt,readers,try,rt,shutdown,catch,throwable,t,log,error,error,while,shutting,down,io,manager,reader,thread,t,try,for,writer,thread,wt,writers,wt,join,for,reader,thread,rt,readers,rt,join,catch,interrupted,exception,iex
IOManagerAsync -> @Override 	public void shutdown();1421050512;Close method. Shuts down the reader and writer threads immediately, not waiting for their_pending requests to be served. This method waits until the threads have actually ceased their_operation.;@Override_	public void shutdown() {_		synchronized (shutdownLock) {_			if (shutdown) {_				return__			}_			_			shutdown = true__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Shutting down I/O manager.")__			}__			_			__			for (WriterThread wt : writers) {_				try {_					wt.shutdown()__				}_				catch (Throwable t) {_					LOG.error("Error while shutting down IO Manager writer thread.", t)__				}_			}_			for (ReaderThread rt : readers) {_				try {_					rt.shutdown()__				}_				catch (Throwable t) {_					LOG.error("Error while shutting down IO Manager reader thread.", t)__				}_			}_			try {_				for (WriterThread wt : writers) {_					wt.join()__				}_				for (ReaderThread rt : readers) {_					rt.join()__				}_			}_			catch (InterruptedException iex) {}_		}_	};close,method,shuts,down,the,reader,and,writer,threads,immediately,not,waiting,for,their,pending,requests,to,be,served,this,method,waits,until,the,threads,have,actually,ceased,their,operation;override,public,void,shutdown,synchronized,shutdown,lock,if,shutdown,return,shutdown,true,if,log,is,debug,enabled,log,debug,shutting,down,i,o,manager,for,writer,thread,wt,writers,try,wt,shutdown,catch,throwable,t,log,error,error,while,shutting,down,io,manager,writer,thread,t,for,reader,thread,rt,readers,try,rt,shutdown,catch,throwable,t,log,error,error,while,shutting,down,io,manager,reader,thread,t,try,for,writer,thread,wt,writers,wt,join,for,reader,thread,rt,readers,rt,join,catch,interrupted,exception,iex
IOManagerAsync -> @Override 	public void shutdown();1421838095;Close method. Shuts down the reader and writer threads immediately, not waiting for their_pending requests to be served. This method waits until the threads have actually ceased their_operation.;@Override_	public void shutdown() {_		synchronized (shutdownLock) {_			if (shutdown) {_				return__			}_			_			shutdown = true__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Shutting down I/O manager.")__			}__			_			__			for (WriterThread wt : writers) {_				try {_					wt.shutdown()__				}_				catch (Throwable t) {_					LOG.error("Error while shutting down IO Manager writer thread.", t)__				}_			}_			for (ReaderThread rt : readers) {_				try {_					rt.shutdown()__				}_				catch (Throwable t) {_					LOG.error("Error while shutting down IO Manager reader thread.", t)__				}_			}_			try {_				for (WriterThread wt : writers) {_					wt.join()__				}_				for (ReaderThread rt : readers) {_					rt.join()__				}_			}_			catch (InterruptedException iex) {}_		}_	};close,method,shuts,down,the,reader,and,writer,threads,immediately,not,waiting,for,their,pending,requests,to,be,served,this,method,waits,until,the,threads,have,actually,ceased,their,operation;override,public,void,shutdown,synchronized,shutdown,lock,if,shutdown,return,shutdown,true,if,log,is,debug,enabled,log,debug,shutting,down,i,o,manager,for,writer,thread,wt,writers,try,wt,shutdown,catch,throwable,t,log,error,error,while,shutting,down,io,manager,writer,thread,t,for,reader,thread,rt,readers,try,rt,shutdown,catch,throwable,t,log,error,error,while,shutting,down,io,manager,reader,thread,t,try,for,writer,thread,wt,writers,wt,join,for,reader,thread,rt,readers,rt,join,catch,interrupted,exception,iex
IOManagerAsync -> @Override 	public void shutdown();1424338528;Close method. Shuts down the reader and writer threads immediately, not waiting for their_pending requests to be served. This method waits until the threads have actually ceased their_operation.;@Override_	public void shutdown() {_		_		if (!isShutdown.compareAndSet(false, true)) {_			return__		}__		try {_			if (LOG.isDebugEnabled()) {_				LOG.debug("Shutting down I/O manager.")__			}__			_			__			for (WriterThread wt : writers) {_				try {_					wt.shutdown()__				}_				catch (Throwable t) {_					LOG.error("Error while shutting down IO Manager writer thread.", t)__				}_			}_			for (ReaderThread rt : readers) {_				try {_					rt.shutdown()__				}_				catch (Throwable t) {_					LOG.error("Error while shutting down IO Manager reader thread.", t)__				}_			}_			try {_				for (WriterThread wt : writers) {_					wt.join()__				}_				for (ReaderThread rt : readers) {_					rt.join()__				}_			}_			catch (InterruptedException iex) {_				_			}_		}_		finally {_			_			_			super.shutdown()__		}_	};close,method,shuts,down,the,reader,and,writer,threads,immediately,not,waiting,for,their,pending,requests,to,be,served,this,method,waits,until,the,threads,have,actually,ceased,their,operation;override,public,void,shutdown,if,is,shutdown,compare,and,set,false,true,return,try,if,log,is,debug,enabled,log,debug,shutting,down,i,o,manager,for,writer,thread,wt,writers,try,wt,shutdown,catch,throwable,t,log,error,error,while,shutting,down,io,manager,writer,thread,t,for,reader,thread,rt,readers,try,rt,shutdown,catch,throwable,t,log,error,error,while,shutting,down,io,manager,reader,thread,t,try,for,writer,thread,wt,writers,wt,join,for,reader,thread,rt,readers,rt,join,catch,interrupted,exception,iex,finally,super,shutdown
IOManagerAsync -> @Override 	public void shutdown();1426697080;Close method. Shuts down the reader and writer threads immediately, not waiting for their_pending requests to be served. This method waits until the threads have actually ceased their_operation.;@Override_	public void shutdown() {_		_		if (!isShutdown.compareAndSet(false, true)) {_			return__		}__		try {_			if (LOG.isDebugEnabled()) {_				LOG.debug("Shutting down I/O manager.")__			}__			_			__			for (WriterThread wt : writers) {_				try {_					wt.shutdown()__				}_				catch (Throwable t) {_					LOG.error("Error while shutting down IO Manager writer thread.", t)__				}_			}_			for (ReaderThread rt : readers) {_				try {_					rt.shutdown()__				}_				catch (Throwable t) {_					LOG.error("Error while shutting down IO Manager reader thread.", t)__				}_			}_			try {_				for (WriterThread wt : writers) {_					wt.join()__				}_				for (ReaderThread rt : readers) {_					rt.join()__				}_			}_			catch (InterruptedException iex) {_				_			}_		}_		finally {_			_			_			super.shutdown()__		}_	};close,method,shuts,down,the,reader,and,writer,threads,immediately,not,waiting,for,their,pending,requests,to,be,served,this,method,waits,until,the,threads,have,actually,ceased,their,operation;override,public,void,shutdown,if,is,shutdown,compare,and,set,false,true,return,try,if,log,is,debug,enabled,log,debug,shutting,down,i,o,manager,for,writer,thread,wt,writers,try,wt,shutdown,catch,throwable,t,log,error,error,while,shutting,down,io,manager,writer,thread,t,for,reader,thread,rt,readers,try,rt,shutdown,catch,throwable,t,log,error,error,while,shutting,down,io,manager,reader,thread,t,try,for,writer,thread,wt,writers,wt,join,for,reader,thread,rt,readers,rt,join,catch,interrupted,exception,iex,finally,super,shutdown
IOManagerAsync -> @Override 	public void shutdown();1427820865;Close method. Shuts down the reader and writer threads immediately, not waiting for their_pending requests to be served. This method waits until the threads have actually ceased their_operation.;@Override_	public void shutdown() {_		_		if (!isShutdown.compareAndSet(false, true)) {_			return__		}__		try {_			if (LOG.isDebugEnabled()) {_				LOG.debug("Shutting down I/O manager.")__			}__			_			__			for (WriterThread wt : writers) {_				try {_					wt.shutdown()__				}_				catch (Throwable t) {_					LOG.error("Error while shutting down IO Manager writer thread.", t)__				}_			}_			for (ReaderThread rt : readers) {_				try {_					rt.shutdown()__				}_				catch (Throwable t) {_					LOG.error("Error while shutting down IO Manager reader thread.", t)__				}_			}_			try {_				for (WriterThread wt : writers) {_					wt.join()__				}_				for (ReaderThread rt : readers) {_					rt.join()__				}_			}_			catch (InterruptedException iex) {_				_			}_		}_		finally {_			_			_			super.shutdown()__		}_	};close,method,shuts,down,the,reader,and,writer,threads,immediately,not,waiting,for,their,pending,requests,to,be,served,this,method,waits,until,the,threads,have,actually,ceased,their,operation;override,public,void,shutdown,if,is,shutdown,compare,and,set,false,true,return,try,if,log,is,debug,enabled,log,debug,shutting,down,i,o,manager,for,writer,thread,wt,writers,try,wt,shutdown,catch,throwable,t,log,error,error,while,shutting,down,io,manager,writer,thread,t,for,reader,thread,rt,readers,try,rt,shutdown,catch,throwable,t,log,error,error,while,shutting,down,io,manager,reader,thread,t,try,for,writer,thread,wt,writers,wt,join,for,reader,thread,rt,readers,rt,join,catch,interrupted,exception,iex,finally,super,shutdown
IOManagerAsync -> @Override 	public void shutdown();1441195974;Close method. Shuts down the reader and writer threads immediately, not waiting for their_pending requests to be served. This method waits until the threads have actually ceased their_operation.;@Override_	public void shutdown() {_		_		if (!isShutdown.compareAndSet(false, true)) {_			return__		}__		_		if (shutdownHook != null && shutdownHook != Thread.currentThread()) {_			try {_				Runtime.getRuntime().removeShutdownHook(shutdownHook)__			}_			catch (IllegalStateException e) {_				_				LOG.debug("Unable to remove shutdown hook, shutdown already in progress", e)__			}_			catch (Throwable t) {_				LOG.warn("Exception while unregistering IOManager's shutdown hook.", t)__			}_		}_		_		try {_			if (LOG.isDebugEnabled()) {_				LOG.debug("Shutting down I/O manager.")__			}__			_			__			for (WriterThread wt : writers) {_				try {_					wt.shutdown()__				}_				catch (Throwable t) {_					LOG.error("Error while shutting down IO Manager writer thread.", t)__				}_			}_			for (ReaderThread rt : readers) {_				try {_					rt.shutdown()__				}_				catch (Throwable t) {_					LOG.error("Error while shutting down IO Manager reader thread.", t)__				}_			}_			try {_				for (WriterThread wt : writers) {_					wt.join()__				}_				for (ReaderThread rt : readers) {_					rt.join()__				}_			}_			catch (InterruptedException iex) {_				_			}_		}_		finally {_			_			_			super.shutdown()__		}_	};close,method,shuts,down,the,reader,and,writer,threads,immediately,not,waiting,for,their,pending,requests,to,be,served,this,method,waits,until,the,threads,have,actually,ceased,their,operation;override,public,void,shutdown,if,is,shutdown,compare,and,set,false,true,return,if,shutdown,hook,null,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,e,log,debug,unable,to,remove,shutdown,hook,shutdown,already,in,progress,e,catch,throwable,t,log,warn,exception,while,unregistering,iomanager,s,shutdown,hook,t,try,if,log,is,debug,enabled,log,debug,shutting,down,i,o,manager,for,writer,thread,wt,writers,try,wt,shutdown,catch,throwable,t,log,error,error,while,shutting,down,io,manager,writer,thread,t,for,reader,thread,rt,readers,try,rt,shutdown,catch,throwable,t,log,error,error,while,shutting,down,io,manager,reader,thread,t,try,for,writer,thread,wt,writers,wt,join,for,reader,thread,rt,readers,rt,join,catch,interrupted,exception,iex,finally,super,shutdown
IOManagerAsync -> @Override 	public void shutdown();1465991918;Close method. Shuts down the reader and writer threads immediately, not waiting for their_pending requests to be served. This method waits until the threads have actually ceased their_operation.;@Override_	public void shutdown() {_		_		if (!isShutdown.compareAndSet(false, true)) {_			return__		}__		_		if (shutdownHook != null && shutdownHook != Thread.currentThread()) {_			try {_				Runtime.getRuntime().removeShutdownHook(shutdownHook)__			}_			catch (IllegalStateException e) {_				_				LOG.debug("Unable to remove shutdown hook, shutdown already in progress", e)__			}_			catch (Throwable t) {_				LOG.warn("Exception while unregistering IOManager's shutdown hook.", t)__			}_		}_		_		try {_			if (LOG.isDebugEnabled()) {_				LOG.debug("Shutting down I/O manager.")__			}__			_			__			for (WriterThread wt : writers) {_				try {_					wt.shutdown()__				}_				catch (Throwable t) {_					LOG.error("Error while shutting down IO Manager writer thread.", t)__				}_			}_			for (ReaderThread rt : readers) {_				try {_					rt.shutdown()__				}_				catch (Throwable t) {_					LOG.error("Error while shutting down IO Manager reader thread.", t)__				}_			}_			try {_				for (WriterThread wt : writers) {_					wt.join()__				}_				for (ReaderThread rt : readers) {_					rt.join()__				}_			}_			catch (InterruptedException iex) {_				_			}_		}_		finally {_			_			_			super.shutdown()__		}_	};close,method,shuts,down,the,reader,and,writer,threads,immediately,not,waiting,for,their,pending,requests,to,be,served,this,method,waits,until,the,threads,have,actually,ceased,their,operation;override,public,void,shutdown,if,is,shutdown,compare,and,set,false,true,return,if,shutdown,hook,null,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,e,log,debug,unable,to,remove,shutdown,hook,shutdown,already,in,progress,e,catch,throwable,t,log,warn,exception,while,unregistering,iomanager,s,shutdown,hook,t,try,if,log,is,debug,enabled,log,debug,shutting,down,i,o,manager,for,writer,thread,wt,writers,try,wt,shutdown,catch,throwable,t,log,error,error,while,shutting,down,io,manager,writer,thread,t,for,reader,thread,rt,readers,try,rt,shutdown,catch,throwable,t,log,error,error,while,shutting,down,io,manager,reader,thread,t,try,for,writer,thread,wt,writers,wt,join,for,reader,thread,rt,readers,rt,join,catch,interrupted,exception,iex,finally,super,shutdown
IOManagerAsync -> @Override 	public void shutdown();1519567828;Close method. Shuts down the reader and writer threads immediately, not waiting for their_pending requests to be served. This method waits until the threads have actually ceased their_operation.;@Override_	public void shutdown() {_		_		if (!isShutdown.compareAndSet(false, true)) {_			return__		}__		_		ShutdownHookUtil.removeShutdownHook(shutdownHook, getClass().getSimpleName(), LOG)___		try {_			if (LOG.isDebugEnabled()) {_				LOG.debug("Shutting down I/O manager.")__			}__			_			__			for (WriterThread wt : writers) {_				try {_					wt.shutdown()__				}_				catch (Throwable t) {_					LOG.error("Error while shutting down IO Manager writer thread.", t)__				}_			}_			for (ReaderThread rt : readers) {_				try {_					rt.shutdown()__				}_				catch (Throwable t) {_					LOG.error("Error while shutting down IO Manager reader thread.", t)__				}_			}_			try {_				for (WriterThread wt : writers) {_					wt.join()__				}_				for (ReaderThread rt : readers) {_					rt.join()__				}_			}_			catch (InterruptedException iex) {_				_			}_		}_		finally {_			_			_			super.shutdown()__		}_	};close,method,shuts,down,the,reader,and,writer,threads,immediately,not,waiting,for,their,pending,requests,to,be,served,this,method,waits,until,the,threads,have,actually,ceased,their,operation;override,public,void,shutdown,if,is,shutdown,compare,and,set,false,true,return,shutdown,hook,util,remove,shutdown,hook,shutdown,hook,get,class,get,simple,name,log,try,if,log,is,debug,enabled,log,debug,shutting,down,i,o,manager,for,writer,thread,wt,writers,try,wt,shutdown,catch,throwable,t,log,error,error,while,shutting,down,io,manager,writer,thread,t,for,reader,thread,rt,readers,try,rt,shutdown,catch,throwable,t,log,error,error,while,shutting,down,io,manager,reader,thread,t,try,for,writer,thread,wt,writers,wt,join,for,reader,thread,rt,readers,rt,join,catch,interrupted,exception,iex,finally,super,shutdown
IOManagerAsync -> @Override 	public void shutdown();1550673194;Close method. Shuts down the reader and writer threads immediately, not waiting for their_pending requests to be served. This method waits until the threads have actually ceased their_operation.;@Override_	public void shutdown() {_		_		if (!isShutdown.compareAndSet(false, true)) {_			return__		}__		_		ShutdownHookUtil.removeShutdownHook(shutdownHook, getClass().getSimpleName(), LOG)___		try {_			if (LOG.isDebugEnabled()) {_				LOG.debug("Shutting down I/O manager.")__			}__			_			__			for (WriterThread wt : writers) {_				try {_					wt.shutdown()__				}_				catch (Throwable t) {_					LOG.error("Error while shutting down IO Manager writer thread.", t)__				}_			}_			for (ReaderThread rt : readers) {_				try {_					rt.shutdown()__				}_				catch (Throwable t) {_					LOG.error("Error while shutting down IO Manager reader thread.", t)__				}_			}_			try {_				for (WriterThread wt : writers) {_					wt.join()__				}_				for (ReaderThread rt : readers) {_					rt.join()__				}_			}_			catch (InterruptedException iex) {_				_			}_		}_		finally {_			_			_			super.shutdown()__		}_	};close,method,shuts,down,the,reader,and,writer,threads,immediately,not,waiting,for,their,pending,requests,to,be,served,this,method,waits,until,the,threads,have,actually,ceased,their,operation;override,public,void,shutdown,if,is,shutdown,compare,and,set,false,true,return,shutdown,hook,util,remove,shutdown,hook,shutdown,hook,get,class,get,simple,name,log,try,if,log,is,debug,enabled,log,debug,shutting,down,i,o,manager,for,writer,thread,wt,writers,try,wt,shutdown,catch,throwable,t,log,error,error,while,shutting,down,io,manager,writer,thread,t,for,reader,thread,rt,readers,try,rt,shutdown,catch,throwable,t,log,error,error,while,shutting,down,io,manager,reader,thread,t,try,for,writer,thread,wt,writers,wt,join,for,reader,thread,rt,readers,rt,join,catch,interrupted,exception,iex,finally,super,shutdown
IOManagerAsync -> @Override 	public boolean isProperlyShutDown();1415702894;Utility method to check whether the IO manager has been properly shut down. The IO manager is considered_to be properly shut down when it is closed and its threads have ceased operation.__@return True, if the IO manager has properly shut down, false otherwise.;@Override_	public boolean isProperlyShutDown() {_		boolean readersShutDown = true__		for (ReaderThread rt : readers) {_			readersShutDown &= rt.getState() == Thread.State.TERMINATED__		}_		_		boolean writersShutDown = true__		for (WriterThread wt : writers) {_			readersShutDown &= wt.getState() == Thread.State.TERMINATED__		}_		_		return shutdown && writersShutDown && readersShutDown__	};utility,method,to,check,whether,the,io,manager,has,been,properly,shut,down,the,io,manager,is,considered,to,be,properly,shut,down,when,it,is,closed,and,its,threads,have,ceased,operation,return,true,if,the,io,manager,has,properly,shut,down,false,otherwise;override,public,boolean,is,properly,shut,down,boolean,readers,shut,down,true,for,reader,thread,rt,readers,readers,shut,down,rt,get,state,thread,state,terminated,boolean,writers,shut,down,true,for,writer,thread,wt,writers,readers,shut,down,wt,get,state,thread,state,terminated,return,shutdown,writers,shut,down,readers,shut,down
IOManagerAsync -> @Override 	public boolean isProperlyShutDown();1421050512;Utility method to check whether the IO manager has been properly shut down. The IO manager is considered_to be properly shut down when it is closed and its threads have ceased operation.__@return True, if the IO manager has properly shut down, false otherwise.;@Override_	public boolean isProperlyShutDown() {_		boolean readersShutDown = true__		for (ReaderThread rt : readers) {_			readersShutDown &= rt.getState() == Thread.State.TERMINATED__		}_		_		boolean writersShutDown = true__		for (WriterThread wt : writers) {_			readersShutDown &= wt.getState() == Thread.State.TERMINATED__		}_		_		return shutdown && writersShutDown && readersShutDown__	};utility,method,to,check,whether,the,io,manager,has,been,properly,shut,down,the,io,manager,is,considered,to,be,properly,shut,down,when,it,is,closed,and,its,threads,have,ceased,operation,return,true,if,the,io,manager,has,properly,shut,down,false,otherwise;override,public,boolean,is,properly,shut,down,boolean,readers,shut,down,true,for,reader,thread,rt,readers,readers,shut,down,rt,get,state,thread,state,terminated,boolean,writers,shut,down,true,for,writer,thread,wt,writers,readers,shut,down,wt,get,state,thread,state,terminated,return,shutdown,writers,shut,down,readers,shut,down
IOManagerAsync -> @Override 	public boolean isProperlyShutDown();1421838095;Utility method to check whether the IO manager has been properly shut down. The IO manager is considered_to be properly shut down when it is closed and its threads have ceased operation.__@return True, if the IO manager has properly shut down, false otherwise.;@Override_	public boolean isProperlyShutDown() {_		boolean readersShutDown = true__		for (ReaderThread rt : readers) {_			readersShutDown &= rt.getState() == Thread.State.TERMINATED__		}_		_		boolean writersShutDown = true__		for (WriterThread wt : writers) {_			readersShutDown &= wt.getState() == Thread.State.TERMINATED__		}_		_		return shutdown && writersShutDown && readersShutDown__	};utility,method,to,check,whether,the,io,manager,has,been,properly,shut,down,the,io,manager,is,considered,to,be,properly,shut,down,when,it,is,closed,and,its,threads,have,ceased,operation,return,true,if,the,io,manager,has,properly,shut,down,false,otherwise;override,public,boolean,is,properly,shut,down,boolean,readers,shut,down,true,for,reader,thread,rt,readers,readers,shut,down,rt,get,state,thread,state,terminated,boolean,writers,shut,down,true,for,writer,thread,wt,writers,readers,shut,down,wt,get,state,thread,state,terminated,return,shutdown,writers,shut,down,readers,shut,down
IOManagerAsync -> @Override 	public boolean isProperlyShutDown();1424338528;Utility method to check whether the IO manager has been properly shut down. The IO manager is considered_to be properly shut down when it is closed and its threads have ceased operation.__@return True, if the IO manager has properly shut down, false otherwise.;@Override_	public boolean isProperlyShutDown() {_		boolean readersShutDown = true__		for (ReaderThread rt : readers) {_			readersShutDown &= rt.getState() == Thread.State.TERMINATED__		}_		_		boolean writersShutDown = true__		for (WriterThread wt : writers) {_			writersShutDown &= wt.getState() == Thread.State.TERMINATED__		}_		_		return isShutdown.get() && readersShutDown && writersShutDown && super.isProperlyShutDown()__	};utility,method,to,check,whether,the,io,manager,has,been,properly,shut,down,the,io,manager,is,considered,to,be,properly,shut,down,when,it,is,closed,and,its,threads,have,ceased,operation,return,true,if,the,io,manager,has,properly,shut,down,false,otherwise;override,public,boolean,is,properly,shut,down,boolean,readers,shut,down,true,for,reader,thread,rt,readers,readers,shut,down,rt,get,state,thread,state,terminated,boolean,writers,shut,down,true,for,writer,thread,wt,writers,writers,shut,down,wt,get,state,thread,state,terminated,return,is,shutdown,get,readers,shut,down,writers,shut,down,super,is,properly,shut,down
IOManagerAsync -> @Override 	public boolean isProperlyShutDown();1426697080;Utility method to check whether the IO manager has been properly shut down. The IO manager is considered_to be properly shut down when it is closed and its threads have ceased operation.__@return True, if the IO manager has properly shut down, false otherwise.;@Override_	public boolean isProperlyShutDown() {_		boolean readersShutDown = true__		for (ReaderThread rt : readers) {_			readersShutDown &= rt.getState() == Thread.State.TERMINATED__		}_		_		boolean writersShutDown = true__		for (WriterThread wt : writers) {_			writersShutDown &= wt.getState() == Thread.State.TERMINATED__		}_		_		return isShutdown.get() && readersShutDown && writersShutDown && super.isProperlyShutDown()__	};utility,method,to,check,whether,the,io,manager,has,been,properly,shut,down,the,io,manager,is,considered,to,be,properly,shut,down,when,it,is,closed,and,its,threads,have,ceased,operation,return,true,if,the,io,manager,has,properly,shut,down,false,otherwise;override,public,boolean,is,properly,shut,down,boolean,readers,shut,down,true,for,reader,thread,rt,readers,readers,shut,down,rt,get,state,thread,state,terminated,boolean,writers,shut,down,true,for,writer,thread,wt,writers,writers,shut,down,wt,get,state,thread,state,terminated,return,is,shutdown,get,readers,shut,down,writers,shut,down,super,is,properly,shut,down
IOManagerAsync -> @Override 	public boolean isProperlyShutDown();1427820865;Utility method to check whether the IO manager has been properly shut down. The IO manager is considered_to be properly shut down when it is closed and its threads have ceased operation.__@return True, if the IO manager has properly shut down, false otherwise.;@Override_	public boolean isProperlyShutDown() {_		boolean readersShutDown = true__		for (ReaderThread rt : readers) {_			readersShutDown &= rt.getState() == Thread.State.TERMINATED__		}_		_		boolean writersShutDown = true__		for (WriterThread wt : writers) {_			writersShutDown &= wt.getState() == Thread.State.TERMINATED__		}_		_		return isShutdown.get() && readersShutDown && writersShutDown && super.isProperlyShutDown()__	};utility,method,to,check,whether,the,io,manager,has,been,properly,shut,down,the,io,manager,is,considered,to,be,properly,shut,down,when,it,is,closed,and,its,threads,have,ceased,operation,return,true,if,the,io,manager,has,properly,shut,down,false,otherwise;override,public,boolean,is,properly,shut,down,boolean,readers,shut,down,true,for,reader,thread,rt,readers,readers,shut,down,rt,get,state,thread,state,terminated,boolean,writers,shut,down,true,for,writer,thread,wt,writers,writers,shut,down,wt,get,state,thread,state,terminated,return,is,shutdown,get,readers,shut,down,writers,shut,down,super,is,properly,shut,down
IOManagerAsync -> @Override 	public boolean isProperlyShutDown();1441195974;Utility method to check whether the IO manager has been properly shut down. The IO manager is considered_to be properly shut down when it is closed and its threads have ceased operation.__@return True, if the IO manager has properly shut down, false otherwise.;@Override_	public boolean isProperlyShutDown() {_		boolean readersShutDown = true__		for (ReaderThread rt : readers) {_			readersShutDown &= rt.getState() == Thread.State.TERMINATED__		}_		_		boolean writersShutDown = true__		for (WriterThread wt : writers) {_			writersShutDown &= wt.getState() == Thread.State.TERMINATED__		}_		_		return isShutdown.get() && readersShutDown && writersShutDown && super.isProperlyShutDown()__	};utility,method,to,check,whether,the,io,manager,has,been,properly,shut,down,the,io,manager,is,considered,to,be,properly,shut,down,when,it,is,closed,and,its,threads,have,ceased,operation,return,true,if,the,io,manager,has,properly,shut,down,false,otherwise;override,public,boolean,is,properly,shut,down,boolean,readers,shut,down,true,for,reader,thread,rt,readers,readers,shut,down,rt,get,state,thread,state,terminated,boolean,writers,shut,down,true,for,writer,thread,wt,writers,writers,shut,down,wt,get,state,thread,state,terminated,return,is,shutdown,get,readers,shut,down,writers,shut,down,super,is,properly,shut,down
IOManagerAsync -> @Override 	public boolean isProperlyShutDown();1465991918;Utility method to check whether the IO manager has been properly shut down. The IO manager is considered_to be properly shut down when it is closed and its threads have ceased operation.__@return True, if the IO manager has properly shut down, false otherwise.;@Override_	public boolean isProperlyShutDown() {_		boolean readersShutDown = true__		for (ReaderThread rt : readers) {_			readersShutDown &= rt.getState() == Thread.State.TERMINATED__		}_		_		boolean writersShutDown = true__		for (WriterThread wt : writers) {_			writersShutDown &= wt.getState() == Thread.State.TERMINATED__		}_		_		return isShutdown.get() && readersShutDown && writersShutDown && super.isProperlyShutDown()__	};utility,method,to,check,whether,the,io,manager,has,been,properly,shut,down,the,io,manager,is,considered,to,be,properly,shut,down,when,it,is,closed,and,its,threads,have,ceased,operation,return,true,if,the,io,manager,has,properly,shut,down,false,otherwise;override,public,boolean,is,properly,shut,down,boolean,readers,shut,down,true,for,reader,thread,rt,readers,readers,shut,down,rt,get,state,thread,state,terminated,boolean,writers,shut,down,true,for,writer,thread,wt,writers,writers,shut,down,wt,get,state,thread,state,terminated,return,is,shutdown,get,readers,shut,down,writers,shut,down,super,is,properly,shut,down
IOManagerAsync -> @Override 	public boolean isProperlyShutDown();1519567828;Utility method to check whether the IO manager has been properly shut down. The IO manager is considered_to be properly shut down when it is closed and its threads have ceased operation.__@return True, if the IO manager has properly shut down, false otherwise.;@Override_	public boolean isProperlyShutDown() {_		boolean readersShutDown = true__		for (ReaderThread rt : readers) {_			readersShutDown &= rt.getState() == Thread.State.TERMINATED__		}_		_		boolean writersShutDown = true__		for (WriterThread wt : writers) {_			writersShutDown &= wt.getState() == Thread.State.TERMINATED__		}_		_		return isShutdown.get() && readersShutDown && writersShutDown && super.isProperlyShutDown()__	};utility,method,to,check,whether,the,io,manager,has,been,properly,shut,down,the,io,manager,is,considered,to,be,properly,shut,down,when,it,is,closed,and,its,threads,have,ceased,operation,return,true,if,the,io,manager,has,properly,shut,down,false,otherwise;override,public,boolean,is,properly,shut,down,boolean,readers,shut,down,true,for,reader,thread,rt,readers,readers,shut,down,rt,get,state,thread,state,terminated,boolean,writers,shut,down,true,for,writer,thread,wt,writers,writers,shut,down,wt,get,state,thread,state,terminated,return,is,shutdown,get,readers,shut,down,writers,shut,down,super,is,properly,shut,down
IOManagerAsync -> @Override 	public boolean isProperlyShutDown();1550673194;Utility method to check whether the IO manager has been properly shut down. The IO manager is considered_to be properly shut down when it is closed and its threads have ceased operation.__@return True, if the IO manager has properly shut down, false otherwise.;@Override_	public boolean isProperlyShutDown() {_		boolean readersShutDown = true__		for (ReaderThread rt : readers) {_			readersShutDown &= rt.getState() == Thread.State.TERMINATED__		}_		_		boolean writersShutDown = true__		for (WriterThread wt : writers) {_			writersShutDown &= wt.getState() == Thread.State.TERMINATED__		}_		_		return isShutdown.get() && readersShutDown && writersShutDown && super.isProperlyShutDown()__	};utility,method,to,check,whether,the,io,manager,has,been,properly,shut,down,the,io,manager,is,considered,to,be,properly,shut,down,when,it,is,closed,and,its,threads,have,ceased,operation,return,true,if,the,io,manager,has,properly,shut,down,false,otherwise;override,public,boolean,is,properly,shut,down,boolean,readers,shut,down,true,for,reader,thread,rt,readers,readers,shut,down,rt,get,state,thread,state,terminated,boolean,writers,shut,down,true,for,writer,thread,wt,writers,writers,shut,down,wt,get,state,thread,state,terminated,return,is,shutdown,get,readers,shut,down,writers,shut,down,super,is,properly,shut,down
IOManagerAsync -> @Override 	public BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID, 			List<MemorySegment> targetSegments, int numBlocks) throws IOException;1441195974;Creates a block channel reader that reads all blocks from the given channel directly in one bulk._The reader draws segments to read the blocks into from a supplied list, which must contain as many_segments as the channel has blocks. After the reader is done, the list with the full segments can be_obtained from the reader._<p>_If a channel is not to be read in one bulk, but in multiple smaller batches, a_{@link BlockChannelReader} should be used.__@param channelID The descriptor for the channel to write to._@param targetSegments The list to take the segments from into which to read the data._@param numBlocks The number of blocks in the channel to read._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;@Override_	public BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID,_			List<MemorySegment> targetSegments, int numBlocks) throws IOException_	{_		checkState(!isShutdown.get(), "I/O-Manger is shut down.")__		return new AsynchronousBulkBlockReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, targetSegments, numBlocks)__	};creates,a,block,channel,reader,that,reads,all,blocks,from,the,given,channel,directly,in,one,bulk,the,reader,draws,segments,to,read,the,blocks,into,from,a,supplied,list,which,must,contain,as,many,segments,as,the,channel,has,blocks,after,the,reader,is,done,the,list,with,the,full,segments,can,be,obtained,from,the,reader,p,if,a,channel,is,not,to,be,read,in,one,bulk,but,in,multiple,smaller,batches,a,link,block,channel,reader,should,be,used,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,target,segments,the,list,to,take,the,segments,from,into,which,to,read,the,data,param,num,blocks,the,number,of,blocks,in,the,channel,to,read,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;override,public,bulk,block,channel,reader,create,bulk,block,channel,reader,file,iochannel,id,channel,id,list,memory,segment,target,segments,int,num,blocks,throws,ioexception,check,state,is,shutdown,get,i,o,manger,is,shut,down,return,new,asynchronous,bulk,block,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,target,segments,num,blocks
IOManagerAsync -> @Override 	public BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID, 			List<MemorySegment> targetSegments, int numBlocks) throws IOException;1465991918;Creates a block channel reader that reads all blocks from the given channel directly in one bulk._The reader draws segments to read the blocks into from a supplied list, which must contain as many_segments as the channel has blocks. After the reader is done, the list with the full segments can be_obtained from the reader._<p>_If a channel is not to be read in one bulk, but in multiple smaller batches, a_{@link BlockChannelReader} should be used.__@param channelID The descriptor for the channel to write to._@param targetSegments The list to take the segments from into which to read the data._@param numBlocks The number of blocks in the channel to read._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;@Override_	public BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID,_			List<MemorySegment> targetSegments, int numBlocks) throws IOException_	{_		checkState(!isShutdown.get(), "I/O-Manger is shut down.")__		return new AsynchronousBulkBlockReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, targetSegments, numBlocks)__	};creates,a,block,channel,reader,that,reads,all,blocks,from,the,given,channel,directly,in,one,bulk,the,reader,draws,segments,to,read,the,blocks,into,from,a,supplied,list,which,must,contain,as,many,segments,as,the,channel,has,blocks,after,the,reader,is,done,the,list,with,the,full,segments,can,be,obtained,from,the,reader,p,if,a,channel,is,not,to,be,read,in,one,bulk,but,in,multiple,smaller,batches,a,link,block,channel,reader,should,be,used,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,target,segments,the,list,to,take,the,segments,from,into,which,to,read,the,data,param,num,blocks,the,number,of,blocks,in,the,channel,to,read,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;override,public,bulk,block,channel,reader,create,bulk,block,channel,reader,file,iochannel,id,channel,id,list,memory,segment,target,segments,int,num,blocks,throws,ioexception,check,state,is,shutdown,get,i,o,manger,is,shut,down,return,new,asynchronous,bulk,block,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,target,segments,num,blocks
IOManagerAsync -> @Override 	public BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID, 			List<MemorySegment> targetSegments, int numBlocks) throws IOException;1519567828;Creates a block channel reader that reads all blocks from the given channel directly in one bulk._The reader draws segments to read the blocks into from a supplied list, which must contain as many_segments as the channel has blocks. After the reader is done, the list with the full segments can be_obtained from the reader._<p>_If a channel is not to be read in one bulk, but in multiple smaller batches, a_{@link BlockChannelReader} should be used.__@param channelID The descriptor for the channel to write to._@param targetSegments The list to take the segments from into which to read the data._@param numBlocks The number of blocks in the channel to read._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;@Override_	public BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID,_			List<MemorySegment> targetSegments, int numBlocks) throws IOException_	{_		checkState(!isShutdown.get(), "I/O-Manger is shut down.")__		return new AsynchronousBulkBlockReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, targetSegments, numBlocks)__	};creates,a,block,channel,reader,that,reads,all,blocks,from,the,given,channel,directly,in,one,bulk,the,reader,draws,segments,to,read,the,blocks,into,from,a,supplied,list,which,must,contain,as,many,segments,as,the,channel,has,blocks,after,the,reader,is,done,the,list,with,the,full,segments,can,be,obtained,from,the,reader,p,if,a,channel,is,not,to,be,read,in,one,bulk,but,in,multiple,smaller,batches,a,link,block,channel,reader,should,be,used,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,target,segments,the,list,to,take,the,segments,from,into,which,to,read,the,data,param,num,blocks,the,number,of,blocks,in,the,channel,to,read,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;override,public,bulk,block,channel,reader,create,bulk,block,channel,reader,file,iochannel,id,channel,id,list,memory,segment,target,segments,int,num,blocks,throws,ioexception,check,state,is,shutdown,get,i,o,manger,is,shut,down,return,new,asynchronous,bulk,block,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,target,segments,num,blocks
IOManagerAsync -> @Override 	public BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID, 			List<MemorySegment> targetSegments, int numBlocks) throws IOException;1550673194;Creates a block channel reader that reads all blocks from the given channel directly in one bulk._The reader draws segments to read the blocks into from a supplied list, which must contain as many_segments as the channel has blocks. After the reader is done, the list with the full segments can be_obtained from the reader._<p>_If a channel is not to be read in one bulk, but in multiple smaller batches, a_{@link BlockChannelReader} should be used.__@param channelID The descriptor for the channel to write to._@param targetSegments The list to take the segments from into which to read the data._@param numBlocks The number of blocks in the channel to read._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;@Override_	public BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID,_			List<MemorySegment> targetSegments, int numBlocks) throws IOException_	{_		checkState(!isShutdown.get(), "I/O-Manager is shut down.")__		return new AsynchronousBulkBlockReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, targetSegments, numBlocks)__	};creates,a,block,channel,reader,that,reads,all,blocks,from,the,given,channel,directly,in,one,bulk,the,reader,draws,segments,to,read,the,blocks,into,from,a,supplied,list,which,must,contain,as,many,segments,as,the,channel,has,blocks,after,the,reader,is,done,the,list,with,the,full,segments,can,be,obtained,from,the,reader,p,if,a,channel,is,not,to,be,read,in,one,bulk,but,in,multiple,smaller,batches,a,link,block,channel,reader,should,be,used,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,target,segments,the,list,to,take,the,segments,from,into,which,to,read,the,data,param,num,blocks,the,number,of,blocks,in,the,channel,to,read,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;override,public,bulk,block,channel,reader,create,bulk,block,channel,reader,file,iochannel,id,channel,id,list,memory,segment,target,segments,int,num,blocks,throws,ioexception,check,state,is,shutdown,get,i,o,manager,is,shut,down,return,new,asynchronous,bulk,block,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,target,segments,num,blocks
IOManagerAsync -> @Override 	public BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID, 			List<MemorySegment> targetSegments,	int numBlocks) throws IOException;1415702894;Creates a block channel reader that reads all blocks from the given channel directly in one bulk._The reader draws segments to read the blocks into from a supplied list, which must contain as many_segments as the channel has blocks. After the reader is done, the list with the full segments can be_obtained from the reader._<p>_If a channel is not to be read in one bulk, but in multiple smaller batches, a_{@link BlockChannelReader} should be used.__@param channelID The descriptor for the channel to write to._@param targetSegments The list to take the segments from into which to read the data._@param numBlocks The number of blocks in the channel to read._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;@Override_	public BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID,_			List<MemorySegment> targetSegments,	int numBlocks) throws IOException_	{_		Preconditions.checkState(!shutdown, "I/O-Manger is closed.")__		return new AsynchronousBulkBlockReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, targetSegments, numBlocks)__	};creates,a,block,channel,reader,that,reads,all,blocks,from,the,given,channel,directly,in,one,bulk,the,reader,draws,segments,to,read,the,blocks,into,from,a,supplied,list,which,must,contain,as,many,segments,as,the,channel,has,blocks,after,the,reader,is,done,the,list,with,the,full,segments,can,be,obtained,from,the,reader,p,if,a,channel,is,not,to,be,read,in,one,bulk,but,in,multiple,smaller,batches,a,link,block,channel,reader,should,be,used,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,target,segments,the,list,to,take,the,segments,from,into,which,to,read,the,data,param,num,blocks,the,number,of,blocks,in,the,channel,to,read,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;override,public,bulk,block,channel,reader,create,bulk,block,channel,reader,file,iochannel,id,channel,id,list,memory,segment,target,segments,int,num,blocks,throws,ioexception,preconditions,check,state,shutdown,i,o,manger,is,closed,return,new,asynchronous,bulk,block,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,target,segments,num,blocks
IOManagerAsync -> @Override 	public BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID, 			List<MemorySegment> targetSegments,	int numBlocks) throws IOException;1421050512;Creates a block channel reader that reads all blocks from the given channel directly in one bulk._The reader draws segments to read the blocks into from a supplied list, which must contain as many_segments as the channel has blocks. After the reader is done, the list with the full segments can be_obtained from the reader._<p>_If a channel is not to be read in one bulk, but in multiple smaller batches, a_{@link BlockChannelReader} should be used.__@param channelID The descriptor for the channel to write to._@param targetSegments The list to take the segments from into which to read the data._@param numBlocks The number of blocks in the channel to read._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;@Override_	public BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID,_			List<MemorySegment> targetSegments,	int numBlocks) throws IOException_	{_		checkState(!shutdown, "I/O-Manger is closed.")__		return new AsynchronousBulkBlockReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, targetSegments, numBlocks)__	};creates,a,block,channel,reader,that,reads,all,blocks,from,the,given,channel,directly,in,one,bulk,the,reader,draws,segments,to,read,the,blocks,into,from,a,supplied,list,which,must,contain,as,many,segments,as,the,channel,has,blocks,after,the,reader,is,done,the,list,with,the,full,segments,can,be,obtained,from,the,reader,p,if,a,channel,is,not,to,be,read,in,one,bulk,but,in,multiple,smaller,batches,a,link,block,channel,reader,should,be,used,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,target,segments,the,list,to,take,the,segments,from,into,which,to,read,the,data,param,num,blocks,the,number,of,blocks,in,the,channel,to,read,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;override,public,bulk,block,channel,reader,create,bulk,block,channel,reader,file,iochannel,id,channel,id,list,memory,segment,target,segments,int,num,blocks,throws,ioexception,check,state,shutdown,i,o,manger,is,closed,return,new,asynchronous,bulk,block,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,target,segments,num,blocks
IOManagerAsync -> @Override 	public BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID, 			List<MemorySegment> targetSegments,	int numBlocks) throws IOException;1421838095;Creates a block channel reader that reads all blocks from the given channel directly in one bulk._The reader draws segments to read the blocks into from a supplied list, which must contain as many_segments as the channel has blocks. After the reader is done, the list with the full segments can be_obtained from the reader._<p>_If a channel is not to be read in one bulk, but in multiple smaller batches, a_{@link BlockChannelReader} should be used.__@param channelID The descriptor for the channel to write to._@param targetSegments The list to take the segments from into which to read the data._@param numBlocks The number of blocks in the channel to read._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;@Override_	public BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID,_			List<MemorySegment> targetSegments,	int numBlocks) throws IOException_	{_		checkState(!shutdown, "I/O-Manger is closed.")__		return new AsynchronousBulkBlockReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, targetSegments, numBlocks)__	};creates,a,block,channel,reader,that,reads,all,blocks,from,the,given,channel,directly,in,one,bulk,the,reader,draws,segments,to,read,the,blocks,into,from,a,supplied,list,which,must,contain,as,many,segments,as,the,channel,has,blocks,after,the,reader,is,done,the,list,with,the,full,segments,can,be,obtained,from,the,reader,p,if,a,channel,is,not,to,be,read,in,one,bulk,but,in,multiple,smaller,batches,a,link,block,channel,reader,should,be,used,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,target,segments,the,list,to,take,the,segments,from,into,which,to,read,the,data,param,num,blocks,the,number,of,blocks,in,the,channel,to,read,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;override,public,bulk,block,channel,reader,create,bulk,block,channel,reader,file,iochannel,id,channel,id,list,memory,segment,target,segments,int,num,blocks,throws,ioexception,check,state,shutdown,i,o,manger,is,closed,return,new,asynchronous,bulk,block,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,target,segments,num,blocks
IOManagerAsync -> @Override 	public BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID, 			List<MemorySegment> targetSegments,	int numBlocks) throws IOException;1424338528;Creates a block channel reader that reads all blocks from the given channel directly in one bulk._The reader draws segments to read the blocks into from a supplied list, which must contain as many_segments as the channel has blocks. After the reader is done, the list with the full segments can be_obtained from the reader._<p>_If a channel is not to be read in one bulk, but in multiple smaller batches, a_{@link BlockChannelReader} should be used.__@param channelID The descriptor for the channel to write to._@param targetSegments The list to take the segments from into which to read the data._@param numBlocks The number of blocks in the channel to read._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;@Override_	public BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID,_			List<MemorySegment> targetSegments,	int numBlocks) throws IOException_	{_		checkState(!isShutdown.get(), "I/O-Manger is shut down.")__		return new AsynchronousBulkBlockReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, targetSegments, numBlocks)__	};creates,a,block,channel,reader,that,reads,all,blocks,from,the,given,channel,directly,in,one,bulk,the,reader,draws,segments,to,read,the,blocks,into,from,a,supplied,list,which,must,contain,as,many,segments,as,the,channel,has,blocks,after,the,reader,is,done,the,list,with,the,full,segments,can,be,obtained,from,the,reader,p,if,a,channel,is,not,to,be,read,in,one,bulk,but,in,multiple,smaller,batches,a,link,block,channel,reader,should,be,used,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,target,segments,the,list,to,take,the,segments,from,into,which,to,read,the,data,param,num,blocks,the,number,of,blocks,in,the,channel,to,read,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;override,public,bulk,block,channel,reader,create,bulk,block,channel,reader,file,iochannel,id,channel,id,list,memory,segment,target,segments,int,num,blocks,throws,ioexception,check,state,is,shutdown,get,i,o,manger,is,shut,down,return,new,asynchronous,bulk,block,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,target,segments,num,blocks
IOManagerAsync -> @Override 	public BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID, 			List<MemorySegment> targetSegments,	int numBlocks) throws IOException;1426697080;Creates a block channel reader that reads all blocks from the given channel directly in one bulk._The reader draws segments to read the blocks into from a supplied list, which must contain as many_segments as the channel has blocks. After the reader is done, the list with the full segments can be_obtained from the reader._<p>_If a channel is not to be read in one bulk, but in multiple smaller batches, a_{@link BlockChannelReader} should be used.__@param channelID The descriptor for the channel to write to._@param targetSegments The list to take the segments from into which to read the data._@param numBlocks The number of blocks in the channel to read._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;@Override_	public BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID,_			List<MemorySegment> targetSegments,	int numBlocks) throws IOException_	{_		checkState(!isShutdown.get(), "I/O-Manger is shut down.")__		return new AsynchronousBulkBlockReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, targetSegments, numBlocks)__	};creates,a,block,channel,reader,that,reads,all,blocks,from,the,given,channel,directly,in,one,bulk,the,reader,draws,segments,to,read,the,blocks,into,from,a,supplied,list,which,must,contain,as,many,segments,as,the,channel,has,blocks,after,the,reader,is,done,the,list,with,the,full,segments,can,be,obtained,from,the,reader,p,if,a,channel,is,not,to,be,read,in,one,bulk,but,in,multiple,smaller,batches,a,link,block,channel,reader,should,be,used,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,target,segments,the,list,to,take,the,segments,from,into,which,to,read,the,data,param,num,blocks,the,number,of,blocks,in,the,channel,to,read,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;override,public,bulk,block,channel,reader,create,bulk,block,channel,reader,file,iochannel,id,channel,id,list,memory,segment,target,segments,int,num,blocks,throws,ioexception,check,state,is,shutdown,get,i,o,manger,is,shut,down,return,new,asynchronous,bulk,block,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,target,segments,num,blocks
IOManagerAsync -> @Override 	public BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID, 			List<MemorySegment> targetSegments,	int numBlocks) throws IOException;1427820865;Creates a block channel reader that reads all blocks from the given channel directly in one bulk._The reader draws segments to read the blocks into from a supplied list, which must contain as many_segments as the channel has blocks. After the reader is done, the list with the full segments can be_obtained from the reader._<p>_If a channel is not to be read in one bulk, but in multiple smaller batches, a_{@link BlockChannelReader} should be used.__@param channelID The descriptor for the channel to write to._@param targetSegments The list to take the segments from into which to read the data._@param numBlocks The number of blocks in the channel to read._@return A block channel reader that reads from the given channel._@throws IOException Thrown, if the channel for the reader could not be opened.;@Override_	public BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID,_			List<MemorySegment> targetSegments,	int numBlocks) throws IOException_	{_		checkState(!isShutdown.get(), "I/O-Manger is shut down.")__		return new AsynchronousBulkBlockReader(channelID, this.readers[channelID.getThreadNum()].requestQueue, targetSegments, numBlocks)__	};creates,a,block,channel,reader,that,reads,all,blocks,from,the,given,channel,directly,in,one,bulk,the,reader,draws,segments,to,read,the,blocks,into,from,a,supplied,list,which,must,contain,as,many,segments,as,the,channel,has,blocks,after,the,reader,is,done,the,list,with,the,full,segments,can,be,obtained,from,the,reader,p,if,a,channel,is,not,to,be,read,in,one,bulk,but,in,multiple,smaller,batches,a,link,block,channel,reader,should,be,used,param,channel,id,the,descriptor,for,the,channel,to,write,to,param,target,segments,the,list,to,take,the,segments,from,into,which,to,read,the,data,param,num,blocks,the,number,of,blocks,in,the,channel,to,read,return,a,block,channel,reader,that,reads,from,the,given,channel,throws,ioexception,thrown,if,the,channel,for,the,reader,could,not,be,opened;override,public,bulk,block,channel,reader,create,bulk,block,channel,reader,file,iochannel,id,channel,id,list,memory,segment,target,segments,int,num,blocks,throws,ioexception,check,state,is,shutdown,get,i,o,manger,is,shut,down,return,new,asynchronous,bulk,block,reader,channel,id,this,readers,channel,id,get,thread,num,request,queue,target,segments,num,blocks
IOManagerAsync -> ReaderThread -> protected void shutdown();1415702894;Shuts the thread down. This operation does not wait for all pending requests to be served, halts the thread_immediately. All buffers of pending requests are handed back to their channel readers and an exception is_reported to them, declaring their request queue as closed.;protected void shutdown() {_			synchronized (this) {_				if (alive) {_					alive = false__					requestQueue.close()__					interrupt()__				}__				try {_					join(1000)__				}_				catch (InterruptedException e) {}_				_				_				IOException ioex = new IOException("IO-Manager has been closed.")__					_				while (!this.requestQueue.isEmpty()) {_					ReadRequest request = this.requestQueue.poll()__					if (request != null) {_						try {_							request.requestDone(ioex)__						}_						catch (Throwable t) {_							IOManagerAsync.LOG.error("The handler of the request complete callback threw an exception"_									+ (t.getMessage() == null ? "." : ": " + t.getMessage()), t)__						}_					}_				}_			}_		};shuts,the,thread,down,this,operation,does,not,wait,for,all,pending,requests,to,be,served,halts,the,thread,immediately,all,buffers,of,pending,requests,are,handed,back,to,their,channel,readers,and,an,exception,is,reported,to,them,declaring,their,request,queue,as,closed;protected,void,shutdown,synchronized,this,if,alive,alive,false,request,queue,close,interrupt,try,join,1000,catch,interrupted,exception,e,ioexception,ioex,new,ioexception,io,manager,has,been,closed,while,this,request,queue,is,empty,read,request,request,this,request,queue,poll,if,request,null,try,request,request,done,ioex,catch,throwable,t,iomanager,async,log,error,the,handler,of,the,request,complete,callback,threw,an,exception,t,get,message,null,t,get,message,t
IOManagerAsync -> ReaderThread -> protected void shutdown();1421050512;Shuts the thread down. This operation does not wait for all pending requests to be served, halts the thread_immediately. All buffers of pending requests are handed back to their channel readers and an exception is_reported to them, declaring their request queue as closed.;protected void shutdown() {_			synchronized (this) {_				if (alive) {_					alive = false__					requestQueue.close()__					interrupt()__				}__				try {_					join(1000)__				}_				catch (InterruptedException e) {}_				_				_				IOException ioex = new IOException("IO-Manager has been closed.")__					_				while (!this.requestQueue.isEmpty()) {_					ReadRequest request = this.requestQueue.poll()__					if (request != null) {_						try {_							request.requestDone(ioex)__						}_						catch (Throwable t) {_							IOManagerAsync.LOG.error("The handler of the request complete callback threw an exception"_									+ (t.getMessage() == null ? "." : ": " + t.getMessage()), t)__						}_					}_				}_			}_		};shuts,the,thread,down,this,operation,does,not,wait,for,all,pending,requests,to,be,served,halts,the,thread,immediately,all,buffers,of,pending,requests,are,handed,back,to,their,channel,readers,and,an,exception,is,reported,to,them,declaring,their,request,queue,as,closed;protected,void,shutdown,synchronized,this,if,alive,alive,false,request,queue,close,interrupt,try,join,1000,catch,interrupted,exception,e,ioexception,ioex,new,ioexception,io,manager,has,been,closed,while,this,request,queue,is,empty,read,request,request,this,request,queue,poll,if,request,null,try,request,request,done,ioex,catch,throwable,t,iomanager,async,log,error,the,handler,of,the,request,complete,callback,threw,an,exception,t,get,message,null,t,get,message,t
IOManagerAsync -> ReaderThread -> protected void shutdown();1421838095;Shuts the thread down. This operation does not wait for all pending requests to be served, halts the thread_immediately. All buffers of pending requests are handed back to their channel readers and an exception is_reported to them, declaring their request queue as closed.;protected void shutdown() {_			synchronized (this) {_				if (alive) {_					alive = false__					requestQueue.close()__					interrupt()__				}__				try {_					join(1000)__				}_				catch (InterruptedException e) {}_				_				_				IOException ioex = new IOException("IO-Manager has been closed.")__					_				while (!this.requestQueue.isEmpty()) {_					ReadRequest request = this.requestQueue.poll()__					if (request != null) {_						try {_							request.requestDone(ioex)__						}_						catch (Throwable t) {_							IOManagerAsync.LOG.error("The handler of the request complete callback threw an exception"_									+ (t.getMessage() == null ? "." : ": " + t.getMessage()), t)__						}_					}_				}_			}_		};shuts,the,thread,down,this,operation,does,not,wait,for,all,pending,requests,to,be,served,halts,the,thread,immediately,all,buffers,of,pending,requests,are,handed,back,to,their,channel,readers,and,an,exception,is,reported,to,them,declaring,their,request,queue,as,closed;protected,void,shutdown,synchronized,this,if,alive,alive,false,request,queue,close,interrupt,try,join,1000,catch,interrupted,exception,e,ioexception,ioex,new,ioexception,io,manager,has,been,closed,while,this,request,queue,is,empty,read,request,request,this,request,queue,poll,if,request,null,try,request,request,done,ioex,catch,throwable,t,iomanager,async,log,error,the,handler,of,the,request,complete,callback,threw,an,exception,t,get,message,null,t,get,message,t
IOManagerAsync -> ReaderThread -> protected void shutdown();1424338528;Shuts the thread down. This operation does not wait for all pending requests to be served, halts the thread_immediately. All buffers of pending requests are handed back to their channel readers and an exception is_reported to them, declaring their request queue as closed.;protected void shutdown() {_			synchronized (this) {_				if (alive) {_					alive = false__					requestQueue.close()__					interrupt()__				}__				try {_					join(1000)__				}_				catch (InterruptedException e) {}_				_				_				IOException ioex = new IOException("IO-Manager has been closed.")__					_				while (!this.requestQueue.isEmpty()) {_					ReadRequest request = this.requestQueue.poll()__					if (request != null) {_						try {_							request.requestDone(ioex)__						}_						catch (Throwable t) {_							IOManagerAsync.LOG.error("The handler of the request complete callback threw an exception"_									+ (t.getMessage() == null ? "." : ": " + t.getMessage()), t)__						}_					}_				}_			}_		};shuts,the,thread,down,this,operation,does,not,wait,for,all,pending,requests,to,be,served,halts,the,thread,immediately,all,buffers,of,pending,requests,are,handed,back,to,their,channel,readers,and,an,exception,is,reported,to,them,declaring,their,request,queue,as,closed;protected,void,shutdown,synchronized,this,if,alive,alive,false,request,queue,close,interrupt,try,join,1000,catch,interrupted,exception,e,ioexception,ioex,new,ioexception,io,manager,has,been,closed,while,this,request,queue,is,empty,read,request,request,this,request,queue,poll,if,request,null,try,request,request,done,ioex,catch,throwable,t,iomanager,async,log,error,the,handler,of,the,request,complete,callback,threw,an,exception,t,get,message,null,t,get,message,t
IOManagerAsync -> ReaderThread -> protected void shutdown();1426697080;Shuts the thread down. This operation does not wait for all pending requests to be served, halts the thread_immediately. All buffers of pending requests are handed back to their channel readers and an exception is_reported to them, declaring their request queue as closed.;protected void shutdown() {_			synchronized (this) {_				if (alive) {_					alive = false__					requestQueue.close()__					interrupt()__				}__				try {_					join(1000)__				}_				catch (InterruptedException e) {}_				_				_				IOException ioex = new IOException("IO-Manager has been closed.")__					_				while (!this.requestQueue.isEmpty()) {_					ReadRequest request = this.requestQueue.poll()__					if (request != null) {_						try {_							request.requestDone(ioex)__						}_						catch (Throwable t) {_							IOManagerAsync.LOG.error("The handler of the request complete callback threw an exception"_									+ (t.getMessage() == null ? "." : ": " + t.getMessage()), t)__						}_					}_				}_			}_		};shuts,the,thread,down,this,operation,does,not,wait,for,all,pending,requests,to,be,served,halts,the,thread,immediately,all,buffers,of,pending,requests,are,handed,back,to,their,channel,readers,and,an,exception,is,reported,to,them,declaring,their,request,queue,as,closed;protected,void,shutdown,synchronized,this,if,alive,alive,false,request,queue,close,interrupt,try,join,1000,catch,interrupted,exception,e,ioexception,ioex,new,ioexception,io,manager,has,been,closed,while,this,request,queue,is,empty,read,request,request,this,request,queue,poll,if,request,null,try,request,request,done,ioex,catch,throwable,t,iomanager,async,log,error,the,handler,of,the,request,complete,callback,threw,an,exception,t,get,message,null,t,get,message,t
IOManagerAsync -> ReaderThread -> protected void shutdown();1427820865;Shuts the thread down. This operation does not wait for all pending requests to be served, halts the thread_immediately. All buffers of pending requests are handed back to their channel readers and an exception is_reported to them, declaring their request queue as closed.;protected void shutdown() {_			synchronized (this) {_				if (alive) {_					alive = false__					requestQueue.close()__					interrupt()__				}__				try {_					join(1000)__				}_				catch (InterruptedException e) {}_				_				_				IOException ioex = new IOException("IO-Manager has been closed.")__					_				while (!this.requestQueue.isEmpty()) {_					ReadRequest request = this.requestQueue.poll()__					if (request != null) {_						try {_							request.requestDone(ioex)__						}_						catch (Throwable t) {_							IOManagerAsync.LOG.error("The handler of the request complete callback threw an exception"_									+ (t.getMessage() == null ? "." : ": " + t.getMessage()), t)__						}_					}_				}_			}_		};shuts,the,thread,down,this,operation,does,not,wait,for,all,pending,requests,to,be,served,halts,the,thread,immediately,all,buffers,of,pending,requests,are,handed,back,to,their,channel,readers,and,an,exception,is,reported,to,them,declaring,their,request,queue,as,closed;protected,void,shutdown,synchronized,this,if,alive,alive,false,request,queue,close,interrupt,try,join,1000,catch,interrupted,exception,e,ioexception,ioex,new,ioexception,io,manager,has,been,closed,while,this,request,queue,is,empty,read,request,request,this,request,queue,poll,if,request,null,try,request,request,done,ioex,catch,throwable,t,iomanager,async,log,error,the,handler,of,the,request,complete,callback,threw,an,exception,t,get,message,null,t,get,message,t
IOManagerAsync -> ReaderThread -> protected void shutdown();1441195974;Shuts the thread down. This operation does not wait for all pending requests to be served, halts the thread_immediately. All buffers of pending requests are handed back to their channel readers and an exception is_reported to them, declaring their request queue as closed.;protected void shutdown() {_			synchronized (this) {_				if (alive) {_					alive = false__					requestQueue.close()__					interrupt()__				}__				try {_					join(1000)__				}_				catch (InterruptedException ignored) {}_				_				_				IOException ioex = new IOException("IO-Manager has been closed.")__					_				while (!this.requestQueue.isEmpty()) {_					ReadRequest request = this.requestQueue.poll()__					if (request != null) {_						try {_							request.requestDone(ioex)__						}_						catch (Throwable t) {_							IOManagerAsync.LOG.error("The handler of the request complete callback threw an exception"_									+ (t.getMessage() == null ? "." : ": " + t.getMessage()), t)__						}_					}_				}_			}_		};shuts,the,thread,down,this,operation,does,not,wait,for,all,pending,requests,to,be,served,halts,the,thread,immediately,all,buffers,of,pending,requests,are,handed,back,to,their,channel,readers,and,an,exception,is,reported,to,them,declaring,their,request,queue,as,closed;protected,void,shutdown,synchronized,this,if,alive,alive,false,request,queue,close,interrupt,try,join,1000,catch,interrupted,exception,ignored,ioexception,ioex,new,ioexception,io,manager,has,been,closed,while,this,request,queue,is,empty,read,request,request,this,request,queue,poll,if,request,null,try,request,request,done,ioex,catch,throwable,t,iomanager,async,log,error,the,handler,of,the,request,complete,callback,threw,an,exception,t,get,message,null,t,get,message,t
IOManagerAsync -> ReaderThread -> protected void shutdown();1465991918;Shuts the thread down. This operation does not wait for all pending requests to be served, halts the thread_immediately. All buffers of pending requests are handed back to their channel readers and an exception is_reported to them, declaring their request queue as closed.;protected void shutdown() {_			synchronized (this) {_				if (alive) {_					alive = false__					requestQueue.close()__					interrupt()__				}__				try {_					join(1000)__				}_				catch (InterruptedException ignored) {}_				_				_				IOException ioex = new IOException("IO-Manager has been closed.")__					_				while (!this.requestQueue.isEmpty()) {_					ReadRequest request = this.requestQueue.poll()__					if (request != null) {_						try {_							request.requestDone(ioex)__						}_						catch (Throwable t) {_							IOManagerAsync.LOG.error("The handler of the request complete callback threw an exception"_									+ (t.getMessage() == null ? "." : ": " + t.getMessage()), t)__						}_					}_				}_			}_		};shuts,the,thread,down,this,operation,does,not,wait,for,all,pending,requests,to,be,served,halts,the,thread,immediately,all,buffers,of,pending,requests,are,handed,back,to,their,channel,readers,and,an,exception,is,reported,to,them,declaring,their,request,queue,as,closed;protected,void,shutdown,synchronized,this,if,alive,alive,false,request,queue,close,interrupt,try,join,1000,catch,interrupted,exception,ignored,ioexception,ioex,new,ioexception,io,manager,has,been,closed,while,this,request,queue,is,empty,read,request,request,this,request,queue,poll,if,request,null,try,request,request,done,ioex,catch,throwable,t,iomanager,async,log,error,the,handler,of,the,request,complete,callback,threw,an,exception,t,get,message,null,t,get,message,t
IOManagerAsync -> ReaderThread -> protected void shutdown();1519567828;Shuts the thread down. This operation does not wait for all pending requests to be served, halts the thread_immediately. All buffers of pending requests are handed back to their channel readers and an exception is_reported to them, declaring their request queue as closed.;protected void shutdown() {_			synchronized (this) {_				if (alive) {_					alive = false__					requestQueue.close()__					interrupt()__				}__				try {_					join(1000)__				}_				catch (InterruptedException ignored) {}_				_				_				IOException ioex = new IOException("IO-Manager has been closed.")__					_				while (!this.requestQueue.isEmpty()) {_					ReadRequest request = this.requestQueue.poll()__					if (request != null) {_						try {_							request.requestDone(ioex)__						}_						catch (Throwable t) {_							IOManagerAsync.LOG.error("The handler of the request complete callback threw an exception"_									+ (t.getMessage() == null ? "." : ": " + t.getMessage()), t)__						}_					}_				}_			}_		};shuts,the,thread,down,this,operation,does,not,wait,for,all,pending,requests,to,be,served,halts,the,thread,immediately,all,buffers,of,pending,requests,are,handed,back,to,their,channel,readers,and,an,exception,is,reported,to,them,declaring,their,request,queue,as,closed;protected,void,shutdown,synchronized,this,if,alive,alive,false,request,queue,close,interrupt,try,join,1000,catch,interrupted,exception,ignored,ioexception,ioex,new,ioexception,io,manager,has,been,closed,while,this,request,queue,is,empty,read,request,request,this,request,queue,poll,if,request,null,try,request,request,done,ioex,catch,throwable,t,iomanager,async,log,error,the,handler,of,the,request,complete,callback,threw,an,exception,t,get,message,null,t,get,message,t
IOManagerAsync -> ReaderThread -> protected void shutdown();1550673194;Shuts the thread down. This operation does not wait for all pending requests to be served, halts the thread_immediately. All buffers of pending requests are handed back to their channel readers and an exception is_reported to them, declaring their request queue as closed.;protected void shutdown() {_			synchronized (this) {_				if (alive) {_					alive = false__					requestQueue.close()__					interrupt()__				}__				try {_					join(1000)__				}_				catch (InterruptedException ignored) {}_				_				_				IOException ioex = new IOException("IO-Manager has been closed.")__					_				while (!this.requestQueue.isEmpty()) {_					ReadRequest request = this.requestQueue.poll()__					if (request != null) {_						try {_							request.requestDone(ioex)__						}_						catch (Throwable t) {_							IOManagerAsync.LOG.error("The handler of the request complete callback threw an exception"_									+ (t.getMessage() == null ? "." : ": " + t.getMessage()), t)__						}_					}_				}_			}_		};shuts,the,thread,down,this,operation,does,not,wait,for,all,pending,requests,to,be,served,halts,the,thread,immediately,all,buffers,of,pending,requests,are,handed,back,to,their,channel,readers,and,an,exception,is,reported,to,them,declaring,their,request,queue,as,closed;protected,void,shutdown,synchronized,this,if,alive,alive,false,request,queue,close,interrupt,try,join,1000,catch,interrupted,exception,ignored,ioexception,ioex,new,ioexception,io,manager,has,been,closed,while,this,request,queue,is,empty,read,request,request,this,request,queue,poll,if,request,null,try,request,request,done,ioex,catch,throwable,t,iomanager,async,log,error,the,handler,of,the,request,complete,callback,threw,an,exception,t,get,message,null,t,get,message,t
IOManagerAsync -> public IOManagerAsync(String tempDir);1415702894;Constructs a new asynchronous I/O manger, writing file to the given directory.__@param tempDir The directory to write temporary files to.;public IOManagerAsync(String tempDir) {_		this(new String[] {tempDir})__	};constructs,a,new,asynchronous,i,o,manger,writing,file,to,the,given,directory,param,temp,dir,the,directory,to,write,temporary,files,to;public,iomanager,async,string,temp,dir,this,new,string,temp,dir
IOManagerAsync -> public IOManagerAsync(String tempDir);1421050512;Constructs a new asynchronous I/O manger, writing file to the given directory.__@param tempDir The directory to write temporary files to.;public IOManagerAsync(String tempDir) {_		this(new String[] {tempDir})__	};constructs,a,new,asynchronous,i,o,manger,writing,file,to,the,given,directory,param,temp,dir,the,directory,to,write,temporary,files,to;public,iomanager,async,string,temp,dir,this,new,string,temp,dir
IOManagerAsync -> public IOManagerAsync(String tempDir);1421838095;Constructs a new asynchronous I/O manger, writing file to the given directory.__@param tempDir The directory to write temporary files to.;public IOManagerAsync(String tempDir) {_		this(new String[] {tempDir})__	};constructs,a,new,asynchronous,i,o,manger,writing,file,to,the,given,directory,param,temp,dir,the,directory,to,write,temporary,files,to;public,iomanager,async,string,temp,dir,this,new,string,temp,dir
IOManagerAsync -> public IOManagerAsync(String tempDir);1424338528;Constructs a new asynchronous I/O manger, writing file to the given directory.__@param tempDir The directory to write temporary files to.;public IOManagerAsync(String tempDir) {_		this(new String[] {tempDir})__	};constructs,a,new,asynchronous,i,o,manger,writing,file,to,the,given,directory,param,temp,dir,the,directory,to,write,temporary,files,to;public,iomanager,async,string,temp,dir,this,new,string,temp,dir
IOManagerAsync -> public IOManagerAsync(String tempDir);1426697080;Constructs a new asynchronous I/O manger, writing file to the given directory.__@param tempDir The directory to write temporary files to.;public IOManagerAsync(String tempDir) {_		this(new String[] {tempDir})__	};constructs,a,new,asynchronous,i,o,manger,writing,file,to,the,given,directory,param,temp,dir,the,directory,to,write,temporary,files,to;public,iomanager,async,string,temp,dir,this,new,string,temp,dir
IOManagerAsync -> public IOManagerAsync(String tempDir);1427820865;Constructs a new asynchronous I/O manger, writing file to the given directory.__@param tempDir The directory to write temporary files to.;public IOManagerAsync(String tempDir) {_		this(new String[] {tempDir})__	};constructs,a,new,asynchronous,i,o,manger,writing,file,to,the,given,directory,param,temp,dir,the,directory,to,write,temporary,files,to;public,iomanager,async,string,temp,dir,this,new,string,temp,dir
IOManagerAsync -> public IOManagerAsync(String tempDir);1441195974;Constructs a new asynchronous I/O manger, writing file to the given directory.__@param tempDir The directory to write temporary files to.;public IOManagerAsync(String tempDir) {_		this(new String[] {tempDir})__	};constructs,a,new,asynchronous,i,o,manger,writing,file,to,the,given,directory,param,temp,dir,the,directory,to,write,temporary,files,to;public,iomanager,async,string,temp,dir,this,new,string,temp,dir
IOManagerAsync -> public IOManagerAsync(String tempDir);1465991918;Constructs a new asynchronous I/O manger, writing file to the given directory.__@param tempDir The directory to write temporary files to.;public IOManagerAsync(String tempDir) {_		this(new String[] {tempDir})__	};constructs,a,new,asynchronous,i,o,manger,writing,file,to,the,given,directory,param,temp,dir,the,directory,to,write,temporary,files,to;public,iomanager,async,string,temp,dir,this,new,string,temp,dir
IOManagerAsync -> public IOManagerAsync(String tempDir);1519567828;Constructs a new asynchronous I/O manger, writing file to the given directory.__@param tempDir The directory to write temporary files to.;public IOManagerAsync(String tempDir) {_		this(new String[] {tempDir})__	};constructs,a,new,asynchronous,i,o,manger,writing,file,to,the,given,directory,param,temp,dir,the,directory,to,write,temporary,files,to;public,iomanager,async,string,temp,dir,this,new,string,temp,dir
IOManagerAsync -> public IOManagerAsync(String tempDir);1550673194;Constructs a new asynchronous I/O manager, writing file to the given directory.__@param tempDir The directory to write temporary files to.;public IOManagerAsync(String tempDir) {_		this(new String[] {tempDir})__	};constructs,a,new,asynchronous,i,o,manager,writing,file,to,the,given,directory,param,temp,dir,the,directory,to,write,temporary,files,to;public,iomanager,async,string,temp,dir,this,new,string,temp,dir
IOManagerAsync -> public IOManagerAsync(String[] tempDirs);1415702894;Constructs a new asynchronous I/O manger, writing file round robin across the given directories.__@param tempDirs The directories to write temporary files to.;public IOManagerAsync(String[] tempDirs) {_		super(tempDirs)__		_		_		this.writers = new WriterThread[tempDirs.length]__		for (int i = 0_ i < this.writers.length_ i++) {_			final WriterThread t = new WriterThread()__			this.writers[i] = t__			t.setName("IOManager writer thread #" + (i + 1))__			t.setDaemon(true)__			t.setUncaughtExceptionHandler(this)__			t.start()__		}__		_		this.readers = new ReaderThread[tempDirs.length]__		for (int i = 0_ i < this.readers.length_ i++) {_			final ReaderThread t = new ReaderThread()__			this.readers[i] = t__			t.setName("IOManager reader thread #" + (i + 1))__			t.setDaemon(true)__			t.setUncaughtExceptionHandler(this)__			t.start()__		}_	};constructs,a,new,asynchronous,i,o,manger,writing,file,round,robin,across,the,given,directories,param,temp,dirs,the,directories,to,write,temporary,files,to;public,iomanager,async,string,temp,dirs,super,temp,dirs,this,writers,new,writer,thread,temp,dirs,length,for,int,i,0,i,this,writers,length,i,final,writer,thread,t,new,writer,thread,this,writers,i,t,t,set,name,iomanager,writer,thread,i,1,t,set,daemon,true,t,set,uncaught,exception,handler,this,t,start,this,readers,new,reader,thread,temp,dirs,length,for,int,i,0,i,this,readers,length,i,final,reader,thread,t,new,reader,thread,this,readers,i,t,t,set,name,iomanager,reader,thread,i,1,t,set,daemon,true,t,set,uncaught,exception,handler,this,t,start
IOManagerAsync -> public IOManagerAsync(String[] tempDirs);1421050512;Constructs a new asynchronous I/O manger, writing file round robin across the given directories.__@param tempDirs The directories to write temporary files to.;public IOManagerAsync(String[] tempDirs) {_		super(tempDirs)__		_		_		this.writers = new WriterThread[tempDirs.length]__		for (int i = 0_ i < this.writers.length_ i++) {_			final WriterThread t = new WriterThread()__			this.writers[i] = t__			t.setName("IOManager writer thread #" + (i + 1))__			t.setDaemon(true)__			t.setUncaughtExceptionHandler(this)__			t.start()__		}__		_		this.readers = new ReaderThread[tempDirs.length]__		for (int i = 0_ i < this.readers.length_ i++) {_			final ReaderThread t = new ReaderThread()__			this.readers[i] = t__			t.setName("IOManager reader thread #" + (i + 1))__			t.setDaemon(true)__			t.setUncaughtExceptionHandler(this)__			t.start()__		}_	};constructs,a,new,asynchronous,i,o,manger,writing,file,round,robin,across,the,given,directories,param,temp,dirs,the,directories,to,write,temporary,files,to;public,iomanager,async,string,temp,dirs,super,temp,dirs,this,writers,new,writer,thread,temp,dirs,length,for,int,i,0,i,this,writers,length,i,final,writer,thread,t,new,writer,thread,this,writers,i,t,t,set,name,iomanager,writer,thread,i,1,t,set,daemon,true,t,set,uncaught,exception,handler,this,t,start,this,readers,new,reader,thread,temp,dirs,length,for,int,i,0,i,this,readers,length,i,final,reader,thread,t,new,reader,thread,this,readers,i,t,t,set,name,iomanager,reader,thread,i,1,t,set,daemon,true,t,set,uncaught,exception,handler,this,t,start
IOManagerAsync -> public IOManagerAsync(String[] tempDirs);1421838095;Constructs a new asynchronous I/O manger, writing file round robin across the given directories.__@param tempDirs The directories to write temporary files to.;public IOManagerAsync(String[] tempDirs) {_		super(tempDirs)__		_		_		this.writers = new WriterThread[tempDirs.length]__		for (int i = 0_ i < this.writers.length_ i++) {_			final WriterThread t = new WriterThread()__			this.writers[i] = t__			t.setName("IOManager writer thread #" + (i + 1))__			t.setDaemon(true)__			t.setUncaughtExceptionHandler(this)__			t.start()__		}__		_		this.readers = new ReaderThread[tempDirs.length]__		for (int i = 0_ i < this.readers.length_ i++) {_			final ReaderThread t = new ReaderThread()__			this.readers[i] = t__			t.setName("IOManager reader thread #" + (i + 1))__			t.setDaemon(true)__			t.setUncaughtExceptionHandler(this)__			t.start()__		}_	};constructs,a,new,asynchronous,i,o,manger,writing,file,round,robin,across,the,given,directories,param,temp,dirs,the,directories,to,write,temporary,files,to;public,iomanager,async,string,temp,dirs,super,temp,dirs,this,writers,new,writer,thread,temp,dirs,length,for,int,i,0,i,this,writers,length,i,final,writer,thread,t,new,writer,thread,this,writers,i,t,t,set,name,iomanager,writer,thread,i,1,t,set,daemon,true,t,set,uncaught,exception,handler,this,t,start,this,readers,new,reader,thread,temp,dirs,length,for,int,i,0,i,this,readers,length,i,final,reader,thread,t,new,reader,thread,this,readers,i,t,t,set,name,iomanager,reader,thread,i,1,t,set,daemon,true,t,set,uncaught,exception,handler,this,t,start
IOManagerAsync -> public IOManagerAsync(String[] tempDirs);1424338528;Constructs a new asynchronous I/O manger, writing file round robin across the given directories.__@param tempDirs The directories to write temporary files to.;public IOManagerAsync(String[] tempDirs) {_		super(tempDirs)__		_		_		this.writers = new WriterThread[tempDirs.length]__		for (int i = 0_ i < this.writers.length_ i++) {_			final WriterThread t = new WriterThread()__			this.writers[i] = t__			t.setName("IOManager writer thread #" + (i + 1))__			t.setDaemon(true)__			t.setUncaughtExceptionHandler(this)__			t.start()__		}__		_		this.readers = new ReaderThread[tempDirs.length]__		for (int i = 0_ i < this.readers.length_ i++) {_			final ReaderThread t = new ReaderThread()__			this.readers[i] = t__			t.setName("IOManager reader thread #" + (i + 1))__			t.setDaemon(true)__			t.setUncaughtExceptionHandler(this)__			t.start()__		}_	};constructs,a,new,asynchronous,i,o,manger,writing,file,round,robin,across,the,given,directories,param,temp,dirs,the,directories,to,write,temporary,files,to;public,iomanager,async,string,temp,dirs,super,temp,dirs,this,writers,new,writer,thread,temp,dirs,length,for,int,i,0,i,this,writers,length,i,final,writer,thread,t,new,writer,thread,this,writers,i,t,t,set,name,iomanager,writer,thread,i,1,t,set,daemon,true,t,set,uncaught,exception,handler,this,t,start,this,readers,new,reader,thread,temp,dirs,length,for,int,i,0,i,this,readers,length,i,final,reader,thread,t,new,reader,thread,this,readers,i,t,t,set,name,iomanager,reader,thread,i,1,t,set,daemon,true,t,set,uncaught,exception,handler,this,t,start
IOManagerAsync -> public IOManagerAsync(String[] tempDirs);1426697080;Constructs a new asynchronous I/O manger, writing file round robin across the given directories.__@param tempDirs The directories to write temporary files to.;public IOManagerAsync(String[] tempDirs) {_		super(tempDirs)__		_		_		this.writers = new WriterThread[tempDirs.length]__		for (int i = 0_ i < this.writers.length_ i++) {_			final WriterThread t = new WriterThread()__			this.writers[i] = t__			t.setName("IOManager writer thread #" + (i + 1))__			t.setDaemon(true)__			t.setUncaughtExceptionHandler(this)__			t.start()__		}__		_		this.readers = new ReaderThread[tempDirs.length]__		for (int i = 0_ i < this.readers.length_ i++) {_			final ReaderThread t = new ReaderThread()__			this.readers[i] = t__			t.setName("IOManager reader thread #" + (i + 1))__			t.setDaemon(true)__			t.setUncaughtExceptionHandler(this)__			t.start()__		}_	};constructs,a,new,asynchronous,i,o,manger,writing,file,round,robin,across,the,given,directories,param,temp,dirs,the,directories,to,write,temporary,files,to;public,iomanager,async,string,temp,dirs,super,temp,dirs,this,writers,new,writer,thread,temp,dirs,length,for,int,i,0,i,this,writers,length,i,final,writer,thread,t,new,writer,thread,this,writers,i,t,t,set,name,iomanager,writer,thread,i,1,t,set,daemon,true,t,set,uncaught,exception,handler,this,t,start,this,readers,new,reader,thread,temp,dirs,length,for,int,i,0,i,this,readers,length,i,final,reader,thread,t,new,reader,thread,this,readers,i,t,t,set,name,iomanager,reader,thread,i,1,t,set,daemon,true,t,set,uncaught,exception,handler,this,t,start
IOManagerAsync -> public IOManagerAsync(String[] tempDirs);1427820865;Constructs a new asynchronous I/O manger, writing file round robin across the given directories.__@param tempDirs The directories to write temporary files to.;public IOManagerAsync(String[] tempDirs) {_		super(tempDirs)__		_		_		this.writers = new WriterThread[tempDirs.length]__		for (int i = 0_ i < this.writers.length_ i++) {_			final WriterThread t = new WriterThread()__			this.writers[i] = t__			t.setName("IOManager writer thread #" + (i + 1))__			t.setDaemon(true)__			t.setUncaughtExceptionHandler(this)__			t.start()__		}__		_		this.readers = new ReaderThread[tempDirs.length]__		for (int i = 0_ i < this.readers.length_ i++) {_			final ReaderThread t = new ReaderThread()__			this.readers[i] = t__			t.setName("IOManager reader thread #" + (i + 1))__			t.setDaemon(true)__			t.setUncaughtExceptionHandler(this)__			t.start()__		}_	};constructs,a,new,asynchronous,i,o,manger,writing,file,round,robin,across,the,given,directories,param,temp,dirs,the,directories,to,write,temporary,files,to;public,iomanager,async,string,temp,dirs,super,temp,dirs,this,writers,new,writer,thread,temp,dirs,length,for,int,i,0,i,this,writers,length,i,final,writer,thread,t,new,writer,thread,this,writers,i,t,t,set,name,iomanager,writer,thread,i,1,t,set,daemon,true,t,set,uncaught,exception,handler,this,t,start,this,readers,new,reader,thread,temp,dirs,length,for,int,i,0,i,this,readers,length,i,final,reader,thread,t,new,reader,thread,this,readers,i,t,t,set,name,iomanager,reader,thread,i,1,t,set,daemon,true,t,set,uncaught,exception,handler,this,t,start
IOManagerAsync -> public IOManagerAsync(String[] tempDirs);1441195974;Constructs a new asynchronous I/O manger, writing file round robin across the given directories.__@param tempDirs The directories to write temporary files to.;public IOManagerAsync(String[] tempDirs) {_		super(tempDirs)__		_		_		this.writers = new WriterThread[tempDirs.length]__		for (int i = 0_ i < this.writers.length_ i++) {_			final WriterThread t = new WriterThread()__			this.writers[i] = t__			t.setName("IOManager writer thread #" + (i + 1))__			t.setDaemon(true)__			t.setUncaughtExceptionHandler(this)__			t.start()__		}__		_		this.readers = new ReaderThread[tempDirs.length]__		for (int i = 0_ i < this.readers.length_ i++) {_			final ReaderThread t = new ReaderThread()__			this.readers[i] = t__			t.setName("IOManager reader thread #" + (i + 1))__			t.setDaemon(true)__			t.setUncaughtExceptionHandler(this)__			t.start()__		}__		_		this.shutdownHook = new Thread("I/O manager shutdown hook") {_			@Override_			public void run() {_				shutdown()__			}_		}__		try {_			Runtime.getRuntime().addShutdownHook(this.shutdownHook)__		}_		catch (IllegalStateException e) {_			_			LOG.debug("Unable to add shutdown hook, shutdown already in progress", e)__		}_		catch (Throwable t) {_			LOG.warn("Error while adding shutdown hook for IOManager", t)__		}_	};constructs,a,new,asynchronous,i,o,manger,writing,file,round,robin,across,the,given,directories,param,temp,dirs,the,directories,to,write,temporary,files,to;public,iomanager,async,string,temp,dirs,super,temp,dirs,this,writers,new,writer,thread,temp,dirs,length,for,int,i,0,i,this,writers,length,i,final,writer,thread,t,new,writer,thread,this,writers,i,t,t,set,name,iomanager,writer,thread,i,1,t,set,daemon,true,t,set,uncaught,exception,handler,this,t,start,this,readers,new,reader,thread,temp,dirs,length,for,int,i,0,i,this,readers,length,i,final,reader,thread,t,new,reader,thread,this,readers,i,t,t,set,name,iomanager,reader,thread,i,1,t,set,daemon,true,t,set,uncaught,exception,handler,this,t,start,this,shutdown,hook,new,thread,i,o,manager,shutdown,hook,override,public,void,run,shutdown,try,runtime,get,runtime,add,shutdown,hook,this,shutdown,hook,catch,illegal,state,exception,e,log,debug,unable,to,add,shutdown,hook,shutdown,already,in,progress,e,catch,throwable,t,log,warn,error,while,adding,shutdown,hook,for,iomanager,t
IOManagerAsync -> public IOManagerAsync(String[] tempDirs);1465991918;Constructs a new asynchronous I/O manger, writing file round robin across the given directories.__@param tempDirs The directories to write temporary files to.;public IOManagerAsync(String[] tempDirs) {_		super(tempDirs)__		_		_		this.writers = new WriterThread[tempDirs.length]__		for (int i = 0_ i < this.writers.length_ i++) {_			final WriterThread t = new WriterThread()__			this.writers[i] = t__			t.setName("IOManager writer thread #" + (i + 1))__			t.setDaemon(true)__			t.setUncaughtExceptionHandler(this)__			t.start()__		}__		_		this.readers = new ReaderThread[tempDirs.length]__		for (int i = 0_ i < this.readers.length_ i++) {_			final ReaderThread t = new ReaderThread()__			this.readers[i] = t__			t.setName("IOManager reader thread #" + (i + 1))__			t.setDaemon(true)__			t.setUncaughtExceptionHandler(this)__			t.start()__		}__		_		this.shutdownHook = new Thread("I/O manager shutdown hook") {_			@Override_			public void run() {_				shutdown()__			}_		}__		try {_			Runtime.getRuntime().addShutdownHook(this.shutdownHook)__		}_		catch (IllegalStateException e) {_			_			LOG.debug("Unable to add shutdown hook, shutdown already in progress", e)__		}_		catch (Throwable t) {_			LOG.warn("Error while adding shutdown hook for IOManager", t)__		}_	};constructs,a,new,asynchronous,i,o,manger,writing,file,round,robin,across,the,given,directories,param,temp,dirs,the,directories,to,write,temporary,files,to;public,iomanager,async,string,temp,dirs,super,temp,dirs,this,writers,new,writer,thread,temp,dirs,length,for,int,i,0,i,this,writers,length,i,final,writer,thread,t,new,writer,thread,this,writers,i,t,t,set,name,iomanager,writer,thread,i,1,t,set,daemon,true,t,set,uncaught,exception,handler,this,t,start,this,readers,new,reader,thread,temp,dirs,length,for,int,i,0,i,this,readers,length,i,final,reader,thread,t,new,reader,thread,this,readers,i,t,t,set,name,iomanager,reader,thread,i,1,t,set,daemon,true,t,set,uncaught,exception,handler,this,t,start,this,shutdown,hook,new,thread,i,o,manager,shutdown,hook,override,public,void,run,shutdown,try,runtime,get,runtime,add,shutdown,hook,this,shutdown,hook,catch,illegal,state,exception,e,log,debug,unable,to,add,shutdown,hook,shutdown,already,in,progress,e,catch,throwable,t,log,warn,error,while,adding,shutdown,hook,for,iomanager,t
IOManagerAsync -> public IOManagerAsync(String[] tempDirs);1519567828;Constructs a new asynchronous I/O manger, writing file round robin across the given directories.__@param tempDirs The directories to write temporary files to.;public IOManagerAsync(String[] tempDirs) {_		super(tempDirs)__		_		_		this.writers = new WriterThread[tempDirs.length]__		for (int i = 0_ i < this.writers.length_ i++) {_			final WriterThread t = new WriterThread()__			this.writers[i] = t__			t.setName("IOManager writer thread #" + (i + 1))__			t.setDaemon(true)__			t.setUncaughtExceptionHandler(this)__			t.start()__		}__		_		this.readers = new ReaderThread[tempDirs.length]__		for (int i = 0_ i < this.readers.length_ i++) {_			final ReaderThread t = new ReaderThread()__			this.readers[i] = t__			t.setName("IOManager reader thread #" + (i + 1))__			t.setDaemon(true)__			t.setUncaughtExceptionHandler(this)__			t.start()__		}__		_		this.shutdownHook = ShutdownHookUtil.addShutdownHook(this::shutdown, getClass().getSimpleName(), LOG)__	};constructs,a,new,asynchronous,i,o,manger,writing,file,round,robin,across,the,given,directories,param,temp,dirs,the,directories,to,write,temporary,files,to;public,iomanager,async,string,temp,dirs,super,temp,dirs,this,writers,new,writer,thread,temp,dirs,length,for,int,i,0,i,this,writers,length,i,final,writer,thread,t,new,writer,thread,this,writers,i,t,t,set,name,iomanager,writer,thread,i,1,t,set,daemon,true,t,set,uncaught,exception,handler,this,t,start,this,readers,new,reader,thread,temp,dirs,length,for,int,i,0,i,this,readers,length,i,final,reader,thread,t,new,reader,thread,this,readers,i,t,t,set,name,iomanager,reader,thread,i,1,t,set,daemon,true,t,set,uncaught,exception,handler,this,t,start,this,shutdown,hook,shutdown,hook,util,add,shutdown,hook,this,shutdown,get,class,get,simple,name,log
IOManagerAsync -> public IOManagerAsync(String[] tempDirs);1550673194;Constructs a new asynchronous I/O manager, writing file round robin across the given directories.__@param tempDirs The directories to write temporary files to.;public IOManagerAsync(String[] tempDirs) {_		super(tempDirs)__		_		_		this.writers = new WriterThread[tempDirs.length]__		for (int i = 0_ i < this.writers.length_ i++) {_			final WriterThread t = new WriterThread()__			this.writers[i] = t__			t.setName("IOManager writer thread #" + (i + 1))__			t.setDaemon(true)__			t.setUncaughtExceptionHandler(this)__			t.start()__		}__		_		this.readers = new ReaderThread[tempDirs.length]__		for (int i = 0_ i < this.readers.length_ i++) {_			final ReaderThread t = new ReaderThread()__			this.readers[i] = t__			t.setName("IOManager reader thread #" + (i + 1))__			t.setDaemon(true)__			t.setUncaughtExceptionHandler(this)__			t.start()__		}__		_		this.shutdownHook = ShutdownHookUtil.addShutdownHook(this::shutdown, getClass().getSimpleName(), LOG)__	};constructs,a,new,asynchronous,i,o,manager,writing,file,round,robin,across,the,given,directories,param,temp,dirs,the,directories,to,write,temporary,files,to;public,iomanager,async,string,temp,dirs,super,temp,dirs,this,writers,new,writer,thread,temp,dirs,length,for,int,i,0,i,this,writers,length,i,final,writer,thread,t,new,writer,thread,this,writers,i,t,t,set,name,iomanager,writer,thread,i,1,t,set,daemon,true,t,set,uncaught,exception,handler,this,t,start,this,readers,new,reader,thread,temp,dirs,length,for,int,i,0,i,this,readers,length,i,final,reader,thread,t,new,reader,thread,this,readers,i,t,t,set,name,iomanager,reader,thread,i,1,t,set,daemon,true,t,set,uncaught,exception,handler,this,t,start,this,shutdown,hook,shutdown,hook,util,add,shutdown,hook,this,shutdown,get,class,get,simple,name,log
