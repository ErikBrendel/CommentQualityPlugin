# id;timestamp;commentText;codeText;commentWords;codeWords
PartitionRequestClient -> public void sendTaskEvent(ResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException;1420560668;Sends a task event backwards to an intermediate result partition producer._<p>_Backwards task events flow between readers and writers and therefore_will only work when both are running at the same time, which is only_guaranteed to be the case when both the respective producer and_consumer task run pipelined.;public void sendTaskEvent(ResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException {__		tcpChannel.writeAndFlush(new TaskEventRequest(event, partitionId, inputChannel.getInputChannelId()))_				.addListener(_						new ChannelFutureListener() {_							@Override_							public void operationComplete(ChannelFuture future) throws Exception {_								if (!future.isSuccess()) {_									inputChannel.onError(future.cause())__								}_							}_						})__	};sends,a,task,event,backwards,to,an,intermediate,result,partition,producer,p,backwards,task,events,flow,between,readers,and,writers,and,therefore,will,only,work,when,both,are,running,at,the,same,time,which,is,only,guaranteed,to,be,the,case,when,both,the,respective,producer,and,consumer,task,run,pipelined;public,void,send,task,event,result,partition,id,partition,id,task,event,event,final,remote,input,channel,input,channel,throws,ioexception,tcp,channel,write,and,flush,new,task,event,request,event,partition,id,input,channel,get,input,channel,id,add,listener,new,channel,future,listener,override,public,void,operation,complete,channel,future,future,throws,exception,if,future,is,success,input,channel,on,error,future,cause
PartitionRequestClient -> public void sendTaskEvent(ResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException;1427189152;Sends a task event backwards to an intermediate result partition producer._<p>_Backwards task events flow between readers and writers and therefore_will only work when both are running at the same time, which is only_guaranteed to be the case when both the respective producer and_consumer task run pipelined.;public void sendTaskEvent(ResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException {__		tcpChannel.writeAndFlush(new TaskEventRequest(event, partitionId, inputChannel.getInputChannelId()))_				.addListener(_						new ChannelFutureListener() {_							@Override_							public void operationComplete(ChannelFuture future) throws Exception {_								if (!future.isSuccess()) {_									inputChannel.onError(future.cause())__								}_							}_						})__	};sends,a,task,event,backwards,to,an,intermediate,result,partition,producer,p,backwards,task,events,flow,between,readers,and,writers,and,therefore,will,only,work,when,both,are,running,at,the,same,time,which,is,only,guaranteed,to,be,the,case,when,both,the,respective,producer,and,consumer,task,run,pipelined;public,void,send,task,event,result,partition,id,partition,id,task,event,event,final,remote,input,channel,input,channel,throws,ioexception,tcp,channel,write,and,flush,new,task,event,request,event,partition,id,input,channel,get,input,channel,id,add,listener,new,channel,future,listener,override,public,void,operation,complete,channel,future,future,throws,exception,if,future,is,success,input,channel,on,error,future,cause
PartitionRequestClient -> public void sendTaskEvent(ResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException;1431354895;Sends a task event backwards to an intermediate result partition producer._<p>_Backwards task events flow between readers and writers and therefore_will only work when both are running at the same time, which is only_guaranteed to be the case when both the respective producer and_consumer task run pipelined.;public void sendTaskEvent(ResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException {__		tcpChannel.writeAndFlush(new TaskEventRequest(event, partitionId, inputChannel.getInputChannelId()))_				.addListener(_						new ChannelFutureListener() {_							@Override_							public void operationComplete(ChannelFuture future) throws Exception {_								if (!future.isSuccess()) {_									inputChannel.onError(future.cause())__								}_							}_						})__	};sends,a,task,event,backwards,to,an,intermediate,result,partition,producer,p,backwards,task,events,flow,between,readers,and,writers,and,therefore,will,only,work,when,both,are,running,at,the,same,time,which,is,only,guaranteed,to,be,the,case,when,both,the,respective,producer,and,consumer,task,run,pipelined;public,void,send,task,event,result,partition,id,partition,id,task,event,event,final,remote,input,channel,input,channel,throws,ioexception,tcp,channel,write,and,flush,new,task,event,request,event,partition,id,input,channel,get,input,channel,id,add,listener,new,channel,future,listener,override,public,void,operation,complete,channel,future,future,throws,exception,if,future,is,success,input,channel,on,error,future,cause
PartitionRequestClient -> public void sendTaskEvent(ResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException;1432127765;Sends a task event backwards to an intermediate result partition producer._<p>_Backwards task events flow between readers and writers and therefore_will only work when both are running at the same time, which is only_guaranteed to be the case when both the respective producer and_consumer task run pipelined.;public void sendTaskEvent(ResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException {__		tcpChannel.writeAndFlush(new TaskEventRequest(event, partitionId, inputChannel.getInputChannelId()))_				.addListener(_						new ChannelFutureListener() {_							@Override_							public void operationComplete(ChannelFuture future) throws Exception {_								if (!future.isSuccess()) {_									inputChannel.onError(new LocalTransportException(_											"Sending the task event failed.",_											future.channel().localAddress(), future.cause()_									))__								}_							}_						})__	};sends,a,task,event,backwards,to,an,intermediate,result,partition,producer,p,backwards,task,events,flow,between,readers,and,writers,and,therefore,will,only,work,when,both,are,running,at,the,same,time,which,is,only,guaranteed,to,be,the,case,when,both,the,respective,producer,and,consumer,task,run,pipelined;public,void,send,task,event,result,partition,id,partition,id,task,event,event,final,remote,input,channel,input,channel,throws,ioexception,tcp,channel,write,and,flush,new,task,event,request,event,partition,id,input,channel,get,input,channel,id,add,listener,new,channel,future,listener,override,public,void,operation,complete,channel,future,future,throws,exception,if,future,is,success,input,channel,on,error,new,local,transport,exception,sending,the,task,event,failed,future,channel,local,address,future,cause
PartitionRequestClient -> public void sendTaskEvent(ResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException;1432806352;Sends a task event backwards to an intermediate result partition producer._<p>_Backwards task events flow between readers and writers and therefore_will only work when both are running at the same time, which is only_guaranteed to be the case when both the respective producer and_consumer task run pipelined.;public void sendTaskEvent(ResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException {__		tcpChannel.writeAndFlush(new TaskEventRequest(event, partitionId, inputChannel.getInputChannelId()))_				.addListener(_						new ChannelFutureListener() {_							@Override_							public void operationComplete(ChannelFuture future) throws Exception {_								if (!future.isSuccess()) {_									inputChannel.onError(new LocalTransportException(_											"Sending the task event failed.",_											future.channel().localAddress(), future.cause()_									))__								}_							}_						})__	};sends,a,task,event,backwards,to,an,intermediate,result,partition,producer,p,backwards,task,events,flow,between,readers,and,writers,and,therefore,will,only,work,when,both,are,running,at,the,same,time,which,is,only,guaranteed,to,be,the,case,when,both,the,respective,producer,and,consumer,task,run,pipelined;public,void,send,task,event,result,partition,id,partition,id,task,event,event,final,remote,input,channel,input,channel,throws,ioexception,tcp,channel,write,and,flush,new,task,event,request,event,partition,id,input,channel,get,input,channel,id,add,listener,new,channel,future,listener,override,public,void,operation,complete,channel,future,future,throws,exception,if,future,is,success,input,channel,on,error,new,local,transport,exception,sending,the,task,event,failed,future,channel,local,address,future,cause
PartitionRequestClient -> public void sendTaskEvent(ResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException;1433349700;Sends a task event backwards to an intermediate result partition producer._<p>_Backwards task events flow between readers and writers and therefore_will only work when both are running at the same time, which is only_guaranteed to be the case when both the respective producer and_consumer task run pipelined.;public void sendTaskEvent(ResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException {_		checkNotClosed()___		tcpChannel.writeAndFlush(new TaskEventRequest(event, partitionId, inputChannel.getInputChannelId()))_				.addListener(_						new ChannelFutureListener() {_							@Override_							public void operationComplete(ChannelFuture future) throws Exception {_								if (!future.isSuccess()) {_									inputChannel.onError(new LocalTransportException(_											"Sending the task event failed.",_											future.channel().localAddress(), future.cause()_									))__								}_							}_						})__	};sends,a,task,event,backwards,to,an,intermediate,result,partition,producer,p,backwards,task,events,flow,between,readers,and,writers,and,therefore,will,only,work,when,both,are,running,at,the,same,time,which,is,only,guaranteed,to,be,the,case,when,both,the,respective,producer,and,consumer,task,run,pipelined;public,void,send,task,event,result,partition,id,partition,id,task,event,event,final,remote,input,channel,input,channel,throws,ioexception,check,not,closed,tcp,channel,write,and,flush,new,task,event,request,event,partition,id,input,channel,get,input,channel,id,add,listener,new,channel,future,listener,override,public,void,operation,complete,channel,future,future,throws,exception,if,future,is,success,input,channel,on,error,new,local,transport,exception,sending,the,task,event,failed,future,channel,local,address,future,cause
PartitionRequestClient -> public void sendTaskEvent(ResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException;1438275734;Sends a task event backwards to an intermediate result partition producer._<p>_Backwards task events flow between readers and writers and therefore_will only work when both are running at the same time, which is only_guaranteed to be the case when both the respective producer and_consumer task run pipelined.;public void sendTaskEvent(ResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException {_		checkNotClosed()___		tcpChannel.writeAndFlush(new TaskEventRequest(event, partitionId, inputChannel.getInputChannelId()))_				.addListener(_						new ChannelFutureListener() {_							@Override_							public void operationComplete(ChannelFuture future) throws Exception {_								if (!future.isSuccess()) {_									inputChannel.onError(new LocalTransportException(_											"Sending the task event failed.",_											future.channel().localAddress(), future.cause()_									))__								}_							}_						})__	};sends,a,task,event,backwards,to,an,intermediate,result,partition,producer,p,backwards,task,events,flow,between,readers,and,writers,and,therefore,will,only,work,when,both,are,running,at,the,same,time,which,is,only,guaranteed,to,be,the,case,when,both,the,respective,producer,and,consumer,task,run,pipelined;public,void,send,task,event,result,partition,id,partition,id,task,event,event,final,remote,input,channel,input,channel,throws,ioexception,check,not,closed,tcp,channel,write,and,flush,new,task,event,request,event,partition,id,input,channel,get,input,channel,id,add,listener,new,channel,future,listener,override,public,void,operation,complete,channel,future,future,throws,exception,if,future,is,success,input,channel,on,error,new,local,transport,exception,sending,the,task,event,failed,future,channel,local,address,future,cause
PartitionRequestClient -> public void sendTaskEvent(ResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException;1455130280;Sends a task event backwards to an intermediate result partition producer._<p>_Backwards task events flow between readers and writers and therefore_will only work when both are running at the same time, which is only_guaranteed to be the case when both the respective producer and_consumer task run pipelined.;public void sendTaskEvent(ResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException {_		checkNotClosed()___		tcpChannel.writeAndFlush(new TaskEventRequest(event, partitionId, inputChannel.getInputChannelId()))_				.addListener(_						new ChannelFutureListener() {_							@Override_							public void operationComplete(ChannelFuture future) throws Exception {_								if (!future.isSuccess()) {_									inputChannel.onError(new LocalTransportException(_											"Sending the task event failed.",_											future.cause()_									))__								}_							}_						})__	};sends,a,task,event,backwards,to,an,intermediate,result,partition,producer,p,backwards,task,events,flow,between,readers,and,writers,and,therefore,will,only,work,when,both,are,running,at,the,same,time,which,is,only,guaranteed,to,be,the,case,when,both,the,respective,producer,and,consumer,task,run,pipelined;public,void,send,task,event,result,partition,id,partition,id,task,event,event,final,remote,input,channel,input,channel,throws,ioexception,check,not,closed,tcp,channel,write,and,flush,new,task,event,request,event,partition,id,input,channel,get,input,channel,id,add,listener,new,channel,future,listener,override,public,void,operation,complete,channel,future,future,throws,exception,if,future,is,success,input,channel,on,error,new,local,transport,exception,sending,the,task,event,failed,future,cause
PartitionRequestClient -> public void sendTaskEvent(ResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException;1455534790;Sends a task event backwards to an intermediate result partition producer._<p>_Backwards task events flow between readers and writers and therefore_will only work when both are running at the same time, which is only_guaranteed to be the case when both the respective producer and_consumer task run pipelined.;public void sendTaskEvent(ResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException {_		checkNotClosed()___		tcpChannel.writeAndFlush(new TaskEventRequest(event, partitionId, inputChannel.getInputChannelId()))_				.addListener(_						new ChannelFutureListener() {_							@Override_							public void operationComplete(ChannelFuture future) throws Exception {_								if (!future.isSuccess()) {_									inputChannel.onError(new LocalTransportException(_											"Sending the task event failed.",_											future.channel().localAddress(), future.cause()_									))__								}_							}_						})__	};sends,a,task,event,backwards,to,an,intermediate,result,partition,producer,p,backwards,task,events,flow,between,readers,and,writers,and,therefore,will,only,work,when,both,are,running,at,the,same,time,which,is,only,guaranteed,to,be,the,case,when,both,the,respective,producer,and,consumer,task,run,pipelined;public,void,send,task,event,result,partition,id,partition,id,task,event,event,final,remote,input,channel,input,channel,throws,ioexception,check,not,closed,tcp,channel,write,and,flush,new,task,event,request,event,partition,id,input,channel,get,input,channel,id,add,listener,new,channel,future,listener,override,public,void,operation,complete,channel,future,future,throws,exception,if,future,is,success,input,channel,on,error,new,local,transport,exception,sending,the,task,event,failed,future,channel,local,address,future,cause
PartitionRequestClient -> public void sendTaskEvent(ResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException;1465394479;Sends a task event backwards to an intermediate result partition producer._<p>_Backwards task events flow between readers and writers and therefore_will only work when both are running at the same time, which is only_guaranteed to be the case when both the respective producer and_consumer task run pipelined.;public void sendTaskEvent(ResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException {_		checkNotClosed()___		tcpChannel.writeAndFlush(new TaskEventRequest(event, partitionId, inputChannel.getInputChannelId()))_				.addListener(_						new ChannelFutureListener() {_							@Override_							public void operationComplete(ChannelFuture future) throws Exception {_								if (!future.isSuccess()) {_									inputChannel.onError(new LocalTransportException(_											"Sending the task event failed.",_											future.channel().localAddress(), future.cause()_									))__								}_							}_						})__	};sends,a,task,event,backwards,to,an,intermediate,result,partition,producer,p,backwards,task,events,flow,between,readers,and,writers,and,therefore,will,only,work,when,both,are,running,at,the,same,time,which,is,only,guaranteed,to,be,the,case,when,both,the,respective,producer,and,consumer,task,run,pipelined;public,void,send,task,event,result,partition,id,partition,id,task,event,event,final,remote,input,channel,input,channel,throws,ioexception,check,not,closed,tcp,channel,write,and,flush,new,task,event,request,event,partition,id,input,channel,get,input,channel,id,add,listener,new,channel,future,listener,override,public,void,operation,complete,channel,future,future,throws,exception,if,future,is,success,input,channel,on,error,new,local,transport,exception,sending,the,task,event,failed,future,channel,local,address,future,cause
PartitionRequestClient -> public void sendTaskEvent(ResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException;1498566436;Sends a task event backwards to an intermediate result partition producer._<p>_Backwards task events flow between readers and writers and therefore_will only work when both are running at the same time, which is only_guaranteed to be the case when both the respective producer and_consumer task run pipelined.;public void sendTaskEvent(ResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException {_		checkNotClosed()___		tcpChannel.writeAndFlush(new TaskEventRequest(event, partitionId, inputChannel.getInputChannelId()))_				.addListener(_						new ChannelFutureListener() {_							@Override_							public void operationComplete(ChannelFuture future) throws Exception {_								if (!future.isSuccess()) {_									inputChannel.onError(new LocalTransportException(_											"Sending the task event failed.",_											future.channel().localAddress(), future.cause()_									))__								}_							}_						})__	};sends,a,task,event,backwards,to,an,intermediate,result,partition,producer,p,backwards,task,events,flow,between,readers,and,writers,and,therefore,will,only,work,when,both,are,running,at,the,same,time,which,is,only,guaranteed,to,be,the,case,when,both,the,respective,producer,and,consumer,task,run,pipelined;public,void,send,task,event,result,partition,id,partition,id,task,event,event,final,remote,input,channel,input,channel,throws,ioexception,check,not,closed,tcp,channel,write,and,flush,new,task,event,request,event,partition,id,input,channel,get,input,channel,id,add,listener,new,channel,future,listener,override,public,void,operation,complete,channel,future,future,throws,exception,if,future,is,success,input,channel,on,error,new,local,transport,exception,sending,the,task,event,failed,future,channel,local,address,future,cause
PartitionRequestClient -> public void sendTaskEvent(ResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException;1505982496;Sends a task event backwards to an intermediate result partition producer._<p>_Backwards task events flow between readers and writers and therefore_will only work when both are running at the same time, which is only_guaranteed to be the case when both the respective producer and_consumer task run pipelined.;public void sendTaskEvent(ResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException {_		checkNotClosed()___		tcpChannel.writeAndFlush(new TaskEventRequest(event, partitionId, inputChannel.getInputChannelId()))_				.addListener(_						new ChannelFutureListener() {_							@Override_							public void operationComplete(ChannelFuture future) throws Exception {_								if (!future.isSuccess()) {_									inputChannel.onError(new LocalTransportException(_											"Sending the task event failed.",_											future.channel().localAddress(), future.cause()_									))__								}_							}_						})__	};sends,a,task,event,backwards,to,an,intermediate,result,partition,producer,p,backwards,task,events,flow,between,readers,and,writers,and,therefore,will,only,work,when,both,are,running,at,the,same,time,which,is,only,guaranteed,to,be,the,case,when,both,the,respective,producer,and,consumer,task,run,pipelined;public,void,send,task,event,result,partition,id,partition,id,task,event,event,final,remote,input,channel,input,channel,throws,ioexception,check,not,closed,tcp,channel,write,and,flush,new,task,event,request,event,partition,id,input,channel,get,input,channel,id,add,listener,new,channel,future,listener,override,public,void,operation,complete,channel,future,future,throws,exception,if,future,is,success,input,channel,on,error,new,local,transport,exception,sending,the,task,event,failed,future,channel,local,address,future,cause
PartitionRequestClient -> public void sendTaskEvent(ResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException;1506613166;Sends a task event backwards to an intermediate result partition producer._<p>_Backwards task events flow between readers and writers and therefore_will only work when both are running at the same time, which is only_guaranteed to be the case when both the respective producer and_consumer task run pipelined.;public void sendTaskEvent(ResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException {_		checkNotClosed()___		tcpChannel.writeAndFlush(new TaskEventRequest(event, partitionId, inputChannel.getInputChannelId()))_				.addListener(_						new ChannelFutureListener() {_							@Override_							public void operationComplete(ChannelFuture future) throws Exception {_								if (!future.isSuccess()) {_									inputChannel.onError(new LocalTransportException(_											"Sending the task event failed.",_											future.channel().localAddress(), future.cause()_									))__								}_							}_						})__	};sends,a,task,event,backwards,to,an,intermediate,result,partition,producer,p,backwards,task,events,flow,between,readers,and,writers,and,therefore,will,only,work,when,both,are,running,at,the,same,time,which,is,only,guaranteed,to,be,the,case,when,both,the,respective,producer,and,consumer,task,run,pipelined;public,void,send,task,event,result,partition,id,partition,id,task,event,event,final,remote,input,channel,input,channel,throws,ioexception,check,not,closed,tcp,channel,write,and,flush,new,task,event,request,event,partition,id,input,channel,get,input,channel,id,add,listener,new,channel,future,listener,override,public,void,operation,complete,channel,future,future,throws,exception,if,future,is,success,input,channel,on,error,new,local,transport,exception,sending,the,task,event,failed,future,channel,local,address,future,cause
PartitionRequestClient -> public void sendTaskEvent(ResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException;1506753379;Sends a task event backwards to an intermediate result partition producer._<p>_Backwards task events flow between readers and writers and therefore_will only work when both are running at the same time, which is only_guaranteed to be the case when both the respective producer and_consumer task run pipelined.;public void sendTaskEvent(ResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException {_		checkNotClosed()___		tcpChannel.writeAndFlush(new TaskEventRequest(event, partitionId, inputChannel.getInputChannelId()))_				.addListener(_						new ChannelFutureListener() {_							@Override_							public void operationComplete(ChannelFuture future) throws Exception {_								if (!future.isSuccess()) {_									inputChannel.onError(new LocalTransportException(_											"Sending the task event failed.",_											future.channel().localAddress(), future.cause()_									))__								}_							}_						})__	};sends,a,task,event,backwards,to,an,intermediate,result,partition,producer,p,backwards,task,events,flow,between,readers,and,writers,and,therefore,will,only,work,when,both,are,running,at,the,same,time,which,is,only,guaranteed,to,be,the,case,when,both,the,respective,producer,and,consumer,task,run,pipelined;public,void,send,task,event,result,partition,id,partition,id,task,event,event,final,remote,input,channel,input,channel,throws,ioexception,check,not,closed,tcp,channel,write,and,flush,new,task,event,request,event,partition,id,input,channel,get,input,channel,id,add,listener,new,channel,future,listener,override,public,void,operation,complete,channel,future,future,throws,exception,if,future,is,success,input,channel,on,error,new,local,transport,exception,sending,the,task,event,failed,future,channel,local,address,future,cause
PartitionRequestClient -> public void sendTaskEvent(ResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException;1516169704;Sends a task event backwards to an intermediate result partition producer._<p>_Backwards task events flow between readers and writers and therefore_will only work when both are running at the same time, which is only_guaranteed to be the case when both the respective producer and_consumer task run pipelined.;public void sendTaskEvent(ResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException {_		checkNotClosed()___		tcpChannel.writeAndFlush(new TaskEventRequest(event, partitionId, inputChannel.getInputChannelId()))_				.addListener(_						new ChannelFutureListener() {_							@Override_							public void operationComplete(ChannelFuture future) throws Exception {_								if (!future.isSuccess()) {_									inputChannel.onError(new LocalTransportException(_											"Sending the task event failed.",_											future.channel().localAddress(), future.cause()_									))__								}_							}_						})__	};sends,a,task,event,backwards,to,an,intermediate,result,partition,producer,p,backwards,task,events,flow,between,readers,and,writers,and,therefore,will,only,work,when,both,are,running,at,the,same,time,which,is,only,guaranteed,to,be,the,case,when,both,the,respective,producer,and,consumer,task,run,pipelined;public,void,send,task,event,result,partition,id,partition,id,task,event,event,final,remote,input,channel,input,channel,throws,ioexception,check,not,closed,tcp,channel,write,and,flush,new,task,event,request,event,partition,id,input,channel,get,input,channel,id,add,listener,new,channel,future,listener,override,public,void,operation,complete,channel,future,future,throws,exception,if,future,is,success,input,channel,on,error,new,local,transport,exception,sending,the,task,event,failed,future,channel,local,address,future,cause
PartitionRequestClient -> public void sendTaskEvent(ResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException;1531147755;Sends a task event backwards to an intermediate result partition producer._<p>_Backwards task events flow between readers and writers and therefore_will only work when both are running at the same time, which is only_guaranteed to be the case when both the respective producer and_consumer task run pipelined.;public void sendTaskEvent(ResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException {_		checkNotClosed()___		tcpChannel.writeAndFlush(new TaskEventRequest(event, partitionId, inputChannel.getInputChannelId()))_				.addListener(_						new ChannelFutureListener() {_							@Override_							public void operationComplete(ChannelFuture future) throws Exception {_								if (!future.isSuccess()) {_									SocketAddress remoteAddr = future.channel().remoteAddress()__									inputChannel.onError(new LocalTransportException(_										String.format("Sending the task event to '%s' failed.", remoteAddr),_										future.channel().localAddress(), future.cause()_									))__								}_							}_						})__	};sends,a,task,event,backwards,to,an,intermediate,result,partition,producer,p,backwards,task,events,flow,between,readers,and,writers,and,therefore,will,only,work,when,both,are,running,at,the,same,time,which,is,only,guaranteed,to,be,the,case,when,both,the,respective,producer,and,consumer,task,run,pipelined;public,void,send,task,event,result,partition,id,partition,id,task,event,event,final,remote,input,channel,input,channel,throws,ioexception,check,not,closed,tcp,channel,write,and,flush,new,task,event,request,event,partition,id,input,channel,get,input,channel,id,add,listener,new,channel,future,listener,override,public,void,operation,complete,channel,future,future,throws,exception,if,future,is,success,socket,address,remote,addr,future,channel,remote,address,input,channel,on,error,new,local,transport,exception,string,format,sending,the,task,event,to,s,failed,remote,addr,future,channel,local,address,future,cause
PartitionRequestClient -> public void sendTaskEvent(ResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException;1533422492;Sends a task event backwards to an intermediate result partition producer._<p>_Backwards task events flow between readers and writers and therefore_will only work when both are running at the same time, which is only_guaranteed to be the case when both the respective producer and_consumer task run pipelined.;public void sendTaskEvent(ResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException {_		checkNotClosed()___		tcpChannel.writeAndFlush(new TaskEventRequest(event, partitionId, inputChannel.getInputChannelId()))_				.addListener(_						new ChannelFutureListener() {_							@Override_							public void operationComplete(ChannelFuture future) throws Exception {_								if (!future.isSuccess()) {_									SocketAddress remoteAddr = future.channel().remoteAddress()__									inputChannel.onError(new LocalTransportException(_										String.format("Sending the task event to '%s' failed.", remoteAddr),_										future.channel().localAddress(), future.cause()_									))__								}_							}_						})__	};sends,a,task,event,backwards,to,an,intermediate,result,partition,producer,p,backwards,task,events,flow,between,readers,and,writers,and,therefore,will,only,work,when,both,are,running,at,the,same,time,which,is,only,guaranteed,to,be,the,case,when,both,the,respective,producer,and,consumer,task,run,pipelined;public,void,send,task,event,result,partition,id,partition,id,task,event,event,final,remote,input,channel,input,channel,throws,ioexception,check,not,closed,tcp,channel,write,and,flush,new,task,event,request,event,partition,id,input,channel,get,input,channel,id,add,listener,new,channel,future,listener,override,public,void,operation,complete,channel,future,future,throws,exception,if,future,is,success,socket,address,remote,addr,future,channel,remote,address,input,channel,on,error,new,local,transport,exception,string,format,sending,the,task,event,to,s,failed,remote,addr,future,channel,local,address,future,cause
PartitionRequestClient -> public ChannelFuture requestSubpartition( 			final ResultPartitionID partitionId, 			final int subpartitionIndex, 			final RemoteInputChannel inputChannel, 			int delayMs) throws IOException;1432127765;Requests a remote intermediate result partition queue._<p>_The request goes to the remote producer, for which this partition_request client instance has been created.;public ChannelFuture requestSubpartition(_			final ResultPartitionID partitionId,_			final int subpartitionIndex,_			final RemoteInputChannel inputChannel,_			int delayMs) throws IOException {__		LOG.debug("Requesting subpartition {} of partition {} with {} ms delay.",_				subpartitionIndex, partitionId, delayMs)___		partitionRequestHandler.addInputChannel(inputChannel)___		final PartitionRequest request = new PartitionRequest(_				partitionId, subpartitionIndex, inputChannel.getInputChannelId())___		final ChannelFutureListener listener = new ChannelFutureListener() {_			@Override_			public void operationComplete(ChannelFuture future) throws Exception {_				if (!future.isSuccess()) {_					partitionRequestHandler.removeInputChannel(inputChannel)__					inputChannel.onError(_							new LocalTransportException(_									"Sending the partition request failed.",_									future.channel().localAddress(), future.cause()_							))__				}_			}_		}___		if (delayMs == 0) {_			ChannelFuture f = tcpChannel.writeAndFlush(request)__			f.addListener(listener)__			return f__		}_		else {_			final ChannelFuture[] f = new ChannelFuture[1]__			tcpChannel.eventLoop().schedule(new Runnable() {_				@Override_				public void run() {_					f[0] = tcpChannel.writeAndFlush(request)__					f[0].addListener(listener)__				}_			}, delayMs, TimeUnit.MILLISECONDS)___			return f[0]__		}_	};requests,a,remote,intermediate,result,partition,queue,p,the,request,goes,to,the,remote,producer,for,which,this,partition,request,client,instance,has,been,created;public,channel,future,request,subpartition,final,result,partition,id,partition,id,final,int,subpartition,index,final,remote,input,channel,input,channel,int,delay,ms,throws,ioexception,log,debug,requesting,subpartition,of,partition,with,ms,delay,subpartition,index,partition,id,delay,ms,partition,request,handler,add,input,channel,input,channel,final,partition,request,request,new,partition,request,partition,id,subpartition,index,input,channel,get,input,channel,id,final,channel,future,listener,listener,new,channel,future,listener,override,public,void,operation,complete,channel,future,future,throws,exception,if,future,is,success,partition,request,handler,remove,input,channel,input,channel,input,channel,on,error,new,local,transport,exception,sending,the,partition,request,failed,future,channel,local,address,future,cause,if,delay,ms,0,channel,future,f,tcp,channel,write,and,flush,request,f,add,listener,listener,return,f,else,final,channel,future,f,new,channel,future,1,tcp,channel,event,loop,schedule,new,runnable,override,public,void,run,f,0,tcp,channel,write,and,flush,request,f,0,add,listener,listener,delay,ms,time,unit,milliseconds,return,f,0
PartitionRequestClient -> public ChannelFuture requestSubpartition( 			final ResultPartitionID partitionId, 			final int subpartitionIndex, 			final RemoteInputChannel inputChannel, 			int delayMs) throws IOException;1432806352;Requests a remote intermediate result partition queue._<p>_The request goes to the remote producer, for which this partition_request client instance has been created.;public ChannelFuture requestSubpartition(_			final ResultPartitionID partitionId,_			final int subpartitionIndex,_			final RemoteInputChannel inputChannel,_			int delayMs) throws IOException {__		LOG.debug("Requesting subpartition {} of partition {} with {} ms delay.",_				subpartitionIndex, partitionId, delayMs)___		partitionRequestHandler.addInputChannel(inputChannel)___		final PartitionRequest request = new PartitionRequest(_				partitionId, subpartitionIndex, inputChannel.getInputChannelId())___		final ChannelFutureListener listener = new ChannelFutureListener() {_			@Override_			public void operationComplete(ChannelFuture future) throws Exception {_				if (!future.isSuccess()) {_					partitionRequestHandler.removeInputChannel(inputChannel)__					inputChannel.onError(_							new LocalTransportException(_									"Sending the partition request failed.",_									future.channel().localAddress(), future.cause()_							))__				}_			}_		}___		if (delayMs == 0) {_			ChannelFuture f = tcpChannel.writeAndFlush(request)__			f.addListener(listener)__			return f__		}_		else {_			final ChannelFuture[] f = new ChannelFuture[1]__			tcpChannel.eventLoop().schedule(new Runnable() {_				@Override_				public void run() {_					f[0] = tcpChannel.writeAndFlush(request)__					f[0].addListener(listener)__				}_			}, delayMs, TimeUnit.MILLISECONDS)___			return f[0]__		}_	};requests,a,remote,intermediate,result,partition,queue,p,the,request,goes,to,the,remote,producer,for,which,this,partition,request,client,instance,has,been,created;public,channel,future,request,subpartition,final,result,partition,id,partition,id,final,int,subpartition,index,final,remote,input,channel,input,channel,int,delay,ms,throws,ioexception,log,debug,requesting,subpartition,of,partition,with,ms,delay,subpartition,index,partition,id,delay,ms,partition,request,handler,add,input,channel,input,channel,final,partition,request,request,new,partition,request,partition,id,subpartition,index,input,channel,get,input,channel,id,final,channel,future,listener,listener,new,channel,future,listener,override,public,void,operation,complete,channel,future,future,throws,exception,if,future,is,success,partition,request,handler,remove,input,channel,input,channel,input,channel,on,error,new,local,transport,exception,sending,the,partition,request,failed,future,channel,local,address,future,cause,if,delay,ms,0,channel,future,f,tcp,channel,write,and,flush,request,f,add,listener,listener,return,f,else,final,channel,future,f,new,channel,future,1,tcp,channel,event,loop,schedule,new,runnable,override,public,void,run,f,0,tcp,channel,write,and,flush,request,f,0,add,listener,listener,delay,ms,time,unit,milliseconds,return,f,0
PartitionRequestClient -> public ChannelFuture requestSubpartition( 			final ResultPartitionID partitionId, 			final int subpartitionIndex, 			final RemoteInputChannel inputChannel, 			int delayMs) throws IOException;1433349700;Requests a remote intermediate result partition queue._<p>_The request goes to the remote producer, for which this partition_request client instance has been created.;public ChannelFuture requestSubpartition(_			final ResultPartitionID partitionId,_			final int subpartitionIndex,_			final RemoteInputChannel inputChannel,_			int delayMs) throws IOException {__		checkNotClosed()___		LOG.debug("Requesting subpartition {} of partition {} with {} ms delay.",_				subpartitionIndex, partitionId, delayMs)___		partitionRequestHandler.addInputChannel(inputChannel)___		final PartitionRequest request = new PartitionRequest(_				partitionId, subpartitionIndex, inputChannel.getInputChannelId())___		final ChannelFutureListener listener = new ChannelFutureListener() {_			@Override_			public void operationComplete(ChannelFuture future) throws Exception {_				if (!future.isSuccess()) {_					partitionRequestHandler.removeInputChannel(inputChannel)__					inputChannel.onError(_							new LocalTransportException(_									"Sending the partition request failed.",_									future.channel().localAddress(), future.cause()_							))__				}_			}_		}___		if (delayMs == 0) {_			ChannelFuture f = tcpChannel.writeAndFlush(request)__			f.addListener(listener)__			return f__		}_		else {_			final ChannelFuture[] f = new ChannelFuture[1]__			tcpChannel.eventLoop().schedule(new Runnable() {_				@Override_				public void run() {_					f[0] = tcpChannel.writeAndFlush(request)__					f[0].addListener(listener)__				}_			}, delayMs, TimeUnit.MILLISECONDS)___			return f[0]__		}_	};requests,a,remote,intermediate,result,partition,queue,p,the,request,goes,to,the,remote,producer,for,which,this,partition,request,client,instance,has,been,created;public,channel,future,request,subpartition,final,result,partition,id,partition,id,final,int,subpartition,index,final,remote,input,channel,input,channel,int,delay,ms,throws,ioexception,check,not,closed,log,debug,requesting,subpartition,of,partition,with,ms,delay,subpartition,index,partition,id,delay,ms,partition,request,handler,add,input,channel,input,channel,final,partition,request,request,new,partition,request,partition,id,subpartition,index,input,channel,get,input,channel,id,final,channel,future,listener,listener,new,channel,future,listener,override,public,void,operation,complete,channel,future,future,throws,exception,if,future,is,success,partition,request,handler,remove,input,channel,input,channel,input,channel,on,error,new,local,transport,exception,sending,the,partition,request,failed,future,channel,local,address,future,cause,if,delay,ms,0,channel,future,f,tcp,channel,write,and,flush,request,f,add,listener,listener,return,f,else,final,channel,future,f,new,channel,future,1,tcp,channel,event,loop,schedule,new,runnable,override,public,void,run,f,0,tcp,channel,write,and,flush,request,f,0,add,listener,listener,delay,ms,time,unit,milliseconds,return,f,0
PartitionRequestClient -> public ChannelFuture requestSubpartition( 			final ResultPartitionID partitionId, 			final int subpartitionIndex, 			final RemoteInputChannel inputChannel, 			int delayMs) throws IOException;1438275734;Requests a remote intermediate result partition queue._<p>_The request goes to the remote producer, for which this partition_request client instance has been created.;public ChannelFuture requestSubpartition(_			final ResultPartitionID partitionId,_			final int subpartitionIndex,_			final RemoteInputChannel inputChannel,_			int delayMs) throws IOException {__		checkNotClosed()___		LOG.debug("Requesting subpartition {} of partition {} with {} ms delay.",_				subpartitionIndex, partitionId, delayMs)___		partitionRequestHandler.addInputChannel(inputChannel)___		final PartitionRequest request = new PartitionRequest(_				partitionId, subpartitionIndex, inputChannel.getInputChannelId())___		final ChannelFutureListener listener = new ChannelFutureListener() {_			@Override_			public void operationComplete(ChannelFuture future) throws Exception {_				if (!future.isSuccess()) {_					partitionRequestHandler.removeInputChannel(inputChannel)__					inputChannel.onError(_							new LocalTransportException(_									"Sending the partition request failed.",_									future.channel().localAddress(), future.cause()_							))__				}_			}_		}___		if (delayMs == 0) {_			ChannelFuture f = tcpChannel.writeAndFlush(request)__			f.addListener(listener)__			return f__		}_		else {_			final ChannelFuture[] f = new ChannelFuture[1]__			tcpChannel.eventLoop().schedule(new Runnable() {_				@Override_				public void run() {_					f[0] = tcpChannel.writeAndFlush(request)__					f[0].addListener(listener)__				}_			}, delayMs, TimeUnit.MILLISECONDS)___			return f[0]__		}_	};requests,a,remote,intermediate,result,partition,queue,p,the,request,goes,to,the,remote,producer,for,which,this,partition,request,client,instance,has,been,created;public,channel,future,request,subpartition,final,result,partition,id,partition,id,final,int,subpartition,index,final,remote,input,channel,input,channel,int,delay,ms,throws,ioexception,check,not,closed,log,debug,requesting,subpartition,of,partition,with,ms,delay,subpartition,index,partition,id,delay,ms,partition,request,handler,add,input,channel,input,channel,final,partition,request,request,new,partition,request,partition,id,subpartition,index,input,channel,get,input,channel,id,final,channel,future,listener,listener,new,channel,future,listener,override,public,void,operation,complete,channel,future,future,throws,exception,if,future,is,success,partition,request,handler,remove,input,channel,input,channel,input,channel,on,error,new,local,transport,exception,sending,the,partition,request,failed,future,channel,local,address,future,cause,if,delay,ms,0,channel,future,f,tcp,channel,write,and,flush,request,f,add,listener,listener,return,f,else,final,channel,future,f,new,channel,future,1,tcp,channel,event,loop,schedule,new,runnable,override,public,void,run,f,0,tcp,channel,write,and,flush,request,f,0,add,listener,listener,delay,ms,time,unit,milliseconds,return,f,0
PartitionRequestClient -> public ChannelFuture requestSubpartition( 			final ResultPartitionID partitionId, 			final int subpartitionIndex, 			final RemoteInputChannel inputChannel, 			int delayMs) throws IOException;1455130280;Requests a remote intermediate result partition queue._<p>_The request goes to the remote producer, for which this partition_request client instance has been created.;public ChannelFuture requestSubpartition(_			final ResultPartitionID partitionId,_			final int subpartitionIndex,_			final RemoteInputChannel inputChannel,_			int delayMs) throws IOException {__		checkNotClosed()___		LOG.debug("Requesting subpartition {} of partition {} with {} ms delay.",_				subpartitionIndex, partitionId, delayMs)___		partitionRequestHandler.addInputChannel(inputChannel)___		final PartitionRequest request = new PartitionRequest(_				partitionId, subpartitionIndex, inputChannel.getInputChannelId())___		final ChannelFutureListener listener = new ChannelFutureListener() {_			@Override_			public void operationComplete(ChannelFuture future) throws Exception {_				if (!future.isSuccess()) {_					partitionRequestHandler.removeInputChannel(inputChannel)__					inputChannel.onError(_							new LocalTransportException(_									"Sending the partition request failed.",_									future.cause()_							))__				}_			}_		}___		if (delayMs == 0) {_			ChannelFuture f = tcpChannel.writeAndFlush(request)__			f.addListener(listener)__			return f__		}_		else {_			final ChannelFuture[] f = new ChannelFuture[1]__			tcpChannel.eventLoop().schedule(new Runnable() {_				@Override_				public void run() {_					f[0] = tcpChannel.writeAndFlush(request)__					f[0].addListener(listener)__				}_			}, delayMs, TimeUnit.MILLISECONDS)___			return f[0]__		}_	};requests,a,remote,intermediate,result,partition,queue,p,the,request,goes,to,the,remote,producer,for,which,this,partition,request,client,instance,has,been,created;public,channel,future,request,subpartition,final,result,partition,id,partition,id,final,int,subpartition,index,final,remote,input,channel,input,channel,int,delay,ms,throws,ioexception,check,not,closed,log,debug,requesting,subpartition,of,partition,with,ms,delay,subpartition,index,partition,id,delay,ms,partition,request,handler,add,input,channel,input,channel,final,partition,request,request,new,partition,request,partition,id,subpartition,index,input,channel,get,input,channel,id,final,channel,future,listener,listener,new,channel,future,listener,override,public,void,operation,complete,channel,future,future,throws,exception,if,future,is,success,partition,request,handler,remove,input,channel,input,channel,input,channel,on,error,new,local,transport,exception,sending,the,partition,request,failed,future,cause,if,delay,ms,0,channel,future,f,tcp,channel,write,and,flush,request,f,add,listener,listener,return,f,else,final,channel,future,f,new,channel,future,1,tcp,channel,event,loop,schedule,new,runnable,override,public,void,run,f,0,tcp,channel,write,and,flush,request,f,0,add,listener,listener,delay,ms,time,unit,milliseconds,return,f,0
PartitionRequestClient -> public ChannelFuture requestSubpartition( 			final ResultPartitionID partitionId, 			final int subpartitionIndex, 			final RemoteInputChannel inputChannel, 			int delayMs) throws IOException;1455534790;Requests a remote intermediate result partition queue._<p>_The request goes to the remote producer, for which this partition_request client instance has been created.;public ChannelFuture requestSubpartition(_			final ResultPartitionID partitionId,_			final int subpartitionIndex,_			final RemoteInputChannel inputChannel,_			int delayMs) throws IOException {__		checkNotClosed()___		LOG.debug("Requesting subpartition {} of partition {} with {} ms delay.",_				subpartitionIndex, partitionId, delayMs)___		partitionRequestHandler.addInputChannel(inputChannel)___		final PartitionRequest request = new PartitionRequest(_				partitionId, subpartitionIndex, inputChannel.getInputChannelId())___		final ChannelFutureListener listener = new ChannelFutureListener() {_			@Override_			public void operationComplete(ChannelFuture future) throws Exception {_				if (!future.isSuccess()) {_					partitionRequestHandler.removeInputChannel(inputChannel)__					inputChannel.onError(_							new LocalTransportException(_									"Sending the partition request failed.",_									future.channel().localAddress(), future.cause()_							))__				}_			}_		}___		if (delayMs == 0) {_			ChannelFuture f = tcpChannel.writeAndFlush(request)__			f.addListener(listener)__			return f__		}_		else {_			final ChannelFuture[] f = new ChannelFuture[1]__			tcpChannel.eventLoop().schedule(new Runnable() {_				@Override_				public void run() {_					f[0] = tcpChannel.writeAndFlush(request)__					f[0].addListener(listener)__				}_			}, delayMs, TimeUnit.MILLISECONDS)___			return f[0]__		}_	};requests,a,remote,intermediate,result,partition,queue,p,the,request,goes,to,the,remote,producer,for,which,this,partition,request,client,instance,has,been,created;public,channel,future,request,subpartition,final,result,partition,id,partition,id,final,int,subpartition,index,final,remote,input,channel,input,channel,int,delay,ms,throws,ioexception,check,not,closed,log,debug,requesting,subpartition,of,partition,with,ms,delay,subpartition,index,partition,id,delay,ms,partition,request,handler,add,input,channel,input,channel,final,partition,request,request,new,partition,request,partition,id,subpartition,index,input,channel,get,input,channel,id,final,channel,future,listener,listener,new,channel,future,listener,override,public,void,operation,complete,channel,future,future,throws,exception,if,future,is,success,partition,request,handler,remove,input,channel,input,channel,input,channel,on,error,new,local,transport,exception,sending,the,partition,request,failed,future,channel,local,address,future,cause,if,delay,ms,0,channel,future,f,tcp,channel,write,and,flush,request,f,add,listener,listener,return,f,else,final,channel,future,f,new,channel,future,1,tcp,channel,event,loop,schedule,new,runnable,override,public,void,run,f,0,tcp,channel,write,and,flush,request,f,0,add,listener,listener,delay,ms,time,unit,milliseconds,return,f,0
PartitionRequestClient -> public ChannelFuture requestSubpartition( 			final ResultPartitionID partitionId, 			final int subpartitionIndex, 			final RemoteInputChannel inputChannel, 			int delayMs) throws IOException;1465394479;Requests a remote intermediate result partition queue._<p>_The request goes to the remote producer, for which this partition_request client instance has been created.;public ChannelFuture requestSubpartition(_			final ResultPartitionID partitionId,_			final int subpartitionIndex,_			final RemoteInputChannel inputChannel,_			int delayMs) throws IOException {__		checkNotClosed()___		LOG.debug("Requesting subpartition {} of partition {} with {} ms delay.",_				subpartitionIndex, partitionId, delayMs)___		partitionRequestHandler.addInputChannel(inputChannel)___		final PartitionRequest request = new PartitionRequest(_				partitionId, subpartitionIndex, inputChannel.getInputChannelId())___		final ChannelFutureListener listener = new ChannelFutureListener() {_			@Override_			public void operationComplete(ChannelFuture future) throws Exception {_				if (!future.isSuccess()) {_					partitionRequestHandler.removeInputChannel(inputChannel)__					inputChannel.onError(_							new LocalTransportException(_									"Sending the partition request failed.",_									future.channel().localAddress(), future.cause()_							))__				}_			}_		}___		if (delayMs == 0) {_			ChannelFuture f = tcpChannel.writeAndFlush(request)__			f.addListener(listener)__			return f__		}_		else {_			final ChannelFuture[] f = new ChannelFuture[1]__			tcpChannel.eventLoop().schedule(new Runnable() {_				@Override_				public void run() {_					f[0] = tcpChannel.writeAndFlush(request)__					f[0].addListener(listener)__				}_			}, delayMs, TimeUnit.MILLISECONDS)___			return f[0]__		}_	};requests,a,remote,intermediate,result,partition,queue,p,the,request,goes,to,the,remote,producer,for,which,this,partition,request,client,instance,has,been,created;public,channel,future,request,subpartition,final,result,partition,id,partition,id,final,int,subpartition,index,final,remote,input,channel,input,channel,int,delay,ms,throws,ioexception,check,not,closed,log,debug,requesting,subpartition,of,partition,with,ms,delay,subpartition,index,partition,id,delay,ms,partition,request,handler,add,input,channel,input,channel,final,partition,request,request,new,partition,request,partition,id,subpartition,index,input,channel,get,input,channel,id,final,channel,future,listener,listener,new,channel,future,listener,override,public,void,operation,complete,channel,future,future,throws,exception,if,future,is,success,partition,request,handler,remove,input,channel,input,channel,input,channel,on,error,new,local,transport,exception,sending,the,partition,request,failed,future,channel,local,address,future,cause,if,delay,ms,0,channel,future,f,tcp,channel,write,and,flush,request,f,add,listener,listener,return,f,else,final,channel,future,f,new,channel,future,1,tcp,channel,event,loop,schedule,new,runnable,override,public,void,run,f,0,tcp,channel,write,and,flush,request,f,0,add,listener,listener,delay,ms,time,unit,milliseconds,return,f,0
PartitionRequestClient -> public ChannelFuture requestSubpartition( 			final ResultPartitionID partitionId, 			final int subpartitionIndex, 			final RemoteInputChannel inputChannel, 			int delayMs) throws IOException;1498566436;Requests a remote intermediate result partition queue._<p>_The request goes to the remote producer, for which this partition_request client instance has been created.;public ChannelFuture requestSubpartition(_			final ResultPartitionID partitionId,_			final int subpartitionIndex,_			final RemoteInputChannel inputChannel,_			int delayMs) throws IOException {__		checkNotClosed()___		LOG.debug("Requesting subpartition {} of partition {} with {} ms delay.",_				subpartitionIndex, partitionId, delayMs)___		partitionRequestHandler.addInputChannel(inputChannel)___		final PartitionRequest request = new PartitionRequest(_				partitionId, subpartitionIndex, inputChannel.getInputChannelId())___		final ChannelFutureListener listener = new ChannelFutureListener() {_			@Override_			public void operationComplete(ChannelFuture future) throws Exception {_				if (!future.isSuccess()) {_					partitionRequestHandler.removeInputChannel(inputChannel)__					inputChannel.onError(_							new LocalTransportException(_									"Sending the partition request failed.",_									future.channel().localAddress(), future.cause()_							))__				}_			}_		}___		if (delayMs == 0) {_			ChannelFuture f = tcpChannel.writeAndFlush(request)__			f.addListener(listener)__			return f__		}_		else {_			final ChannelFuture[] f = new ChannelFuture[1]__			tcpChannel.eventLoop().schedule(new Runnable() {_				@Override_				public void run() {_					f[0] = tcpChannel.writeAndFlush(request)__					f[0].addListener(listener)__				}_			}, delayMs, TimeUnit.MILLISECONDS)___			return f[0]__		}_	};requests,a,remote,intermediate,result,partition,queue,p,the,request,goes,to,the,remote,producer,for,which,this,partition,request,client,instance,has,been,created;public,channel,future,request,subpartition,final,result,partition,id,partition,id,final,int,subpartition,index,final,remote,input,channel,input,channel,int,delay,ms,throws,ioexception,check,not,closed,log,debug,requesting,subpartition,of,partition,with,ms,delay,subpartition,index,partition,id,delay,ms,partition,request,handler,add,input,channel,input,channel,final,partition,request,request,new,partition,request,partition,id,subpartition,index,input,channel,get,input,channel,id,final,channel,future,listener,listener,new,channel,future,listener,override,public,void,operation,complete,channel,future,future,throws,exception,if,future,is,success,partition,request,handler,remove,input,channel,input,channel,input,channel,on,error,new,local,transport,exception,sending,the,partition,request,failed,future,channel,local,address,future,cause,if,delay,ms,0,channel,future,f,tcp,channel,write,and,flush,request,f,add,listener,listener,return,f,else,final,channel,future,f,new,channel,future,1,tcp,channel,event,loop,schedule,new,runnable,override,public,void,run,f,0,tcp,channel,write,and,flush,request,f,0,add,listener,listener,delay,ms,time,unit,milliseconds,return,f,0
PartitionRequestClient -> public ChannelFuture requestSubpartition( 			final ResultPartitionID partitionId, 			final int subpartitionIndex, 			final RemoteInputChannel inputChannel, 			int delayMs) throws IOException;1505982496;Requests a remote intermediate result partition queue._<p>_The request goes to the remote producer, for which this partition_request client instance has been created.;public ChannelFuture requestSubpartition(_			final ResultPartitionID partitionId,_			final int subpartitionIndex,_			final RemoteInputChannel inputChannel,_			int delayMs) throws IOException {__		checkNotClosed()___		LOG.debug("Requesting subpartition {} of partition {} with {} ms delay.",_				subpartitionIndex, partitionId, delayMs)___		partitionRequestHandler.addInputChannel(inputChannel)___		final PartitionRequest request = new PartitionRequest(_				partitionId, subpartitionIndex, inputChannel.getInputChannelId(), inputChannel.getInitialCredit())___		final ChannelFutureListener listener = new ChannelFutureListener() {_			@Override_			public void operationComplete(ChannelFuture future) throws Exception {_				if (!future.isSuccess()) {_					partitionRequestHandler.removeInputChannel(inputChannel)__					inputChannel.onError(_							new LocalTransportException(_									"Sending the partition request failed.",_									future.channel().localAddress(), future.cause()_							))__				}_			}_		}___		if (delayMs == 0) {_			ChannelFuture f = tcpChannel.writeAndFlush(request)__			f.addListener(listener)__			return f__		}_		else {_			final ChannelFuture[] f = new ChannelFuture[1]__			tcpChannel.eventLoop().schedule(new Runnable() {_				@Override_				public void run() {_					f[0] = tcpChannel.writeAndFlush(request)__					f[0].addListener(listener)__				}_			}, delayMs, TimeUnit.MILLISECONDS)___			return f[0]__		}_	};requests,a,remote,intermediate,result,partition,queue,p,the,request,goes,to,the,remote,producer,for,which,this,partition,request,client,instance,has,been,created;public,channel,future,request,subpartition,final,result,partition,id,partition,id,final,int,subpartition,index,final,remote,input,channel,input,channel,int,delay,ms,throws,ioexception,check,not,closed,log,debug,requesting,subpartition,of,partition,with,ms,delay,subpartition,index,partition,id,delay,ms,partition,request,handler,add,input,channel,input,channel,final,partition,request,request,new,partition,request,partition,id,subpartition,index,input,channel,get,input,channel,id,input,channel,get,initial,credit,final,channel,future,listener,listener,new,channel,future,listener,override,public,void,operation,complete,channel,future,future,throws,exception,if,future,is,success,partition,request,handler,remove,input,channel,input,channel,input,channel,on,error,new,local,transport,exception,sending,the,partition,request,failed,future,channel,local,address,future,cause,if,delay,ms,0,channel,future,f,tcp,channel,write,and,flush,request,f,add,listener,listener,return,f,else,final,channel,future,f,new,channel,future,1,tcp,channel,event,loop,schedule,new,runnable,override,public,void,run,f,0,tcp,channel,write,and,flush,request,f,0,add,listener,listener,delay,ms,time,unit,milliseconds,return,f,0
PartitionRequestClient -> public ChannelFuture requestSubpartition( 			final ResultPartitionID partitionId, 			final int subpartitionIndex, 			final RemoteInputChannel inputChannel, 			int delayMs) throws IOException;1506613166;Requests a remote intermediate result partition queue._<p>_The request goes to the remote producer, for which this partition_request client instance has been created.;public ChannelFuture requestSubpartition(_			final ResultPartitionID partitionId,_			final int subpartitionIndex,_			final RemoteInputChannel inputChannel,_			int delayMs) throws IOException {__		checkNotClosed()___		LOG.debug("Requesting subpartition {} of partition {} with {} ms delay.",_				subpartitionIndex, partitionId, delayMs)___		partitionRequestHandler.addInputChannel(inputChannel)___		final PartitionRequest request = new PartitionRequest(_				partitionId, subpartitionIndex, inputChannel.getInputChannelId(), inputChannel.getInitialCredit())___		final ChannelFutureListener listener = new ChannelFutureListener() {_			@Override_			public void operationComplete(ChannelFuture future) throws Exception {_				if (!future.isSuccess()) {_					partitionRequestHandler.removeInputChannel(inputChannel)__					inputChannel.onError(_							new LocalTransportException(_									"Sending the partition request failed.",_									future.channel().localAddress(), future.cause()_							))__				}_			}_		}___		if (delayMs == 0) {_			ChannelFuture f = tcpChannel.writeAndFlush(request)__			f.addListener(listener)__			return f__		}_		else {_			final ChannelFuture[] f = new ChannelFuture[1]__			tcpChannel.eventLoop().schedule(new Runnable() {_				@Override_				public void run() {_					f[0] = tcpChannel.writeAndFlush(request)__					f[0].addListener(listener)__				}_			}, delayMs, TimeUnit.MILLISECONDS)___			return f[0]__		}_	};requests,a,remote,intermediate,result,partition,queue,p,the,request,goes,to,the,remote,producer,for,which,this,partition,request,client,instance,has,been,created;public,channel,future,request,subpartition,final,result,partition,id,partition,id,final,int,subpartition,index,final,remote,input,channel,input,channel,int,delay,ms,throws,ioexception,check,not,closed,log,debug,requesting,subpartition,of,partition,with,ms,delay,subpartition,index,partition,id,delay,ms,partition,request,handler,add,input,channel,input,channel,final,partition,request,request,new,partition,request,partition,id,subpartition,index,input,channel,get,input,channel,id,input,channel,get,initial,credit,final,channel,future,listener,listener,new,channel,future,listener,override,public,void,operation,complete,channel,future,future,throws,exception,if,future,is,success,partition,request,handler,remove,input,channel,input,channel,input,channel,on,error,new,local,transport,exception,sending,the,partition,request,failed,future,channel,local,address,future,cause,if,delay,ms,0,channel,future,f,tcp,channel,write,and,flush,request,f,add,listener,listener,return,f,else,final,channel,future,f,new,channel,future,1,tcp,channel,event,loop,schedule,new,runnable,override,public,void,run,f,0,tcp,channel,write,and,flush,request,f,0,add,listener,listener,delay,ms,time,unit,milliseconds,return,f,0
PartitionRequestClient -> public ChannelFuture requestSubpartition( 			final ResultPartitionID partitionId, 			final int subpartitionIndex, 			final RemoteInputChannel inputChannel, 			int delayMs) throws IOException;1506753379;Requests a remote intermediate result partition queue._<p>_The request goes to the remote producer, for which this partition_request client instance has been created.;public ChannelFuture requestSubpartition(_			final ResultPartitionID partitionId,_			final int subpartitionIndex,_			final RemoteInputChannel inputChannel,_			int delayMs) throws IOException {__		checkNotClosed()___		LOG.debug("Requesting subpartition {} of partition {} with {} ms delay.",_				subpartitionIndex, partitionId, delayMs)___		partitionRequestHandler.addInputChannel(inputChannel)___		final PartitionRequest request = new PartitionRequest(_				partitionId, subpartitionIndex, inputChannel.getInputChannelId(), inputChannel.getInitialCredit())___		final ChannelFutureListener listener = new ChannelFutureListener() {_			@Override_			public void operationComplete(ChannelFuture future) throws Exception {_				if (!future.isSuccess()) {_					partitionRequestHandler.removeInputChannel(inputChannel)__					inputChannel.onError(_							new LocalTransportException(_									"Sending the partition request failed.",_									future.channel().localAddress(), future.cause()_							))__				}_			}_		}___		if (delayMs == 0) {_			ChannelFuture f = tcpChannel.writeAndFlush(request)__			f.addListener(listener)__			return f__		}_		else {_			final ChannelFuture[] f = new ChannelFuture[1]__			tcpChannel.eventLoop().schedule(new Runnable() {_				@Override_				public void run() {_					f[0] = tcpChannel.writeAndFlush(request)__					f[0].addListener(listener)__				}_			}, delayMs, TimeUnit.MILLISECONDS)___			return f[0]__		}_	};requests,a,remote,intermediate,result,partition,queue,p,the,request,goes,to,the,remote,producer,for,which,this,partition,request,client,instance,has,been,created;public,channel,future,request,subpartition,final,result,partition,id,partition,id,final,int,subpartition,index,final,remote,input,channel,input,channel,int,delay,ms,throws,ioexception,check,not,closed,log,debug,requesting,subpartition,of,partition,with,ms,delay,subpartition,index,partition,id,delay,ms,partition,request,handler,add,input,channel,input,channel,final,partition,request,request,new,partition,request,partition,id,subpartition,index,input,channel,get,input,channel,id,input,channel,get,initial,credit,final,channel,future,listener,listener,new,channel,future,listener,override,public,void,operation,complete,channel,future,future,throws,exception,if,future,is,success,partition,request,handler,remove,input,channel,input,channel,input,channel,on,error,new,local,transport,exception,sending,the,partition,request,failed,future,channel,local,address,future,cause,if,delay,ms,0,channel,future,f,tcp,channel,write,and,flush,request,f,add,listener,listener,return,f,else,final,channel,future,f,new,channel,future,1,tcp,channel,event,loop,schedule,new,runnable,override,public,void,run,f,0,tcp,channel,write,and,flush,request,f,0,add,listener,listener,delay,ms,time,unit,milliseconds,return,f,0
PartitionRequestClient -> public ChannelFuture requestSubpartition( 			final ResultPartitionID partitionId, 			final int subpartitionIndex, 			final RemoteInputChannel inputChannel, 			int delayMs) throws IOException;1516169704;Requests a remote intermediate result partition queue.__<p>The request goes to the remote producer, for which this partition_request client instance has been created.;public ChannelFuture requestSubpartition(_			final ResultPartitionID partitionId,_			final int subpartitionIndex,_			final RemoteInputChannel inputChannel,_			int delayMs) throws IOException {__		checkNotClosed()___		LOG.debug("Requesting subpartition {} of partition {} with {} ms delay.",_				subpartitionIndex, partitionId, delayMs)___		clientHandler.addInputChannel(inputChannel)___		final PartitionRequest request = new PartitionRequest(_				partitionId, subpartitionIndex, inputChannel.getInputChannelId(), inputChannel.getInitialCredit())___		final ChannelFutureListener listener = new ChannelFutureListener() {_			@Override_			public void operationComplete(ChannelFuture future) throws Exception {_				if (!future.isSuccess()) {_					clientHandler.removeInputChannel(inputChannel)__					inputChannel.onError(_							new LocalTransportException(_									"Sending the partition request failed.",_									future.channel().localAddress(), future.cause()_							))__				}_			}_		}___		if (delayMs == 0) {_			ChannelFuture f = tcpChannel.writeAndFlush(request)__			f.addListener(listener)__			return f__		} else {_			final ChannelFuture[] f = new ChannelFuture[1]__			tcpChannel.eventLoop().schedule(new Runnable() {_				@Override_				public void run() {_					f[0] = tcpChannel.writeAndFlush(request)__					f[0].addListener(listener)__				}_			}, delayMs, TimeUnit.MILLISECONDS)___			return f[0]__		}_	};requests,a,remote,intermediate,result,partition,queue,p,the,request,goes,to,the,remote,producer,for,which,this,partition,request,client,instance,has,been,created;public,channel,future,request,subpartition,final,result,partition,id,partition,id,final,int,subpartition,index,final,remote,input,channel,input,channel,int,delay,ms,throws,ioexception,check,not,closed,log,debug,requesting,subpartition,of,partition,with,ms,delay,subpartition,index,partition,id,delay,ms,client,handler,add,input,channel,input,channel,final,partition,request,request,new,partition,request,partition,id,subpartition,index,input,channel,get,input,channel,id,input,channel,get,initial,credit,final,channel,future,listener,listener,new,channel,future,listener,override,public,void,operation,complete,channel,future,future,throws,exception,if,future,is,success,client,handler,remove,input,channel,input,channel,input,channel,on,error,new,local,transport,exception,sending,the,partition,request,failed,future,channel,local,address,future,cause,if,delay,ms,0,channel,future,f,tcp,channel,write,and,flush,request,f,add,listener,listener,return,f,else,final,channel,future,f,new,channel,future,1,tcp,channel,event,loop,schedule,new,runnable,override,public,void,run,f,0,tcp,channel,write,and,flush,request,f,0,add,listener,listener,delay,ms,time,unit,milliseconds,return,f,0
PartitionRequestClient -> public ChannelFuture requestSubpartition( 			final ResultPartitionID partitionId, 			final int subpartitionIndex, 			final RemoteInputChannel inputChannel, 			int delayMs) throws IOException;1531147755;Requests a remote intermediate result partition queue.__<p>The request goes to the remote producer, for which this partition_request client instance has been created.;public ChannelFuture requestSubpartition(_			final ResultPartitionID partitionId,_			final int subpartitionIndex,_			final RemoteInputChannel inputChannel,_			int delayMs) throws IOException {__		checkNotClosed()___		LOG.debug("Requesting subpartition {} of partition {} with {} ms delay.",_				subpartitionIndex, partitionId, delayMs)___		clientHandler.addInputChannel(inputChannel)___		final PartitionRequest request = new PartitionRequest(_				partitionId, subpartitionIndex, inputChannel.getInputChannelId(), inputChannel.getInitialCredit())___		final ChannelFutureListener listener = new ChannelFutureListener() {_			@Override_			public void operationComplete(ChannelFuture future) throws Exception {_				if (!future.isSuccess()) {_					clientHandler.removeInputChannel(inputChannel)__					SocketAddress remoteAddr = future.channel().remoteAddress()__					inputChannel.onError(_							new LocalTransportException(_								String.format("Sending the partition request to '%s' failed.", remoteAddr),_								future.channel().localAddress(), future.cause()_							))__				}_			}_		}___		if (delayMs == 0) {_			ChannelFuture f = tcpChannel.writeAndFlush(request)__			f.addListener(listener)__			return f__		} else {_			final ChannelFuture[] f = new ChannelFuture[1]__			tcpChannel.eventLoop().schedule(new Runnable() {_				@Override_				public void run() {_					f[0] = tcpChannel.writeAndFlush(request)__					f[0].addListener(listener)__				}_			}, delayMs, TimeUnit.MILLISECONDS)___			return f[0]__		}_	};requests,a,remote,intermediate,result,partition,queue,p,the,request,goes,to,the,remote,producer,for,which,this,partition,request,client,instance,has,been,created;public,channel,future,request,subpartition,final,result,partition,id,partition,id,final,int,subpartition,index,final,remote,input,channel,input,channel,int,delay,ms,throws,ioexception,check,not,closed,log,debug,requesting,subpartition,of,partition,with,ms,delay,subpartition,index,partition,id,delay,ms,client,handler,add,input,channel,input,channel,final,partition,request,request,new,partition,request,partition,id,subpartition,index,input,channel,get,input,channel,id,input,channel,get,initial,credit,final,channel,future,listener,listener,new,channel,future,listener,override,public,void,operation,complete,channel,future,future,throws,exception,if,future,is,success,client,handler,remove,input,channel,input,channel,socket,address,remote,addr,future,channel,remote,address,input,channel,on,error,new,local,transport,exception,string,format,sending,the,partition,request,to,s,failed,remote,addr,future,channel,local,address,future,cause,if,delay,ms,0,channel,future,f,tcp,channel,write,and,flush,request,f,add,listener,listener,return,f,else,final,channel,future,f,new,channel,future,1,tcp,channel,event,loop,schedule,new,runnable,override,public,void,run,f,0,tcp,channel,write,and,flush,request,f,0,add,listener,listener,delay,ms,time,unit,milliseconds,return,f,0
PartitionRequestClient -> public ChannelFuture requestSubpartition( 			final ResultPartitionID partitionId, 			final int subpartitionIndex, 			final RemoteInputChannel inputChannel, 			int delayMs) throws IOException;1533422492;Requests a remote intermediate result partition queue.__<p>The request goes to the remote producer, for which this partition_request client instance has been created.;public ChannelFuture requestSubpartition(_			final ResultPartitionID partitionId,_			final int subpartitionIndex,_			final RemoteInputChannel inputChannel,_			int delayMs) throws IOException {__		checkNotClosed()___		LOG.debug("Requesting subpartition {} of partition {} with {} ms delay.",_				subpartitionIndex, partitionId, delayMs)___		clientHandler.addInputChannel(inputChannel)___		final PartitionRequest request = new PartitionRequest(_				partitionId, subpartitionIndex, inputChannel.getInputChannelId(), inputChannel.getInitialCredit())___		final ChannelFutureListener listener = new ChannelFutureListener() {_			@Override_			public void operationComplete(ChannelFuture future) throws Exception {_				if (!future.isSuccess()) {_					clientHandler.removeInputChannel(inputChannel)__					SocketAddress remoteAddr = future.channel().remoteAddress()__					inputChannel.onError(_							new LocalTransportException(_								String.format("Sending the partition request to '%s' failed.", remoteAddr),_								future.channel().localAddress(), future.cause()_							))__				}_			}_		}___		if (delayMs == 0) {_			ChannelFuture f = tcpChannel.writeAndFlush(request)__			f.addListener(listener)__			return f__		} else {_			final ChannelFuture[] f = new ChannelFuture[1]__			tcpChannel.eventLoop().schedule(new Runnable() {_				@Override_				public void run() {_					f[0] = tcpChannel.writeAndFlush(request)__					f[0].addListener(listener)__				}_			}, delayMs, TimeUnit.MILLISECONDS)___			return f[0]__		}_	};requests,a,remote,intermediate,result,partition,queue,p,the,request,goes,to,the,remote,producer,for,which,this,partition,request,client,instance,has,been,created;public,channel,future,request,subpartition,final,result,partition,id,partition,id,final,int,subpartition,index,final,remote,input,channel,input,channel,int,delay,ms,throws,ioexception,check,not,closed,log,debug,requesting,subpartition,of,partition,with,ms,delay,subpartition,index,partition,id,delay,ms,client,handler,add,input,channel,input,channel,final,partition,request,request,new,partition,request,partition,id,subpartition,index,input,channel,get,input,channel,id,input,channel,get,initial,credit,final,channel,future,listener,listener,new,channel,future,listener,override,public,void,operation,complete,channel,future,future,throws,exception,if,future,is,success,client,handler,remove,input,channel,input,channel,socket,address,remote,addr,future,channel,remote,address,input,channel,on,error,new,local,transport,exception,string,format,sending,the,partition,request,to,s,failed,remote,addr,future,channel,local,address,future,cause,if,delay,ms,0,channel,future,f,tcp,channel,write,and,flush,request,f,add,listener,listener,return,f,else,final,channel,future,f,new,channel,future,1,tcp,channel,event,loop,schedule,new,runnable,override,public,void,run,f,0,tcp,channel,write,and,flush,request,f,0,add,listener,listener,delay,ms,time,unit,milliseconds,return,f,0
PartitionRequestClient -> boolean incrementReferenceCounter();1412761231;Increments the reference counter._<p>_Note: the reference counter has to be incremented before returning the_instance of this client to ensure correct closing logic.;boolean incrementReferenceCounter() {_		return closeReferenceCounter.incrementReferenceCounter()__	};increments,the,reference,counter,p,note,the,reference,counter,has,to,be,incremented,before,returning,the,instance,of,this,client,to,ensure,correct,closing,logic;boolean,increment,reference,counter,return,close,reference,counter,increment,reference,counter
PartitionRequestClient -> boolean incrementReferenceCounter();1420560668;Increments the reference counter._<p>_Note: the reference counter has to be incremented before returning the_instance of this client to ensure correct closing logic.;boolean incrementReferenceCounter() {_		return closeReferenceCounter.increment()__	};increments,the,reference,counter,p,note,the,reference,counter,has,to,be,incremented,before,returning,the,instance,of,this,client,to,ensure,correct,closing,logic;boolean,increment,reference,counter,return,close,reference,counter,increment
PartitionRequestClient -> boolean incrementReferenceCounter();1424695745;Increments the reference counter._<p>_Note: the reference counter has to be incremented before returning the_instance of this client to ensure correct closing logic.;boolean incrementReferenceCounter() {_		return closeReferenceCounter.incrementReferenceCounter()__	};increments,the,reference,counter,p,note,the,reference,counter,has,to,be,incremented,before,returning,the,instance,of,this,client,to,ensure,correct,closing,logic;boolean,increment,reference,counter,return,close,reference,counter,increment,reference,counter
PartitionRequestClient -> boolean incrementReferenceCounter();1427189152;Increments the reference counter._<p>_Note: the reference counter has to be incremented before returning the_instance of this client to ensure correct closing logic.;boolean incrementReferenceCounter() {_		return closeReferenceCounter.increment()__	};increments,the,reference,counter,p,note,the,reference,counter,has,to,be,incremented,before,returning,the,instance,of,this,client,to,ensure,correct,closing,logic;boolean,increment,reference,counter,return,close,reference,counter,increment
PartitionRequestClient -> boolean incrementReferenceCounter();1431354895;Increments the reference counter._<p>_Note: the reference counter has to be incremented before returning the_instance of this client to ensure correct closing logic.;boolean incrementReferenceCounter() {_		return closeReferenceCounter.increment()__	};increments,the,reference,counter,p,note,the,reference,counter,has,to,be,incremented,before,returning,the,instance,of,this,client,to,ensure,correct,closing,logic;boolean,increment,reference,counter,return,close,reference,counter,increment
PartitionRequestClient -> boolean incrementReferenceCounter();1432127765;Increments the reference counter._<p>_Note: the reference counter has to be incremented before returning the_instance of this client to ensure correct closing logic.;boolean incrementReferenceCounter() {_		return closeReferenceCounter.increment()__	};increments,the,reference,counter,p,note,the,reference,counter,has,to,be,incremented,before,returning,the,instance,of,this,client,to,ensure,correct,closing,logic;boolean,increment,reference,counter,return,close,reference,counter,increment
PartitionRequestClient -> boolean incrementReferenceCounter();1432806352;Increments the reference counter._<p>_Note: the reference counter has to be incremented before returning the_instance of this client to ensure correct closing logic.;boolean incrementReferenceCounter() {_		return closeReferenceCounter.increment()__	};increments,the,reference,counter,p,note,the,reference,counter,has,to,be,incremented,before,returning,the,instance,of,this,client,to,ensure,correct,closing,logic;boolean,increment,reference,counter,return,close,reference,counter,increment
PartitionRequestClient -> boolean incrementReferenceCounter();1433349700;Increments the reference counter._<p>_Note: the reference counter has to be incremented before returning the_instance of this client to ensure correct closing logic.;boolean incrementReferenceCounter() {_		return closeReferenceCounter.increment()__	};increments,the,reference,counter,p,note,the,reference,counter,has,to,be,incremented,before,returning,the,instance,of,this,client,to,ensure,correct,closing,logic;boolean,increment,reference,counter,return,close,reference,counter,increment
PartitionRequestClient -> boolean incrementReferenceCounter();1438275734;Increments the reference counter._<p>_Note: the reference counter has to be incremented before returning the_instance of this client to ensure correct closing logic.;boolean incrementReferenceCounter() {_		return closeReferenceCounter.increment()__	};increments,the,reference,counter,p,note,the,reference,counter,has,to,be,incremented,before,returning,the,instance,of,this,client,to,ensure,correct,closing,logic;boolean,increment,reference,counter,return,close,reference,counter,increment
PartitionRequestClient -> boolean incrementReferenceCounter();1455130280;Increments the reference counter._<p>_Note: the reference counter has to be incremented before returning the_instance of this client to ensure correct closing logic.;boolean incrementReferenceCounter() {_		return closeReferenceCounter.increment()__	};increments,the,reference,counter,p,note,the,reference,counter,has,to,be,incremented,before,returning,the,instance,of,this,client,to,ensure,correct,closing,logic;boolean,increment,reference,counter,return,close,reference,counter,increment
PartitionRequestClient -> boolean incrementReferenceCounter();1455534790;Increments the reference counter._<p>_Note: the reference counter has to be incremented before returning the_instance of this client to ensure correct closing logic.;boolean incrementReferenceCounter() {_		return closeReferenceCounter.increment()__	};increments,the,reference,counter,p,note,the,reference,counter,has,to,be,incremented,before,returning,the,instance,of,this,client,to,ensure,correct,closing,logic;boolean,increment,reference,counter,return,close,reference,counter,increment
PartitionRequestClient -> boolean incrementReferenceCounter();1465394479;Increments the reference counter._<p>_Note: the reference counter has to be incremented before returning the_instance of this client to ensure correct closing logic.;boolean incrementReferenceCounter() {_		return closeReferenceCounter.increment()__	};increments,the,reference,counter,p,note,the,reference,counter,has,to,be,incremented,before,returning,the,instance,of,this,client,to,ensure,correct,closing,logic;boolean,increment,reference,counter,return,close,reference,counter,increment
PartitionRequestClient -> boolean incrementReferenceCounter();1498566436;Increments the reference counter._<p>_Note: the reference counter has to be incremented before returning the_instance of this client to ensure correct closing logic.;boolean incrementReferenceCounter() {_		return closeReferenceCounter.increment()__	};increments,the,reference,counter,p,note,the,reference,counter,has,to,be,incremented,before,returning,the,instance,of,this,client,to,ensure,correct,closing,logic;boolean,increment,reference,counter,return,close,reference,counter,increment
PartitionRequestClient -> boolean incrementReferenceCounter();1505982496;Increments the reference counter._<p>_Note: the reference counter has to be incremented before returning the_instance of this client to ensure correct closing logic.;boolean incrementReferenceCounter() {_		return closeReferenceCounter.increment()__	};increments,the,reference,counter,p,note,the,reference,counter,has,to,be,incremented,before,returning,the,instance,of,this,client,to,ensure,correct,closing,logic;boolean,increment,reference,counter,return,close,reference,counter,increment
PartitionRequestClient -> boolean incrementReferenceCounter();1506613166;Increments the reference counter._<p>_Note: the reference counter has to be incremented before returning the_instance of this client to ensure correct closing logic.;boolean incrementReferenceCounter() {_		return closeReferenceCounter.increment()__	};increments,the,reference,counter,p,note,the,reference,counter,has,to,be,incremented,before,returning,the,instance,of,this,client,to,ensure,correct,closing,logic;boolean,increment,reference,counter,return,close,reference,counter,increment
PartitionRequestClient -> boolean incrementReferenceCounter();1506753379;Increments the reference counter._<p>_Note: the reference counter has to be incremented before returning the_instance of this client to ensure correct closing logic.;boolean incrementReferenceCounter() {_		return closeReferenceCounter.increment()__	};increments,the,reference,counter,p,note,the,reference,counter,has,to,be,incremented,before,returning,the,instance,of,this,client,to,ensure,correct,closing,logic;boolean,increment,reference,counter,return,close,reference,counter,increment
PartitionRequestClient -> boolean incrementReferenceCounter();1516169704;Increments the reference counter.__<p>Note: the reference counter has to be incremented before returning the_instance of this client to ensure correct closing logic.;boolean incrementReferenceCounter() {_		return closeReferenceCounter.increment()__	};increments,the,reference,counter,p,note,the,reference,counter,has,to,be,incremented,before,returning,the,instance,of,this,client,to,ensure,correct,closing,logic;boolean,increment,reference,counter,return,close,reference,counter,increment
PartitionRequestClient -> boolean incrementReferenceCounter();1531147755;Increments the reference counter.__<p>Note: the reference counter has to be incremented before returning the_instance of this client to ensure correct closing logic.;boolean incrementReferenceCounter() {_		return closeReferenceCounter.increment()__	};increments,the,reference,counter,p,note,the,reference,counter,has,to,be,incremented,before,returning,the,instance,of,this,client,to,ensure,correct,closing,logic;boolean,increment,reference,counter,return,close,reference,counter,increment
PartitionRequestClient -> boolean incrementReferenceCounter();1533422492;Increments the reference counter.__<p>Note: the reference counter has to be incremented before returning the_instance of this client to ensure correct closing logic.;boolean incrementReferenceCounter() {_		return closeReferenceCounter.increment()__	};increments,the,reference,counter,p,note,the,reference,counter,has,to,be,incremented,before,returning,the,instance,of,this,client,to,ensure,correct,closing,logic;boolean,increment,reference,counter,return,close,reference,counter,increment
PartitionRequestClient -> public void sendTaskEvent(ExecutionAttemptID producerExecutionId, IntermediateResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException;1412761231;Sends a task event backwards to an intermediate result partition producer._<p>_Backwards task events flow between readers and writers and therefore_will only work when both are running at the same time, which is only_guaranteed to be the case when both the respective producer and_consumer task run pipelined.;public void sendTaskEvent(ExecutionAttemptID producerExecutionId, IntermediateResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException {__		tcpChannel.writeAndFlush(new TaskEventRequest(event, producerExecutionId, partitionId, inputChannel.getInputChannelId()))_				.addListener(_						new ChannelFutureListener() {_							@Override_							public void operationComplete(ChannelFuture future) throws Exception {_								if (!future.isSuccess()) {_									inputChannel.onError(future.cause())__								}_							}_						})__	};sends,a,task,event,backwards,to,an,intermediate,result,partition,producer,p,backwards,task,events,flow,between,readers,and,writers,and,therefore,will,only,work,when,both,are,running,at,the,same,time,which,is,only,guaranteed,to,be,the,case,when,both,the,respective,producer,and,consumer,task,run,pipelined;public,void,send,task,event,execution,attempt,id,producer,execution,id,intermediate,result,partition,id,partition,id,task,event,event,final,remote,input,channel,input,channel,throws,ioexception,tcp,channel,write,and,flush,new,task,event,request,event,producer,execution,id,partition,id,input,channel,get,input,channel,id,add,listener,new,channel,future,listener,override,public,void,operation,complete,channel,future,future,throws,exception,if,future,is,success,input,channel,on,error,future,cause
PartitionRequestClient -> public void sendTaskEvent(ExecutionAttemptID producerExecutionId, IntermediateResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException;1424695745;Sends a task event backwards to an intermediate result partition producer._<p>_Backwards task events flow between readers and writers and therefore_will only work when both are running at the same time, which is only_guaranteed to be the case when both the respective producer and_consumer task run pipelined.;public void sendTaskEvent(ExecutionAttemptID producerExecutionId, IntermediateResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException {__		tcpChannel.writeAndFlush(new TaskEventRequest(event, producerExecutionId, partitionId, inputChannel.getInputChannelId()))_				.addListener(_						new ChannelFutureListener() {_							@Override_							public void operationComplete(ChannelFuture future) throws Exception {_								if (!future.isSuccess()) {_									inputChannel.onError(future.cause())__								}_							}_						})__	};sends,a,task,event,backwards,to,an,intermediate,result,partition,producer,p,backwards,task,events,flow,between,readers,and,writers,and,therefore,will,only,work,when,both,are,running,at,the,same,time,which,is,only,guaranteed,to,be,the,case,when,both,the,respective,producer,and,consumer,task,run,pipelined;public,void,send,task,event,execution,attempt,id,producer,execution,id,intermediate,result,partition,id,partition,id,task,event,event,final,remote,input,channel,input,channel,throws,ioexception,tcp,channel,write,and,flush,new,task,event,request,event,producer,execution,id,partition,id,input,channel,get,input,channel,id,add,listener,new,channel,future,listener,override,public,void,operation,complete,channel,future,future,throws,exception,if,future,is,success,input,channel,on,error,future,cause
PartitionRequestClient -> public void requestIntermediateResultPartition(ExecutionAttemptID producerExecutionId, final IntermediateResultPartitionID partitionId, final int requestedQueueIndex, final RemoteInputChannel inputChannel) throws IOException;1412761231;Requests a remote intermediate result partition queue._<p>_The request goes to the remote producer, for which this partition_request client instance has been created.;public void requestIntermediateResultPartition(ExecutionAttemptID producerExecutionId, final IntermediateResultPartitionID partitionId, final int requestedQueueIndex, final RemoteInputChannel inputChannel) throws IOException {_		partitionRequestHandler.addInputChannel(inputChannel)___		tcpChannel.writeAndFlush(new PartitionRequest(producerExecutionId, partitionId, requestedQueueIndex, inputChannel.getInputChannelId()))_				.addListener(_						new ChannelFutureListener() {_							@Override_							public void operationComplete(ChannelFuture future) throws Exception {_								if (!future.isSuccess()) {_									partitionRequestHandler.removeInputChannel(inputChannel)__									inputChannel.onError(future.cause())__								}_							}_						}_				)__	};requests,a,remote,intermediate,result,partition,queue,p,the,request,goes,to,the,remote,producer,for,which,this,partition,request,client,instance,has,been,created;public,void,request,intermediate,result,partition,execution,attempt,id,producer,execution,id,final,intermediate,result,partition,id,partition,id,final,int,requested,queue,index,final,remote,input,channel,input,channel,throws,ioexception,partition,request,handler,add,input,channel,input,channel,tcp,channel,write,and,flush,new,partition,request,producer,execution,id,partition,id,requested,queue,index,input,channel,get,input,channel,id,add,listener,new,channel,future,listener,override,public,void,operation,complete,channel,future,future,throws,exception,if,future,is,success,partition,request,handler,remove,input,channel,input,channel,input,channel,on,error,future,cause
PartitionRequestClient -> public void requestIntermediateResultPartition(ExecutionAttemptID producerExecutionId, final IntermediateResultPartitionID partitionId, final int requestedQueueIndex, final RemoteInputChannel inputChannel) throws IOException;1424695745;Requests a remote intermediate result partition queue._<p>_The request goes to the remote producer, for which this partition_request client instance has been created.;public void requestIntermediateResultPartition(ExecutionAttemptID producerExecutionId, final IntermediateResultPartitionID partitionId, final int requestedQueueIndex, final RemoteInputChannel inputChannel) throws IOException {_		partitionRequestHandler.addInputChannel(inputChannel)___		tcpChannel.writeAndFlush(new PartitionRequest(producerExecutionId, partitionId, requestedQueueIndex, inputChannel.getInputChannelId()))_				.addListener(_						new ChannelFutureListener() {_							@Override_							public void operationComplete(ChannelFuture future) throws Exception {_								if (!future.isSuccess()) {_									partitionRequestHandler.removeInputChannel(inputChannel)__									inputChannel.onError(future.cause())__								}_							}_						}_				)__	};requests,a,remote,intermediate,result,partition,queue,p,the,request,goes,to,the,remote,producer,for,which,this,partition,request,client,instance,has,been,created;public,void,request,intermediate,result,partition,execution,attempt,id,producer,execution,id,final,intermediate,result,partition,id,partition,id,final,int,requested,queue,index,final,remote,input,channel,input,channel,throws,ioexception,partition,request,handler,add,input,channel,input,channel,tcp,channel,write,and,flush,new,partition,request,producer,execution,id,partition,id,requested,queue,index,input,channel,get,input,channel,id,add,listener,new,channel,future,listener,override,public,void,operation,complete,channel,future,future,throws,exception,if,future,is,success,partition,request,handler,remove,input,channel,input,channel,input,channel,on,error,future,cause
