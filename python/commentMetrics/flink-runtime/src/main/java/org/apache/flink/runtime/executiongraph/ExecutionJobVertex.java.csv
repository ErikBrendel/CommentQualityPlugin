# id;timestamp;commentText;codeText;commentWords;codeWords
ExecutionJobVertex -> public void scheduleAll( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint);1509638685;Schedules all execution vertices of this ExecutionJobVertex.__@param slotProvider to allocate the slots from_@param queued if the allocations can be queued_@param locationPreferenceConstraint constraint for the location preferences;public void scheduleAll(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) {_		_		final ExecutionVertex[] vertices = this.taskVertices___		_		for (ExecutionVertex ev : vertices) {_			ev.scheduleForExecution(slotProvider, queued, locationPreferenceConstraint)__		}_	};schedules,all,execution,vertices,of,this,execution,job,vertex,param,slot,provider,to,allocate,the,slots,from,param,queued,if,the,allocations,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences;public,void,schedule,all,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,final,execution,vertex,vertices,this,task,vertices,for,execution,vertex,ev,vertices,ev,schedule,for,execution,slot,provider,queued,location,preference,constraint
ExecutionJobVertex -> public void scheduleAll( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint);1513261599;Schedules all execution vertices of this ExecutionJobVertex.__@param slotProvider to allocate the slots from_@param queued if the allocations can be queued_@param locationPreferenceConstraint constraint for the location preferences;public void scheduleAll(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) {_		_		final ExecutionVertex[] vertices = this.taskVertices___		_		for (ExecutionVertex ev : vertices) {_			ev.scheduleForExecution(slotProvider, queued, locationPreferenceConstraint)__		}_	};schedules,all,execution,vertices,of,this,execution,job,vertex,param,slot,provider,to,allocate,the,slots,from,param,queued,if,the,allocations,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences;public,void,schedule,all,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,final,execution,vertex,vertices,this,task,vertices,for,execution,vertex,ev,vertices,ev,schedule,for,execution,slot,provider,queued,location,preference,constraint
ExecutionJobVertex -> public void scheduleAll( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint);1518302632;Schedules all execution vertices of this ExecutionJobVertex.__@param slotProvider to allocate the slots from_@param queued if the allocations can be queued_@param locationPreferenceConstraint constraint for the location preferences;public void scheduleAll(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) {_		_		final ExecutionVertex[] vertices = this.taskVertices___		_		for (ExecutionVertex ev : vertices) {_			ev.scheduleForExecution(slotProvider, queued, locationPreferenceConstraint)__		}_	};schedules,all,execution,vertices,of,this,execution,job,vertex,param,slot,provider,to,allocate,the,slots,from,param,queued,if,the,allocations,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences;public,void,schedule,all,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,final,execution,vertex,vertices,this,task,vertices,for,execution,vertex,ev,vertices,ev,schedule,for,execution,slot,provider,queued,location,preference,constraint
ExecutionJobVertex -> public void scheduleAll( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint);1518680774;Schedules all execution vertices of this ExecutionJobVertex.__@param slotProvider to allocate the slots from_@param queued if the allocations can be queued_@param locationPreferenceConstraint constraint for the location preferences;public void scheduleAll(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) {_		_		final ExecutionVertex[] vertices = this.taskVertices___		_		for (ExecutionVertex ev : vertices) {_			ev.scheduleForExecution(slotProvider, queued, locationPreferenceConstraint)__		}_	};schedules,all,execution,vertices,of,this,execution,job,vertex,param,slot,provider,to,allocate,the,slots,from,param,queued,if,the,allocations,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences;public,void,schedule,all,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,final,execution,vertex,vertices,this,task,vertices,for,execution,vertex,ev,vertices,ev,schedule,for,execution,slot,provider,queued,location,preference,constraint
ExecutionJobVertex -> public void prepareForArchiving();1423135035;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null
ExecutionJobVertex -> public void prepareForArchiving();1423158640;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1423158640;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1423493135;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1423493136;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1423493773;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1423847366;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1424822375;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1426697080;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1426697080;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1427784999;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1431459357;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1433537224;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1434467925;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1437494294;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1441881334;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1442492511;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1442492511;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1447958791;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1452526242;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1452854660;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1453733340;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1455716764;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1470419821;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1472483275;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null
ExecutionJobVertex -> public void prepareForArchiving();1472663071;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null
ExecutionJobVertex -> public void prepareForArchiving();1473023399;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null
ExecutionJobVertex -> public void prepareForArchiving();1474548132;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1501622876;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1502801814;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1508861310;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1508861311;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1508861311;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1509638684;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1509638685;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1513261599;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1518302632;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1518680774;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1519316529;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1522049586;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1528203340;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1532383539;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1540920690;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1541770593;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1547644408;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1550220073;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1550683188;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		return FutureUtils.waitForAll(mapExecutionVertices(ExecutionVertex::cancel))__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,return,future,utils,wait,for,all,map,execution,vertices,execution,vertex,cancel
ExecutionJobVertex -> public Future<Void> cancelWithFuture();1493831843;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public Future<Void> cancelWithFuture() {_		_		ArrayList<Future<?>> futures = new ArrayList<>(parallelism)___		_		for (ExecutionVertex ev : getTaskVertices()) {_			futures.add(ev.cancel())__		}__		_		return FutureUtils.combineAll(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,future,void,cancel,with,future,array,list,future,futures,new,array,list,parallelism,for,execution,vertex,ev,get,task,vertices,futures,add,ev,cancel,return,future,utils,combine,all,futures
ExecutionJobVertex -> public Future<Void> cancelWithFuture();1493831843;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public Future<Void> cancelWithFuture() {_		_		ArrayList<Future<?>> futures = new ArrayList<>(parallelism)___		_		for (ExecutionVertex ev : getTaskVertices()) {_			futures.add(ev.cancel())__		}__		_		return FutureUtils.combineAll(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,future,void,cancel,with,future,array,list,future,futures,new,array,list,parallelism,for,execution,vertex,ev,get,task,vertices,futures,add,ev,cancel,return,future,utils,combine,all,futures
ExecutionJobVertex -> public Future<Void> cancelWithFuture();1495001903;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public Future<Void> cancelWithFuture() {_		_		ArrayList<Future<ExecutionState>> futures = new ArrayList<>(parallelism)___		_		for (ExecutionVertex ev : getTaskVertices()) {_			futures.add(ev.cancel())__		}__		_		return FutureUtils.waitForAll(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,future,void,cancel,with,future,array,list,future,execution,state,futures,new,array,list,parallelism,for,execution,vertex,ev,get,task,vertices,futures,add,ev,cancel,return,future,utils,wait,for,all,futures
ExecutionJobVertex -> public Collection<CompletableFuture<Execution>> allocateResourcesForAll( 			SlotProvider resourceProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint);1509638685;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested._@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences;public Collection<CompletableFuture<Execution>> allocateResourcesForAll(_			SlotProvider resourceProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) {_		final ExecutionVertex[] vertices = this.taskVertices__		final CompletableFuture<Execution>[] slots = new CompletableFuture[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {_			_			final Execution exec = vertices[i].getCurrentExecutionAttempt()__			final CompletableFuture<Execution> allocationFuture = exec.allocateAndAssignSlotForExecution(_				resourceProvider,_				queued,_				locationPreferenceConstraint)__			slots[i] = allocationFuture__		}__		_		return Arrays.asList(slots)__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences;public,collection,completable,future,execution,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,location,preference,constraint,location,preference,constraint,final,execution,vertex,vertices,this,task,vertices,final,completable,future,execution,slots,new,completable,future,vertices,length,for,int,i,0,i,vertices,length,i,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,execution,allocation,future,exec,allocate,and,assign,slot,for,execution,resource,provider,queued,location,preference,constraint,slots,i,allocation,future,return,arrays,as,list,slots
ExecutionJobVertex -> public Collection<CompletableFuture<Execution>> allocateResourcesForAll( 			SlotProvider resourceProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint);1513261599;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested._@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences;public Collection<CompletableFuture<Execution>> allocateResourcesForAll(_			SlotProvider resourceProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) {_		final ExecutionVertex[] vertices = this.taskVertices__		final CompletableFuture<Execution>[] slots = new CompletableFuture[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {_			_			final Execution exec = vertices[i].getCurrentExecutionAttempt()__			final CompletableFuture<Execution> allocationFuture = exec.allocateAndAssignSlotForExecution(_				resourceProvider,_				queued,_				locationPreferenceConstraint)__			slots[i] = allocationFuture__		}__		_		return Arrays.asList(slots)__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences;public,collection,completable,future,execution,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,location,preference,constraint,location,preference,constraint,final,execution,vertex,vertices,this,task,vertices,final,completable,future,execution,slots,new,completable,future,vertices,length,for,int,i,0,i,vertices,length,i,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,execution,allocation,future,exec,allocate,and,assign,slot,for,execution,resource,provider,queued,location,preference,constraint,slots,i,allocation,future,return,arrays,as,list,slots
ExecutionJobVertex -> public Collection<CompletableFuture<Execution>> allocateResourcesForAll( 			SlotProvider resourceProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint);1518302632;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested._@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences;public Collection<CompletableFuture<Execution>> allocateResourcesForAll(_			SlotProvider resourceProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) {_		final ExecutionVertex[] vertices = this.taskVertices__		final CompletableFuture<Execution>[] slots = new CompletableFuture[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {_			_			final Execution exec = vertices[i].getCurrentExecutionAttempt()__			final CompletableFuture<Execution> allocationFuture = exec.allocateAndAssignSlotForExecution(_				resourceProvider,_				queued,_				locationPreferenceConstraint)__			slots[i] = allocationFuture__		}__		_		return Arrays.asList(slots)__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences;public,collection,completable,future,execution,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,location,preference,constraint,location,preference,constraint,final,execution,vertex,vertices,this,task,vertices,final,completable,future,execution,slots,new,completable,future,vertices,length,for,int,i,0,i,vertices,length,i,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,execution,allocation,future,exec,allocate,and,assign,slot,for,execution,resource,provider,queued,location,preference,constraint,slots,i,allocation,future,return,arrays,as,list,slots
ExecutionJobVertex -> public Collection<CompletableFuture<Execution>> allocateResourcesForAll( 			SlotProvider resourceProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds, 			Time allocationTimeout);1540920690;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested._@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds the allocation ids of all previous executions in the execution job graph._@param allocationTimeout timeout for allocating the individual slots;public Collection<CompletableFuture<Execution>> allocateResourcesForAll(_			SlotProvider resourceProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds,_			Time allocationTimeout) {_		final ExecutionVertex[] vertices = this.taskVertices__		final CompletableFuture<Execution>[] slots = new CompletableFuture[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {_			_			final Execution exec = vertices[i].getCurrentExecutionAttempt()__			final CompletableFuture<Execution> allocationFuture = exec.allocateAndAssignSlotForExecution(_				resourceProvider,_				queued,_				locationPreferenceConstraint,_				allPreviousExecutionGraphAllocationIds,_				allocationTimeout)__			slots[i] = allocationFuture__		}__		_		return Arrays.asList(slots)__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,the,allocation,ids,of,all,previous,executions,in,the,execution,job,graph,param,allocation,timeout,timeout,for,allocating,the,individual,slots;public,collection,completable,future,execution,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,time,allocation,timeout,final,execution,vertex,vertices,this,task,vertices,final,completable,future,execution,slots,new,completable,future,vertices,length,for,int,i,0,i,vertices,length,i,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,execution,allocation,future,exec,allocate,and,assign,slot,for,execution,resource,provider,queued,location,preference,constraint,all,previous,execution,graph,allocation,ids,allocation,timeout,slots,i,allocation,future,return,arrays,as,list,slots
ExecutionJobVertex -> public Collection<CompletableFuture<Execution>> allocateResourcesForAll( 			SlotProvider resourceProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds, 			Time allocationTimeout);1541770593;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested._@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds the allocation ids of all previous executions in the execution job graph._@param allocationTimeout timeout for allocating the individual slots;public Collection<CompletableFuture<Execution>> allocateResourcesForAll(_			SlotProvider resourceProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds,_			Time allocationTimeout) {_		final ExecutionVertex[] vertices = this.taskVertices__		final CompletableFuture<Execution>[] slots = new CompletableFuture[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {_			_			final Execution exec = vertices[i].getCurrentExecutionAttempt()__			final CompletableFuture<Execution> allocationFuture = exec.allocateAndAssignSlotForExecution(_				resourceProvider,_				queued,_				locationPreferenceConstraint,_				allPreviousExecutionGraphAllocationIds,_				allocationTimeout)__			slots[i] = allocationFuture__		}__		_		return Arrays.asList(slots)__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,the,allocation,ids,of,all,previous,executions,in,the,execution,job,graph,param,allocation,timeout,timeout,for,allocating,the,individual,slots;public,collection,completable,future,execution,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,time,allocation,timeout,final,execution,vertex,vertices,this,task,vertices,final,completable,future,execution,slots,new,completable,future,vertices,length,for,int,i,0,i,vertices,length,i,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,execution,allocation,future,exec,allocate,and,assign,slot,for,execution,resource,provider,queued,location,preference,constraint,all,previous,execution,graph,allocation,ids,allocation,timeout,slots,i,allocation,future,return,arrays,as,list,slots
ExecutionJobVertex -> public Collection<CompletableFuture<Execution>> allocateResourcesForAll( 			SlotProvider resourceProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds, 			Time allocationTimeout);1547644408;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested._@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds the allocation ids of all previous executions in the execution job graph._@param allocationTimeout timeout for allocating the individual slots;public Collection<CompletableFuture<Execution>> allocateResourcesForAll(_			SlotProvider resourceProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds,_			Time allocationTimeout) {_		final ExecutionVertex[] vertices = this.taskVertices__		final CompletableFuture<Execution>[] slots = new CompletableFuture[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {_			_			final Execution exec = vertices[i].getCurrentExecutionAttempt()__			final CompletableFuture<Execution> allocationFuture = exec.allocateAndAssignSlotForExecution(_				resourceProvider,_				queued,_				locationPreferenceConstraint,_				allPreviousExecutionGraphAllocationIds,_				allocationTimeout)__			slots[i] = allocationFuture__		}__		_		return Arrays.asList(slots)__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,the,allocation,ids,of,all,previous,executions,in,the,execution,job,graph,param,allocation,timeout,timeout,for,allocating,the,individual,slots;public,collection,completable,future,execution,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,time,allocation,timeout,final,execution,vertex,vertices,this,task,vertices,final,completable,future,execution,slots,new,completable,future,vertices,length,for,int,i,0,i,vertices,length,i,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,execution,allocation,future,exec,allocate,and,assign,slot,for,execution,resource,provider,queued,location,preference,constraint,all,previous,execution,graph,allocation,ids,allocation,timeout,slots,i,allocation,future,return,arrays,as,list,slots
ExecutionJobVertex -> public Collection<CompletableFuture<Execution>> allocateResourcesForAll( 			SlotProvider resourceProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds, 			Time allocationTimeout);1550220073;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested._@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds the allocation ids of all previous executions in the execution job graph._@param allocationTimeout timeout for allocating the individual slots;public Collection<CompletableFuture<Execution>> allocateResourcesForAll(_			SlotProvider resourceProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds,_			Time allocationTimeout) {_		final ExecutionVertex[] vertices = this.taskVertices___		@SuppressWarnings("unchecked")_		final CompletableFuture<Execution>[] slots = new CompletableFuture[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {_			_			final Execution exec = vertices[i].getCurrentExecutionAttempt()__			final CompletableFuture<Execution> allocationFuture = exec.allocateAndAssignSlotForExecution(_				resourceProvider,_				queued,_				locationPreferenceConstraint,_				allPreviousExecutionGraphAllocationIds,_				allocationTimeout)__			slots[i] = allocationFuture__		}__		_		return Arrays.asList(slots)__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,the,allocation,ids,of,all,previous,executions,in,the,execution,job,graph,param,allocation,timeout,timeout,for,allocating,the,individual,slots;public,collection,completable,future,execution,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,time,allocation,timeout,final,execution,vertex,vertices,this,task,vertices,suppress,warnings,unchecked,final,completable,future,execution,slots,new,completable,future,vertices,length,for,int,i,0,i,vertices,length,i,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,execution,allocation,future,exec,allocate,and,assign,slot,for,execution,resource,provider,queued,location,preference,constraint,all,previous,execution,graph,allocation,ids,allocation,timeout,slots,i,allocation,future,return,arrays,as,list,slots
ExecutionJobVertex -> public Collection<CompletableFuture<Execution>> allocateResourcesForAll( 			SlotProvider resourceProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds, 			Time allocationTimeout);1550683188;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested._@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds the allocation ids of all previous executions in the execution job graph._@param allocationTimeout timeout for allocating the individual slots;public Collection<CompletableFuture<Execution>> allocateResourcesForAll(_			SlotProvider resourceProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds,_			Time allocationTimeout) {_		final ExecutionVertex[] vertices = this.taskVertices___		@SuppressWarnings("unchecked")_		final CompletableFuture<Execution>[] slots = new CompletableFuture[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {_			_			final Execution exec = vertices[i].getCurrentExecutionAttempt()__			final CompletableFuture<Execution> allocationFuture = exec.allocateAndAssignSlotForExecution(_				resourceProvider,_				queued,_				locationPreferenceConstraint,_				allPreviousExecutionGraphAllocationIds,_				allocationTimeout)__			slots[i] = allocationFuture__		}__		_		return Arrays.asList(slots)__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,the,allocation,ids,of,all,previous,executions,in,the,execution,job,graph,param,allocation,timeout,timeout,for,allocating,the,individual,slots;public,collection,completable,future,execution,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,time,allocation,timeout,final,execution,vertex,vertices,this,task,vertices,suppress,warnings,unchecked,final,completable,future,execution,slots,new,completable,future,vertices,length,for,int,i,0,i,vertices,length,i,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,execution,allocation,future,exec,allocate,and,assign,slot,for,execution,resource,provider,queued,location,preference,constraint,all,previous,execution,graph,allocation,ids,allocation,timeout,slots,i,allocation,future,return,arrays,as,list,slots
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1493403095;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1493831843;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1493831843;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1495001903;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1501622876;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1502801814;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1508861310;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1508861311;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1508861311;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1509638684;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1509638685;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1513261599;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1518302632;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1518680774;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1519316529;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1522049586;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1528203340;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1532383539;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1540920690;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1541770593;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1547644408;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1550220073;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1550683188;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public void cancel();1493831843;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1493831843;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1495001903;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1501622876;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1502801814;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1508861310;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1508861311;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1508861311;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1509638684;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1509638685;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1513261599;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1518302632;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1518680774;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1519316529;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1522049586;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1528203340;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1532383539;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1540920690;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1541770593;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1547644408;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1550220073;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1550683188;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1493831843;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1495001903;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1501622876;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1502801814;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1508861310;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1508861311;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1508861311;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1509638684;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1509638685;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1513261599;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1518302632;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1518680774;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1519316529;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1522049586;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1528203340;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1532383539;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1540920690;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1541770593;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1547644408;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1550220073;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1550683188;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> public Collection<CompletableFuture<Execution>> allocateResourcesForAll( 			SlotProvider resourceProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			Time allocationTimeout);1518680774;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested._@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allocationTimeout timeout for allocating the individual slots;public Collection<CompletableFuture<Execution>> allocateResourcesForAll(_			SlotProvider resourceProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			Time allocationTimeout) {_		final ExecutionVertex[] vertices = this.taskVertices__		final CompletableFuture<Execution>[] slots = new CompletableFuture[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {_			_			final Execution exec = vertices[i].getCurrentExecutionAttempt()__			final CompletableFuture<Execution> allocationFuture = exec.allocateAndAssignSlotForExecution(_				resourceProvider,_				queued,_				locationPreferenceConstraint,_				allocationTimeout)__			slots[i] = allocationFuture__		}__		_		return Arrays.asList(slots)__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,allocation,timeout,timeout,for,allocating,the,individual,slots;public,collection,completable,future,execution,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,location,preference,constraint,location,preference,constraint,time,allocation,timeout,final,execution,vertex,vertices,this,task,vertices,final,completable,future,execution,slots,new,completable,future,vertices,length,for,int,i,0,i,vertices,length,i,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,execution,allocation,future,exec,allocate,and,assign,slot,for,execution,resource,provider,queued,location,preference,constraint,allocation,timeout,slots,i,allocation,future,return,arrays,as,list,slots
ExecutionJobVertex -> public Collection<CompletableFuture<Execution>> allocateResourcesForAll( 			SlotProvider resourceProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			Time allocationTimeout);1519316529;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested._@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allocationTimeout timeout for allocating the individual slots;public Collection<CompletableFuture<Execution>> allocateResourcesForAll(_			SlotProvider resourceProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			Time allocationTimeout) {_		final ExecutionVertex[] vertices = this.taskVertices__		final CompletableFuture<Execution>[] slots = new CompletableFuture[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {_			_			final Execution exec = vertices[i].getCurrentExecutionAttempt()__			final CompletableFuture<Execution> allocationFuture = exec.allocateAndAssignSlotForExecution(_				resourceProvider,_				queued,_				locationPreferenceConstraint,_				allocationTimeout)__			slots[i] = allocationFuture__		}__		_		return Arrays.asList(slots)__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,allocation,timeout,timeout,for,allocating,the,individual,slots;public,collection,completable,future,execution,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,location,preference,constraint,location,preference,constraint,time,allocation,timeout,final,execution,vertex,vertices,this,task,vertices,final,completable,future,execution,slots,new,completable,future,vertices,length,for,int,i,0,i,vertices,length,i,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,execution,allocation,future,exec,allocate,and,assign,slot,for,execution,resource,provider,queued,location,preference,constraint,allocation,timeout,slots,i,allocation,future,return,arrays,as,list,slots
ExecutionJobVertex -> public Collection<CompletableFuture<Execution>> allocateResourcesForAll( 			SlotProvider resourceProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			Time allocationTimeout);1522049586;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested._@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allocationTimeout timeout for allocating the individual slots;public Collection<CompletableFuture<Execution>> allocateResourcesForAll(_			SlotProvider resourceProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			Time allocationTimeout) {_		final ExecutionVertex[] vertices = this.taskVertices__		final CompletableFuture<Execution>[] slots = new CompletableFuture[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {_			_			final Execution exec = vertices[i].getCurrentExecutionAttempt()__			final CompletableFuture<Execution> allocationFuture = exec.allocateAndAssignSlotForExecution(_				resourceProvider,_				queued,_				locationPreferenceConstraint,_				allocationTimeout)__			slots[i] = allocationFuture__		}__		_		return Arrays.asList(slots)__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,allocation,timeout,timeout,for,allocating,the,individual,slots;public,collection,completable,future,execution,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,location,preference,constraint,location,preference,constraint,time,allocation,timeout,final,execution,vertex,vertices,this,task,vertices,final,completable,future,execution,slots,new,completable,future,vertices,length,for,int,i,0,i,vertices,length,i,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,execution,allocation,future,exec,allocate,and,assign,slot,for,execution,resource,provider,queued,location,preference,constraint,allocation,timeout,slots,i,allocation,future,return,arrays,as,list,slots
ExecutionJobVertex -> public Collection<CompletableFuture<Execution>> allocateResourcesForAll( 			SlotProvider resourceProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			Time allocationTimeout);1528203340;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested._@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allocationTimeout timeout for allocating the individual slots;public Collection<CompletableFuture<Execution>> allocateResourcesForAll(_			SlotProvider resourceProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			Time allocationTimeout) {_		final ExecutionVertex[] vertices = this.taskVertices__		final CompletableFuture<Execution>[] slots = new CompletableFuture[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {_			_			final Execution exec = vertices[i].getCurrentExecutionAttempt()__			final CompletableFuture<Execution> allocationFuture = exec.allocateAndAssignSlotForExecution(_				resourceProvider,_				queued,_				locationPreferenceConstraint,_				allocationTimeout)__			slots[i] = allocationFuture__		}__		_		return Arrays.asList(slots)__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,allocation,timeout,timeout,for,allocating,the,individual,slots;public,collection,completable,future,execution,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,location,preference,constraint,location,preference,constraint,time,allocation,timeout,final,execution,vertex,vertices,this,task,vertices,final,completable,future,execution,slots,new,completable,future,vertices,length,for,int,i,0,i,vertices,length,i,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,execution,allocation,future,exec,allocate,and,assign,slot,for,execution,resource,provider,queued,location,preference,constraint,allocation,timeout,slots,i,allocation,future,return,arrays,as,list,slots
ExecutionJobVertex -> public Collection<CompletableFuture<Execution>> allocateResourcesForAll( 			SlotProvider resourceProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			Time allocationTimeout);1532383539;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested._@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allocationTimeout timeout for allocating the individual slots;public Collection<CompletableFuture<Execution>> allocateResourcesForAll(_			SlotProvider resourceProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			Time allocationTimeout) {_		final ExecutionVertex[] vertices = this.taskVertices__		final CompletableFuture<Execution>[] slots = new CompletableFuture[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {_			_			final Execution exec = vertices[i].getCurrentExecutionAttempt()__			final CompletableFuture<Execution> allocationFuture = exec.allocateAndAssignSlotForExecution(_				resourceProvider,_				queued,_				locationPreferenceConstraint,_				allocationTimeout)__			slots[i] = allocationFuture__		}__		_		return Arrays.asList(slots)__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,allocation,timeout,timeout,for,allocating,the,individual,slots;public,collection,completable,future,execution,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,location,preference,constraint,location,preference,constraint,time,allocation,timeout,final,execution,vertex,vertices,this,task,vertices,final,completable,future,execution,slots,new,completable,future,vertices,length,for,int,i,0,i,vertices,length,i,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,execution,allocation,future,exec,allocate,and,assign,slot,for,execution,resource,provider,queued,location,preference,constraint,allocation,timeout,slots,i,allocation,future,return,arrays,as,list,slots
ExecutionJobVertex -> public CompletableFuture<Void> scheduleAll( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds);1540920690;Schedules all execution vertices of this ExecutionJobVertex.__@param slotProvider to allocate the slots from_@param queued if the allocations can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph._Can be empty if the allocation ids are not required for scheduling._@return Future which is completed once all {@link Execution} could be deployed;public CompletableFuture<Void> scheduleAll(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds) {__		final ExecutionVertex[] vertices = this.taskVertices___		final ArrayList<CompletableFuture<Void>> scheduleFutures = new ArrayList<>(vertices.length)___		_		for (ExecutionVertex ev : vertices) {_			scheduleFutures.add(ev.scheduleForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint,_				allPreviousExecutionGraphAllocationIds))__		}__		return FutureUtils.waitForAll(scheduleFutures)__	};schedules,all,execution,vertices,of,this,execution,job,vertex,param,slot,provider,to,allocate,the,slots,from,param,queued,if,the,allocations,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,set,with,all,previous,allocation,ids,in,the,job,graph,can,be,empty,if,the,allocation,ids,are,not,required,for,scheduling,return,future,which,is,completed,once,all,link,execution,could,be,deployed;public,completable,future,void,schedule,all,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,final,execution,vertex,vertices,this,task,vertices,final,array,list,completable,future,void,schedule,futures,new,array,list,vertices,length,for,execution,vertex,ev,vertices,schedule,futures,add,ev,schedule,for,execution,slot,provider,queued,location,preference,constraint,all,previous,execution,graph,allocation,ids,return,future,utils,wait,for,all,schedule,futures
ExecutionJobVertex -> public CompletableFuture<Void> scheduleAll( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds);1541770593;Schedules all execution vertices of this ExecutionJobVertex.__@param slotProvider to allocate the slots from_@param queued if the allocations can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph._Can be empty if the allocation ids are not required for scheduling._@return Future which is completed once all {@link Execution} could be deployed;public CompletableFuture<Void> scheduleAll(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds) {__		final ExecutionVertex[] vertices = this.taskVertices___		final ArrayList<CompletableFuture<Void>> scheduleFutures = new ArrayList<>(vertices.length)___		_		for (ExecutionVertex ev : vertices) {_			scheduleFutures.add(ev.scheduleForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint,_				allPreviousExecutionGraphAllocationIds))__		}__		return FutureUtils.waitForAll(scheduleFutures)__	};schedules,all,execution,vertices,of,this,execution,job,vertex,param,slot,provider,to,allocate,the,slots,from,param,queued,if,the,allocations,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,set,with,all,previous,allocation,ids,in,the,job,graph,can,be,empty,if,the,allocation,ids,are,not,required,for,scheduling,return,future,which,is,completed,once,all,link,execution,could,be,deployed;public,completable,future,void,schedule,all,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,final,execution,vertex,vertices,this,task,vertices,final,array,list,completable,future,void,schedule,futures,new,array,list,vertices,length,for,execution,vertex,ev,vertices,schedule,futures,add,ev,schedule,for,execution,slot,provider,queued,location,preference,constraint,all,previous,execution,graph,allocation,ids,return,future,utils,wait,for,all,schedule,futures
ExecutionJobVertex -> public CompletableFuture<Void> scheduleAll( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds);1547644408;Schedules all execution vertices of this ExecutionJobVertex.__@param slotProvider to allocate the slots from_@param queued if the allocations can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph._Can be empty if the allocation ids are not required for scheduling._@return Future which is completed once all {@link Execution} could be deployed;public CompletableFuture<Void> scheduleAll(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds) {__		final ExecutionVertex[] vertices = this.taskVertices___		final ArrayList<CompletableFuture<Void>> scheduleFutures = new ArrayList<>(vertices.length)___		_		for (ExecutionVertex ev : vertices) {_			scheduleFutures.add(ev.scheduleForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint,_				allPreviousExecutionGraphAllocationIds))__		}__		return FutureUtils.waitForAll(scheduleFutures)__	};schedules,all,execution,vertices,of,this,execution,job,vertex,param,slot,provider,to,allocate,the,slots,from,param,queued,if,the,allocations,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,set,with,all,previous,allocation,ids,in,the,job,graph,can,be,empty,if,the,allocation,ids,are,not,required,for,scheduling,return,future,which,is,completed,once,all,link,execution,could,be,deployed;public,completable,future,void,schedule,all,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,final,execution,vertex,vertices,this,task,vertices,final,array,list,completable,future,void,schedule,futures,new,array,list,vertices,length,for,execution,vertex,ev,vertices,schedule,futures,add,ev,schedule,for,execution,slot,provider,queued,location,preference,constraint,all,previous,execution,graph,allocation,ids,return,future,utils,wait,for,all,schedule,futures
ExecutionJobVertex -> public CompletableFuture<Void> scheduleAll( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds);1550220073;Schedules all execution vertices of this ExecutionJobVertex.__@param slotProvider to allocate the slots from_@param queued if the allocations can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph._Can be empty if the allocation ids are not required for scheduling._@return Future which is completed once all {@link Execution} could be deployed;public CompletableFuture<Void> scheduleAll(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds) {__		final ExecutionVertex[] vertices = this.taskVertices___		final ArrayList<CompletableFuture<Void>> scheduleFutures = new ArrayList<>(vertices.length)___		_		for (ExecutionVertex ev : vertices) {_			scheduleFutures.add(ev.scheduleForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint,_				allPreviousExecutionGraphAllocationIds))__		}__		return FutureUtils.waitForAll(scheduleFutures)__	};schedules,all,execution,vertices,of,this,execution,job,vertex,param,slot,provider,to,allocate,the,slots,from,param,queued,if,the,allocations,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,set,with,all,previous,allocation,ids,in,the,job,graph,can,be,empty,if,the,allocation,ids,are,not,required,for,scheduling,return,future,which,is,completed,once,all,link,execution,could,be,deployed;public,completable,future,void,schedule,all,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,final,execution,vertex,vertices,this,task,vertices,final,array,list,completable,future,void,schedule,futures,new,array,list,vertices,length,for,execution,vertex,ev,vertices,schedule,futures,add,ev,schedule,for,execution,slot,provider,queued,location,preference,constraint,all,previous,execution,graph,allocation,ids,return,future,utils,wait,for,all,schedule,futures
ExecutionJobVertex -> public CompletableFuture<Void> scheduleAll( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds);1550683188;Schedules all execution vertices of this ExecutionJobVertex.__@param slotProvider to allocate the slots from_@param queued if the allocations can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph._Can be empty if the allocation ids are not required for scheduling._@return Future which is completed once all {@link Execution} could be deployed;public CompletableFuture<Void> scheduleAll(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds) {__		final ExecutionVertex[] vertices = this.taskVertices___		final ArrayList<CompletableFuture<Void>> scheduleFutures = new ArrayList<>(vertices.length)___		_		for (ExecutionVertex ev : vertices) {_			scheduleFutures.add(ev.scheduleForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint,_				allPreviousExecutionGraphAllocationIds))__		}__		return FutureUtils.waitForAll(scheduleFutures)__	};schedules,all,execution,vertices,of,this,execution,job,vertex,param,slot,provider,to,allocate,the,slots,from,param,queued,if,the,allocations,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,set,with,all,previous,allocation,ids,in,the,job,graph,can,be,empty,if,the,allocation,ids,are,not,required,for,scheduling,return,future,which,is,completed,once,all,link,execution,could,be,deployed;public,completable,future,void,schedule,all,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,final,execution,vertex,vertices,this,task,vertices,final,array,list,completable,future,void,schedule,futures,new,array,list,vertices,length,for,execution,vertex,ev,vertices,schedule,futures,add,ev,schedule,for,execution,slot,provider,queued,location,preference,constraint,all,previous,execution,graph,allocation,ids,return,future,utils,wait,for,all,schedule,futures
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1493403095;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1493831843;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1493831843;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1495001903;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1501622876;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1502801814;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1508861310;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1508861311;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1508861311;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1509638684;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1509638685;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1513261599;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1518302632;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1518680774;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1519316529;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1522049586;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1528203340;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1532383539;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1540920690;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1541770593;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1547644408;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1550220073;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1550683188;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1493831843;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1495001903;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1501622876;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1502801814;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1508861310;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1508861311;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1508861311;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1509638684;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1509638685;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1513261599;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1518302632;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1518680774;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1519316529;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1522049586;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1528203340;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1532383539;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1540920690;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1541770593;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1547644408;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1550220073;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1550683188;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public CompletableFuture<Void> scheduleAll( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint);1519316529;Schedules all execution vertices of this ExecutionJobVertex.__@param slotProvider to allocate the slots from_@param queued if the allocations can be queued_@param locationPreferenceConstraint constraint for the location preferences_@return Future which is completed once all {@link Execution} could be deployed;public CompletableFuture<Void> scheduleAll(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) {_		_		final ExecutionVertex[] vertices = this.taskVertices___		final ArrayList<CompletableFuture<Void>> scheduleFutures = new ArrayList<>(vertices.length)___		_		for (ExecutionVertex ev : vertices) {_			scheduleFutures.add(ev.scheduleForExecution(slotProvider, queued, locationPreferenceConstraint))__		}__		return FutureUtils.waitForAll(scheduleFutures)__	};schedules,all,execution,vertices,of,this,execution,job,vertex,param,slot,provider,to,allocate,the,slots,from,param,queued,if,the,allocations,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,return,future,which,is,completed,once,all,link,execution,could,be,deployed;public,completable,future,void,schedule,all,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,final,execution,vertex,vertices,this,task,vertices,final,array,list,completable,future,void,schedule,futures,new,array,list,vertices,length,for,execution,vertex,ev,vertices,schedule,futures,add,ev,schedule,for,execution,slot,provider,queued,location,preference,constraint,return,future,utils,wait,for,all,schedule,futures
ExecutionJobVertex -> public CompletableFuture<Void> scheduleAll( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint);1522049586;Schedules all execution vertices of this ExecutionJobVertex.__@param slotProvider to allocate the slots from_@param queued if the allocations can be queued_@param locationPreferenceConstraint constraint for the location preferences_@return Future which is completed once all {@link Execution} could be deployed;public CompletableFuture<Void> scheduleAll(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) {_		_		final ExecutionVertex[] vertices = this.taskVertices___		final ArrayList<CompletableFuture<Void>> scheduleFutures = new ArrayList<>(vertices.length)___		_		for (ExecutionVertex ev : vertices) {_			scheduleFutures.add(ev.scheduleForExecution(slotProvider, queued, locationPreferenceConstraint))__		}__		return FutureUtils.waitForAll(scheduleFutures)__	};schedules,all,execution,vertices,of,this,execution,job,vertex,param,slot,provider,to,allocate,the,slots,from,param,queued,if,the,allocations,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,return,future,which,is,completed,once,all,link,execution,could,be,deployed;public,completable,future,void,schedule,all,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,final,execution,vertex,vertices,this,task,vertices,final,array,list,completable,future,void,schedule,futures,new,array,list,vertices,length,for,execution,vertex,ev,vertices,schedule,futures,add,ev,schedule,for,execution,slot,provider,queued,location,preference,constraint,return,future,utils,wait,for,all,schedule,futures
ExecutionJobVertex -> public CompletableFuture<Void> scheduleAll( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint);1528203340;Schedules all execution vertices of this ExecutionJobVertex.__@param slotProvider to allocate the slots from_@param queued if the allocations can be queued_@param locationPreferenceConstraint constraint for the location preferences_@return Future which is completed once all {@link Execution} could be deployed;public CompletableFuture<Void> scheduleAll(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) {_		_		final ExecutionVertex[] vertices = this.taskVertices___		final ArrayList<CompletableFuture<Void>> scheduleFutures = new ArrayList<>(vertices.length)___		_		for (ExecutionVertex ev : vertices) {_			scheduleFutures.add(ev.scheduleForExecution(slotProvider, queued, locationPreferenceConstraint))__		}__		return FutureUtils.waitForAll(scheduleFutures)__	};schedules,all,execution,vertices,of,this,execution,job,vertex,param,slot,provider,to,allocate,the,slots,from,param,queued,if,the,allocations,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,return,future,which,is,completed,once,all,link,execution,could,be,deployed;public,completable,future,void,schedule,all,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,final,execution,vertex,vertices,this,task,vertices,final,array,list,completable,future,void,schedule,futures,new,array,list,vertices,length,for,execution,vertex,ev,vertices,schedule,futures,add,ev,schedule,for,execution,slot,provider,queued,location,preference,constraint,return,future,utils,wait,for,all,schedule,futures
ExecutionJobVertex -> public CompletableFuture<Void> scheduleAll( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint);1532383539;Schedules all execution vertices of this ExecutionJobVertex.__@param slotProvider to allocate the slots from_@param queued if the allocations can be queued_@param locationPreferenceConstraint constraint for the location preferences_@return Future which is completed once all {@link Execution} could be deployed;public CompletableFuture<Void> scheduleAll(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) {__		final ExecutionVertex[] vertices = this.taskVertices___		final ArrayList<CompletableFuture<Void>> scheduleFutures = new ArrayList<>(vertices.length)___		_		for (ExecutionVertex ev : vertices) {_			scheduleFutures.add(ev.scheduleForExecution(slotProvider, queued, locationPreferenceConstraint))__		}__		return FutureUtils.waitForAll(scheduleFutures)__	};schedules,all,execution,vertices,of,this,execution,job,vertex,param,slot,provider,to,allocate,the,slots,from,param,queued,if,the,allocations,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,return,future,which,is,completed,once,all,link,execution,could,be,deployed;public,completable,future,void,schedule,all,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,final,execution,vertex,vertices,this,task,vertices,final,array,list,completable,future,void,schedule,futures,new,array,list,vertices,length,for,execution,vertex,ev,vertices,schedule,futures,add,ev,schedule,for,execution,slot,provider,queued,location,preference,constraint,return,future,utils,wait,for,all,schedule,futures
ExecutionJobVertex -> public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued);1487548884;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested.;public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued) {_		final ExecutionVertex[] vertices = this.taskVertices__		final ExecutionAndSlot[] slots = new ExecutionAndSlot[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {__			_			_			boolean successful = false___			try {_				_				final Execution exec = vertices[i].getCurrentExecutionAttempt()__				final Future<SimpleSlot> future = exec.allocateSlotForExecution(resourceProvider, queued)__				slots[i] = new ExecutionAndSlot(exec, future)__				successful = true__			}_			finally {_				if (!successful) {_					_					for (int k = 0_ k < i_ k++) {_						ExecutionGraphUtils.releaseSlotFuture(slots[k].slotFuture)__					}_				}_			}_		}__		_		return slots__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested;public,execution,and,slot,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,final,execution,vertex,vertices,this,task,vertices,final,execution,and,slot,slots,new,execution,and,slot,vertices,length,for,int,i,0,i,vertices,length,i,boolean,successful,false,try,final,execution,exec,vertices,i,get,current,execution,attempt,final,future,simple,slot,future,exec,allocate,slot,for,execution,resource,provider,queued,slots,i,new,execution,and,slot,exec,future,successful,true,finally,if,successful,for,int,k,0,k,i,k,execution,graph,utils,release,slot,future,slots,k,slot,future,return,slots
ExecutionJobVertex -> public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued);1489149057;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested.;public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued) {_		final ExecutionVertex[] vertices = this.taskVertices__		final ExecutionAndSlot[] slots = new ExecutionAndSlot[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {__			_			_			boolean successful = false___			try {_				_				final Execution exec = vertices[i].getCurrentExecutionAttempt()__				final Future<SimpleSlot> future = exec.allocateSlotForExecution(resourceProvider, queued)__				slots[i] = new ExecutionAndSlot(exec, future)__				successful = true__			}_			finally {_				if (!successful) {_					_					for (int k = 0_ k < i_ k++) {_						ExecutionGraphUtils.releaseSlotFuture(slots[k].slotFuture)__					}_				}_			}_		}__		_		return slots__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested;public,execution,and,slot,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,final,execution,vertex,vertices,this,task,vertices,final,execution,and,slot,slots,new,execution,and,slot,vertices,length,for,int,i,0,i,vertices,length,i,boolean,successful,false,try,final,execution,exec,vertices,i,get,current,execution,attempt,final,future,simple,slot,future,exec,allocate,slot,for,execution,resource,provider,queued,slots,i,new,execution,and,slot,exec,future,successful,true,finally,if,successful,for,int,k,0,k,i,k,execution,graph,utils,release,slot,future,slots,k,slot,future,return,slots
ExecutionJobVertex -> public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued);1489782894;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested.;public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued) {_		final ExecutionVertex[] vertices = this.taskVertices__		final ExecutionAndSlot[] slots = new ExecutionAndSlot[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {__			_			_			boolean successful = false___			try {_				_				final Execution exec = vertices[i].getCurrentExecutionAttempt()__				final Future<SimpleSlot> future = exec.allocateSlotForExecution(resourceProvider, queued)__				slots[i] = new ExecutionAndSlot(exec, future)__				successful = true__			}_			finally {_				if (!successful) {_					_					for (int k = 0_ k < i_ k++) {_						ExecutionGraphUtils.releaseSlotFuture(slots[k].slotFuture)__					}_				}_			}_		}__		_		return slots__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested;public,execution,and,slot,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,final,execution,vertex,vertices,this,task,vertices,final,execution,and,slot,slots,new,execution,and,slot,vertices,length,for,int,i,0,i,vertices,length,i,boolean,successful,false,try,final,execution,exec,vertices,i,get,current,execution,attempt,final,future,simple,slot,future,exec,allocate,slot,for,execution,resource,provider,queued,slots,i,new,execution,and,slot,exec,future,successful,true,finally,if,successful,for,int,k,0,k,i,k,execution,graph,utils,release,slot,future,slots,k,slot,future,return,slots
ExecutionJobVertex -> public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued);1490128641;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested.;public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued) {_		final ExecutionVertex[] vertices = this.taskVertices__		final ExecutionAndSlot[] slots = new ExecutionAndSlot[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {__			_			_			boolean successful = false___			try {_				_				final Execution exec = vertices[i].getCurrentExecutionAttempt()__				final Future<SimpleSlot> future = exec.allocateSlotForExecution(resourceProvider, queued)__				slots[i] = new ExecutionAndSlot(exec, future)__				successful = true__			}_			finally {_				if (!successful) {_					_					for (int k = 0_ k < i_ k++) {_						ExecutionGraphUtils.releaseSlotFuture(slots[k].slotFuture)__					}_				}_			}_		}__		_		return slots__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested;public,execution,and,slot,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,final,execution,vertex,vertices,this,task,vertices,final,execution,and,slot,slots,new,execution,and,slot,vertices,length,for,int,i,0,i,vertices,length,i,boolean,successful,false,try,final,execution,exec,vertices,i,get,current,execution,attempt,final,future,simple,slot,future,exec,allocate,slot,for,execution,resource,provider,queued,slots,i,new,execution,and,slot,exec,future,successful,true,finally,if,successful,for,int,k,0,k,i,k,execution,graph,utils,release,slot,future,slots,k,slot,future,return,slots
ExecutionJobVertex -> public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued);1492530130;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested.;public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued) {_		final ExecutionVertex[] vertices = this.taskVertices__		final ExecutionAndSlot[] slots = new ExecutionAndSlot[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {__			_			_			boolean successful = false___			try {_				_				final Execution exec = vertices[i].getCurrentExecutionAttempt()__				final Future<SimpleSlot> future = exec.allocateSlotForExecution(resourceProvider, queued)__				slots[i] = new ExecutionAndSlot(exec, future)__				successful = true__			}_			finally {_				if (!successful) {_					_					for (int k = 0_ k < i_ k++) {_						ExecutionGraphUtils.releaseSlotFuture(slots[k].slotFuture)__					}_				}_			}_		}__		_		return slots__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested;public,execution,and,slot,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,final,execution,vertex,vertices,this,task,vertices,final,execution,and,slot,slots,new,execution,and,slot,vertices,length,for,int,i,0,i,vertices,length,i,boolean,successful,false,try,final,execution,exec,vertices,i,get,current,execution,attempt,final,future,simple,slot,future,exec,allocate,slot,for,execution,resource,provider,queued,slots,i,new,execution,and,slot,exec,future,successful,true,finally,if,successful,for,int,k,0,k,i,k,execution,graph,utils,release,slot,future,slots,k,slot,future,return,slots
ExecutionJobVertex -> public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued);1493403095;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested.;public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued) {_		final ExecutionVertex[] vertices = this.taskVertices__		final ExecutionAndSlot[] slots = new ExecutionAndSlot[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {__			_			_			boolean successful = false___			try {_				_				final Execution exec = vertices[i].getCurrentExecutionAttempt()__				final Future<SimpleSlot> future = exec.allocateSlotForExecution(resourceProvider, queued)__				slots[i] = new ExecutionAndSlot(exec, future)__				successful = true__			}_			finally {_				if (!successful) {_					_					for (int k = 0_ k < i_ k++) {_						ExecutionGraphUtils.releaseSlotFuture(slots[k].slotFuture)__					}_				}_			}_		}__		_		return slots__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested;public,execution,and,slot,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,final,execution,vertex,vertices,this,task,vertices,final,execution,and,slot,slots,new,execution,and,slot,vertices,length,for,int,i,0,i,vertices,length,i,boolean,successful,false,try,final,execution,exec,vertices,i,get,current,execution,attempt,final,future,simple,slot,future,exec,allocate,slot,for,execution,resource,provider,queued,slots,i,new,execution,and,slot,exec,future,successful,true,finally,if,successful,for,int,k,0,k,i,k,execution,graph,utils,release,slot,future,slots,k,slot,future,return,slots
ExecutionJobVertex -> public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued);1493831843;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested.;public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued) {_		final ExecutionVertex[] vertices = this.taskVertices__		final ExecutionAndSlot[] slots = new ExecutionAndSlot[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {__			_			_			boolean successful = false___			try {_				_				final Execution exec = vertices[i].getCurrentExecutionAttempt()__				final Future<SimpleSlot> future = exec.allocateSlotForExecution(resourceProvider, queued)__				slots[i] = new ExecutionAndSlot(exec, future)__				successful = true__			}_			finally {_				if (!successful) {_					_					for (int k = 0_ k < i_ k++) {_						ExecutionGraphUtils.releaseSlotFuture(slots[k].slotFuture)__					}_				}_			}_		}__		_		return slots__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested;public,execution,and,slot,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,final,execution,vertex,vertices,this,task,vertices,final,execution,and,slot,slots,new,execution,and,slot,vertices,length,for,int,i,0,i,vertices,length,i,boolean,successful,false,try,final,execution,exec,vertices,i,get,current,execution,attempt,final,future,simple,slot,future,exec,allocate,slot,for,execution,resource,provider,queued,slots,i,new,execution,and,slot,exec,future,successful,true,finally,if,successful,for,int,k,0,k,i,k,execution,graph,utils,release,slot,future,slots,k,slot,future,return,slots
ExecutionJobVertex -> public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued);1493831843;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested.;public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued) {_		final ExecutionVertex[] vertices = this.taskVertices__		final ExecutionAndSlot[] slots = new ExecutionAndSlot[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {__			_			_			boolean successful = false___			try {_				_				final Execution exec = vertices[i].getCurrentExecutionAttempt()__				final Future<SimpleSlot> future = exec.allocateSlotForExecution(resourceProvider, queued)__				slots[i] = new ExecutionAndSlot(exec, future)__				successful = true__			}_			finally {_				if (!successful) {_					_					for (int k = 0_ k < i_ k++) {_						ExecutionGraphUtils.releaseSlotFuture(slots[k].slotFuture)__					}_				}_			}_		}__		_		return slots__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested;public,execution,and,slot,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,final,execution,vertex,vertices,this,task,vertices,final,execution,and,slot,slots,new,execution,and,slot,vertices,length,for,int,i,0,i,vertices,length,i,boolean,successful,false,try,final,execution,exec,vertices,i,get,current,execution,attempt,final,future,simple,slot,future,exec,allocate,slot,for,execution,resource,provider,queued,slots,i,new,execution,and,slot,exec,future,successful,true,finally,if,successful,for,int,k,0,k,i,k,execution,graph,utils,release,slot,future,slots,k,slot,future,return,slots
ExecutionJobVertex -> public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued);1495001903;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested.;public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued) {_		final ExecutionVertex[] vertices = this.taskVertices__		final ExecutionAndSlot[] slots = new ExecutionAndSlot[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {__			_			_			boolean successful = false___			try {_				_				final Execution exec = vertices[i].getCurrentExecutionAttempt()__				final Future<SimpleSlot> future = exec.allocateSlotForExecution(resourceProvider, queued)__				slots[i] = new ExecutionAndSlot(exec, future)__				successful = true__			}_			finally {_				if (!successful) {_					_					for (int k = 0_ k < i_ k++) {_						ExecutionGraphUtils.releaseSlotFuture(slots[k].slotFuture)__					}_				}_			}_		}__		_		return slots__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested;public,execution,and,slot,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,final,execution,vertex,vertices,this,task,vertices,final,execution,and,slot,slots,new,execution,and,slot,vertices,length,for,int,i,0,i,vertices,length,i,boolean,successful,false,try,final,execution,exec,vertices,i,get,current,execution,attempt,final,future,simple,slot,future,exec,allocate,slot,for,execution,resource,provider,queued,slots,i,new,execution,and,slot,exec,future,successful,true,finally,if,successful,for,int,k,0,k,i,k,execution,graph,utils,release,slot,future,slots,k,slot,future,return,slots
ExecutionJobVertex -> public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued);1501622876;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested.;public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued) {_		final ExecutionVertex[] vertices = this.taskVertices__		final ExecutionAndSlot[] slots = new ExecutionAndSlot[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {__			_			_			boolean successful = false___			try {_				_				final Execution exec = vertices[i].getCurrentExecutionAttempt()__				final CompletableFuture<SimpleSlot> future = exec.allocateSlotForExecution(resourceProvider, queued)__				slots[i] = new ExecutionAndSlot(exec, future)__				successful = true__			}_			finally {_				if (!successful) {_					_					for (int k = 0_ k < i_ k++) {_						ExecutionGraphUtils.releaseSlotFuture(slots[k].slotFuture)__					}_				}_			}_		}__		_		return slots__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested;public,execution,and,slot,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,final,execution,vertex,vertices,this,task,vertices,final,execution,and,slot,slots,new,execution,and,slot,vertices,length,for,int,i,0,i,vertices,length,i,boolean,successful,false,try,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,simple,slot,future,exec,allocate,slot,for,execution,resource,provider,queued,slots,i,new,execution,and,slot,exec,future,successful,true,finally,if,successful,for,int,k,0,k,i,k,execution,graph,utils,release,slot,future,slots,k,slot,future,return,slots
ExecutionJobVertex -> public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued);1502801814;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested.;public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued) {_		final ExecutionVertex[] vertices = this.taskVertices__		final ExecutionAndSlot[] slots = new ExecutionAndSlot[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {__			_			_			boolean successful = false___			try {_				_				final Execution exec = vertices[i].getCurrentExecutionAttempt()__				final CompletableFuture<SimpleSlot> future = exec.allocateSlotForExecution(resourceProvider, queued)__				slots[i] = new ExecutionAndSlot(exec, future)__				successful = true__			}_			finally {_				if (!successful) {_					_					for (int k = 0_ k < i_ k++) {_						ExecutionGraphUtils.releaseSlotFuture(slots[k].slotFuture)__					}_				}_			}_		}__		_		return slots__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested;public,execution,and,slot,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,final,execution,vertex,vertices,this,task,vertices,final,execution,and,slot,slots,new,execution,and,slot,vertices,length,for,int,i,0,i,vertices,length,i,boolean,successful,false,try,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,simple,slot,future,exec,allocate,slot,for,execution,resource,provider,queued,slots,i,new,execution,and,slot,exec,future,successful,true,finally,if,successful,for,int,k,0,k,i,k,execution,graph,utils,release,slot,future,slots,k,slot,future,return,slots
ExecutionJobVertex -> public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued);1508861310;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested.;public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued) {_		final ExecutionVertex[] vertices = this.taskVertices__		final ExecutionAndSlot[] slots = new ExecutionAndSlot[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {__			_			_			boolean successful = false___			try {_				_				final Execution exec = vertices[i].getCurrentExecutionAttempt()__				final CompletableFuture<SimpleSlot> future = exec.allocateSlotForExecution(resourceProvider, queued)__				slots[i] = new ExecutionAndSlot(exec, future)__				successful = true__			}_			finally {_				if (!successful) {_					_					for (int k = 0_ k < i_ k++) {_						ExecutionGraphUtils.releaseSlotFuture(slots[k].slotFuture)__					}_				}_			}_		}__		_		return slots__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested;public,execution,and,slot,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,final,execution,vertex,vertices,this,task,vertices,final,execution,and,slot,slots,new,execution,and,slot,vertices,length,for,int,i,0,i,vertices,length,i,boolean,successful,false,try,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,simple,slot,future,exec,allocate,slot,for,execution,resource,provider,queued,slots,i,new,execution,and,slot,exec,future,successful,true,finally,if,successful,for,int,k,0,k,i,k,execution,graph,utils,release,slot,future,slots,k,slot,future,return,slots
ExecutionJobVertex -> public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued);1508861311;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested.;public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued) {_		final ExecutionVertex[] vertices = this.taskVertices__		final ExecutionAndSlot[] slots = new ExecutionAndSlot[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {__			_			_			boolean successful = false___			try {_				_				final Execution exec = vertices[i].getCurrentExecutionAttempt()__				final CompletableFuture<SimpleSlot> future = exec.allocateSlotForExecution(resourceProvider, queued)__				slots[i] = new ExecutionAndSlot(exec, future)__				successful = true__			}_			finally {_				if (!successful) {_					_					for (int k = 0_ k < i_ k++) {_						ExecutionGraphUtils.releaseSlotFuture(slots[k].slotFuture)__					}_				}_			}_		}__		_		return slots__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested;public,execution,and,slot,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,final,execution,vertex,vertices,this,task,vertices,final,execution,and,slot,slots,new,execution,and,slot,vertices,length,for,int,i,0,i,vertices,length,i,boolean,successful,false,try,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,simple,slot,future,exec,allocate,slot,for,execution,resource,provider,queued,slots,i,new,execution,and,slot,exec,future,successful,true,finally,if,successful,for,int,k,0,k,i,k,execution,graph,utils,release,slot,future,slots,k,slot,future,return,slots
ExecutionJobVertex -> public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued);1508861311;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested.;public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued) {_		final ExecutionVertex[] vertices = this.taskVertices__		final ExecutionAndSlot[] slots = new ExecutionAndSlot[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {__			_			_			boolean successful = false___			try {_				_				final Execution exec = vertices[i].getCurrentExecutionAttempt()__				final CompletableFuture<SimpleSlot> future = exec.allocateSlotForExecution(resourceProvider, queued)__				slots[i] = new ExecutionAndSlot(exec, future)__				successful = true__			}_			finally {_				if (!successful) {_					_					for (int k = 0_ k < i_ k++) {_						ExecutionGraphUtils.releaseSlotFuture(slots[k].slotFuture)__					}_				}_			}_		}__		_		return slots__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested;public,execution,and,slot,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,final,execution,vertex,vertices,this,task,vertices,final,execution,and,slot,slots,new,execution,and,slot,vertices,length,for,int,i,0,i,vertices,length,i,boolean,successful,false,try,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,simple,slot,future,exec,allocate,slot,for,execution,resource,provider,queued,slots,i,new,execution,and,slot,exec,future,successful,true,finally,if,successful,for,int,k,0,k,i,k,execution,graph,utils,release,slot,future,slots,k,slot,future,return,slots
