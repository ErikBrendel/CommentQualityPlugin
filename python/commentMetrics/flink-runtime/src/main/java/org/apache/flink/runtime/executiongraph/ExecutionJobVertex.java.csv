# id;timestamp;commentText;codeText;commentWords;codeWords
ExecutionJobVertex -> public void scheduleAll( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint);1509090423;Schedules all execution vertices of this ExecutionJobVertex.__@param slotProvider to allocate the slots from_@param queued if the allocations can be queued_@param locationPreferenceConstraint constraint for the location preferences;public void scheduleAll(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) {_		_		final ExecutionVertex[] vertices = this.taskVertices___		_		for (ExecutionVertex ev : vertices) {_			ev.scheduleForExecution(slotProvider, queued, locationPreferenceConstraint)__		}_	};schedules,all,execution,vertices,of,this,execution,job,vertex,param,slot,provider,to,allocate,the,slots,from,param,queued,if,the,allocations,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences;public,void,schedule,all,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,final,execution,vertex,vertices,this,task,vertices,for,execution,vertex,ev,vertices,ev,schedule,for,execution,slot,provider,queued,location,preference,constraint
ExecutionJobVertex -> public void scheduleAll( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint);1513261475;Schedules all execution vertices of this ExecutionJobVertex.__@param slotProvider to allocate the slots from_@param queued if the allocations can be queued_@param locationPreferenceConstraint constraint for the location preferences;public void scheduleAll(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) {_		_		final ExecutionVertex[] vertices = this.taskVertices___		_		for (ExecutionVertex ev : vertices) {_			ev.scheduleForExecution(slotProvider, queued, locationPreferenceConstraint)__		}_	};schedules,all,execution,vertices,of,this,execution,job,vertex,param,slot,provider,to,allocate,the,slots,from,param,queued,if,the,allocations,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences;public,void,schedule,all,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,final,execution,vertex,vertices,this,task,vertices,for,execution,vertex,ev,vertices,ev,schedule,for,execution,slot,provider,queued,location,preference,constraint
ExecutionJobVertex -> public void scheduleAll( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint);1517561834;Schedules all execution vertices of this ExecutionJobVertex.__@param slotProvider to allocate the slots from_@param queued if the allocations can be queued_@param locationPreferenceConstraint constraint for the location preferences;public void scheduleAll(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) {_		_		final ExecutionVertex[] vertices = this.taskVertices___		_		for (ExecutionVertex ev : vertices) {_			ev.scheduleForExecution(slotProvider, queued, locationPreferenceConstraint)__		}_	};schedules,all,execution,vertices,of,this,execution,job,vertex,param,slot,provider,to,allocate,the,slots,from,param,queued,if,the,allocations,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences;public,void,schedule,all,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,final,execution,vertex,vertices,this,task,vertices,for,execution,vertex,ev,vertices,ev,schedule,for,execution,slot,provider,queued,location,preference,constraint
ExecutionJobVertex -> public void scheduleAll( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint);1518522104;Schedules all execution vertices of this ExecutionJobVertex.__@param slotProvider to allocate the slots from_@param queued if the allocations can be queued_@param locationPreferenceConstraint constraint for the location preferences;public void scheduleAll(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) {_		_		final ExecutionVertex[] vertices = this.taskVertices___		_		for (ExecutionVertex ev : vertices) {_			ev.scheduleForExecution(slotProvider, queued, locationPreferenceConstraint)__		}_	};schedules,all,execution,vertices,of,this,execution,job,vertex,param,slot,provider,to,allocate,the,slots,from,param,queued,if,the,allocations,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences;public,void,schedule,all,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,final,execution,vertex,vertices,this,task,vertices,for,execution,vertex,ev,vertices,ev,schedule,for,execution,slot,provider,queued,location,preference,constraint
ExecutionJobVertex -> public void prepareForArchiving();1420560668;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1423053613;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null
ExecutionJobVertex -> public void prepareForArchiving();1423134222;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1423147697;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1423157292;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1423419464;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1423493773;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1423847366;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1424822375;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1426258431;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1426585339;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1428337646;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1430416776;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1433536769;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1434399167;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1440106070;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1440173964;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1441799380;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1447227619;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1448991211;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1452707135;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1453255421;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1455203048;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1469711304;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null
ExecutionJobVertex -> public void prepareForArchiving();1470322117;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_		inputSplitsPerSubtask = null__	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null,input,splits,per,subtask,null
ExecutionJobVertex -> public void prepareForArchiving();1472205100;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null
ExecutionJobVertex -> public void prepareForArchiving();1472304218;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null
ExecutionJobVertex -> public void prepareForArchiving();1474021314;This method cleans fields that are irrelevant for the archived execution attempt.;public void prepareForArchiving() {_		_		for (ExecutionVertex vertex : taskVertices) {_			vertex.prepareForArchiving()__		}_		_		_		inputs.clear()__		producedDataSets = null__		_		_		if (slotSharingGroup != null) {_			slotSharingGroup.clearTaskAssignment()__		}_		if (coLocationGroup != null) {_			coLocationGroup.resetConstraints()__		}_		_		_		splitAssigner = null__		if (inputSplits != null) {_			for (int i = 0_ i < inputSplits.length_ i++) {_				inputSplits[i] = null__			}_		}_	};this,method,cleans,fields,that,are,irrelevant,for,the,archived,execution,attempt;public,void,prepare,for,archiving,for,execution,vertex,vertex,task,vertices,vertex,prepare,for,archiving,inputs,clear,produced,data,sets,null,if,slot,sharing,group,null,slot,sharing,group,clear,task,assignment,if,co,location,group,null,co,location,group,reset,constraints,split,assigner,null,if,input,splits,null,for,int,i,0,i,input,splits,length,i,input,splits,i,null
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1500977056;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1501511601;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1507284174;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1508155453;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1508535554;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1508581881;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1509090423;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1513261475;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1517561834;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1518522104;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1519225070;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1521634116;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1522574090;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1532285197;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1538764056;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1538764056;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1541644381;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1544096225;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		_		CompletableFuture<ExecutionState>[] futures = Arrays.stream(getTaskVertices())_			.map(ExecutionVertex::cancel)_			.<CompletableFuture<ExecutionState>>toArray(CompletableFuture[]::new)___		_		return CompletableFuture.allOf(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,completable,future,execution,state,futures,arrays,stream,get,task,vertices,map,execution,vertex,cancel,completable,future,execution,state,to,array,completable,future,new,return,completable,future,all,of,futures
ExecutionJobVertex -> public CompletableFuture<Void> cancelWithFuture();1550584266;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public CompletableFuture<Void> cancelWithFuture() {_		return FutureUtils.waitForAll(mapExecutionVertices(ExecutionVertex::cancel))__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,completable,future,void,cancel,with,future,return,future,utils,wait,for,all,map,execution,vertices,execution,vertex,cancel
ExecutionJobVertex -> public Future<Void> cancelWithFuture();1490120014;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public Future<Void> cancelWithFuture() {_		_		ArrayList<Future<?>> futures = new ArrayList<>(parallelism)___		_		for (ExecutionVertex ev : getTaskVertices()) {_			futures.add(ev.cancel())__		}__		_		return FutureUtils.combineAll(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,future,void,cancel,with,future,array,list,future,futures,new,array,list,parallelism,for,execution,vertex,ev,get,task,vertices,futures,add,ev,cancel,return,future,utils,combine,all,futures
ExecutionJobVertex -> public Future<Void> cancelWithFuture();1490820594;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public Future<Void> cancelWithFuture() {_		_		ArrayList<Future<?>> futures = new ArrayList<>(parallelism)___		_		for (ExecutionVertex ev : getTaskVertices()) {_			futures.add(ev.cancel())__		}__		_		return FutureUtils.combineAll(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,future,void,cancel,with,future,array,list,future,futures,new,array,list,parallelism,for,execution,vertex,ev,get,task,vertices,futures,add,ev,cancel,return,future,utils,combine,all,futures
ExecutionJobVertex -> public Future<Void> cancelWithFuture();1494516977;Cancels all currently running vertex executions.__@return A future that is complete once all tasks have canceled.;public Future<Void> cancelWithFuture() {_		_		ArrayList<Future<ExecutionState>> futures = new ArrayList<>(parallelism)___		_		for (ExecutionVertex ev : getTaskVertices()) {_			futures.add(ev.cancel())__		}__		_		return FutureUtils.waitForAll(futures)__	};cancels,all,currently,running,vertex,executions,return,a,future,that,is,complete,once,all,tasks,have,canceled;public,future,void,cancel,with,future,array,list,future,execution,state,futures,new,array,list,parallelism,for,execution,vertex,ev,get,task,vertices,futures,add,ev,cancel,return,future,utils,wait,for,all,futures
ExecutionJobVertex -> public Collection<CompletableFuture<Execution>> allocateResourcesForAll( 			SlotProvider resourceProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint);1509090423;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested._@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences;public Collection<CompletableFuture<Execution>> allocateResourcesForAll(_			SlotProvider resourceProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) {_		final ExecutionVertex[] vertices = this.taskVertices__		final CompletableFuture<Execution>[] slots = new CompletableFuture[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {_			_			final Execution exec = vertices[i].getCurrentExecutionAttempt()__			final CompletableFuture<Execution> allocationFuture = exec.allocateAndAssignSlotForExecution(_				resourceProvider,_				queued,_				locationPreferenceConstraint)__			slots[i] = allocationFuture__		}__		_		return Arrays.asList(slots)__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences;public,collection,completable,future,execution,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,location,preference,constraint,location,preference,constraint,final,execution,vertex,vertices,this,task,vertices,final,completable,future,execution,slots,new,completable,future,vertices,length,for,int,i,0,i,vertices,length,i,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,execution,allocation,future,exec,allocate,and,assign,slot,for,execution,resource,provider,queued,location,preference,constraint,slots,i,allocation,future,return,arrays,as,list,slots
ExecutionJobVertex -> public Collection<CompletableFuture<Execution>> allocateResourcesForAll( 			SlotProvider resourceProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint);1513261475;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested._@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences;public Collection<CompletableFuture<Execution>> allocateResourcesForAll(_			SlotProvider resourceProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) {_		final ExecutionVertex[] vertices = this.taskVertices__		final CompletableFuture<Execution>[] slots = new CompletableFuture[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {_			_			final Execution exec = vertices[i].getCurrentExecutionAttempt()__			final CompletableFuture<Execution> allocationFuture = exec.allocateAndAssignSlotForExecution(_				resourceProvider,_				queued,_				locationPreferenceConstraint)__			slots[i] = allocationFuture__		}__		_		return Arrays.asList(slots)__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences;public,collection,completable,future,execution,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,location,preference,constraint,location,preference,constraint,final,execution,vertex,vertices,this,task,vertices,final,completable,future,execution,slots,new,completable,future,vertices,length,for,int,i,0,i,vertices,length,i,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,execution,allocation,future,exec,allocate,and,assign,slot,for,execution,resource,provider,queued,location,preference,constraint,slots,i,allocation,future,return,arrays,as,list,slots
ExecutionJobVertex -> public Collection<CompletableFuture<Execution>> allocateResourcesForAll( 			SlotProvider resourceProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint);1517561834;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested._@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences;public Collection<CompletableFuture<Execution>> allocateResourcesForAll(_			SlotProvider resourceProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) {_		final ExecutionVertex[] vertices = this.taskVertices__		final CompletableFuture<Execution>[] slots = new CompletableFuture[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {_			_			final Execution exec = vertices[i].getCurrentExecutionAttempt()__			final CompletableFuture<Execution> allocationFuture = exec.allocateAndAssignSlotForExecution(_				resourceProvider,_				queued,_				locationPreferenceConstraint)__			slots[i] = allocationFuture__		}__		_		return Arrays.asList(slots)__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences;public,collection,completable,future,execution,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,location,preference,constraint,location,preference,constraint,final,execution,vertex,vertices,this,task,vertices,final,completable,future,execution,slots,new,completable,future,vertices,length,for,int,i,0,i,vertices,length,i,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,execution,allocation,future,exec,allocate,and,assign,slot,for,execution,resource,provider,queued,location,preference,constraint,slots,i,allocation,future,return,arrays,as,list,slots
ExecutionJobVertex -> public Collection<CompletableFuture<Execution>> allocateResourcesForAll( 			SlotProvider resourceProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds, 			Time allocationTimeout);1538764056;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested._@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds the allocation ids of all previous executions in the execution job graph._@param allocationTimeout timeout for allocating the individual slots;public Collection<CompletableFuture<Execution>> allocateResourcesForAll(_			SlotProvider resourceProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds,_			Time allocationTimeout) {_		final ExecutionVertex[] vertices = this.taskVertices__		final CompletableFuture<Execution>[] slots = new CompletableFuture[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {_			_			final Execution exec = vertices[i].getCurrentExecutionAttempt()__			final CompletableFuture<Execution> allocationFuture = exec.allocateAndAssignSlotForExecution(_				resourceProvider,_				queued,_				locationPreferenceConstraint,_				allPreviousExecutionGraphAllocationIds,_				allocationTimeout)__			slots[i] = allocationFuture__		}__		_		return Arrays.asList(slots)__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,the,allocation,ids,of,all,previous,executions,in,the,execution,job,graph,param,allocation,timeout,timeout,for,allocating,the,individual,slots;public,collection,completable,future,execution,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,time,allocation,timeout,final,execution,vertex,vertices,this,task,vertices,final,completable,future,execution,slots,new,completable,future,vertices,length,for,int,i,0,i,vertices,length,i,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,execution,allocation,future,exec,allocate,and,assign,slot,for,execution,resource,provider,queued,location,preference,constraint,all,previous,execution,graph,allocation,ids,allocation,timeout,slots,i,allocation,future,return,arrays,as,list,slots
ExecutionJobVertex -> public Collection<CompletableFuture<Execution>> allocateResourcesForAll( 			SlotProvider resourceProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds, 			Time allocationTimeout);1538764056;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested._@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds the allocation ids of all previous executions in the execution job graph._@param allocationTimeout timeout for allocating the individual slots;public Collection<CompletableFuture<Execution>> allocateResourcesForAll(_			SlotProvider resourceProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds,_			Time allocationTimeout) {_		final ExecutionVertex[] vertices = this.taskVertices___		@SuppressWarnings("unchecked")_		final CompletableFuture<Execution>[] slots = new CompletableFuture[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {_			_			final Execution exec = vertices[i].getCurrentExecutionAttempt()__			final CompletableFuture<Execution> allocationFuture = exec.allocateAndAssignSlotForExecution(_				resourceProvider,_				queued,_				locationPreferenceConstraint,_				allPreviousExecutionGraphAllocationIds,_				allocationTimeout)__			slots[i] = allocationFuture__		}__		_		return Arrays.asList(slots)__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,the,allocation,ids,of,all,previous,executions,in,the,execution,job,graph,param,allocation,timeout,timeout,for,allocating,the,individual,slots;public,collection,completable,future,execution,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,time,allocation,timeout,final,execution,vertex,vertices,this,task,vertices,suppress,warnings,unchecked,final,completable,future,execution,slots,new,completable,future,vertices,length,for,int,i,0,i,vertices,length,i,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,execution,allocation,future,exec,allocate,and,assign,slot,for,execution,resource,provider,queued,location,preference,constraint,all,previous,execution,graph,allocation,ids,allocation,timeout,slots,i,allocation,future,return,arrays,as,list,slots
ExecutionJobVertex -> public Collection<CompletableFuture<Execution>> allocateResourcesForAll( 			SlotProvider resourceProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds, 			Time allocationTimeout);1541644381;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested._@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds the allocation ids of all previous executions in the execution job graph._@param allocationTimeout timeout for allocating the individual slots;public Collection<CompletableFuture<Execution>> allocateResourcesForAll(_			SlotProvider resourceProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds,_			Time allocationTimeout) {_		final ExecutionVertex[] vertices = this.taskVertices__		final CompletableFuture<Execution>[] slots = new CompletableFuture[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {_			_			final Execution exec = vertices[i].getCurrentExecutionAttempt()__			final CompletableFuture<Execution> allocationFuture = exec.allocateAndAssignSlotForExecution(_				resourceProvider,_				queued,_				locationPreferenceConstraint,_				allPreviousExecutionGraphAllocationIds,_				allocationTimeout)__			slots[i] = allocationFuture__		}__		_		return Arrays.asList(slots)__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,the,allocation,ids,of,all,previous,executions,in,the,execution,job,graph,param,allocation,timeout,timeout,for,allocating,the,individual,slots;public,collection,completable,future,execution,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,time,allocation,timeout,final,execution,vertex,vertices,this,task,vertices,final,completable,future,execution,slots,new,completable,future,vertices,length,for,int,i,0,i,vertices,length,i,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,execution,allocation,future,exec,allocate,and,assign,slot,for,execution,resource,provider,queued,location,preference,constraint,all,previous,execution,graph,allocation,ids,allocation,timeout,slots,i,allocation,future,return,arrays,as,list,slots
ExecutionJobVertex -> public Collection<CompletableFuture<Execution>> allocateResourcesForAll( 			SlotProvider resourceProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds, 			Time allocationTimeout);1544096225;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested._@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds the allocation ids of all previous executions in the execution job graph._@param allocationTimeout timeout for allocating the individual slots;public Collection<CompletableFuture<Execution>> allocateResourcesForAll(_			SlotProvider resourceProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds,_			Time allocationTimeout) {_		final ExecutionVertex[] vertices = this.taskVertices__		final CompletableFuture<Execution>[] slots = new CompletableFuture[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {_			_			final Execution exec = vertices[i].getCurrentExecutionAttempt()__			final CompletableFuture<Execution> allocationFuture = exec.allocateAndAssignSlotForExecution(_				resourceProvider,_				queued,_				locationPreferenceConstraint,_				allPreviousExecutionGraphAllocationIds,_				allocationTimeout)__			slots[i] = allocationFuture__		}__		_		return Arrays.asList(slots)__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,the,allocation,ids,of,all,previous,executions,in,the,execution,job,graph,param,allocation,timeout,timeout,for,allocating,the,individual,slots;public,collection,completable,future,execution,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,time,allocation,timeout,final,execution,vertex,vertices,this,task,vertices,final,completable,future,execution,slots,new,completable,future,vertices,length,for,int,i,0,i,vertices,length,i,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,execution,allocation,future,exec,allocate,and,assign,slot,for,execution,resource,provider,queued,location,preference,constraint,all,previous,execution,graph,allocation,ids,allocation,timeout,slots,i,allocation,future,return,arrays,as,list,slots
ExecutionJobVertex -> public Collection<CompletableFuture<Execution>> allocateResourcesForAll( 			SlotProvider resourceProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds, 			Time allocationTimeout);1550584266;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested._@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds the allocation ids of all previous executions in the execution job graph._@param allocationTimeout timeout for allocating the individual slots;public Collection<CompletableFuture<Execution>> allocateResourcesForAll(_			SlotProvider resourceProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds,_			Time allocationTimeout) {_		final ExecutionVertex[] vertices = this.taskVertices___		@SuppressWarnings("unchecked")_		final CompletableFuture<Execution>[] slots = new CompletableFuture[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {_			_			final Execution exec = vertices[i].getCurrentExecutionAttempt()__			final CompletableFuture<Execution> allocationFuture = exec.allocateAndAssignSlotForExecution(_				resourceProvider,_				queued,_				locationPreferenceConstraint,_				allPreviousExecutionGraphAllocationIds,_				allocationTimeout)__			slots[i] = allocationFuture__		}__		_		return Arrays.asList(slots)__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,the,allocation,ids,of,all,previous,executions,in,the,execution,job,graph,param,allocation,timeout,timeout,for,allocating,the,individual,slots;public,collection,completable,future,execution,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,time,allocation,timeout,final,execution,vertex,vertices,this,task,vertices,suppress,warnings,unchecked,final,completable,future,execution,slots,new,completable,future,vertices,length,for,int,i,0,i,vertices,length,i,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,execution,allocation,future,exec,allocate,and,assign,slot,for,execution,resource,provider,queued,location,preference,constraint,all,previous,execution,graph,allocation,ids,allocation,timeout,slots,i,allocation,future,return,arrays,as,list,slots
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1490120014;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1490820594;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1493401220;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1494516977;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1500977056;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1501511601;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1507284174;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1508155453;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1508535554;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1508581881;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1509090423;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1513261475;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1517561834;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1518522104;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1519225070;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1521634116;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1522574090;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1532285197;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1538764056;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1538764056;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1541644381;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1544096225;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public List<OperatorID> getOperatorIDs();1550584266;Returns a list containing the IDs of all operators contained in this execution job vertex.__@return list containing the IDs of all contained operators;public List<OperatorID> getOperatorIDs() {_		return operatorIDs__	};returns,a,list,containing,the,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,the,ids,of,all,contained,operators;public,list,operator,id,get,operator,ids,return,operator,ids
ExecutionJobVertex -> public void cancel();1490120014;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1490820594;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1494516977;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1500977056;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1501511601;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1507284174;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1508155453;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1508535554;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1508581881;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1509090423;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1513261475;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1517561834;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1518522104;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1519225070;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1521634116;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1522574090;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1532285197;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1538764056;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1538764056;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1541644381;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1544096225;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> public void cancel();1550584266;Cancels all currently running vertex executions.;public void cancel() {_		for (ExecutionVertex ev : getTaskVertices()) {_			ev.cancel()__		}_	};cancels,all,currently,running,vertex,executions;public,void,cancel,for,execution,vertex,ev,get,task,vertices,ev,cancel
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1490120014;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1494516977;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1500977056;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1501511601;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1507284174;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1508155453;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1508535554;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1508581881;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1509090423;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1513261475;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1517561834;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1518522104;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1519225070;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1521634116;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1522574090;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1532285197;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1538764056;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1538764056;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1541644381;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1544096225;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> @VisibleForTesting 	ExecutionJobVertex( 		ExecutionGraph graph, 		JobVertex jobVertex, 		int defaultParallelism, 		Time timeout) throws JobException;1550584266;Convenience constructor for testing.;@VisibleForTesting_	ExecutionJobVertex(_		ExecutionGraph graph,_		JobVertex jobVertex,_		int defaultParallelism,_		Time timeout) throws JobException {__		this(graph, jobVertex, defaultParallelism, timeout, 1L, System.currentTimeMillis())__	};convenience,constructor,for,testing;visible,for,testing,execution,job,vertex,execution,graph,graph,job,vertex,job,vertex,int,default,parallelism,time,timeout,throws,job,exception,this,graph,job,vertex,default,parallelism,timeout,1l,system,current,time,millis
ExecutionJobVertex -> public Collection<CompletableFuture<Execution>> allocateResourcesForAll( 			SlotProvider resourceProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			Time allocationTimeout);1518522104;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested._@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allocationTimeout timeout for allocating the individual slots;public Collection<CompletableFuture<Execution>> allocateResourcesForAll(_			SlotProvider resourceProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			Time allocationTimeout) {_		final ExecutionVertex[] vertices = this.taskVertices__		final CompletableFuture<Execution>[] slots = new CompletableFuture[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {_			_			final Execution exec = vertices[i].getCurrentExecutionAttempt()__			final CompletableFuture<Execution> allocationFuture = exec.allocateAndAssignSlotForExecution(_				resourceProvider,_				queued,_				locationPreferenceConstraint,_				allocationTimeout)__			slots[i] = allocationFuture__		}__		_		return Arrays.asList(slots)__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,allocation,timeout,timeout,for,allocating,the,individual,slots;public,collection,completable,future,execution,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,location,preference,constraint,location,preference,constraint,time,allocation,timeout,final,execution,vertex,vertices,this,task,vertices,final,completable,future,execution,slots,new,completable,future,vertices,length,for,int,i,0,i,vertices,length,i,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,execution,allocation,future,exec,allocate,and,assign,slot,for,execution,resource,provider,queued,location,preference,constraint,allocation,timeout,slots,i,allocation,future,return,arrays,as,list,slots
ExecutionJobVertex -> public Collection<CompletableFuture<Execution>> allocateResourcesForAll( 			SlotProvider resourceProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			Time allocationTimeout);1519225070;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested._@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allocationTimeout timeout for allocating the individual slots;public Collection<CompletableFuture<Execution>> allocateResourcesForAll(_			SlotProvider resourceProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			Time allocationTimeout) {_		final ExecutionVertex[] vertices = this.taskVertices__		final CompletableFuture<Execution>[] slots = new CompletableFuture[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {_			_			final Execution exec = vertices[i].getCurrentExecutionAttempt()__			final CompletableFuture<Execution> allocationFuture = exec.allocateAndAssignSlotForExecution(_				resourceProvider,_				queued,_				locationPreferenceConstraint,_				allocationTimeout)__			slots[i] = allocationFuture__		}__		_		return Arrays.asList(slots)__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,allocation,timeout,timeout,for,allocating,the,individual,slots;public,collection,completable,future,execution,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,location,preference,constraint,location,preference,constraint,time,allocation,timeout,final,execution,vertex,vertices,this,task,vertices,final,completable,future,execution,slots,new,completable,future,vertices,length,for,int,i,0,i,vertices,length,i,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,execution,allocation,future,exec,allocate,and,assign,slot,for,execution,resource,provider,queued,location,preference,constraint,allocation,timeout,slots,i,allocation,future,return,arrays,as,list,slots
ExecutionJobVertex -> public Collection<CompletableFuture<Execution>> allocateResourcesForAll( 			SlotProvider resourceProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			Time allocationTimeout);1521634116;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested._@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allocationTimeout timeout for allocating the individual slots;public Collection<CompletableFuture<Execution>> allocateResourcesForAll(_			SlotProvider resourceProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			Time allocationTimeout) {_		final ExecutionVertex[] vertices = this.taskVertices__		final CompletableFuture<Execution>[] slots = new CompletableFuture[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {_			_			final Execution exec = vertices[i].getCurrentExecutionAttempt()__			final CompletableFuture<Execution> allocationFuture = exec.allocateAndAssignSlotForExecution(_				resourceProvider,_				queued,_				locationPreferenceConstraint,_				allocationTimeout)__			slots[i] = allocationFuture__		}__		_		return Arrays.asList(slots)__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,allocation,timeout,timeout,for,allocating,the,individual,slots;public,collection,completable,future,execution,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,location,preference,constraint,location,preference,constraint,time,allocation,timeout,final,execution,vertex,vertices,this,task,vertices,final,completable,future,execution,slots,new,completable,future,vertices,length,for,int,i,0,i,vertices,length,i,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,execution,allocation,future,exec,allocate,and,assign,slot,for,execution,resource,provider,queued,location,preference,constraint,allocation,timeout,slots,i,allocation,future,return,arrays,as,list,slots
ExecutionJobVertex -> public Collection<CompletableFuture<Execution>> allocateResourcesForAll( 			SlotProvider resourceProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			Time allocationTimeout);1522574090;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested._@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allocationTimeout timeout for allocating the individual slots;public Collection<CompletableFuture<Execution>> allocateResourcesForAll(_			SlotProvider resourceProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			Time allocationTimeout) {_		final ExecutionVertex[] vertices = this.taskVertices__		final CompletableFuture<Execution>[] slots = new CompletableFuture[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {_			_			final Execution exec = vertices[i].getCurrentExecutionAttempt()__			final CompletableFuture<Execution> allocationFuture = exec.allocateAndAssignSlotForExecution(_				resourceProvider,_				queued,_				locationPreferenceConstraint,_				allocationTimeout)__			slots[i] = allocationFuture__		}__		_		return Arrays.asList(slots)__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,allocation,timeout,timeout,for,allocating,the,individual,slots;public,collection,completable,future,execution,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,location,preference,constraint,location,preference,constraint,time,allocation,timeout,final,execution,vertex,vertices,this,task,vertices,final,completable,future,execution,slots,new,completable,future,vertices,length,for,int,i,0,i,vertices,length,i,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,execution,allocation,future,exec,allocate,and,assign,slot,for,execution,resource,provider,queued,location,preference,constraint,allocation,timeout,slots,i,allocation,future,return,arrays,as,list,slots
ExecutionJobVertex -> public Collection<CompletableFuture<Execution>> allocateResourcesForAll( 			SlotProvider resourceProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			Time allocationTimeout);1532285197;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested._@param queued if the allocation can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allocationTimeout timeout for allocating the individual slots;public Collection<CompletableFuture<Execution>> allocateResourcesForAll(_			SlotProvider resourceProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			Time allocationTimeout) {_		final ExecutionVertex[] vertices = this.taskVertices__		final CompletableFuture<Execution>[] slots = new CompletableFuture[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {_			_			final Execution exec = vertices[i].getCurrentExecutionAttempt()__			final CompletableFuture<Execution> allocationFuture = exec.allocateAndAssignSlotForExecution(_				resourceProvider,_				queued,_				locationPreferenceConstraint,_				allocationTimeout)__			slots[i] = allocationFuture__		}__		_		return Arrays.asList(slots)__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested,param,queued,if,the,allocation,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,allocation,timeout,timeout,for,allocating,the,individual,slots;public,collection,completable,future,execution,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,location,preference,constraint,location,preference,constraint,time,allocation,timeout,final,execution,vertex,vertices,this,task,vertices,final,completable,future,execution,slots,new,completable,future,vertices,length,for,int,i,0,i,vertices,length,i,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,execution,allocation,future,exec,allocate,and,assign,slot,for,execution,resource,provider,queued,location,preference,constraint,allocation,timeout,slots,i,allocation,future,return,arrays,as,list,slots
ExecutionJobVertex -> public CompletableFuture<Void> scheduleAll( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds);1538764056;Schedules all execution vertices of this ExecutionJobVertex.__@param slotProvider to allocate the slots from_@param queued if the allocations can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph._Can be empty if the allocation ids are not required for scheduling._@return Future which is completed once all {@link Execution} could be deployed;public CompletableFuture<Void> scheduleAll(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds) {__		final ExecutionVertex[] vertices = this.taskVertices___		final ArrayList<CompletableFuture<Void>> scheduleFutures = new ArrayList<>(vertices.length)___		_		for (ExecutionVertex ev : vertices) {_			scheduleFutures.add(ev.scheduleForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint,_				allPreviousExecutionGraphAllocationIds))__		}__		return FutureUtils.waitForAll(scheduleFutures)__	};schedules,all,execution,vertices,of,this,execution,job,vertex,param,slot,provider,to,allocate,the,slots,from,param,queued,if,the,allocations,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,set,with,all,previous,allocation,ids,in,the,job,graph,can,be,empty,if,the,allocation,ids,are,not,required,for,scheduling,return,future,which,is,completed,once,all,link,execution,could,be,deployed;public,completable,future,void,schedule,all,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,final,execution,vertex,vertices,this,task,vertices,final,array,list,completable,future,void,schedule,futures,new,array,list,vertices,length,for,execution,vertex,ev,vertices,schedule,futures,add,ev,schedule,for,execution,slot,provider,queued,location,preference,constraint,all,previous,execution,graph,allocation,ids,return,future,utils,wait,for,all,schedule,futures
ExecutionJobVertex -> public CompletableFuture<Void> scheduleAll( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds);1538764056;Schedules all execution vertices of this ExecutionJobVertex.__@param slotProvider to allocate the slots from_@param queued if the allocations can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph._Can be empty if the allocation ids are not required for scheduling._@return Future which is completed once all {@link Execution} could be deployed;public CompletableFuture<Void> scheduleAll(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds) {__		final ExecutionVertex[] vertices = this.taskVertices___		final ArrayList<CompletableFuture<Void>> scheduleFutures = new ArrayList<>(vertices.length)___		_		for (ExecutionVertex ev : vertices) {_			scheduleFutures.add(ev.scheduleForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint,_				allPreviousExecutionGraphAllocationIds))__		}__		return FutureUtils.waitForAll(scheduleFutures)__	};schedules,all,execution,vertices,of,this,execution,job,vertex,param,slot,provider,to,allocate,the,slots,from,param,queued,if,the,allocations,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,set,with,all,previous,allocation,ids,in,the,job,graph,can,be,empty,if,the,allocation,ids,are,not,required,for,scheduling,return,future,which,is,completed,once,all,link,execution,could,be,deployed;public,completable,future,void,schedule,all,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,final,execution,vertex,vertices,this,task,vertices,final,array,list,completable,future,void,schedule,futures,new,array,list,vertices,length,for,execution,vertex,ev,vertices,schedule,futures,add,ev,schedule,for,execution,slot,provider,queued,location,preference,constraint,all,previous,execution,graph,allocation,ids,return,future,utils,wait,for,all,schedule,futures
ExecutionJobVertex -> public CompletableFuture<Void> scheduleAll( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds);1541644381;Schedules all execution vertices of this ExecutionJobVertex.__@param slotProvider to allocate the slots from_@param queued if the allocations can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph._Can be empty if the allocation ids are not required for scheduling._@return Future which is completed once all {@link Execution} could be deployed;public CompletableFuture<Void> scheduleAll(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds) {__		final ExecutionVertex[] vertices = this.taskVertices___		final ArrayList<CompletableFuture<Void>> scheduleFutures = new ArrayList<>(vertices.length)___		_		for (ExecutionVertex ev : vertices) {_			scheduleFutures.add(ev.scheduleForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint,_				allPreviousExecutionGraphAllocationIds))__		}__		return FutureUtils.waitForAll(scheduleFutures)__	};schedules,all,execution,vertices,of,this,execution,job,vertex,param,slot,provider,to,allocate,the,slots,from,param,queued,if,the,allocations,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,set,with,all,previous,allocation,ids,in,the,job,graph,can,be,empty,if,the,allocation,ids,are,not,required,for,scheduling,return,future,which,is,completed,once,all,link,execution,could,be,deployed;public,completable,future,void,schedule,all,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,final,execution,vertex,vertices,this,task,vertices,final,array,list,completable,future,void,schedule,futures,new,array,list,vertices,length,for,execution,vertex,ev,vertices,schedule,futures,add,ev,schedule,for,execution,slot,provider,queued,location,preference,constraint,all,previous,execution,graph,allocation,ids,return,future,utils,wait,for,all,schedule,futures
ExecutionJobVertex -> public CompletableFuture<Void> scheduleAll( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds);1544096225;Schedules all execution vertices of this ExecutionJobVertex.__@param slotProvider to allocate the slots from_@param queued if the allocations can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph._Can be empty if the allocation ids are not required for scheduling._@return Future which is completed once all {@link Execution} could be deployed;public CompletableFuture<Void> scheduleAll(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds) {__		final ExecutionVertex[] vertices = this.taskVertices___		final ArrayList<CompletableFuture<Void>> scheduleFutures = new ArrayList<>(vertices.length)___		_		for (ExecutionVertex ev : vertices) {_			scheduleFutures.add(ev.scheduleForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint,_				allPreviousExecutionGraphAllocationIds))__		}__		return FutureUtils.waitForAll(scheduleFutures)__	};schedules,all,execution,vertices,of,this,execution,job,vertex,param,slot,provider,to,allocate,the,slots,from,param,queued,if,the,allocations,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,set,with,all,previous,allocation,ids,in,the,job,graph,can,be,empty,if,the,allocation,ids,are,not,required,for,scheduling,return,future,which,is,completed,once,all,link,execution,could,be,deployed;public,completable,future,void,schedule,all,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,final,execution,vertex,vertices,this,task,vertices,final,array,list,completable,future,void,schedule,futures,new,array,list,vertices,length,for,execution,vertex,ev,vertices,schedule,futures,add,ev,schedule,for,execution,slot,provider,queued,location,preference,constraint,all,previous,execution,graph,allocation,ids,return,future,utils,wait,for,all,schedule,futures
ExecutionJobVertex -> public CompletableFuture<Void> scheduleAll( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint, 			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds);1550584266;Schedules all execution vertices of this ExecutionJobVertex.__@param slotProvider to allocate the slots from_@param queued if the allocations can be queued_@param locationPreferenceConstraint constraint for the location preferences_@param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph._Can be empty if the allocation ids are not required for scheduling._@return Future which is completed once all {@link Execution} could be deployed;public CompletableFuture<Void> scheduleAll(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint,_			@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds) {__		final ExecutionVertex[] vertices = this.taskVertices___		final ArrayList<CompletableFuture<Void>> scheduleFutures = new ArrayList<>(vertices.length)___		_		for (ExecutionVertex ev : vertices) {_			scheduleFutures.add(ev.scheduleForExecution(_				slotProvider,_				queued,_				locationPreferenceConstraint,_				allPreviousExecutionGraphAllocationIds))__		}__		return FutureUtils.waitForAll(scheduleFutures)__	};schedules,all,execution,vertices,of,this,execution,job,vertex,param,slot,provider,to,allocate,the,slots,from,param,queued,if,the,allocations,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,param,all,previous,execution,graph,allocation,ids,set,with,all,previous,allocation,ids,in,the,job,graph,can,be,empty,if,the,allocation,ids,are,not,required,for,scheduling,return,future,which,is,completed,once,all,link,execution,could,be,deployed;public,completable,future,void,schedule,all,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,nonnull,set,allocation,id,all,previous,execution,graph,allocation,ids,final,execution,vertex,vertices,this,task,vertices,final,array,list,completable,future,void,schedule,futures,new,array,list,vertices,length,for,execution,vertex,ev,vertices,schedule,futures,add,ev,schedule,for,execution,slot,provider,queued,location,preference,constraint,all,previous,execution,graph,allocation,ids,return,future,utils,wait,for,all,schedule,futures
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1490120014;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1490820594;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1493401220;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1494516977;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1500977056;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1501511601;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1507284174;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1508155453;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1508535554;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1508581881;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1509090423;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1513261475;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1517561834;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1518522104;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1519225070;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1521634116;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1522574090;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1532285197;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1538764056;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1538764056;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1541644381;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1544096225;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public List<OperatorID> getUserDefinedOperatorIDs();1550584266;Returns a list containing the alternative IDs of all operators contained in this execution job vertex.__@return list containing alternative the IDs of all contained operators;public List<OperatorID> getUserDefinedOperatorIDs() {_		return userDefinedOperatorIds__	};returns,a,list,containing,the,alternative,ids,of,all,operators,contained,in,this,execution,job,vertex,return,list,containing,alternative,the,ids,of,all,contained,operators;public,list,operator,id,get,user,defined,operator,ids,return,user,defined,operator,ids
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1490120014;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1494516977;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1500977056;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1501511601;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1507284174;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1508155453;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1508535554;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1508581881;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1509090423;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1513261475;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1517561834;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1518522104;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1519225070;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1521634116;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1522574090;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1532285197;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1538764056;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1538764056;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1541644381;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1544096225;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism);1550584266;A utility function that computes an "aggregated" state for the vertex.__<p>This state is not used anywhere in the  coordination, but can be used for display_in dashboards to as a summary for how the particular parallel operation represented by_this ExecutionJobVertex is currently behaving.__<p>For example, if at least one parallel task is failed, the aggregate state is failed._If not, and at least one parallel task is cancelling (or cancelled), the aggregate state_is cancelling (or cancelled). If all tasks are finished, the aggregate state is finished,_and so on.__@param verticesPerState The number of vertices in each state (indexed by the ordinal of_the ExecutionState values)._@param parallelism The parallelism of the ExecutionJobVertex__@return The aggregate state of this ExecutionJobVertex.;public static ExecutionState getAggregateJobVertexState(int[] verticesPerState, int parallelism) {_		if (verticesPerState == null || verticesPerState.length != ExecutionState.values().length) {_			throw new IllegalArgumentException("Must provide an array as large as there are execution states.")__		}__		if (verticesPerState[ExecutionState.FAILED.ordinal()] > 0) {_			return ExecutionState.FAILED__		}_		if (verticesPerState[ExecutionState.CANCELING.ordinal()] > 0) {_			return ExecutionState.CANCELING__		}_		else if (verticesPerState[ExecutionState.CANCELED.ordinal()] > 0) {_			return ExecutionState.CANCELED__		}_		else if (verticesPerState[ExecutionState.RUNNING.ordinal()] > 0) {_			return ExecutionState.RUNNING__		}_		else if (verticesPerState[ExecutionState.FINISHED.ordinal()] > 0) {_			return verticesPerState[ExecutionState.FINISHED.ordinal()] == parallelism ?_					ExecutionState.FINISHED : ExecutionState.RUNNING__		}_		else {_			_			return ExecutionState.CREATED__		}_	};a,utility,function,that,computes,an,aggregated,state,for,the,vertex,p,this,state,is,not,used,anywhere,in,the,coordination,but,can,be,used,for,display,in,dashboards,to,as,a,summary,for,how,the,particular,parallel,operation,represented,by,this,execution,job,vertex,is,currently,behaving,p,for,example,if,at,least,one,parallel,task,is,failed,the,aggregate,state,is,failed,if,not,and,at,least,one,parallel,task,is,cancelling,or,cancelled,the,aggregate,state,is,cancelling,or,cancelled,if,all,tasks,are,finished,the,aggregate,state,is,finished,and,so,on,param,vertices,per,state,the,number,of,vertices,in,each,state,indexed,by,the,ordinal,of,the,execution,state,values,param,parallelism,the,parallelism,of,the,execution,job,vertex,return,the,aggregate,state,of,this,execution,job,vertex;public,static,execution,state,get,aggregate,job,vertex,state,int,vertices,per,state,int,parallelism,if,vertices,per,state,null,vertices,per,state,length,execution,state,values,length,throw,new,illegal,argument,exception,must,provide,an,array,as,large,as,there,are,execution,states,if,vertices,per,state,execution,state,failed,ordinal,0,return,execution,state,failed,if,vertices,per,state,execution,state,canceling,ordinal,0,return,execution,state,canceling,else,if,vertices,per,state,execution,state,canceled,ordinal,0,return,execution,state,canceled,else,if,vertices,per,state,execution,state,running,ordinal,0,return,execution,state,running,else,if,vertices,per,state,execution,state,finished,ordinal,0,return,vertices,per,state,execution,state,finished,ordinal,parallelism,execution,state,finished,execution,state,running,else,return,execution,state,created
ExecutionJobVertex -> public CompletableFuture<Void> scheduleAll( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint);1519225070;Schedules all execution vertices of this ExecutionJobVertex.__@param slotProvider to allocate the slots from_@param queued if the allocations can be queued_@param locationPreferenceConstraint constraint for the location preferences_@return Future which is completed once all {@link Execution} could be deployed;public CompletableFuture<Void> scheduleAll(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) {_		_		final ExecutionVertex[] vertices = this.taskVertices___		final ArrayList<CompletableFuture<Void>> scheduleFutures = new ArrayList<>(vertices.length)___		_		for (ExecutionVertex ev : vertices) {_			scheduleFutures.add(ev.scheduleForExecution(slotProvider, queued, locationPreferenceConstraint))__		}__		return FutureUtils.waitForAll(scheduleFutures)__	};schedules,all,execution,vertices,of,this,execution,job,vertex,param,slot,provider,to,allocate,the,slots,from,param,queued,if,the,allocations,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,return,future,which,is,completed,once,all,link,execution,could,be,deployed;public,completable,future,void,schedule,all,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,final,execution,vertex,vertices,this,task,vertices,final,array,list,completable,future,void,schedule,futures,new,array,list,vertices,length,for,execution,vertex,ev,vertices,schedule,futures,add,ev,schedule,for,execution,slot,provider,queued,location,preference,constraint,return,future,utils,wait,for,all,schedule,futures
ExecutionJobVertex -> public CompletableFuture<Void> scheduleAll( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint);1521634116;Schedules all execution vertices of this ExecutionJobVertex.__@param slotProvider to allocate the slots from_@param queued if the allocations can be queued_@param locationPreferenceConstraint constraint for the location preferences_@return Future which is completed once all {@link Execution} could be deployed;public CompletableFuture<Void> scheduleAll(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) {_		_		final ExecutionVertex[] vertices = this.taskVertices___		final ArrayList<CompletableFuture<Void>> scheduleFutures = new ArrayList<>(vertices.length)___		_		for (ExecutionVertex ev : vertices) {_			scheduleFutures.add(ev.scheduleForExecution(slotProvider, queued, locationPreferenceConstraint))__		}__		return FutureUtils.waitForAll(scheduleFutures)__	};schedules,all,execution,vertices,of,this,execution,job,vertex,param,slot,provider,to,allocate,the,slots,from,param,queued,if,the,allocations,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,return,future,which,is,completed,once,all,link,execution,could,be,deployed;public,completable,future,void,schedule,all,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,final,execution,vertex,vertices,this,task,vertices,final,array,list,completable,future,void,schedule,futures,new,array,list,vertices,length,for,execution,vertex,ev,vertices,schedule,futures,add,ev,schedule,for,execution,slot,provider,queued,location,preference,constraint,return,future,utils,wait,for,all,schedule,futures
ExecutionJobVertex -> public CompletableFuture<Void> scheduleAll( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint);1522574090;Schedules all execution vertices of this ExecutionJobVertex.__@param slotProvider to allocate the slots from_@param queued if the allocations can be queued_@param locationPreferenceConstraint constraint for the location preferences_@return Future which is completed once all {@link Execution} could be deployed;public CompletableFuture<Void> scheduleAll(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) {_		_		final ExecutionVertex[] vertices = this.taskVertices___		final ArrayList<CompletableFuture<Void>> scheduleFutures = new ArrayList<>(vertices.length)___		_		for (ExecutionVertex ev : vertices) {_			scheduleFutures.add(ev.scheduleForExecution(slotProvider, queued, locationPreferenceConstraint))__		}__		return FutureUtils.waitForAll(scheduleFutures)__	};schedules,all,execution,vertices,of,this,execution,job,vertex,param,slot,provider,to,allocate,the,slots,from,param,queued,if,the,allocations,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,return,future,which,is,completed,once,all,link,execution,could,be,deployed;public,completable,future,void,schedule,all,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,final,execution,vertex,vertices,this,task,vertices,final,array,list,completable,future,void,schedule,futures,new,array,list,vertices,length,for,execution,vertex,ev,vertices,schedule,futures,add,ev,schedule,for,execution,slot,provider,queued,location,preference,constraint,return,future,utils,wait,for,all,schedule,futures
ExecutionJobVertex -> public CompletableFuture<Void> scheduleAll( 			SlotProvider slotProvider, 			boolean queued, 			LocationPreferenceConstraint locationPreferenceConstraint);1532285197;Schedules all execution vertices of this ExecutionJobVertex.__@param slotProvider to allocate the slots from_@param queued if the allocations can be queued_@param locationPreferenceConstraint constraint for the location preferences_@return Future which is completed once all {@link Execution} could be deployed;public CompletableFuture<Void> scheduleAll(_			SlotProvider slotProvider,_			boolean queued,_			LocationPreferenceConstraint locationPreferenceConstraint) {__		final ExecutionVertex[] vertices = this.taskVertices___		final ArrayList<CompletableFuture<Void>> scheduleFutures = new ArrayList<>(vertices.length)___		_		for (ExecutionVertex ev : vertices) {_			scheduleFutures.add(ev.scheduleForExecution(slotProvider, queued, locationPreferenceConstraint))__		}__		return FutureUtils.waitForAll(scheduleFutures)__	};schedules,all,execution,vertices,of,this,execution,job,vertex,param,slot,provider,to,allocate,the,slots,from,param,queued,if,the,allocations,can,be,queued,param,location,preference,constraint,constraint,for,the,location,preferences,return,future,which,is,completed,once,all,link,execution,could,be,deployed;public,completable,future,void,schedule,all,slot,provider,slot,provider,boolean,queued,location,preference,constraint,location,preference,constraint,final,execution,vertex,vertices,this,task,vertices,final,array,list,completable,future,void,schedule,futures,new,array,list,vertices,length,for,execution,vertex,ev,vertices,schedule,futures,add,ev,schedule,for,execution,slot,provider,queued,location,preference,constraint,return,future,utils,wait,for,all,schedule,futures
ExecutionJobVertex -> public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued);1486149983;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested.;public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued) {_		final ExecutionVertex[] vertices = this.taskVertices__		final ExecutionAndSlot[] slots = new ExecutionAndSlot[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {__			_			_			boolean successful = false___			try {_				_				final Execution exec = vertices[i].getCurrentExecutionAttempt()__				final Future<SimpleSlot> future = exec.allocateSlotForExecution(resourceProvider, queued)__				slots[i] = new ExecutionAndSlot(exec, future)__				successful = true__			}_			finally {_				if (!successful) {_					_					for (int k = 0_ k < i_ k++) {_						ExecutionGraphUtils.releaseSlotFuture(slots[k].slotFuture)__					}_				}_			}_		}__		_		return slots__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested;public,execution,and,slot,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,final,execution,vertex,vertices,this,task,vertices,final,execution,and,slot,slots,new,execution,and,slot,vertices,length,for,int,i,0,i,vertices,length,i,boolean,successful,false,try,final,execution,exec,vertices,i,get,current,execution,attempt,final,future,simple,slot,future,exec,allocate,slot,for,execution,resource,provider,queued,slots,i,new,execution,and,slot,exec,future,successful,true,finally,if,successful,for,int,k,0,k,i,k,execution,graph,utils,release,slot,future,slots,k,slot,future,return,slots
ExecutionJobVertex -> public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued);1488888670;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested.;public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued) {_		final ExecutionVertex[] vertices = this.taskVertices__		final ExecutionAndSlot[] slots = new ExecutionAndSlot[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {__			_			_			boolean successful = false___			try {_				_				final Execution exec = vertices[i].getCurrentExecutionAttempt()__				final Future<SimpleSlot> future = exec.allocateSlotForExecution(resourceProvider, queued)__				slots[i] = new ExecutionAndSlot(exec, future)__				successful = true__			}_			finally {_				if (!successful) {_					_					for (int k = 0_ k < i_ k++) {_						ExecutionGraphUtils.releaseSlotFuture(slots[k].slotFuture)__					}_				}_			}_		}__		_		return slots__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested;public,execution,and,slot,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,final,execution,vertex,vertices,this,task,vertices,final,execution,and,slot,slots,new,execution,and,slot,vertices,length,for,int,i,0,i,vertices,length,i,boolean,successful,false,try,final,execution,exec,vertices,i,get,current,execution,attempt,final,future,simple,slot,future,exec,allocate,slot,for,execution,resource,provider,queued,slots,i,new,execution,and,slot,exec,future,successful,true,finally,if,successful,for,int,k,0,k,i,k,execution,graph,utils,release,slot,future,slots,k,slot,future,return,slots
ExecutionJobVertex -> public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued);1489153046;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested.;public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued) {_		final ExecutionVertex[] vertices = this.taskVertices__		final ExecutionAndSlot[] slots = new ExecutionAndSlot[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {__			_			_			boolean successful = false___			try {_				_				final Execution exec = vertices[i].getCurrentExecutionAttempt()__				final Future<SimpleSlot> future = exec.allocateSlotForExecution(resourceProvider, queued)__				slots[i] = new ExecutionAndSlot(exec, future)__				successful = true__			}_			finally {_				if (!successful) {_					_					for (int k = 0_ k < i_ k++) {_						ExecutionGraphUtils.releaseSlotFuture(slots[k].slotFuture)__					}_				}_			}_		}__		_		return slots__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested;public,execution,and,slot,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,final,execution,vertex,vertices,this,task,vertices,final,execution,and,slot,slots,new,execution,and,slot,vertices,length,for,int,i,0,i,vertices,length,i,boolean,successful,false,try,final,execution,exec,vertices,i,get,current,execution,attempt,final,future,simple,slot,future,exec,allocate,slot,for,execution,resource,provider,queued,slots,i,new,execution,and,slot,exec,future,successful,true,finally,if,successful,for,int,k,0,k,i,k,execution,graph,utils,release,slot,future,slots,k,slot,future,return,slots
ExecutionJobVertex -> public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued);1490112446;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested.;public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued) {_		final ExecutionVertex[] vertices = this.taskVertices__		final ExecutionAndSlot[] slots = new ExecutionAndSlot[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {__			_			_			boolean successful = false___			try {_				_				final Execution exec = vertices[i].getCurrentExecutionAttempt()__				final Future<SimpleSlot> future = exec.allocateSlotForExecution(resourceProvider, queued)__				slots[i] = new ExecutionAndSlot(exec, future)__				successful = true__			}_			finally {_				if (!successful) {_					_					for (int k = 0_ k < i_ k++) {_						ExecutionGraphUtils.releaseSlotFuture(slots[k].slotFuture)__					}_				}_			}_		}__		_		return slots__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested;public,execution,and,slot,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,final,execution,vertex,vertices,this,task,vertices,final,execution,and,slot,slots,new,execution,and,slot,vertices,length,for,int,i,0,i,vertices,length,i,boolean,successful,false,try,final,execution,exec,vertices,i,get,current,execution,attempt,final,future,simple,slot,future,exec,allocate,slot,for,execution,resource,provider,queued,slots,i,new,execution,and,slot,exec,future,successful,true,finally,if,successful,for,int,k,0,k,i,k,execution,graph,utils,release,slot,future,slots,k,slot,future,return,slots
ExecutionJobVertex -> public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued);1490120014;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested.;public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued) {_		final ExecutionVertex[] vertices = this.taskVertices__		final ExecutionAndSlot[] slots = new ExecutionAndSlot[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {__			_			_			boolean successful = false___			try {_				_				final Execution exec = vertices[i].getCurrentExecutionAttempt()__				final Future<SimpleSlot> future = exec.allocateSlotForExecution(resourceProvider, queued)__				slots[i] = new ExecutionAndSlot(exec, future)__				successful = true__			}_			finally {_				if (!successful) {_					_					for (int k = 0_ k < i_ k++) {_						ExecutionGraphUtils.releaseSlotFuture(slots[k].slotFuture)__					}_				}_			}_		}__		_		return slots__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested;public,execution,and,slot,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,final,execution,vertex,vertices,this,task,vertices,final,execution,and,slot,slots,new,execution,and,slot,vertices,length,for,int,i,0,i,vertices,length,i,boolean,successful,false,try,final,execution,exec,vertices,i,get,current,execution,attempt,final,future,simple,slot,future,exec,allocate,slot,for,execution,resource,provider,queued,slots,i,new,execution,and,slot,exec,future,successful,true,finally,if,successful,for,int,k,0,k,i,k,execution,graph,utils,release,slot,future,slots,k,slot,future,return,slots
ExecutionJobVertex -> public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued);1490820594;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested.;public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued) {_		final ExecutionVertex[] vertices = this.taskVertices__		final ExecutionAndSlot[] slots = new ExecutionAndSlot[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {__			_			_			boolean successful = false___			try {_				_				final Execution exec = vertices[i].getCurrentExecutionAttempt()__				final Future<SimpleSlot> future = exec.allocateSlotForExecution(resourceProvider, queued)__				slots[i] = new ExecutionAndSlot(exec, future)__				successful = true__			}_			finally {_				if (!successful) {_					_					for (int k = 0_ k < i_ k++) {_						ExecutionGraphUtils.releaseSlotFuture(slots[k].slotFuture)__					}_				}_			}_		}__		_		return slots__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested;public,execution,and,slot,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,final,execution,vertex,vertices,this,task,vertices,final,execution,and,slot,slots,new,execution,and,slot,vertices,length,for,int,i,0,i,vertices,length,i,boolean,successful,false,try,final,execution,exec,vertices,i,get,current,execution,attempt,final,future,simple,slot,future,exec,allocate,slot,for,execution,resource,provider,queued,slots,i,new,execution,and,slot,exec,future,successful,true,finally,if,successful,for,int,k,0,k,i,k,execution,graph,utils,release,slot,future,slots,k,slot,future,return,slots
ExecutionJobVertex -> public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued);1491307406;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested.;public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued) {_		final ExecutionVertex[] vertices = this.taskVertices__		final ExecutionAndSlot[] slots = new ExecutionAndSlot[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {__			_			_			boolean successful = false___			try {_				_				final Execution exec = vertices[i].getCurrentExecutionAttempt()__				final Future<SimpleSlot> future = exec.allocateSlotForExecution(resourceProvider, queued)__				slots[i] = new ExecutionAndSlot(exec, future)__				successful = true__			}_			finally {_				if (!successful) {_					_					for (int k = 0_ k < i_ k++) {_						ExecutionGraphUtils.releaseSlotFuture(slots[k].slotFuture)__					}_				}_			}_		}__		_		return slots__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested;public,execution,and,slot,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,final,execution,vertex,vertices,this,task,vertices,final,execution,and,slot,slots,new,execution,and,slot,vertices,length,for,int,i,0,i,vertices,length,i,boolean,successful,false,try,final,execution,exec,vertices,i,get,current,execution,attempt,final,future,simple,slot,future,exec,allocate,slot,for,execution,resource,provider,queued,slots,i,new,execution,and,slot,exec,future,successful,true,finally,if,successful,for,int,k,0,k,i,k,execution,graph,utils,release,slot,future,slots,k,slot,future,return,slots
ExecutionJobVertex -> public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued);1493401220;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested.;public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued) {_		final ExecutionVertex[] vertices = this.taskVertices__		final ExecutionAndSlot[] slots = new ExecutionAndSlot[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {__			_			_			boolean successful = false___			try {_				_				final Execution exec = vertices[i].getCurrentExecutionAttempt()__				final Future<SimpleSlot> future = exec.allocateSlotForExecution(resourceProvider, queued)__				slots[i] = new ExecutionAndSlot(exec, future)__				successful = true__			}_			finally {_				if (!successful) {_					_					for (int k = 0_ k < i_ k++) {_						ExecutionGraphUtils.releaseSlotFuture(slots[k].slotFuture)__					}_				}_			}_		}__		_		return slots__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested;public,execution,and,slot,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,final,execution,vertex,vertices,this,task,vertices,final,execution,and,slot,slots,new,execution,and,slot,vertices,length,for,int,i,0,i,vertices,length,i,boolean,successful,false,try,final,execution,exec,vertices,i,get,current,execution,attempt,final,future,simple,slot,future,exec,allocate,slot,for,execution,resource,provider,queued,slots,i,new,execution,and,slot,exec,future,successful,true,finally,if,successful,for,int,k,0,k,i,k,execution,graph,utils,release,slot,future,slots,k,slot,future,return,slots
ExecutionJobVertex -> public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued);1494516977;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested.;public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued) {_		final ExecutionVertex[] vertices = this.taskVertices__		final ExecutionAndSlot[] slots = new ExecutionAndSlot[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {__			_			_			boolean successful = false___			try {_				_				final Execution exec = vertices[i].getCurrentExecutionAttempt()__				final Future<SimpleSlot> future = exec.allocateSlotForExecution(resourceProvider, queued)__				slots[i] = new ExecutionAndSlot(exec, future)__				successful = true__			}_			finally {_				if (!successful) {_					_					for (int k = 0_ k < i_ k++) {_						ExecutionGraphUtils.releaseSlotFuture(slots[k].slotFuture)__					}_				}_			}_		}__		_		return slots__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested;public,execution,and,slot,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,final,execution,vertex,vertices,this,task,vertices,final,execution,and,slot,slots,new,execution,and,slot,vertices,length,for,int,i,0,i,vertices,length,i,boolean,successful,false,try,final,execution,exec,vertices,i,get,current,execution,attempt,final,future,simple,slot,future,exec,allocate,slot,for,execution,resource,provider,queued,slots,i,new,execution,and,slot,exec,future,successful,true,finally,if,successful,for,int,k,0,k,i,k,execution,graph,utils,release,slot,future,slots,k,slot,future,return,slots
ExecutionJobVertex -> public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued);1500977056;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested.;public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued) {_		final ExecutionVertex[] vertices = this.taskVertices__		final ExecutionAndSlot[] slots = new ExecutionAndSlot[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {__			_			_			boolean successful = false___			try {_				_				final Execution exec = vertices[i].getCurrentExecutionAttempt()__				final CompletableFuture<SimpleSlot> future = exec.allocateSlotForExecution(resourceProvider, queued)__				slots[i] = new ExecutionAndSlot(exec, future)__				successful = true__			}_			finally {_				if (!successful) {_					_					for (int k = 0_ k < i_ k++) {_						ExecutionGraphUtils.releaseSlotFuture(slots[k].slotFuture)__					}_				}_			}_		}__		_		return slots__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested;public,execution,and,slot,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,final,execution,vertex,vertices,this,task,vertices,final,execution,and,slot,slots,new,execution,and,slot,vertices,length,for,int,i,0,i,vertices,length,i,boolean,successful,false,try,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,simple,slot,future,exec,allocate,slot,for,execution,resource,provider,queued,slots,i,new,execution,and,slot,exec,future,successful,true,finally,if,successful,for,int,k,0,k,i,k,execution,graph,utils,release,slot,future,slots,k,slot,future,return,slots
ExecutionJobVertex -> public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued);1501511601;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested.;public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued) {_		final ExecutionVertex[] vertices = this.taskVertices__		final ExecutionAndSlot[] slots = new ExecutionAndSlot[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {__			_			_			boolean successful = false___			try {_				_				final Execution exec = vertices[i].getCurrentExecutionAttempt()__				final CompletableFuture<SimpleSlot> future = exec.allocateSlotForExecution(resourceProvider, queued)__				slots[i] = new ExecutionAndSlot(exec, future)__				successful = true__			}_			finally {_				if (!successful) {_					_					for (int k = 0_ k < i_ k++) {_						ExecutionGraphUtils.releaseSlotFuture(slots[k].slotFuture)__					}_				}_			}_		}__		_		return slots__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested;public,execution,and,slot,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,final,execution,vertex,vertices,this,task,vertices,final,execution,and,slot,slots,new,execution,and,slot,vertices,length,for,int,i,0,i,vertices,length,i,boolean,successful,false,try,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,simple,slot,future,exec,allocate,slot,for,execution,resource,provider,queued,slots,i,new,execution,and,slot,exec,future,successful,true,finally,if,successful,for,int,k,0,k,i,k,execution,graph,utils,release,slot,future,slots,k,slot,future,return,slots
ExecutionJobVertex -> public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued);1507284174;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested.;public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued) {_		final ExecutionVertex[] vertices = this.taskVertices__		final ExecutionAndSlot[] slots = new ExecutionAndSlot[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {__			_			_			boolean successful = false___			try {_				_				final Execution exec = vertices[i].getCurrentExecutionAttempt()__				final CompletableFuture<SimpleSlot> future = exec.allocateSlotForExecution(resourceProvider, queued)__				slots[i] = new ExecutionAndSlot(exec, future)__				successful = true__			}_			finally {_				if (!successful) {_					_					for (int k = 0_ k < i_ k++) {_						ExecutionGraphUtils.releaseSlotFuture(slots[k].slotFuture)__					}_				}_			}_		}__		_		return slots__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested;public,execution,and,slot,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,final,execution,vertex,vertices,this,task,vertices,final,execution,and,slot,slots,new,execution,and,slot,vertices,length,for,int,i,0,i,vertices,length,i,boolean,successful,false,try,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,simple,slot,future,exec,allocate,slot,for,execution,resource,provider,queued,slots,i,new,execution,and,slot,exec,future,successful,true,finally,if,successful,for,int,k,0,k,i,k,execution,graph,utils,release,slot,future,slots,k,slot,future,return,slots
ExecutionJobVertex -> public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued);1508535554;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested.;public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued) {_		final ExecutionVertex[] vertices = this.taskVertices__		final ExecutionAndSlot[] slots = new ExecutionAndSlot[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {__			_			_			boolean successful = false___			try {_				_				final Execution exec = vertices[i].getCurrentExecutionAttempt()__				final CompletableFuture<SimpleSlot> future = exec.allocateSlotForExecution(resourceProvider, queued)__				slots[i] = new ExecutionAndSlot(exec, future)__				successful = true__			}_			finally {_				if (!successful) {_					_					for (int k = 0_ k < i_ k++) {_						ExecutionGraphUtils.releaseSlotFuture(slots[k].slotFuture)__					}_				}_			}_		}__		_		return slots__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested;public,execution,and,slot,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,final,execution,vertex,vertices,this,task,vertices,final,execution,and,slot,slots,new,execution,and,slot,vertices,length,for,int,i,0,i,vertices,length,i,boolean,successful,false,try,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,simple,slot,future,exec,allocate,slot,for,execution,resource,provider,queued,slots,i,new,execution,and,slot,exec,future,successful,true,finally,if,successful,for,int,k,0,k,i,k,execution,graph,utils,release,slot,future,slots,k,slot,future,return,slots
ExecutionJobVertex -> public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued);1508581881;Acquires a slot for all the execution vertices of this ExecutionJobVertex. The method returns_pairs of the slots and execution attempts, to ease correlation between vertices and execution_attempts.__<p>If this method throws an exception, it makes sure to release all so far requested slots.__@param resourceProvider The resource provider from whom the slots are requested.;public ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, boolean queued) {_		final ExecutionVertex[] vertices = this.taskVertices__		final ExecutionAndSlot[] slots = new ExecutionAndSlot[vertices.length]___		_		_		for (int i = 0_ i < vertices.length_ i++) {__			_			_			boolean successful = false___			try {_				_				final Execution exec = vertices[i].getCurrentExecutionAttempt()__				final CompletableFuture<SimpleSlot> future = exec.allocateSlotForExecution(resourceProvider, queued)__				slots[i] = new ExecutionAndSlot(exec, future)__				successful = true__			}_			finally {_				if (!successful) {_					_					for (int k = 0_ k < i_ k++) {_						ExecutionGraphUtils.releaseSlotFuture(slots[k].slotFuture)__					}_				}_			}_		}__		_		return slots__	};acquires,a,slot,for,all,the,execution,vertices,of,this,execution,job,vertex,the,method,returns,pairs,of,the,slots,and,execution,attempts,to,ease,correlation,between,vertices,and,execution,attempts,p,if,this,method,throws,an,exception,it,makes,sure,to,release,all,so,far,requested,slots,param,resource,provider,the,resource,provider,from,whom,the,slots,are,requested;public,execution,and,slot,allocate,resources,for,all,slot,provider,resource,provider,boolean,queued,final,execution,vertex,vertices,this,task,vertices,final,execution,and,slot,slots,new,execution,and,slot,vertices,length,for,int,i,0,i,vertices,length,i,boolean,successful,false,try,final,execution,exec,vertices,i,get,current,execution,attempt,final,completable,future,simple,slot,future,exec,allocate,slot,for,execution,resource,provider,queued,slots,i,new,execution,and,slot,exec,future,successful,true,finally,if,successful,for,int,k,0,k,i,k,execution,graph,utils,release,slot,future,slots,k,slot,future,return,slots
