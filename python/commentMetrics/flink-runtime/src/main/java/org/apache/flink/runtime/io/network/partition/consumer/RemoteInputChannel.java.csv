# id;timestamp;commentText;codeText;commentWords;codeWords
RemoteInputChannel -> @Override 	public void releaseAllResources() throws IOException;1412761231;Releases all received buffers and closes the partition request client.;@Override_	public void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,public,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this
RemoteInputChannel -> @Override 	public void releaseAllResources() throws IOException;1420560668;Releases all received buffers and closes the partition request client.;@Override_	public void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(producerAddress)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,public,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,producer,address
RemoteInputChannel -> @Override 	public void releaseAllResources() throws IOException;1423577144;Releases all received buffers and closes the partition request client.;@Override_	public void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,public,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this
RemoteInputChannel -> @Override 	public void releaseAllResources() throws IOException;1424803030;Releases all received buffers and closes the partition request client.;@Override_	public void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(producerAddress)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,public,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,producer,address
RemoteInputChannel -> @Override 	public void releaseAllResources() throws IOException;1425323313;Releases all received buffers and closes the partition request client.;@Override_	public void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(producerAddress)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,public,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,producer,address
RemoteInputChannel -> @Override 	public void releaseAllResources() throws IOException;1426876316;Releases all received buffers and closes the partition request client.;@Override_	public void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(producerAddress)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,public,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,producer,address
RemoteInputChannel -> private void notifyCreditAvailable();1506753379;Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.;private void notifyCreditAvailable() {_		checkState(partitionRequestClient != null, "Tried to send task event to producer before requesting a queue.")___		_		if (!isReleased.get()) {_			partitionRequestClient.notifyCreditAvailable(this)__		}_	};enqueue,this,input,channel,in,the,pipeline,for,notifying,the,producer,of,unannounced,credit;private,void,notify,credit,available,check,state,partition,request,client,null,tried,to,send,task,event,to,producer,before,requesting,a,queue,if,is,released,get,partition,request,client,notify,credit,available,this
RemoteInputChannel -> private void notifyCreditAvailable();1516801403;Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.;private void notifyCreditAvailable() {_		checkState(partitionRequestClient != null, "Tried to send task event to producer before requesting a queue.")___		_		if (!isReleased.get()) {_			partitionRequestClient.notifyCreditAvailable(this)__		}_	};enqueue,this,input,channel,in,the,pipeline,for,notifying,the,producer,of,unannounced,credit;private,void,notify,credit,available,check,state,partition,request,client,null,tried,to,send,task,event,to,producer,before,requesting,a,queue,if,is,released,get,partition,request,client,notify,credit,available,this
RemoteInputChannel -> private void notifyCreditAvailable();1519310498;Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.;private void notifyCreditAvailable() {_		checkState(partitionRequestClient != null, "Tried to send task event to producer before requesting a queue.")___		_		if (!isReleased.get()) {_			partitionRequestClient.notifyCreditAvailable(this)__		}_	};enqueue,this,input,channel,in,the,pipeline,for,notifying,the,producer,of,unannounced,credit;private,void,notify,credit,available,check,state,partition,request,client,null,tried,to,send,task,event,to,producer,before,requesting,a,queue,if,is,released,get,partition,request,client,notify,credit,available,this
RemoteInputChannel -> private void notifyCreditAvailable();1519350957;Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.;private void notifyCreditAvailable() {_		checkState(partitionRequestClient != null, "Tried to send task event to producer before requesting a queue.")___		_		if (!isReleased.get()) {_			partitionRequestClient.notifyCreditAvailable(this)__		}_	};enqueue,this,input,channel,in,the,pipeline,for,notifying,the,producer,of,unannounced,credit;private,void,notify,credit,available,check,state,partition,request,client,null,tried,to,send,task,event,to,producer,before,requesting,a,queue,if,is,released,get,partition,request,client,notify,credit,available,this
RemoteInputChannel -> private void notifyCreditAvailable();1530744513;Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.;private void notifyCreditAvailable() {_		checkState(partitionRequestClient != null, "Tried to send task event to producer before requesting a queue.")___		_		if (!isReleased.get()) {_			partitionRequestClient.notifyCreditAvailable(this)__		}_	};enqueue,this,input,channel,in,the,pipeline,for,notifying,the,producer,of,unannounced,credit;private,void,notify,credit,available,check,state,partition,request,client,null,tried,to,send,task,event,to,producer,before,requesting,a,queue,if,is,released,get,partition,request,client,notify,credit,available,this
RemoteInputChannel -> private void notifyCreditAvailable();1533422492;Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.;private void notifyCreditAvailable() {_		checkState(partitionRequestClient != null, "Tried to send task event to producer before requesting a queue.")___		partitionRequestClient.notifyCreditAvailable(this)__	};enqueue,this,input,channel,in,the,pipeline,for,notifying,the,producer,of,unannounced,credit;private,void,notify,credit,available,check,state,partition,request,client,null,tried,to,send,task,event,to,producer,before,requesting,a,queue,partition,request,client,notify,credit,available,this
RemoteInputChannel -> private void notifyCreditAvailable();1534276258;Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.;private void notifyCreditAvailable() {_		checkState(partitionRequestClient != null, "Tried to send task event to producer before requesting a queue.")___		_		if (!isReleased.get()) {_			partitionRequestClient.notifyCreditAvailable(this)__		}_	};enqueue,this,input,channel,in,the,pipeline,for,notifying,the,producer,of,unannounced,credit;private,void,notify,credit,available,check,state,partition,request,client,null,tried,to,send,task,event,to,producer,before,requesting,a,queue,if,is,released,get,partition,request,client,notify,credit,available,this
RemoteInputChannel -> private void notifyCreditAvailable();1534864589;Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.;private void notifyCreditAvailable() {_		checkState(partitionRequestClient != null, "Tried to send task event to producer before requesting a queue.")___		_		if (!isReleased.get()) {_			partitionRequestClient.notifyCreditAvailable(this)__		}_	};enqueue,this,input,channel,in,the,pipeline,for,notifying,the,producer,of,unannounced,credit;private,void,notify,credit,available,check,state,partition,request,client,null,tried,to,send,task,event,to,producer,before,requesting,a,queue,if,is,released,get,partition,request,client,notify,credit,available,this
RemoteInputChannel -> private void notifyCreditAvailable();1534865689;Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.;private void notifyCreditAvailable() {_		checkState(partitionRequestClient != null, "Tried to send task event to producer before requesting a queue.")___		_		if (!isReleased.get()) {_			partitionRequestClient.notifyCreditAvailable(this)__		}_	};enqueue,this,input,channel,in,the,pipeline,for,notifying,the,producer,of,unannounced,credit;private,void,notify,credit,available,check,state,partition,request,client,null,tried,to,send,task,event,to,producer,before,requesting,a,queue,if,is,released,get,partition,request,client,notify,credit,available,this
RemoteInputChannel -> private void notifyCreditAvailable();1543328832;Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.;private void notifyCreditAvailable() {_		checkState(partitionRequestClient != null, "Tried to send task event to producer before requesting a queue.")___		partitionRequestClient.notifyCreditAvailable(this)__	};enqueue,this,input,channel,in,the,pipeline,for,notifying,the,producer,of,unannounced,credit;private,void,notify,credit,available,check,state,partition,request,client,null,tried,to,send,task,event,to,producer,before,requesting,a,queue,partition,request,client,notify,credit,available,this
RemoteInputChannel -> public int getUnannouncedCredit();1502969925;Gets the currently unannounced credit.__@return Credit which was not announced to the sender yet.;public int getUnannouncedCredit() {_		return unannouncedCredit.get()__	};gets,the,currently,unannounced,credit,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,unannounced,credit,return,unannounced,credit,get
RemoteInputChannel -> public int getUnannouncedCredit();1506613166;Gets the currently unannounced credit.__@return Credit which was not announced to the sender yet.;public int getUnannouncedCredit() {_		return unannouncedCredit.get()__	};gets,the,currently,unannounced,credit,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,unannounced,credit,return,unannounced,credit,get
RemoteInputChannel -> public int getUnannouncedCredit();1506753379;Gets the currently unannounced credit.__@return Credit which was not announced to the sender yet.;public int getUnannouncedCredit() {_		return unannouncedCredit.get()__	};gets,the,currently,unannounced,credit,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,unannounced,credit,return,unannounced,credit,get
RemoteInputChannel -> public int getUnannouncedCredit();1515514130;Gets the currently unannounced credit.__@return Credit which was not announced to the sender yet.;public int getUnannouncedCredit() {_		return unannouncedCredit.get()__	};gets,the,currently,unannounced,credit,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,unannounced,credit,return,unannounced,credit,get
RemoteInputChannel -> public int getUnannouncedCredit();1515534998;Gets the currently unannounced credit.__@return Credit which was not announced to the sender yet.;public int getUnannouncedCredit() {_		return unannouncedCredit.get()__	};gets,the,currently,unannounced,credit,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,unannounced,credit,return,unannounced,credit,get
RemoteInputChannel -> public int getUnannouncedCredit();1516801403;Gets the currently unannounced credit.__@return Credit which was not announced to the sender yet.;public int getUnannouncedCredit() {_		return unannouncedCredit.get()__	};gets,the,currently,unannounced,credit,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,unannounced,credit,return,unannounced,credit,get
RemoteInputChannel -> public int getUnannouncedCredit();1519310498;Gets the currently unannounced credit.__@return Credit which was not announced to the sender yet.;public int getUnannouncedCredit() {_		return unannouncedCredit.get()__	};gets,the,currently,unannounced,credit,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,unannounced,credit,return,unannounced,credit,get
RemoteInputChannel -> public int getUnannouncedCredit();1519350957;Gets the currently unannounced credit.__@return Credit which was not announced to the sender yet.;public int getUnannouncedCredit() {_		return unannouncedCredit.get()__	};gets,the,currently,unannounced,credit,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,unannounced,credit,return,unannounced,credit,get
RemoteInputChannel -> public int getUnannouncedCredit();1530744513;Gets the currently unannounced credit.__@return Credit which was not announced to the sender yet.;public int getUnannouncedCredit() {_		return unannouncedCredit.get()__	};gets,the,currently,unannounced,credit,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,unannounced,credit,return,unannounced,credit,get
RemoteInputChannel -> public int getUnannouncedCredit();1533422492;Gets the currently unannounced credit.__@return Credit which was not announced to the sender yet.;public int getUnannouncedCredit() {_		return unannouncedCredit.get()__	};gets,the,currently,unannounced,credit,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,unannounced,credit,return,unannounced,credit,get
RemoteInputChannel -> public int getUnannouncedCredit();1534276258;Gets the currently unannounced credit.__@return Credit which was not announced to the sender yet.;public int getUnannouncedCredit() {_		return unannouncedCredit.get()__	};gets,the,currently,unannounced,credit,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,unannounced,credit,return,unannounced,credit,get
RemoteInputChannel -> public int getUnannouncedCredit();1534864589;Gets the currently unannounced credit.__@return Credit which was not announced to the sender yet.;public int getUnannouncedCredit() {_		return unannouncedCredit.get()__	};gets,the,currently,unannounced,credit,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,unannounced,credit,return,unannounced,credit,get
RemoteInputChannel -> public int getUnannouncedCredit();1534865689;Gets the currently unannounced credit.__@return Credit which was not announced to the sender yet.;public int getUnannouncedCredit() {_		return unannouncedCredit.get()__	};gets,the,currently,unannounced,credit,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,unannounced,credit,return,unannounced,credit,get
RemoteInputChannel -> public int getUnannouncedCredit();1543328832;Gets the currently unannounced credit.__@return Credit which was not announced to the sender yet.;public int getUnannouncedCredit() {_		return unannouncedCredit.get()__	};gets,the,currently,unannounced,credit,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,unannounced,credit,return,unannounced,credit,get
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1431354895;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		_		if (nextRequestBackoffMs == 0) {_			failPartitionRequest()__		}_		else if (nextRequestBackoffMs <= maxRequestBackoffMs) {_			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, nextRequestBackoffMs)___			_			nextRequestBackoffMs = nextRequestBackoffMs < maxRequestBackoffMs_					? Math.min(nextRequestBackoffMs * 2, maxRequestBackoffMs)_					: maxRequestBackoffMs + 1_ _		}_		else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,next,request,backoff,ms,0,fail,partition,request,else,if,next,request,backoff,ms,max,request,backoff,ms,partition,request,client,request,subpartition,partition,id,subpartition,index,this,next,request,backoff,ms,next,request,backoff,ms,next,request,backoff,ms,max,request,backoff,ms,math,min,next,request,backoff,ms,2,max,request,backoff,ms,max,request,backoff,ms,1,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1432647455;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_					partitionId, subpartitionIndex, this, getCurrentBackoff())__		}_		else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1432806352;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_					partitionId, subpartitionIndex, this, getCurrentBackoff())__		}_		else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1438275734;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_					partitionId, subpartitionIndex, this, getCurrentBackoff())__		}_		else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1464773080;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_					partitionId, subpartitionIndex, this, getCurrentBackoff())__		}_		else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1465394479;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_					partitionId, subpartitionIndex, this, getCurrentBackoff())__		}_		else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1469183596;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_					partitionId, subpartitionIndex, this, getCurrentBackoff())__		}_		else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1472628826;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_					partitionId, subpartitionIndex, this, getCurrentBackoff())__		}_		else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1475838130;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_					partitionId, subpartitionIndex, this, getCurrentBackoff())__		}_		else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1479407816;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1480323569;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1502098277;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1502282631;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1502342953;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1502692247;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1502969925;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1505982496;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1506507855;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1506613166;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1506753379;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1515514130;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1515534998;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1516801403;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1519310498;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1519350957;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1530744513;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1533422492;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1534276258;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1534864589;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1534865689;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1543328832;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1502282631;Exclusive buffer is recycled to this input channel directly and it may trigger notify_credit to producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		synchronized (availableBuffers) {_			_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Arrays.asList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			availableBuffers.add(new Buffer(segment, this))__		}__		if (unannouncedCredit.getAndAdd(1) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,notify,credit,to,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,synchronized,available,buffers,if,is,released,get,try,input,gate,return,exclusive,segments,arrays,as,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,available,buffers,add,new,buffer,segment,this,if,unannounced,credit,get,and,add,1,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1502342953;Exclusive buffer is recycled to this input channel directly and it may trigger return extra_floating buffer and notify increased credit to the producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		int numAddedBuffers___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Collections.singletonList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			numAddedBuffers = bufferQueue.addExclusiveBuffer(new Buffer(segment, this), numRequiredBuffers)__		}__		if (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,return,extra,floating,buffer,and,notify,increased,credit,to,the,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,int,num,added,buffers,synchronized,buffer,queue,if,is,released,get,try,input,gate,return,exclusive,segments,collections,singleton,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,num,added,buffers,buffer,queue,add,exclusive,buffer,new,buffer,segment,this,num,required,buffers,if,num,added,buffers,0,unannounced,credit,get,and,add,num,added,buffers,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1502692247;Exclusive buffer is recycled to this input channel directly and it may trigger notify_credit to producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		synchronized (availableBuffers) {_			_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Arrays.asList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			availableBuffers.add(new Buffer(segment, this))__		}__		if (unannouncedCredit.getAndAdd(1) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,notify,credit,to,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,synchronized,available,buffers,if,is,released,get,try,input,gate,return,exclusive,segments,arrays,as,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,available,buffers,add,new,buffer,segment,this,if,unannounced,credit,get,and,add,1,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1502969925;Exclusive buffer is recycled to this input channel directly and it may trigger return extra_floating buffer and notify increased credit to the producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		int numAddedBuffers___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Collections.singletonList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			numAddedBuffers = bufferQueue.addExclusiveBuffer(new Buffer(segment, this), numRequiredBuffers)__		}__		if (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,return,extra,floating,buffer,and,notify,increased,credit,to,the,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,int,num,added,buffers,synchronized,buffer,queue,if,is,released,get,try,input,gate,return,exclusive,segments,collections,singleton,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,num,added,buffers,buffer,queue,add,exclusive,buffer,new,buffer,segment,this,num,required,buffers,if,num,added,buffers,0,unannounced,credit,get,and,add,num,added,buffers,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1505982496;Exclusive buffer is recycled to this input channel directly and it may trigger notify_credit to producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		synchronized (availableBuffers) {_			_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Arrays.asList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			availableBuffers.add(new Buffer(segment, this))__		}__		if (unannouncedCredit.getAndAdd(1) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,notify,credit,to,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,synchronized,available,buffers,if,is,released,get,try,input,gate,return,exclusive,segments,arrays,as,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,available,buffers,add,new,buffer,segment,this,if,unannounced,credit,get,and,add,1,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1506507855;Exclusive buffer is recycled to this input channel directly and it may trigger notify_credit to producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		synchronized (availableBuffers) {_			_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Arrays.asList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			availableBuffers.add(new Buffer(segment, this))__		}__		if (unannouncedCredit.getAndAdd(1) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,notify,credit,to,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,synchronized,available,buffers,if,is,released,get,try,input,gate,return,exclusive,segments,arrays,as,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,available,buffers,add,new,buffer,segment,this,if,unannounced,credit,get,and,add,1,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1506613166;Exclusive buffer is recycled to this input channel directly and it may trigger return extra_floating buffer and notify increased credit to the producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		int numAddedBuffers___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Collections.singletonList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			numAddedBuffers = bufferQueue.addExclusiveBuffer(new Buffer(segment, this), numRequiredBuffers)__		}__		if (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,return,extra,floating,buffer,and,notify,increased,credit,to,the,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,int,num,added,buffers,synchronized,buffer,queue,if,is,released,get,try,input,gate,return,exclusive,segments,collections,singleton,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,num,added,buffers,buffer,queue,add,exclusive,buffer,new,buffer,segment,this,num,required,buffers,if,num,added,buffers,0,unannounced,credit,get,and,add,num,added,buffers,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1506753379;Exclusive buffer is recycled to this input channel directly and it may trigger return extra_floating buffer and notify increased credit to the producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		int numAddedBuffers___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Collections.singletonList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			numAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__		}__		if (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,return,extra,floating,buffer,and,notify,increased,credit,to,the,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,int,num,added,buffers,synchronized,buffer,queue,if,is,released,get,try,input,gate,return,exclusive,segments,collections,singleton,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,num,added,buffers,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers,if,num,added,buffers,0,unannounced,credit,get,and,add,num,added,buffers,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1515514130;Exclusive buffer is recycled to this input channel directly and it may trigger return extra_floating buffer and notify increased credit to the producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		int numAddedBuffers___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Collections.singletonList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			numAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__		}__		if (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,return,extra,floating,buffer,and,notify,increased,credit,to,the,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,int,num,added,buffers,synchronized,buffer,queue,if,is,released,get,try,input,gate,return,exclusive,segments,collections,singleton,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,num,added,buffers,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers,if,num,added,buffers,0,unannounced,credit,get,and,add,num,added,buffers,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1515534998;Exclusive buffer is recycled to this input channel directly and it may trigger return extra_floating buffer and notify increased credit to the producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		int numAddedBuffers___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Collections.singletonList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			numAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__		}__		if (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,return,extra,floating,buffer,and,notify,increased,credit,to,the,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,int,num,added,buffers,synchronized,buffer,queue,if,is,released,get,try,input,gate,return,exclusive,segments,collections,singleton,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,num,added,buffers,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers,if,num,added,buffers,0,unannounced,credit,get,and,add,num,added,buffers,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1516801403;Exclusive buffer is recycled to this input channel directly and it may trigger return extra_floating buffer and notify increased credit to the producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		int numAddedBuffers___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Collections.singletonList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			numAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__		}__		if (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,return,extra,floating,buffer,and,notify,increased,credit,to,the,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,int,num,added,buffers,synchronized,buffer,queue,if,is,released,get,try,input,gate,return,exclusive,segments,collections,singleton,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,num,added,buffers,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers,if,num,added,buffers,0,unannounced,credit,get,and,add,num,added,buffers,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1519310498;Exclusive buffer is recycled to this input channel directly and it may trigger return extra_floating buffer and notify increased credit to the producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		int numAddedBuffers___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Collections.singletonList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			numAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__		}__		if (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,return,extra,floating,buffer,and,notify,increased,credit,to,the,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,int,num,added,buffers,synchronized,buffer,queue,if,is,released,get,try,input,gate,return,exclusive,segments,collections,singleton,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,num,added,buffers,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers,if,num,added,buffers,0,unannounced,credit,get,and,add,num,added,buffers,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1519350957;Exclusive buffer is recycled to this input channel directly and it may trigger return extra_floating buffer and notify increased credit to the producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		int numAddedBuffers___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Collections.singletonList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			numAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__		}__		if (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,return,extra,floating,buffer,and,notify,increased,credit,to,the,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,int,num,added,buffers,synchronized,buffer,queue,if,is,released,get,try,input,gate,return,exclusive,segments,collections,singleton,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,num,added,buffers,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers,if,num,added,buffers,0,unannounced,credit,get,and,add,num,added,buffers,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1530744513;Exclusive buffer is recycled to this input channel directly and it may trigger return extra_floating buffer and notify increased credit to the producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		int numAddedBuffers___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Collections.singletonList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			numAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__		}__		if (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,return,extra,floating,buffer,and,notify,increased,credit,to,the,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,int,num,added,buffers,synchronized,buffer,queue,if,is,released,get,try,input,gate,return,exclusive,segments,collections,singleton,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,num,added,buffers,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers,if,num,added,buffers,0,unannounced,credit,get,and,add,num,added,buffers,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1533422492;Exclusive buffer is recycled to this input channel directly and it may trigger return extra_floating buffer and notify increased credit to the producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		int numAddedBuffers___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Collections.singletonList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			numAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__		}__		if (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,return,extra,floating,buffer,and,notify,increased,credit,to,the,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,int,num,added,buffers,synchronized,buffer,queue,if,is,released,get,try,input,gate,return,exclusive,segments,collections,singleton,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,num,added,buffers,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers,if,num,added,buffers,0,unannounced,credit,get,and,add,num,added,buffers,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1534276258;Exclusive buffer is recycled to this input channel directly and it may trigger return extra_floating buffer and notify increased credit to the producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		int numAddedBuffers___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Collections.singletonList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			numAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__		}__		if (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,return,extra,floating,buffer,and,notify,increased,credit,to,the,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,int,num,added,buffers,synchronized,buffer,queue,if,is,released,get,try,input,gate,return,exclusive,segments,collections,singleton,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,num,added,buffers,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers,if,num,added,buffers,0,unannounced,credit,get,and,add,num,added,buffers,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1534864589;Exclusive buffer is recycled to this input channel directly and it may trigger return extra_floating buffer and notify increased credit to the producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		int numAddedBuffers___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Collections.singletonList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			numAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__		}__		if (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,return,extra,floating,buffer,and,notify,increased,credit,to,the,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,int,num,added,buffers,synchronized,buffer,queue,if,is,released,get,try,input,gate,return,exclusive,segments,collections,singleton,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,num,added,buffers,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers,if,num,added,buffers,0,unannounced,credit,get,and,add,num,added,buffers,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1534865689;Exclusive buffer is recycled to this input channel directly and it may trigger return extra_floating buffer and notify increased credit to the producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		int numAddedBuffers___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Collections.singletonList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			numAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__		}__		if (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,return,extra,floating,buffer,and,notify,increased,credit,to,the,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,int,num,added,buffers,synchronized,buffer,queue,if,is,released,get,try,input,gate,return,exclusive,segments,collections,singleton,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,num,added,buffers,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers,if,num,added,buffers,0,unannounced,credit,get,and,add,num,added,buffers,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1543328832;Exclusive buffer is recycled to this input channel directly and it may trigger return extra_floating buffer and notify increased credit to the producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		int numAddedBuffers___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Collections.singletonList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			numAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__		}__		if (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,return,extra,floating,buffer,and,notify,increased,credit,to,the,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,int,num,added,buffers,synchronized,buffer,queue,if,is,released,get,try,input,gate,return,exclusive,segments,collections,singleton,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,num,added,buffers,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers,if,num,added,buffers,0,unannounced,credit,get,and,add,num,added,buffers,0,notify,credit,available
RemoteInputChannel -> AvailableBufferQueue -> void releaseAll(List<MemorySegment> exclusiveSegments);1502342953;The floating buffer is recycled to local buffer pool directly, and the_exclusive buffer will be gathered to return to global buffer pool later.__@param exclusiveSegments The list that we will add exclusive segments into.;void releaseAll(List<MemorySegment> exclusiveSegments) {_			Buffer buffer__			while ((buffer = floatingBuffers.poll()) != null) {_				buffer.recycle()__			}_			while ((buffer = exclusiveBuffers.poll()) != null) {_				exclusiveSegments.add(buffer.getMemorySegment())__			}_		};the,floating,buffer,is,recycled,to,local,buffer,pool,directly,and,the,exclusive,buffer,will,be,gathered,to,return,to,global,buffer,pool,later,param,exclusive,segments,the,list,that,we,will,add,exclusive,segments,into;void,release,all,list,memory,segment,exclusive,segments,buffer,buffer,while,buffer,floating,buffers,poll,null,buffer,recycle,while,buffer,exclusive,buffers,poll,null,exclusive,segments,add,buffer,get,memory,segment
RemoteInputChannel -> AvailableBufferQueue -> void releaseAll(List<MemorySegment> exclusiveSegments);1502969925;The floating buffer is recycled to local buffer pool directly, and the_exclusive buffer will be gathered to return to global buffer pool later.__@param exclusiveSegments The list that we will add exclusive segments into.;void releaseAll(List<MemorySegment> exclusiveSegments) {_			Buffer buffer__			while ((buffer = floatingBuffers.poll()) != null) {_				buffer.recycle()__			}_			while ((buffer = exclusiveBuffers.poll()) != null) {_				exclusiveSegments.add(buffer.getMemorySegment())__			}_		};the,floating,buffer,is,recycled,to,local,buffer,pool,directly,and,the,exclusive,buffer,will,be,gathered,to,return,to,global,buffer,pool,later,param,exclusive,segments,the,list,that,we,will,add,exclusive,segments,into;void,release,all,list,memory,segment,exclusive,segments,buffer,buffer,while,buffer,floating,buffers,poll,null,buffer,recycle,while,buffer,exclusive,buffers,poll,null,exclusive,segments,add,buffer,get,memory,segment
RemoteInputChannel -> AvailableBufferQueue -> void releaseAll(List<MemorySegment> exclusiveSegments);1506613166;The floating buffer is recycled to local buffer pool directly, and the_exclusive buffer will be gathered to return to global buffer pool later.__@param exclusiveSegments The list that we will add exclusive segments into.;void releaseAll(List<MemorySegment> exclusiveSegments) {_			Buffer buffer__			while ((buffer = floatingBuffers.poll()) != null) {_				buffer.recycle()__			}_			while ((buffer = exclusiveBuffers.poll()) != null) {_				exclusiveSegments.add(buffer.getMemorySegment())__			}_		};the,floating,buffer,is,recycled,to,local,buffer,pool,directly,and,the,exclusive,buffer,will,be,gathered,to,return,to,global,buffer,pool,later,param,exclusive,segments,the,list,that,we,will,add,exclusive,segments,into;void,release,all,list,memory,segment,exclusive,segments,buffer,buffer,while,buffer,floating,buffers,poll,null,buffer,recycle,while,buffer,exclusive,buffers,poll,null,exclusive,segments,add,buffer,get,memory,segment
RemoteInputChannel -> AvailableBufferQueue -> void releaseAll(List<MemorySegment> exclusiveSegments);1506753379;The floating buffer is recycled to local buffer pool directly, and the_exclusive buffer will be gathered to return to global buffer pool later.__@param exclusiveSegments The list that we will add exclusive segments into.;void releaseAll(List<MemorySegment> exclusiveSegments) {_			Buffer buffer__			while ((buffer = floatingBuffers.poll()) != null) {_				buffer.recycleBuffer()__			}_			while ((buffer = exclusiveBuffers.poll()) != null) {_				exclusiveSegments.add(buffer.getMemorySegment())__			}_		};the,floating,buffer,is,recycled,to,local,buffer,pool,directly,and,the,exclusive,buffer,will,be,gathered,to,return,to,global,buffer,pool,later,param,exclusive,segments,the,list,that,we,will,add,exclusive,segments,into;void,release,all,list,memory,segment,exclusive,segments,buffer,buffer,while,buffer,floating,buffers,poll,null,buffer,recycle,buffer,while,buffer,exclusive,buffers,poll,null,exclusive,segments,add,buffer,get,memory,segment
RemoteInputChannel -> AvailableBufferQueue -> void releaseAll(List<MemorySegment> exclusiveSegments);1515514130;The floating buffer is recycled to local buffer pool directly, and the_exclusive buffer will be gathered to return to global buffer pool later.__@param exclusiveSegments The list that we will add exclusive segments into.;void releaseAll(List<MemorySegment> exclusiveSegments) {_			Buffer buffer__			while ((buffer = floatingBuffers.poll()) != null) {_				buffer.recycle()__			}_			while ((buffer = exclusiveBuffers.poll()) != null) {_				exclusiveSegments.add(buffer.getMemorySegment())__			}_		};the,floating,buffer,is,recycled,to,local,buffer,pool,directly,and,the,exclusive,buffer,will,be,gathered,to,return,to,global,buffer,pool,later,param,exclusive,segments,the,list,that,we,will,add,exclusive,segments,into;void,release,all,list,memory,segment,exclusive,segments,buffer,buffer,while,buffer,floating,buffers,poll,null,buffer,recycle,while,buffer,exclusive,buffers,poll,null,exclusive,segments,add,buffer,get,memory,segment
RemoteInputChannel -> AvailableBufferQueue -> void releaseAll(List<MemorySegment> exclusiveSegments);1515534998;The floating buffer is recycled to local buffer pool directly, and the_exclusive buffer will be gathered to return to global buffer pool later.__@param exclusiveSegments The list that we will add exclusive segments into.;void releaseAll(List<MemorySegment> exclusiveSegments) {_			Buffer buffer__			while ((buffer = floatingBuffers.poll()) != null) {_				buffer.recycleBuffer()__			}_			while ((buffer = exclusiveBuffers.poll()) != null) {_				exclusiveSegments.add(buffer.getMemorySegment())__			}_		};the,floating,buffer,is,recycled,to,local,buffer,pool,directly,and,the,exclusive,buffer,will,be,gathered,to,return,to,global,buffer,pool,later,param,exclusive,segments,the,list,that,we,will,add,exclusive,segments,into;void,release,all,list,memory,segment,exclusive,segments,buffer,buffer,while,buffer,floating,buffers,poll,null,buffer,recycle,buffer,while,buffer,exclusive,buffers,poll,null,exclusive,segments,add,buffer,get,memory,segment
RemoteInputChannel -> AvailableBufferQueue -> void releaseAll(List<MemorySegment> exclusiveSegments);1516801403;The floating buffer is recycled to local buffer pool directly, and the_exclusive buffer will be gathered to return to global buffer pool later.__@param exclusiveSegments The list that we will add exclusive segments into.;void releaseAll(List<MemorySegment> exclusiveSegments) {_			Buffer buffer__			while ((buffer = floatingBuffers.poll()) != null) {_				buffer.recycleBuffer()__			}_			while ((buffer = exclusiveBuffers.poll()) != null) {_				exclusiveSegments.add(buffer.getMemorySegment())__			}_		};the,floating,buffer,is,recycled,to,local,buffer,pool,directly,and,the,exclusive,buffer,will,be,gathered,to,return,to,global,buffer,pool,later,param,exclusive,segments,the,list,that,we,will,add,exclusive,segments,into;void,release,all,list,memory,segment,exclusive,segments,buffer,buffer,while,buffer,floating,buffers,poll,null,buffer,recycle,buffer,while,buffer,exclusive,buffers,poll,null,exclusive,segments,add,buffer,get,memory,segment
RemoteInputChannel -> AvailableBufferQueue -> void releaseAll(List<MemorySegment> exclusiveSegments);1519310498;The floating buffer is recycled to local buffer pool directly, and the_exclusive buffer will be gathered to return to global buffer pool later.__@param exclusiveSegments The list that we will add exclusive segments into.;void releaseAll(List<MemorySegment> exclusiveSegments) {_			Buffer buffer__			while ((buffer = floatingBuffers.poll()) != null) {_				buffer.recycleBuffer()__			}_			while ((buffer = exclusiveBuffers.poll()) != null) {_				exclusiveSegments.add(buffer.getMemorySegment())__			}_		};the,floating,buffer,is,recycled,to,local,buffer,pool,directly,and,the,exclusive,buffer,will,be,gathered,to,return,to,global,buffer,pool,later,param,exclusive,segments,the,list,that,we,will,add,exclusive,segments,into;void,release,all,list,memory,segment,exclusive,segments,buffer,buffer,while,buffer,floating,buffers,poll,null,buffer,recycle,buffer,while,buffer,exclusive,buffers,poll,null,exclusive,segments,add,buffer,get,memory,segment
RemoteInputChannel -> AvailableBufferQueue -> void releaseAll(List<MemorySegment> exclusiveSegments);1519350957;The floating buffer is recycled to local buffer pool directly, and the_exclusive buffer will be gathered to return to global buffer pool later.__@param exclusiveSegments The list that we will add exclusive segments into.;void releaseAll(List<MemorySegment> exclusiveSegments) {_			Buffer buffer__			while ((buffer = floatingBuffers.poll()) != null) {_				buffer.recycleBuffer()__			}_			while ((buffer = exclusiveBuffers.poll()) != null) {_				exclusiveSegments.add(buffer.getMemorySegment())__			}_		};the,floating,buffer,is,recycled,to,local,buffer,pool,directly,and,the,exclusive,buffer,will,be,gathered,to,return,to,global,buffer,pool,later,param,exclusive,segments,the,list,that,we,will,add,exclusive,segments,into;void,release,all,list,memory,segment,exclusive,segments,buffer,buffer,while,buffer,floating,buffers,poll,null,buffer,recycle,buffer,while,buffer,exclusive,buffers,poll,null,exclusive,segments,add,buffer,get,memory,segment
RemoteInputChannel -> AvailableBufferQueue -> void releaseAll(List<MemorySegment> exclusiveSegments);1530744513;The floating buffer is recycled to local buffer pool directly, and the_exclusive buffer will be gathered to return to global buffer pool later.__@param exclusiveSegments The list that we will add exclusive segments into.;void releaseAll(List<MemorySegment> exclusiveSegments) {_			Buffer buffer__			while ((buffer = floatingBuffers.poll()) != null) {_				buffer.recycleBuffer()__			}_			while ((buffer = exclusiveBuffers.poll()) != null) {_				exclusiveSegments.add(buffer.getMemorySegment())__			}_		};the,floating,buffer,is,recycled,to,local,buffer,pool,directly,and,the,exclusive,buffer,will,be,gathered,to,return,to,global,buffer,pool,later,param,exclusive,segments,the,list,that,we,will,add,exclusive,segments,into;void,release,all,list,memory,segment,exclusive,segments,buffer,buffer,while,buffer,floating,buffers,poll,null,buffer,recycle,buffer,while,buffer,exclusive,buffers,poll,null,exclusive,segments,add,buffer,get,memory,segment
RemoteInputChannel -> AvailableBufferQueue -> void releaseAll(List<MemorySegment> exclusiveSegments);1533422492;The floating buffer is recycled to local buffer pool directly, and the_exclusive buffer will be gathered to return to global buffer pool later.__@param exclusiveSegments The list that we will add exclusive segments into.;void releaseAll(List<MemorySegment> exclusiveSegments) {_			Buffer buffer__			while ((buffer = floatingBuffers.poll()) != null) {_				buffer.recycleBuffer()__			}_			while ((buffer = exclusiveBuffers.poll()) != null) {_				exclusiveSegments.add(buffer.getMemorySegment())__			}_		};the,floating,buffer,is,recycled,to,local,buffer,pool,directly,and,the,exclusive,buffer,will,be,gathered,to,return,to,global,buffer,pool,later,param,exclusive,segments,the,list,that,we,will,add,exclusive,segments,into;void,release,all,list,memory,segment,exclusive,segments,buffer,buffer,while,buffer,floating,buffers,poll,null,buffer,recycle,buffer,while,buffer,exclusive,buffers,poll,null,exclusive,segments,add,buffer,get,memory,segment
RemoteInputChannel -> AvailableBufferQueue -> void releaseAll(List<MemorySegment> exclusiveSegments);1534276258;The floating buffer is recycled to local buffer pool directly, and the_exclusive buffer will be gathered to return to global buffer pool later.__@param exclusiveSegments The list that we will add exclusive segments into.;void releaseAll(List<MemorySegment> exclusiveSegments) {_			Buffer buffer__			while ((buffer = floatingBuffers.poll()) != null) {_				buffer.recycleBuffer()__			}_			while ((buffer = exclusiveBuffers.poll()) != null) {_				exclusiveSegments.add(buffer.getMemorySegment())__			}_		};the,floating,buffer,is,recycled,to,local,buffer,pool,directly,and,the,exclusive,buffer,will,be,gathered,to,return,to,global,buffer,pool,later,param,exclusive,segments,the,list,that,we,will,add,exclusive,segments,into;void,release,all,list,memory,segment,exclusive,segments,buffer,buffer,while,buffer,floating,buffers,poll,null,buffer,recycle,buffer,while,buffer,exclusive,buffers,poll,null,exclusive,segments,add,buffer,get,memory,segment
RemoteInputChannel -> AvailableBufferQueue -> void releaseAll(List<MemorySegment> exclusiveSegments);1534864589;The floating buffer is recycled to local buffer pool directly, and the_exclusive buffer will be gathered to return to global buffer pool later.__@param exclusiveSegments The list that we will add exclusive segments into.;void releaseAll(List<MemorySegment> exclusiveSegments) {_			Buffer buffer__			while ((buffer = floatingBuffers.poll()) != null) {_				buffer.recycleBuffer()__			}_			while ((buffer = exclusiveBuffers.poll()) != null) {_				exclusiveSegments.add(buffer.getMemorySegment())__			}_		};the,floating,buffer,is,recycled,to,local,buffer,pool,directly,and,the,exclusive,buffer,will,be,gathered,to,return,to,global,buffer,pool,later,param,exclusive,segments,the,list,that,we,will,add,exclusive,segments,into;void,release,all,list,memory,segment,exclusive,segments,buffer,buffer,while,buffer,floating,buffers,poll,null,buffer,recycle,buffer,while,buffer,exclusive,buffers,poll,null,exclusive,segments,add,buffer,get,memory,segment
RemoteInputChannel -> AvailableBufferQueue -> void releaseAll(List<MemorySegment> exclusiveSegments);1534865689;The floating buffer is recycled to local buffer pool directly, and the_exclusive buffer will be gathered to return to global buffer pool later.__@param exclusiveSegments The list that we will add exclusive segments into.;void releaseAll(List<MemorySegment> exclusiveSegments) {_			Buffer buffer__			while ((buffer = floatingBuffers.poll()) != null) {_				buffer.recycleBuffer()__			}_			while ((buffer = exclusiveBuffers.poll()) != null) {_				exclusiveSegments.add(buffer.getMemorySegment())__			}_		};the,floating,buffer,is,recycled,to,local,buffer,pool,directly,and,the,exclusive,buffer,will,be,gathered,to,return,to,global,buffer,pool,later,param,exclusive,segments,the,list,that,we,will,add,exclusive,segments,into;void,release,all,list,memory,segment,exclusive,segments,buffer,buffer,while,buffer,floating,buffers,poll,null,buffer,recycle,buffer,while,buffer,exclusive,buffers,poll,null,exclusive,segments,add,buffer,get,memory,segment
RemoteInputChannel -> AvailableBufferQueue -> void releaseAll(List<MemorySegment> exclusiveSegments);1543328832;The floating buffer is recycled to local buffer pool directly, and the_exclusive buffer will be gathered to return to global buffer pool later.__@param exclusiveSegments The list that we will add exclusive segments into.;void releaseAll(List<MemorySegment> exclusiveSegments) {_			Buffer buffer__			while ((buffer = floatingBuffers.poll()) != null) {_				buffer.recycleBuffer()__			}_			while ((buffer = exclusiveBuffers.poll()) != null) {_				exclusiveSegments.add(buffer.getMemorySegment())__			}_		};the,floating,buffer,is,recycled,to,local,buffer,pool,directly,and,the,exclusive,buffer,will,be,gathered,to,return,to,global,buffer,pool,later,param,exclusive,segments,the,list,that,we,will,add,exclusive,segments,into;void,release,all,list,memory,segment,exclusive,segments,buffer,buffer,while,buffer,floating,buffers,poll,null,buffer,recycle,buffer,while,buffer,exclusive,buffers,poll,null,exclusive,segments,add,buffer,get,memory,segment
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1427189152;Releases all received buffers and closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			}_			else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1431354895;Releases all received buffers and closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			}_			else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1432647455;Releases all received buffers and closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			}_			else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1432806352;Releases all received buffers and closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			}_			else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1438275734;Releases all received buffers and closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			}_			else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1464773080;Releases all received buffers and closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			}_			else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1465394479;Releases all received buffers and closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			}_			else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1469183596;Releases all received buffers and closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			}_			else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1472628826;Releases all received buffers and closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			}_			else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1475838130;Releases all received buffers and closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			}_			else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1479407816;Releases all received buffers and closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1480323569;Releases all received buffers and closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1502098277;Releases all received buffers and closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1502282631;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycle()__					}_				}_			}__			synchronized (availableBuffers) {_				Buffer buffer__				while ((buffer = availableBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycle()__					}_				}_			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,synchronized,available,buffers,buffer,buffer,while,buffer,available,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1502342953;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycle()__					}_				}_			}_			synchronized (bufferQueue) {_				bufferQueue.releaseAll(exclusiveRecyclingSegments)__			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,synchronized,buffer,queue,buffer,queue,release,all,exclusive,recycling,segments,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1502692247;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycle()__					}_				}_			}__			synchronized (availableBuffers) {_				Buffer buffer__				while ((buffer = availableBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycle()__					}_				}_			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,synchronized,available,buffers,buffer,buffer,while,buffer,available,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1502969925;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycle()__					}_				}_			}_			synchronized (bufferQueue) {_				bufferQueue.releaseAll(exclusiveRecyclingSegments)__			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,synchronized,buffer,queue,buffer,queue,release,all,exclusive,recycling,segments,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1505982496;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycle()__					}_				}_			}__			synchronized (availableBuffers) {_				Buffer buffer__				while ((buffer = availableBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycle()__					}_				}_			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,synchronized,available,buffers,buffer,buffer,while,buffer,available,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1506507855;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycle()__					}_				}_			}__			synchronized (availableBuffers) {_				Buffer buffer__				while ((buffer = availableBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycle()__					}_				}_			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,synchronized,available,buffers,buffer,buffer,while,buffer,available,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1506613166;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycle()__					}_				}_			}_			synchronized (bufferQueue) {_				bufferQueue.releaseAll(exclusiveRecyclingSegments)__			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,synchronized,buffer,queue,buffer,queue,release,all,exclusive,recycling,segments,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1506753379;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycleBuffer()__					}_				}_			}_			synchronized (bufferQueue) {_				bufferQueue.releaseAll(exclusiveRecyclingSegments)__			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,buffer,synchronized,buffer,queue,buffer,queue,release,all,exclusive,recycling,segments,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1515514130;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycle()__					}_				}_			}_			synchronized (bufferQueue) {_				bufferQueue.releaseAll(exclusiveRecyclingSegments)__			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,synchronized,buffer,queue,buffer,queue,release,all,exclusive,recycling,segments,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1515534998;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycleBuffer()__					}_				}_			}_			synchronized (bufferQueue) {_				bufferQueue.releaseAll(exclusiveRecyclingSegments)__			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,buffer,synchronized,buffer,queue,buffer,queue,release,all,exclusive,recycling,segments,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1516801403;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycleBuffer()__					}_				}_			}_			synchronized (bufferQueue) {_				bufferQueue.releaseAll(exclusiveRecyclingSegments)__			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,buffer,synchronized,buffer,queue,buffer,queue,release,all,exclusive,recycling,segments,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1519310498;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycleBuffer()__					}_				}_			}_			synchronized (bufferQueue) {_				bufferQueue.releaseAll(exclusiveRecyclingSegments)__			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,buffer,synchronized,buffer,queue,buffer,queue,release,all,exclusive,recycling,segments,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1519350957;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycleBuffer()__					}_				}_			}_			synchronized (bufferQueue) {_				bufferQueue.releaseAll(exclusiveRecyclingSegments)__			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,buffer,synchronized,buffer,queue,buffer,queue,release,all,exclusive,recycling,segments,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1530744513;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycleBuffer()__					}_				}_			}_			synchronized (bufferQueue) {_				bufferQueue.releaseAll(exclusiveRecyclingSegments)__			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,buffer,synchronized,buffer,queue,buffer,queue,release,all,exclusive,recycling,segments,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1533422492;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycleBuffer()__					}_				}_			}_			synchronized (bufferQueue) {_				bufferQueue.releaseAll(exclusiveRecyclingSegments)__			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,buffer,synchronized,buffer,queue,buffer,queue,release,all,exclusive,recycling,segments,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1534276258;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycleBuffer()__					}_				}_			}_			synchronized (bufferQueue) {_				bufferQueue.releaseAll(exclusiveRecyclingSegments)__			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,buffer,synchronized,buffer,queue,buffer,queue,release,all,exclusive,recycling,segments,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1534864589;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycleBuffer()__					}_				}_			}_			synchronized (bufferQueue) {_				bufferQueue.releaseAll(exclusiveRecyclingSegments)__			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,buffer,synchronized,buffer,queue,buffer,queue,release,all,exclusive,recycling,segments,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1534865689;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycleBuffer()__					}_				}_			}_			synchronized (bufferQueue) {_				bufferQueue.releaseAll(exclusiveRecyclingSegments)__			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,buffer,synchronized,buffer,queue,buffer,queue,release,all,exclusive,recycling,segments,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1543328832;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycleBuffer()__					}_				}_			}_			synchronized (bufferQueue) {_				bufferQueue.releaseAll(exclusiveRecyclingSegments)__			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,buffer,synchronized,buffer,queue,buffer,queue,release,all,exclusive,recycling,segments,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> AvailableBufferQueue -> int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers);1502342953;Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the_number of available buffers in queue is more than the required amount.__@param buffer The exclusive buffer to add_@param numRequiredBuffers The number of required buffers__@return How many buffers were added to the queue;int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {_			exclusiveBuffers.add(buffer)__			if (getAvailableBufferSize() > numRequiredBuffers) {_				Buffer floatingBuffer = floatingBuffers.poll()__				floatingBuffer.recycle()__				return 0__			} else {_				return 1__			}_		};adds,an,exclusive,buffer,back,into,the,queue,and,recycles,one,floating,buffer,if,the,number,of,available,buffers,in,queue,is,more,than,the,required,amount,param,buffer,the,exclusive,buffer,to,add,param,num,required,buffers,the,number,of,required,buffers,return,how,many,buffers,were,added,to,the,queue;int,add,exclusive,buffer,buffer,buffer,int,num,required,buffers,exclusive,buffers,add,buffer,if,get,available,buffer,size,num,required,buffers,buffer,floating,buffer,floating,buffers,poll,floating,buffer,recycle,return,0,else,return,1
RemoteInputChannel -> AvailableBufferQueue -> int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers);1502969925;Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the_number of available buffers in queue is more than the required amount.__@param buffer The exclusive buffer to add_@param numRequiredBuffers The number of required buffers__@return How many buffers were added to the queue;int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {_			exclusiveBuffers.add(buffer)__			if (getAvailableBufferSize() > numRequiredBuffers) {_				Buffer floatingBuffer = floatingBuffers.poll()__				floatingBuffer.recycle()__				return 0__			} else {_				return 1__			}_		};adds,an,exclusive,buffer,back,into,the,queue,and,recycles,one,floating,buffer,if,the,number,of,available,buffers,in,queue,is,more,than,the,required,amount,param,buffer,the,exclusive,buffer,to,add,param,num,required,buffers,the,number,of,required,buffers,return,how,many,buffers,were,added,to,the,queue;int,add,exclusive,buffer,buffer,buffer,int,num,required,buffers,exclusive,buffers,add,buffer,if,get,available,buffer,size,num,required,buffers,buffer,floating,buffer,floating,buffers,poll,floating,buffer,recycle,return,0,else,return,1
RemoteInputChannel -> AvailableBufferQueue -> int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers);1506613166;Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the_number of available buffers in queue is more than the required amount.__@param buffer The exclusive buffer to add_@param numRequiredBuffers The number of required buffers__@return How many buffers were added to the queue;int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {_			exclusiveBuffers.add(buffer)__			if (getAvailableBufferSize() > numRequiredBuffers) {_				Buffer floatingBuffer = floatingBuffers.poll()__				floatingBuffer.recycle()__				return 0__			} else {_				return 1__			}_		};adds,an,exclusive,buffer,back,into,the,queue,and,recycles,one,floating,buffer,if,the,number,of,available,buffers,in,queue,is,more,than,the,required,amount,param,buffer,the,exclusive,buffer,to,add,param,num,required,buffers,the,number,of,required,buffers,return,how,many,buffers,were,added,to,the,queue;int,add,exclusive,buffer,buffer,buffer,int,num,required,buffers,exclusive,buffers,add,buffer,if,get,available,buffer,size,num,required,buffers,buffer,floating,buffer,floating,buffers,poll,floating,buffer,recycle,return,0,else,return,1
RemoteInputChannel -> AvailableBufferQueue -> int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers);1506753379;Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the_number of available buffers in queue is more than the required amount.__@param buffer The exclusive buffer to add_@param numRequiredBuffers The number of required buffers__@return How many buffers were added to the queue;int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {_			exclusiveBuffers.add(buffer)__			if (getAvailableBufferSize() > numRequiredBuffers) {_				Buffer floatingBuffer = floatingBuffers.poll()__				floatingBuffer.recycleBuffer()__				return 0__			} else {_				return 1__			}_		};adds,an,exclusive,buffer,back,into,the,queue,and,recycles,one,floating,buffer,if,the,number,of,available,buffers,in,queue,is,more,than,the,required,amount,param,buffer,the,exclusive,buffer,to,add,param,num,required,buffers,the,number,of,required,buffers,return,how,many,buffers,were,added,to,the,queue;int,add,exclusive,buffer,buffer,buffer,int,num,required,buffers,exclusive,buffers,add,buffer,if,get,available,buffer,size,num,required,buffers,buffer,floating,buffer,floating,buffers,poll,floating,buffer,recycle,buffer,return,0,else,return,1
RemoteInputChannel -> AvailableBufferQueue -> int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers);1515514130;Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the_number of available buffers in queue is more than the required amount.__@param buffer The exclusive buffer to add_@param numRequiredBuffers The number of required buffers__@return How many buffers were added to the queue;int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {_			exclusiveBuffers.add(buffer)__			if (getAvailableBufferSize() > numRequiredBuffers) {_				Buffer floatingBuffer = floatingBuffers.poll()__				floatingBuffer.recycle()__				return 0__			} else {_				return 1__			}_		};adds,an,exclusive,buffer,back,into,the,queue,and,recycles,one,floating,buffer,if,the,number,of,available,buffers,in,queue,is,more,than,the,required,amount,param,buffer,the,exclusive,buffer,to,add,param,num,required,buffers,the,number,of,required,buffers,return,how,many,buffers,were,added,to,the,queue;int,add,exclusive,buffer,buffer,buffer,int,num,required,buffers,exclusive,buffers,add,buffer,if,get,available,buffer,size,num,required,buffers,buffer,floating,buffer,floating,buffers,poll,floating,buffer,recycle,return,0,else,return,1
RemoteInputChannel -> AvailableBufferQueue -> int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers);1515534998;Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the_number of available buffers in queue is more than the required amount.__@param buffer The exclusive buffer to add_@param numRequiredBuffers The number of required buffers__@return How many buffers were added to the queue;int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {_			exclusiveBuffers.add(buffer)__			if (getAvailableBufferSize() > numRequiredBuffers) {_				Buffer floatingBuffer = floatingBuffers.poll()__				floatingBuffer.recycleBuffer()__				return 0__			} else {_				return 1__			}_		};adds,an,exclusive,buffer,back,into,the,queue,and,recycles,one,floating,buffer,if,the,number,of,available,buffers,in,queue,is,more,than,the,required,amount,param,buffer,the,exclusive,buffer,to,add,param,num,required,buffers,the,number,of,required,buffers,return,how,many,buffers,were,added,to,the,queue;int,add,exclusive,buffer,buffer,buffer,int,num,required,buffers,exclusive,buffers,add,buffer,if,get,available,buffer,size,num,required,buffers,buffer,floating,buffer,floating,buffers,poll,floating,buffer,recycle,buffer,return,0,else,return,1
RemoteInputChannel -> AvailableBufferQueue -> int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers);1516801403;Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the_number of available buffers in queue is more than the required amount.__@param buffer The exclusive buffer to add_@param numRequiredBuffers The number of required buffers__@return How many buffers were added to the queue;int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {_			exclusiveBuffers.add(buffer)__			if (getAvailableBufferSize() > numRequiredBuffers) {_				Buffer floatingBuffer = floatingBuffers.poll()__				floatingBuffer.recycleBuffer()__				return 0__			} else {_				return 1__			}_		};adds,an,exclusive,buffer,back,into,the,queue,and,recycles,one,floating,buffer,if,the,number,of,available,buffers,in,queue,is,more,than,the,required,amount,param,buffer,the,exclusive,buffer,to,add,param,num,required,buffers,the,number,of,required,buffers,return,how,many,buffers,were,added,to,the,queue;int,add,exclusive,buffer,buffer,buffer,int,num,required,buffers,exclusive,buffers,add,buffer,if,get,available,buffer,size,num,required,buffers,buffer,floating,buffer,floating,buffers,poll,floating,buffer,recycle,buffer,return,0,else,return,1
RemoteInputChannel -> AvailableBufferQueue -> int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers);1519310498;Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the_number of available buffers in queue is more than the required amount.__@param buffer The exclusive buffer to add_@param numRequiredBuffers The number of required buffers__@return How many buffers were added to the queue;int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {_			exclusiveBuffers.add(buffer)__			if (getAvailableBufferSize() > numRequiredBuffers) {_				Buffer floatingBuffer = floatingBuffers.poll()__				floatingBuffer.recycleBuffer()__				return 0__			} else {_				return 1__			}_		};adds,an,exclusive,buffer,back,into,the,queue,and,recycles,one,floating,buffer,if,the,number,of,available,buffers,in,queue,is,more,than,the,required,amount,param,buffer,the,exclusive,buffer,to,add,param,num,required,buffers,the,number,of,required,buffers,return,how,many,buffers,were,added,to,the,queue;int,add,exclusive,buffer,buffer,buffer,int,num,required,buffers,exclusive,buffers,add,buffer,if,get,available,buffer,size,num,required,buffers,buffer,floating,buffer,floating,buffers,poll,floating,buffer,recycle,buffer,return,0,else,return,1
RemoteInputChannel -> AvailableBufferQueue -> int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers);1519350957;Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the_number of available buffers in queue is more than the required amount.__@param buffer The exclusive buffer to add_@param numRequiredBuffers The number of required buffers__@return How many buffers were added to the queue;int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {_			exclusiveBuffers.add(buffer)__			if (getAvailableBufferSize() > numRequiredBuffers) {_				Buffer floatingBuffer = floatingBuffers.poll()__				floatingBuffer.recycleBuffer()__				return 0__			} else {_				return 1__			}_		};adds,an,exclusive,buffer,back,into,the,queue,and,recycles,one,floating,buffer,if,the,number,of,available,buffers,in,queue,is,more,than,the,required,amount,param,buffer,the,exclusive,buffer,to,add,param,num,required,buffers,the,number,of,required,buffers,return,how,many,buffers,were,added,to,the,queue;int,add,exclusive,buffer,buffer,buffer,int,num,required,buffers,exclusive,buffers,add,buffer,if,get,available,buffer,size,num,required,buffers,buffer,floating,buffer,floating,buffers,poll,floating,buffer,recycle,buffer,return,0,else,return,1
RemoteInputChannel -> AvailableBufferQueue -> int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers);1530744513;Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the_number of available buffers in queue is more than the required amount.__@param buffer The exclusive buffer to add_@param numRequiredBuffers The number of required buffers__@return How many buffers were added to the queue;int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {_			exclusiveBuffers.add(buffer)__			if (getAvailableBufferSize() > numRequiredBuffers) {_				Buffer floatingBuffer = floatingBuffers.poll()__				floatingBuffer.recycleBuffer()__				return 0__			} else {_				return 1__			}_		};adds,an,exclusive,buffer,back,into,the,queue,and,recycles,one,floating,buffer,if,the,number,of,available,buffers,in,queue,is,more,than,the,required,amount,param,buffer,the,exclusive,buffer,to,add,param,num,required,buffers,the,number,of,required,buffers,return,how,many,buffers,were,added,to,the,queue;int,add,exclusive,buffer,buffer,buffer,int,num,required,buffers,exclusive,buffers,add,buffer,if,get,available,buffer,size,num,required,buffers,buffer,floating,buffer,floating,buffers,poll,floating,buffer,recycle,buffer,return,0,else,return,1
RemoteInputChannel -> AvailableBufferQueue -> int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers);1533422492;Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the_number of available buffers in queue is more than the required amount.__@param buffer The exclusive buffer to add_@param numRequiredBuffers The number of required buffers__@return How many buffers were added to the queue;int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {_			exclusiveBuffers.add(buffer)__			if (getAvailableBufferSize() > numRequiredBuffers) {_				Buffer floatingBuffer = floatingBuffers.poll()__				floatingBuffer.recycleBuffer()__				return 0__			} else {_				return 1__			}_		};adds,an,exclusive,buffer,back,into,the,queue,and,recycles,one,floating,buffer,if,the,number,of,available,buffers,in,queue,is,more,than,the,required,amount,param,buffer,the,exclusive,buffer,to,add,param,num,required,buffers,the,number,of,required,buffers,return,how,many,buffers,were,added,to,the,queue;int,add,exclusive,buffer,buffer,buffer,int,num,required,buffers,exclusive,buffers,add,buffer,if,get,available,buffer,size,num,required,buffers,buffer,floating,buffer,floating,buffers,poll,floating,buffer,recycle,buffer,return,0,else,return,1
RemoteInputChannel -> AvailableBufferQueue -> int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers);1534276258;Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the_number of available buffers in queue is more than the required amount.__@param buffer The exclusive buffer to add_@param numRequiredBuffers The number of required buffers__@return How many buffers were added to the queue;int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {_			exclusiveBuffers.add(buffer)__			if (getAvailableBufferSize() > numRequiredBuffers) {_				Buffer floatingBuffer = floatingBuffers.poll()__				floatingBuffer.recycleBuffer()__				return 0__			} else {_				return 1__			}_		};adds,an,exclusive,buffer,back,into,the,queue,and,recycles,one,floating,buffer,if,the,number,of,available,buffers,in,queue,is,more,than,the,required,amount,param,buffer,the,exclusive,buffer,to,add,param,num,required,buffers,the,number,of,required,buffers,return,how,many,buffers,were,added,to,the,queue;int,add,exclusive,buffer,buffer,buffer,int,num,required,buffers,exclusive,buffers,add,buffer,if,get,available,buffer,size,num,required,buffers,buffer,floating,buffer,floating,buffers,poll,floating,buffer,recycle,buffer,return,0,else,return,1
RemoteInputChannel -> AvailableBufferQueue -> int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers);1534864589;Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the_number of available buffers in queue is more than the required amount.__@param buffer The exclusive buffer to add_@param numRequiredBuffers The number of required buffers__@return How many buffers were added to the queue;int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {_			exclusiveBuffers.add(buffer)__			if (getAvailableBufferSize() > numRequiredBuffers) {_				Buffer floatingBuffer = floatingBuffers.poll()__				floatingBuffer.recycleBuffer()__				return 0__			} else {_				return 1__			}_		};adds,an,exclusive,buffer,back,into,the,queue,and,recycles,one,floating,buffer,if,the,number,of,available,buffers,in,queue,is,more,than,the,required,amount,param,buffer,the,exclusive,buffer,to,add,param,num,required,buffers,the,number,of,required,buffers,return,how,many,buffers,were,added,to,the,queue;int,add,exclusive,buffer,buffer,buffer,int,num,required,buffers,exclusive,buffers,add,buffer,if,get,available,buffer,size,num,required,buffers,buffer,floating,buffer,floating,buffers,poll,floating,buffer,recycle,buffer,return,0,else,return,1
RemoteInputChannel -> AvailableBufferQueue -> int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers);1534865689;Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the_number of available buffers in queue is more than the required amount.__@param buffer The exclusive buffer to add_@param numRequiredBuffers The number of required buffers__@return How many buffers were added to the queue;int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {_			exclusiveBuffers.add(buffer)__			if (getAvailableBufferSize() > numRequiredBuffers) {_				Buffer floatingBuffer = floatingBuffers.poll()__				floatingBuffer.recycleBuffer()__				return 0__			} else {_				return 1__			}_		};adds,an,exclusive,buffer,back,into,the,queue,and,recycles,one,floating,buffer,if,the,number,of,available,buffers,in,queue,is,more,than,the,required,amount,param,buffer,the,exclusive,buffer,to,add,param,num,required,buffers,the,number,of,required,buffers,return,how,many,buffers,were,added,to,the,queue;int,add,exclusive,buffer,buffer,buffer,int,num,required,buffers,exclusive,buffers,add,buffer,if,get,available,buffer,size,num,required,buffers,buffer,floating,buffer,floating,buffers,poll,floating,buffer,recycle,buffer,return,0,else,return,1
RemoteInputChannel -> AvailableBufferQueue -> int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers);1543328832;Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the_number of available buffers in queue is more than the required amount.__@param buffer The exclusive buffer to add_@param numRequiredBuffers The number of required buffers__@return How many buffers were added to the queue;int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {_			exclusiveBuffers.add(buffer)__			if (getAvailableBufferSize() > numRequiredBuffers) {_				Buffer floatingBuffer = floatingBuffers.poll()__				floatingBuffer.recycleBuffer()__				return 0__			} else {_				return 1__			}_		};adds,an,exclusive,buffer,back,into,the,queue,and,recycles,one,floating,buffer,if,the,number,of,available,buffers,in,queue,is,more,than,the,required,amount,param,buffer,the,exclusive,buffer,to,add,param,num,required,buffers,the,number,of,required,buffers,return,how,many,buffers,were,added,to,the,queue;int,add,exclusive,buffer,buffer,buffer,int,num,required,buffers,exclusive,buffers,add,buffer,if,get,available,buffer,size,num,required,buffers,buffer,floating,buffer,floating,buffers,poll,floating,buffer,recycle,buffer,return,0,else,return,1
RemoteInputChannel -> @Nullable 	public Buffer requestBuffer();1502342953;Requests buffer from input channel directly for receiving network data._It should always return an available buffer in credit-based mode unless_the channel has been released.__@return The available buffer.;@Nullable_	public Buffer requestBuffer() {_		synchronized (bufferQueue) {_			return bufferQueue.takeBuffer()__		}_	};requests,buffer,from,input,channel,directly,for,receiving,network,data,it,should,always,return,an,available,buffer,in,credit,based,mode,unless,the,channel,has,been,released,return,the,available,buffer;nullable,public,buffer,request,buffer,synchronized,buffer,queue,return,buffer,queue,take,buffer
RemoteInputChannel -> @Nullable 	public Buffer requestBuffer();1502969925;Requests buffer from input channel directly for receiving network data._It should always return an available buffer in credit-based mode unless_the channel has been released.__@return The available buffer.;@Nullable_	public Buffer requestBuffer() {_		synchronized (bufferQueue) {_			return bufferQueue.takeBuffer()__		}_	};requests,buffer,from,input,channel,directly,for,receiving,network,data,it,should,always,return,an,available,buffer,in,credit,based,mode,unless,the,channel,has,been,released,return,the,available,buffer;nullable,public,buffer,request,buffer,synchronized,buffer,queue,return,buffer,queue,take,buffer
RemoteInputChannel -> @Nullable 	public Buffer requestBuffer();1506613166;Requests buffer from input channel directly for receiving network data._It should always return an available buffer in credit-based mode unless_the channel has been released.__@return The available buffer.;@Nullable_	public Buffer requestBuffer() {_		synchronized (bufferQueue) {_			return bufferQueue.takeBuffer()__		}_	};requests,buffer,from,input,channel,directly,for,receiving,network,data,it,should,always,return,an,available,buffer,in,credit,based,mode,unless,the,channel,has,been,released,return,the,available,buffer;nullable,public,buffer,request,buffer,synchronized,buffer,queue,return,buffer,queue,take,buffer
RemoteInputChannel -> @Nullable 	public Buffer requestBuffer();1506753379;Requests buffer from input channel directly for receiving network data._It should always return an available buffer in credit-based mode unless_the channel has been released.__@return The available buffer.;@Nullable_	public Buffer requestBuffer() {_		synchronized (bufferQueue) {_			return bufferQueue.takeBuffer()__		}_	};requests,buffer,from,input,channel,directly,for,receiving,network,data,it,should,always,return,an,available,buffer,in,credit,based,mode,unless,the,channel,has,been,released,return,the,available,buffer;nullable,public,buffer,request,buffer,synchronized,buffer,queue,return,buffer,queue,take,buffer
RemoteInputChannel -> @Nullable 	public Buffer requestBuffer();1515514130;Requests buffer from input channel directly for receiving network data._It should always return an available buffer in credit-based mode unless_the channel has been released.__@return The available buffer.;@Nullable_	public Buffer requestBuffer() {_		synchronized (bufferQueue) {_			return bufferQueue.takeBuffer()__		}_	};requests,buffer,from,input,channel,directly,for,receiving,network,data,it,should,always,return,an,available,buffer,in,credit,based,mode,unless,the,channel,has,been,released,return,the,available,buffer;nullable,public,buffer,request,buffer,synchronized,buffer,queue,return,buffer,queue,take,buffer
RemoteInputChannel -> @Nullable 	public Buffer requestBuffer();1515534998;Requests buffer from input channel directly for receiving network data._It should always return an available buffer in credit-based mode unless_the channel has been released.__@return The available buffer.;@Nullable_	public Buffer requestBuffer() {_		synchronized (bufferQueue) {_			return bufferQueue.takeBuffer()__		}_	};requests,buffer,from,input,channel,directly,for,receiving,network,data,it,should,always,return,an,available,buffer,in,credit,based,mode,unless,the,channel,has,been,released,return,the,available,buffer;nullable,public,buffer,request,buffer,synchronized,buffer,queue,return,buffer,queue,take,buffer
RemoteInputChannel -> @Nullable 	public Buffer requestBuffer();1516801403;Requests buffer from input channel directly for receiving network data._It should always return an available buffer in credit-based mode unless_the channel has been released.__@return The available buffer.;@Nullable_	public Buffer requestBuffer() {_		synchronized (bufferQueue) {_			return bufferQueue.takeBuffer()__		}_	};requests,buffer,from,input,channel,directly,for,receiving,network,data,it,should,always,return,an,available,buffer,in,credit,based,mode,unless,the,channel,has,been,released,return,the,available,buffer;nullable,public,buffer,request,buffer,synchronized,buffer,queue,return,buffer,queue,take,buffer
RemoteInputChannel -> @Nullable 	public Buffer requestBuffer();1519310498;Requests buffer from input channel directly for receiving network data._It should always return an available buffer in credit-based mode unless_the channel has been released.__@return The available buffer.;@Nullable_	public Buffer requestBuffer() {_		synchronized (bufferQueue) {_			return bufferQueue.takeBuffer()__		}_	};requests,buffer,from,input,channel,directly,for,receiving,network,data,it,should,always,return,an,available,buffer,in,credit,based,mode,unless,the,channel,has,been,released,return,the,available,buffer;nullable,public,buffer,request,buffer,synchronized,buffer,queue,return,buffer,queue,take,buffer
RemoteInputChannel -> @Nullable 	public Buffer requestBuffer();1519350957;Requests buffer from input channel directly for receiving network data._It should always return an available buffer in credit-based mode unless_the channel has been released.__@return The available buffer.;@Nullable_	public Buffer requestBuffer() {_		synchronized (bufferQueue) {_			return bufferQueue.takeBuffer()__		}_	};requests,buffer,from,input,channel,directly,for,receiving,network,data,it,should,always,return,an,available,buffer,in,credit,based,mode,unless,the,channel,has,been,released,return,the,available,buffer;nullable,public,buffer,request,buffer,synchronized,buffer,queue,return,buffer,queue,take,buffer
RemoteInputChannel -> @Nullable 	public Buffer requestBuffer();1530744513;Requests buffer from input channel directly for receiving network data._It should always return an available buffer in credit-based mode unless_the channel has been released.__@return The available buffer.;@Nullable_	public Buffer requestBuffer() {_		synchronized (bufferQueue) {_			return bufferQueue.takeBuffer()__		}_	};requests,buffer,from,input,channel,directly,for,receiving,network,data,it,should,always,return,an,available,buffer,in,credit,based,mode,unless,the,channel,has,been,released,return,the,available,buffer;nullable,public,buffer,request,buffer,synchronized,buffer,queue,return,buffer,queue,take,buffer
RemoteInputChannel -> @Nullable 	public Buffer requestBuffer();1533422492;Requests buffer from input channel directly for receiving network data._It should always return an available buffer in credit-based mode unless_the channel has been released.__@return The available buffer.;@Nullable_	public Buffer requestBuffer() {_		synchronized (bufferQueue) {_			return bufferQueue.takeBuffer()__		}_	};requests,buffer,from,input,channel,directly,for,receiving,network,data,it,should,always,return,an,available,buffer,in,credit,based,mode,unless,the,channel,has,been,released,return,the,available,buffer;nullable,public,buffer,request,buffer,synchronized,buffer,queue,return,buffer,queue,take,buffer
RemoteInputChannel -> @Nullable 	public Buffer requestBuffer();1534276258;Requests buffer from input channel directly for receiving network data._It should always return an available buffer in credit-based mode unless_the channel has been released.__@return The available buffer.;@Nullable_	public Buffer requestBuffer() {_		synchronized (bufferQueue) {_			return bufferQueue.takeBuffer()__		}_	};requests,buffer,from,input,channel,directly,for,receiving,network,data,it,should,always,return,an,available,buffer,in,credit,based,mode,unless,the,channel,has,been,released,return,the,available,buffer;nullable,public,buffer,request,buffer,synchronized,buffer,queue,return,buffer,queue,take,buffer
RemoteInputChannel -> @Nullable 	public Buffer requestBuffer();1534864589;Requests buffer from input channel directly for receiving network data._It should always return an available buffer in credit-based mode unless_the channel has been released.__@return The available buffer.;@Nullable_	public Buffer requestBuffer() {_		synchronized (bufferQueue) {_			return bufferQueue.takeBuffer()__		}_	};requests,buffer,from,input,channel,directly,for,receiving,network,data,it,should,always,return,an,available,buffer,in,credit,based,mode,unless,the,channel,has,been,released,return,the,available,buffer;nullable,public,buffer,request,buffer,synchronized,buffer,queue,return,buffer,queue,take,buffer
RemoteInputChannel -> @Nullable 	public Buffer requestBuffer();1534865689;Requests buffer from input channel directly for receiving network data._It should always return an available buffer in credit-based mode unless_the channel has been released.__@return The available buffer.;@Nullable_	public Buffer requestBuffer() {_		synchronized (bufferQueue) {_			return bufferQueue.takeBuffer()__		}_	};requests,buffer,from,input,channel,directly,for,receiving,network,data,it,should,always,return,an,available,buffer,in,credit,based,mode,unless,the,channel,has,been,released,return,the,available,buffer;nullable,public,buffer,request,buffer,synchronized,buffer,queue,return,buffer,queue,take,buffer
RemoteInputChannel -> @Nullable 	public Buffer requestBuffer();1543328832;Requests buffer from input channel directly for receiving network data._It should always return an available buffer in credit-based mode unless_the channel has been released.__@return The available buffer.;@Nullable_	public Buffer requestBuffer() {_		synchronized (bufferQueue) {_			return bufferQueue.takeBuffer()__		}_	};requests,buffer,from,input,channel,directly,for,receiving,network,data,it,should,always,return,an,available,buffer,in,credit,based,mode,unless,the,channel,has,been,released,return,the,available,buffer;nullable,public,buffer,request,buffer,synchronized,buffer,queue,return,buffer,queue,take,buffer
RemoteInputChannel -> @VisibleForTesting 	@Override 	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1502969925;Requests a remote subpartition.;@VisibleForTesting_	@Override_	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;visible,for,testing,override,public,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @VisibleForTesting 	@Override 	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1506613166;Requests a remote subpartition.;@VisibleForTesting_	@Override_	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;visible,for,testing,override,public,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @VisibleForTesting 	@Override 	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1506753379;Requests a remote subpartition.;@VisibleForTesting_	@Override_	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;visible,for,testing,override,public,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @VisibleForTesting 	@Override 	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1515514130;Requests a remote subpartition.;@VisibleForTesting_	@Override_	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;visible,for,testing,override,public,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @VisibleForTesting 	@Override 	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1515534998;Requests a remote subpartition.;@VisibleForTesting_	@Override_	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;visible,for,testing,override,public,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @VisibleForTesting 	@Override 	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1516801403;Requests a remote subpartition.;@VisibleForTesting_	@Override_	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;visible,for,testing,override,public,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @VisibleForTesting 	@Override 	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1519310498;Requests a remote subpartition.;@VisibleForTesting_	@Override_	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;visible,for,testing,override,public,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @VisibleForTesting 	@Override 	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1519350957;Requests a remote subpartition.;@VisibleForTesting_	@Override_	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;visible,for,testing,override,public,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @VisibleForTesting 	@Override 	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1530744513;Requests a remote subpartition.;@VisibleForTesting_	@Override_	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;visible,for,testing,override,public,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @VisibleForTesting 	@Override 	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1533422492;Requests a remote subpartition.;@VisibleForTesting_	@Override_	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;visible,for,testing,override,public,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @VisibleForTesting 	@Override 	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1534276258;Requests a remote subpartition.;@VisibleForTesting_	@Override_	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;visible,for,testing,override,public,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @VisibleForTesting 	@Override 	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1534864589;Requests a remote subpartition.;@VisibleForTesting_	@Override_	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;visible,for,testing,override,public,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @VisibleForTesting 	@Override 	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1534865689;Requests a remote subpartition.;@VisibleForTesting_	@Override_	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;visible,for,testing,override,public,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @VisibleForTesting 	@Override 	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1543328832;Requests a remote subpartition.;@VisibleForTesting_	@Override_	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;visible,for,testing,override,public,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> public int getNumberOfQueuedBuffers();1502969925;Gets the current number of received buffers which have not been processed yet.__@return Buffers queued for processing.;public int getNumberOfQueuedBuffers() {_		synchronized (receivedBuffers) {_			return receivedBuffers.size()__		}_	};gets,the,current,number,of,received,buffers,which,have,not,been,processed,yet,return,buffers,queued,for,processing;public,int,get,number,of,queued,buffers,synchronized,received,buffers,return,received,buffers,size
RemoteInputChannel -> public int getNumberOfQueuedBuffers();1506613166;Gets the current number of received buffers which have not been processed yet.__@return Buffers queued for processing.;public int getNumberOfQueuedBuffers() {_		synchronized (receivedBuffers) {_			return receivedBuffers.size()__		}_	};gets,the,current,number,of,received,buffers,which,have,not,been,processed,yet,return,buffers,queued,for,processing;public,int,get,number,of,queued,buffers,synchronized,received,buffers,return,received,buffers,size
RemoteInputChannel -> public int getNumberOfQueuedBuffers();1506753379;Gets the current number of received buffers which have not been processed yet.__@return Buffers queued for processing.;public int getNumberOfQueuedBuffers() {_		synchronized (receivedBuffers) {_			return receivedBuffers.size()__		}_	};gets,the,current,number,of,received,buffers,which,have,not,been,processed,yet,return,buffers,queued,for,processing;public,int,get,number,of,queued,buffers,synchronized,received,buffers,return,received,buffers,size
RemoteInputChannel -> public int getNumberOfQueuedBuffers();1515514130;Gets the current number of received buffers which have not been processed yet.__@return Buffers queued for processing.;public int getNumberOfQueuedBuffers() {_		synchronized (receivedBuffers) {_			return receivedBuffers.size()__		}_	};gets,the,current,number,of,received,buffers,which,have,not,been,processed,yet,return,buffers,queued,for,processing;public,int,get,number,of,queued,buffers,synchronized,received,buffers,return,received,buffers,size
RemoteInputChannel -> public int getNumberOfQueuedBuffers();1515534998;Gets the current number of received buffers which have not been processed yet.__@return Buffers queued for processing.;public int getNumberOfQueuedBuffers() {_		synchronized (receivedBuffers) {_			return receivedBuffers.size()__		}_	};gets,the,current,number,of,received,buffers,which,have,not,been,processed,yet,return,buffers,queued,for,processing;public,int,get,number,of,queued,buffers,synchronized,received,buffers,return,received,buffers,size
RemoteInputChannel -> public int getNumberOfQueuedBuffers();1516801403;Gets the current number of received buffers which have not been processed yet.__@return Buffers queued for processing.;public int getNumberOfQueuedBuffers() {_		synchronized (receivedBuffers) {_			return receivedBuffers.size()__		}_	};gets,the,current,number,of,received,buffers,which,have,not,been,processed,yet,return,buffers,queued,for,processing;public,int,get,number,of,queued,buffers,synchronized,received,buffers,return,received,buffers,size
RemoteInputChannel -> public int getNumberOfQueuedBuffers();1519310498;Gets the current number of received buffers which have not been processed yet.__@return Buffers queued for processing.;public int getNumberOfQueuedBuffers() {_		synchronized (receivedBuffers) {_			return receivedBuffers.size()__		}_	};gets,the,current,number,of,received,buffers,which,have,not,been,processed,yet,return,buffers,queued,for,processing;public,int,get,number,of,queued,buffers,synchronized,received,buffers,return,received,buffers,size
RemoteInputChannel -> public int getNumberOfQueuedBuffers();1519350957;Gets the current number of received buffers which have not been processed yet.__@return Buffers queued for processing.;public int getNumberOfQueuedBuffers() {_		synchronized (receivedBuffers) {_			return receivedBuffers.size()__		}_	};gets,the,current,number,of,received,buffers,which,have,not,been,processed,yet,return,buffers,queued,for,processing;public,int,get,number,of,queued,buffers,synchronized,received,buffers,return,received,buffers,size
RemoteInputChannel -> public int getNumberOfQueuedBuffers();1530744513;Gets the current number of received buffers which have not been processed yet.__@return Buffers queued for processing.;public int getNumberOfQueuedBuffers() {_		synchronized (receivedBuffers) {_			return receivedBuffers.size()__		}_	};gets,the,current,number,of,received,buffers,which,have,not,been,processed,yet,return,buffers,queued,for,processing;public,int,get,number,of,queued,buffers,synchronized,received,buffers,return,received,buffers,size
RemoteInputChannel -> public int getNumberOfQueuedBuffers();1533422492;Gets the current number of received buffers which have not been processed yet.__@return Buffers queued for processing.;public int getNumberOfQueuedBuffers() {_		synchronized (receivedBuffers) {_			return receivedBuffers.size()__		}_	};gets,the,current,number,of,received,buffers,which,have,not,been,processed,yet,return,buffers,queued,for,processing;public,int,get,number,of,queued,buffers,synchronized,received,buffers,return,received,buffers,size
RemoteInputChannel -> public int getNumberOfQueuedBuffers();1534276258;Gets the current number of received buffers which have not been processed yet.__@return Buffers queued for processing.;public int getNumberOfQueuedBuffers() {_		synchronized (receivedBuffers) {_			return receivedBuffers.size()__		}_	};gets,the,current,number,of,received,buffers,which,have,not,been,processed,yet,return,buffers,queued,for,processing;public,int,get,number,of,queued,buffers,synchronized,received,buffers,return,received,buffers,size
RemoteInputChannel -> public int getNumberOfQueuedBuffers();1534864589;Gets the current number of received buffers which have not been processed yet.__@return Buffers queued for processing.;public int getNumberOfQueuedBuffers() {_		synchronized (receivedBuffers) {_			return receivedBuffers.size()__		}_	};gets,the,current,number,of,received,buffers,which,have,not,been,processed,yet,return,buffers,queued,for,processing;public,int,get,number,of,queued,buffers,synchronized,received,buffers,return,received,buffers,size
RemoteInputChannel -> public int getNumberOfQueuedBuffers();1534865689;Gets the current number of received buffers which have not been processed yet.__@return Buffers queued for processing.;public int getNumberOfQueuedBuffers() {_		synchronized (receivedBuffers) {_			return receivedBuffers.size()__		}_	};gets,the,current,number,of,received,buffers,which,have,not,been,processed,yet,return,buffers,queued,for,processing;public,int,get,number,of,queued,buffers,synchronized,received,buffers,return,received,buffers,size
RemoteInputChannel -> public int getNumberOfQueuedBuffers();1543328832;Gets the current number of received buffers which have not been processed yet.__@return Buffers queued for processing.;public int getNumberOfQueuedBuffers() {_		synchronized (receivedBuffers) {_			return receivedBuffers.size()__		}_	};gets,the,current,number,of,received,buffers,which,have,not,been,processed,yet,return,buffers,queued,for,processing;public,int,get,number,of,queued,buffers,synchronized,received,buffers,return,received,buffers,size
RemoteInputChannel -> @Override 	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1431354895;Requests a remote subpartition.;@Override_	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_					.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;override,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @Override 	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1432647455;Requests a remote subpartition.;@Override_	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_					.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;override,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @Override 	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1432806352;Requests a remote subpartition.;@Override_	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_					.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;override,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @Override 	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1438275734;Requests a remote subpartition.;@Override_	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_					.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;override,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @Override 	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1464773080;Requests a remote subpartition.;@Override_	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_					.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;override,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @Override 	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1465394479;Requests a remote subpartition.;@Override_	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_					.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;override,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @Override 	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1469183596;Requests a remote subpartition.;@Override_	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_					.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;override,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @Override 	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1472628826;Requests a remote subpartition.;@Override_	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_					.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;override,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @Override 	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1475838130;Requests a remote subpartition.;@Override_	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_					.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;override,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @Override 	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1479407816;Requests a remote subpartition.;@Override_	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;override,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @Override 	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1480323569;Requests a remote subpartition.;@Override_	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;override,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @Override 	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1502098277;Requests a remote subpartition.;@Override_	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;override,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @Override 	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1502282631;Requests a remote subpartition.;@Override_	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;override,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @Override 	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1502342953;Requests a remote subpartition.;@Override_	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;override,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @Override 	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1502692247;Requests a remote subpartition.;@Override_	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;override,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @Override 	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1505982496;Requests a remote subpartition.;@Override_	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;override,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @Override 	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1506507855;Requests a remote subpartition.;@Override_	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;override,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1502282631;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()___		synchronized(availableBuffers) {_			for (MemorySegment segment : segments) {_				availableBuffers.add(new Buffer(segment, this))__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,synchronized,available,buffers,for,memory,segment,segment,segments,available,buffers,add,new,buffer,segment,this
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1502342953;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()__		this.numRequiredBuffers = segments.size()___		synchronized(bufferQueue) {_			for (MemorySegment segment : segments) {_				bufferQueue.addExclusiveBuffer(new Buffer(segment, this), numRequiredBuffers)__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,this,num,required,buffers,segments,size,synchronized,buffer,queue,for,memory,segment,segment,segments,buffer,queue,add,exclusive,buffer,new,buffer,segment,this,num,required,buffers
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1502692247;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()___		synchronized(availableBuffers) {_			for (MemorySegment segment : segments) {_				availableBuffers.add(new Buffer(segment, this))__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,synchronized,available,buffers,for,memory,segment,segment,segments,available,buffers,add,new,buffer,segment,this
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1502969925;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()__		this.numRequiredBuffers = segments.size()___		synchronized(bufferQueue) {_			for (MemorySegment segment : segments) {_				bufferQueue.addExclusiveBuffer(new Buffer(segment, this), numRequiredBuffers)__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,this,num,required,buffers,segments,size,synchronized,buffer,queue,for,memory,segment,segment,segments,buffer,queue,add,exclusive,buffer,new,buffer,segment,this,num,required,buffers
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1505982496;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()___		synchronized(availableBuffers) {_			for (MemorySegment segment : segments) {_				availableBuffers.add(new Buffer(segment, this))__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,synchronized,available,buffers,for,memory,segment,segment,segments,available,buffers,add,new,buffer,segment,this
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1506507855;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()___		synchronized(availableBuffers) {_			for (MemorySegment segment : segments) {_				availableBuffers.add(new Buffer(segment, this))__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,synchronized,available,buffers,for,memory,segment,segment,segments,available,buffers,add,new,buffer,segment,this
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1506613166;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()__		this.numRequiredBuffers = segments.size()___		synchronized(bufferQueue) {_			for (MemorySegment segment : segments) {_				bufferQueue.addExclusiveBuffer(new Buffer(segment, this), numRequiredBuffers)__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,this,num,required,buffers,segments,size,synchronized,buffer,queue,for,memory,segment,segment,segments,buffer,queue,add,exclusive,buffer,new,buffer,segment,this,num,required,buffers
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1506753379;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()__		this.numRequiredBuffers = segments.size()___		synchronized (bufferQueue) {_			for (MemorySegment segment : segments) {_				bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,this,num,required,buffers,segments,size,synchronized,buffer,queue,for,memory,segment,segment,segments,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1515514130;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()__		this.numRequiredBuffers = segments.size()___		synchronized (bufferQueue) {_			for (MemorySegment segment : segments) {_				bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,this,num,required,buffers,segments,size,synchronized,buffer,queue,for,memory,segment,segment,segments,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1515534998;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()__		this.numRequiredBuffers = segments.size()___		synchronized (bufferQueue) {_			for (MemorySegment segment : segments) {_				bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,this,num,required,buffers,segments,size,synchronized,buffer,queue,for,memory,segment,segment,segments,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1516801403;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()__		this.numRequiredBuffers = segments.size()___		synchronized (bufferQueue) {_			for (MemorySegment segment : segments) {_				bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,this,num,required,buffers,segments,size,synchronized,buffer,queue,for,memory,segment,segment,segments,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1519310498;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()__		this.numRequiredBuffers = segments.size()___		synchronized (bufferQueue) {_			for (MemorySegment segment : segments) {_				bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,this,num,required,buffers,segments,size,synchronized,buffer,queue,for,memory,segment,segment,segments,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1519350957;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()__		this.numRequiredBuffers = segments.size()___		synchronized (bufferQueue) {_			for (MemorySegment segment : segments) {_				bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,this,num,required,buffers,segments,size,synchronized,buffer,queue,for,memory,segment,segment,segments,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1530744513;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()__		this.numRequiredBuffers = segments.size()___		synchronized (bufferQueue) {_			for (MemorySegment segment : segments) {_				bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,this,num,required,buffers,segments,size,synchronized,buffer,queue,for,memory,segment,segment,segments,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1533422492;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()__		this.numRequiredBuffers = segments.size()___		synchronized (bufferQueue) {_			for (MemorySegment segment : segments) {_				bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,this,num,required,buffers,segments,size,synchronized,buffer,queue,for,memory,segment,segment,segments,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1534276258;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()__		this.numRequiredBuffers = segments.size()___		synchronized (bufferQueue) {_			for (MemorySegment segment : segments) {_				bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,this,num,required,buffers,segments,size,synchronized,buffer,queue,for,memory,segment,segment,segments,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1534864589;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()__		this.numRequiredBuffers = segments.size()___		synchronized (bufferQueue) {_			for (MemorySegment segment : segments) {_				bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,this,num,required,buffers,segments,size,synchronized,buffer,queue,for,memory,segment,segment,segments,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1534865689;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()__		this.numRequiredBuffers = segments.size()___		synchronized (bufferQueue) {_			for (MemorySegment segment : segments) {_				bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,this,num,required,buffers,segments,size,synchronized,buffer,queue,for,memory,segment,segment,segments,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1543328832;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()__		this.numRequiredBuffers = segments.size()___		synchronized (bufferQueue) {_			for (MemorySegment segment : segments) {_				bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,this,num,required,buffers,segments,size,synchronized,buffer,queue,for,memory,segment,segment,segments,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers
RemoteInputChannel -> void notifyCreditAvailable();1502282631;Enqueue this input channel in the pipeline for sending unannounced credits to producer.;void notifyCreditAvailable() {_		_	};enqueue,this,input,channel,in,the,pipeline,for,sending,unannounced,credits,to,producer;void,notify,credit,available
RemoteInputChannel -> void notifyCreditAvailable();1502342953;Enqueue this input channel in the pipeline for sending unannounced credits to producer.;void notifyCreditAvailable() {_		_	};enqueue,this,input,channel,in,the,pipeline,for,sending,unannounced,credits,to,producer;void,notify,credit,available
RemoteInputChannel -> void notifyCreditAvailable();1502692247;Enqueue this input channel in the pipeline for sending unannounced credits to producer.;void notifyCreditAvailable() {_		_	};enqueue,this,input,channel,in,the,pipeline,for,sending,unannounced,credits,to,producer;void,notify,credit,available
RemoteInputChannel -> void notifyCreditAvailable();1502969925;Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.;void notifyCreditAvailable() {_		checkState(partitionRequestClient != null, "Tried to send task event to producer before requesting a queue.")___		_		if (!isReleased.get()) {_			partitionRequestClient.notifyCreditAvailable(this)__		}_	};enqueue,this,input,channel,in,the,pipeline,for,notifying,the,producer,of,unannounced,credit;void,notify,credit,available,check,state,partition,request,client,null,tried,to,send,task,event,to,producer,before,requesting,a,queue,if,is,released,get,partition,request,client,notify,credit,available,this
RemoteInputChannel -> void notifyCreditAvailable();1505982496;Enqueue this input channel in the pipeline for sending unannounced credits to producer.;void notifyCreditAvailable() {_		_	};enqueue,this,input,channel,in,the,pipeline,for,sending,unannounced,credits,to,producer;void,notify,credit,available
RemoteInputChannel -> void notifyCreditAvailable();1506507855;Enqueue this input channel in the pipeline for sending unannounced credits to producer.;void notifyCreditAvailable() {_		_	};enqueue,this,input,channel,in,the,pipeline,for,sending,unannounced,credits,to,producer;void,notify,credit,available
RemoteInputChannel -> void notifyCreditAvailable();1506613166;Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.;void notifyCreditAvailable() {_		checkState(partitionRequestClient != null, "Tried to send task event to producer before requesting a queue.")___		_		if (!isReleased.get()) {_			partitionRequestClient.notifyCreditAvailable(this)__		}_	};enqueue,this,input,channel,in,the,pipeline,for,notifying,the,producer,of,unannounced,credit;void,notify,credit,available,check,state,partition,request,client,null,tried,to,send,task,event,to,producer,before,requesting,a,queue,if,is,released,get,partition,request,client,notify,credit,available,this
RemoteInputChannel -> void notifyCreditAvailable();1515514130;Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.;void notifyCreditAvailable() {_		checkState(partitionRequestClient != null, "Tried to send task event to producer before requesting a queue.")___		_		if (!isReleased.get()) {_			partitionRequestClient.notifyCreditAvailable(this)__		}_	};enqueue,this,input,channel,in,the,pipeline,for,notifying,the,producer,of,unannounced,credit;void,notify,credit,available,check,state,partition,request,client,null,tried,to,send,task,event,to,producer,before,requesting,a,queue,if,is,released,get,partition,request,client,notify,credit,available,this
RemoteInputChannel -> void notifyCreditAvailable();1515534998;Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.;void notifyCreditAvailable() {_		checkState(partitionRequestClient != null, "Tried to send task event to producer before requesting a queue.")___		_		if (!isReleased.get()) {_			partitionRequestClient.notifyCreditAvailable(this)__		}_	};enqueue,this,input,channel,in,the,pipeline,for,notifying,the,producer,of,unannounced,credit;void,notify,credit,available,check,state,partition,request,client,null,tried,to,send,task,event,to,producer,before,requesting,a,queue,if,is,released,get,partition,request,client,notify,credit,available,this
RemoteInputChannel -> @Override 	public boolean notifyBufferAvailable(Buffer buffer);1502282631;The Buffer pool notifies this channel of an available floating buffer. If the channel is released or_currently does not need extra buffers, the buffer should be recycled to the buffer pool. Otherwise,_the buffer will be added into the <tt>availableBuffers</tt> queue and the unannounced credit is_increased by one.__@param buffer Buffer that becomes available in buffer pool._@return True when this channel is waiting for more floating buffers, otherwise false.;@Override_	public boolean notifyBufferAvailable(Buffer buffer) {_		checkState(isWaitingForFloatingBuffers.get(), "This channel should be waiting for floating buffers.")___		synchronized (availableBuffers) {_			_			if (isReleased.get() || availableBuffers.size() >= senderBacklog.get()) {_				isWaitingForFloatingBuffers.set(false)__				buffer.recycle()___				return false__			}__			availableBuffers.add(buffer)___			if (unannouncedCredit.getAndAdd(1) == 0) {_				notifyCreditAvailable()__			}__			if (availableBuffers.size() >= senderBacklog.get()) {_				isWaitingForFloatingBuffers.set(false)__				return false__			} else {_				return true__			}_		}_	};the,buffer,pool,notifies,this,channel,of,an,available,floating,buffer,if,the,channel,is,released,or,currently,does,not,need,extra,buffers,the,buffer,should,be,recycled,to,the,buffer,pool,otherwise,the,buffer,will,be,added,into,the,tt,available,buffers,tt,queue,and,the,unannounced,credit,is,increased,by,one,param,buffer,buffer,that,becomes,available,in,buffer,pool,return,true,when,this,channel,is,waiting,for,more,floating,buffers,otherwise,false;override,public,boolean,notify,buffer,available,buffer,buffer,check,state,is,waiting,for,floating,buffers,get,this,channel,should,be,waiting,for,floating,buffers,synchronized,available,buffers,if,is,released,get,available,buffers,size,sender,backlog,get,is,waiting,for,floating,buffers,set,false,buffer,recycle,return,false,available,buffers,add,buffer,if,unannounced,credit,get,and,add,1,0,notify,credit,available,if,available,buffers,size,sender,backlog,get,is,waiting,for,floating,buffers,set,false,return,false,else,return,true
RemoteInputChannel -> @Override 	public boolean notifyBufferAvailable(Buffer buffer);1502342953;The Buffer pool notifies this channel of an available floating buffer. If the channel is released or_currently does not need extra buffers, the buffer should be recycled to the buffer pool. Otherwise,_the buffer will be added into the <tt>bufferQueue</tt> and the unannounced credit is increased_by one.__@param buffer Buffer that becomes available in buffer pool._@return True when this channel is waiting for more floating buffers, otherwise false.;@Override_	public boolean notifyBufferAvailable(Buffer buffer) {_		_		_		if (isReleased.get()) {_			buffer.recycle()__			return false__		}__		boolean needMoreBuffers = false__		synchronized (bufferQueue) {_			checkState(isWaitingForFloatingBuffers, "This channel should be waiting for floating buffers.")___			_			_			if (isReleased.get() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {_				buffer.recycle()__				return false__			}__			bufferQueue.addFloatingBuffer(buffer)___			if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {_				isWaitingForFloatingBuffers = false__			} else {_				needMoreBuffers =  true__			}_		}__		if (unannouncedCredit.getAndAdd(1) == 0) {_			notifyCreditAvailable()__		}__		return needMoreBuffers__	};the,buffer,pool,notifies,this,channel,of,an,available,floating,buffer,if,the,channel,is,released,or,currently,does,not,need,extra,buffers,the,buffer,should,be,recycled,to,the,buffer,pool,otherwise,the,buffer,will,be,added,into,the,tt,buffer,queue,tt,and,the,unannounced,credit,is,increased,by,one,param,buffer,buffer,that,becomes,available,in,buffer,pool,return,true,when,this,channel,is,waiting,for,more,floating,buffers,otherwise,false;override,public,boolean,notify,buffer,available,buffer,buffer,if,is,released,get,buffer,recycle,return,false,boolean,need,more,buffers,false,synchronized,buffer,queue,check,state,is,waiting,for,floating,buffers,this,channel,should,be,waiting,for,floating,buffers,if,is,released,get,buffer,queue,get,available,buffer,size,num,required,buffers,buffer,recycle,return,false,buffer,queue,add,floating,buffer,buffer,if,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,else,need,more,buffers,true,if,unannounced,credit,get,and,add,1,0,notify,credit,available,return,need,more,buffers
RemoteInputChannel -> @Override 	public boolean notifyBufferAvailable(Buffer buffer);1502969925;The Buffer pool notifies this channel of an available floating buffer. If the channel is released or_currently does not need extra buffers, the buffer should be recycled to the buffer pool. Otherwise,_the buffer will be added into the <tt>bufferQueue</tt> and the unannounced credit is increased_by one.__@param buffer Buffer that becomes available in buffer pool._@return True when this channel is waiting for more floating buffers, otherwise false.;@Override_	public boolean notifyBufferAvailable(Buffer buffer) {_		_		_		if (isReleased.get()) {_			buffer.recycle()__			return false__		}__		boolean needMoreBuffers = false__		synchronized (bufferQueue) {_			checkState(isWaitingForFloatingBuffers, "This channel should be waiting for floating buffers.")___			_			_			if (isReleased.get() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {_				buffer.recycle()__				return false__			}__			bufferQueue.addFloatingBuffer(buffer)___			if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {_				isWaitingForFloatingBuffers = false__			} else {_				needMoreBuffers =  true__			}_		}__		if (unannouncedCredit.getAndAdd(1) == 0) {_			notifyCreditAvailable()__		}__		return needMoreBuffers__	};the,buffer,pool,notifies,this,channel,of,an,available,floating,buffer,if,the,channel,is,released,or,currently,does,not,need,extra,buffers,the,buffer,should,be,recycled,to,the,buffer,pool,otherwise,the,buffer,will,be,added,into,the,tt,buffer,queue,tt,and,the,unannounced,credit,is,increased,by,one,param,buffer,buffer,that,becomes,available,in,buffer,pool,return,true,when,this,channel,is,waiting,for,more,floating,buffers,otherwise,false;override,public,boolean,notify,buffer,available,buffer,buffer,if,is,released,get,buffer,recycle,return,false,boolean,need,more,buffers,false,synchronized,buffer,queue,check,state,is,waiting,for,floating,buffers,this,channel,should,be,waiting,for,floating,buffers,if,is,released,get,buffer,queue,get,available,buffer,size,num,required,buffers,buffer,recycle,return,false,buffer,queue,add,floating,buffer,buffer,if,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,else,need,more,buffers,true,if,unannounced,credit,get,and,add,1,0,notify,credit,available,return,need,more,buffers
RemoteInputChannel -> @Override 	public boolean notifyBufferAvailable(Buffer buffer);1505982496;The Buffer pool notifies this channel of an available floating buffer. If the channel is released or_currently does not need extra buffers, the buffer should be recycled to the buffer pool. Otherwise,_the buffer will be added into the <tt>availableBuffers</tt> queue and the unannounced credit is_increased by one.__@param buffer Buffer that becomes available in buffer pool._@return True when this channel is waiting for more floating buffers, otherwise false.;@Override_	public boolean notifyBufferAvailable(Buffer buffer) {_		checkState(isWaitingForFloatingBuffers.get(), "This channel should be waiting for floating buffers.")___		synchronized (availableBuffers) {_			_			if (isReleased.get() || availableBuffers.size() >= senderBacklog.get()) {_				isWaitingForFloatingBuffers.set(false)__				buffer.recycle()___				return false__			}__			availableBuffers.add(buffer)___			if (unannouncedCredit.getAndAdd(1) == 0) {_				notifyCreditAvailable()__			}__			if (availableBuffers.size() >= senderBacklog.get()) {_				isWaitingForFloatingBuffers.set(false)__				return false__			} else {_				return true__			}_		}_	};the,buffer,pool,notifies,this,channel,of,an,available,floating,buffer,if,the,channel,is,released,or,currently,does,not,need,extra,buffers,the,buffer,should,be,recycled,to,the,buffer,pool,otherwise,the,buffer,will,be,added,into,the,tt,available,buffers,tt,queue,and,the,unannounced,credit,is,increased,by,one,param,buffer,buffer,that,becomes,available,in,buffer,pool,return,true,when,this,channel,is,waiting,for,more,floating,buffers,otherwise,false;override,public,boolean,notify,buffer,available,buffer,buffer,check,state,is,waiting,for,floating,buffers,get,this,channel,should,be,waiting,for,floating,buffers,synchronized,available,buffers,if,is,released,get,available,buffers,size,sender,backlog,get,is,waiting,for,floating,buffers,set,false,buffer,recycle,return,false,available,buffers,add,buffer,if,unannounced,credit,get,and,add,1,0,notify,credit,available,if,available,buffers,size,sender,backlog,get,is,waiting,for,floating,buffers,set,false,return,false,else,return,true
RemoteInputChannel -> @Override 	public boolean notifyBufferAvailable(Buffer buffer);1506507855;The Buffer pool notifies this channel of an available floating buffer. If the channel is released or_currently does not need extra buffers, the buffer should be recycled to the buffer pool. Otherwise,_the buffer will be added into the <tt>availableBuffers</tt> queue and the unannounced credit is_increased by one.__@param buffer Buffer that becomes available in buffer pool._@return True when this channel is waiting for more floating buffers, otherwise false.;@Override_	public boolean notifyBufferAvailable(Buffer buffer) {_		checkState(isWaitingForFloatingBuffers.get(), "This channel should be waiting for floating buffers.")___		synchronized (availableBuffers) {_			_			if (isReleased.get() || availableBuffers.size() >= senderBacklog.get()) {_				isWaitingForFloatingBuffers.set(false)__				buffer.recycle()___				return false__			}__			availableBuffers.add(buffer)___			if (unannouncedCredit.getAndAdd(1) == 0) {_				notifyCreditAvailable()__			}__			if (availableBuffers.size() >= senderBacklog.get()) {_				isWaitingForFloatingBuffers.set(false)__				return false__			} else {_				return true__			}_		}_	};the,buffer,pool,notifies,this,channel,of,an,available,floating,buffer,if,the,channel,is,released,or,currently,does,not,need,extra,buffers,the,buffer,should,be,recycled,to,the,buffer,pool,otherwise,the,buffer,will,be,added,into,the,tt,available,buffers,tt,queue,and,the,unannounced,credit,is,increased,by,one,param,buffer,buffer,that,becomes,available,in,buffer,pool,return,true,when,this,channel,is,waiting,for,more,floating,buffers,otherwise,false;override,public,boolean,notify,buffer,available,buffer,buffer,check,state,is,waiting,for,floating,buffers,get,this,channel,should,be,waiting,for,floating,buffers,synchronized,available,buffers,if,is,released,get,available,buffers,size,sender,backlog,get,is,waiting,for,floating,buffers,set,false,buffer,recycle,return,false,available,buffers,add,buffer,if,unannounced,credit,get,and,add,1,0,notify,credit,available,if,available,buffers,size,sender,backlog,get,is,waiting,for,floating,buffers,set,false,return,false,else,return,true
RemoteInputChannel -> @Override 	public boolean notifyBufferAvailable(Buffer buffer);1506613166;The Buffer pool notifies this channel of an available floating buffer. If the channel is released or_currently does not need extra buffers, the buffer should be recycled to the buffer pool. Otherwise,_the buffer will be added into the <tt>bufferQueue</tt> and the unannounced credit is increased_by one.__@param buffer Buffer that becomes available in buffer pool._@return True when this channel is waiting for more floating buffers, otherwise false.;@Override_	public boolean notifyBufferAvailable(Buffer buffer) {_		_		_		if (isReleased.get()) {_			buffer.recycle()__			return false__		}__		boolean needMoreBuffers = false__		synchronized (bufferQueue) {_			checkState(isWaitingForFloatingBuffers, "This channel should be waiting for floating buffers.")___			_			_			if (isReleased.get() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {_				buffer.recycle()__				return false__			}__			bufferQueue.addFloatingBuffer(buffer)___			if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {_				isWaitingForFloatingBuffers = false__			} else {_				needMoreBuffers =  true__			}_		}__		if (unannouncedCredit.getAndAdd(1) == 0) {_			notifyCreditAvailable()__		}__		return needMoreBuffers__	};the,buffer,pool,notifies,this,channel,of,an,available,floating,buffer,if,the,channel,is,released,or,currently,does,not,need,extra,buffers,the,buffer,should,be,recycled,to,the,buffer,pool,otherwise,the,buffer,will,be,added,into,the,tt,buffer,queue,tt,and,the,unannounced,credit,is,increased,by,one,param,buffer,buffer,that,becomes,available,in,buffer,pool,return,true,when,this,channel,is,waiting,for,more,floating,buffers,otherwise,false;override,public,boolean,notify,buffer,available,buffer,buffer,if,is,released,get,buffer,recycle,return,false,boolean,need,more,buffers,false,synchronized,buffer,queue,check,state,is,waiting,for,floating,buffers,this,channel,should,be,waiting,for,floating,buffers,if,is,released,get,buffer,queue,get,available,buffer,size,num,required,buffers,buffer,recycle,return,false,buffer,queue,add,floating,buffer,buffer,if,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,else,need,more,buffers,true,if,unannounced,credit,get,and,add,1,0,notify,credit,available,return,need,more,buffers
RemoteInputChannel -> @Override 	public boolean notifyBufferAvailable(Buffer buffer);1506753379;The Buffer pool notifies this channel of an available floating buffer. If the channel is released or_currently does not need extra buffers, the buffer should be recycled to the buffer pool. Otherwise,_the buffer will be added into the <tt>bufferQueue</tt> and the unannounced credit is increased_by one.__@param buffer Buffer that becomes available in buffer pool._@return True when this channel is waiting for more floating buffers, otherwise false.;@Override_	public boolean notifyBufferAvailable(Buffer buffer) {_		_		_		if (isReleased.get()) {_			buffer.recycleBuffer()__			return false__		}__		boolean needMoreBuffers = false__		synchronized (bufferQueue) {_			checkState(isWaitingForFloatingBuffers, "This channel should be waiting for floating buffers.")___			_			_			if (isReleased.get() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {_				buffer.recycleBuffer()__				return false__			}__			bufferQueue.addFloatingBuffer(buffer)___			if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {_				isWaitingForFloatingBuffers = false__			} else {_				needMoreBuffers =  true__			}_		}__		if (unannouncedCredit.getAndAdd(1) == 0) {_			notifyCreditAvailable()__		}__		return needMoreBuffers__	};the,buffer,pool,notifies,this,channel,of,an,available,floating,buffer,if,the,channel,is,released,or,currently,does,not,need,extra,buffers,the,buffer,should,be,recycled,to,the,buffer,pool,otherwise,the,buffer,will,be,added,into,the,tt,buffer,queue,tt,and,the,unannounced,credit,is,increased,by,one,param,buffer,buffer,that,becomes,available,in,buffer,pool,return,true,when,this,channel,is,waiting,for,more,floating,buffers,otherwise,false;override,public,boolean,notify,buffer,available,buffer,buffer,if,is,released,get,buffer,recycle,buffer,return,false,boolean,need,more,buffers,false,synchronized,buffer,queue,check,state,is,waiting,for,floating,buffers,this,channel,should,be,waiting,for,floating,buffers,if,is,released,get,buffer,queue,get,available,buffer,size,num,required,buffers,buffer,recycle,buffer,return,false,buffer,queue,add,floating,buffer,buffer,if,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,else,need,more,buffers,true,if,unannounced,credit,get,and,add,1,0,notify,credit,available,return,need,more,buffers
RemoteInputChannel -> @Override 	public boolean notifyBufferAvailable(Buffer buffer);1515514130;The Buffer pool notifies this channel of an available floating buffer. If the channel is released or_currently does not need extra buffers, the buffer should be recycled to the buffer pool. Otherwise,_the buffer will be added into the <tt>bufferQueue</tt> and the unannounced credit is increased_by one.__@param buffer Buffer that becomes available in buffer pool._@return True when this channel is waiting for more floating buffers, otherwise false.;@Override_	public boolean notifyBufferAvailable(Buffer buffer) {_		_		_		if (isReleased.get()) {_			buffer.recycle()__			return false__		}__		boolean needMoreBuffers = false__		synchronized (bufferQueue) {_			checkState(isWaitingForFloatingBuffers, "This channel should be waiting for floating buffers.")___			_			_			if (isReleased.get() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {_				buffer.recycle()__				return false__			}__			bufferQueue.addFloatingBuffer(buffer)___			if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {_				isWaitingForFloatingBuffers = false__			} else {_				needMoreBuffers =  true__			}_		}__		if (unannouncedCredit.getAndAdd(1) == 0) {_			notifyCreditAvailable()__		}__		return needMoreBuffers__	};the,buffer,pool,notifies,this,channel,of,an,available,floating,buffer,if,the,channel,is,released,or,currently,does,not,need,extra,buffers,the,buffer,should,be,recycled,to,the,buffer,pool,otherwise,the,buffer,will,be,added,into,the,tt,buffer,queue,tt,and,the,unannounced,credit,is,increased,by,one,param,buffer,buffer,that,becomes,available,in,buffer,pool,return,true,when,this,channel,is,waiting,for,more,floating,buffers,otherwise,false;override,public,boolean,notify,buffer,available,buffer,buffer,if,is,released,get,buffer,recycle,return,false,boolean,need,more,buffers,false,synchronized,buffer,queue,check,state,is,waiting,for,floating,buffers,this,channel,should,be,waiting,for,floating,buffers,if,is,released,get,buffer,queue,get,available,buffer,size,num,required,buffers,buffer,recycle,return,false,buffer,queue,add,floating,buffer,buffer,if,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,else,need,more,buffers,true,if,unannounced,credit,get,and,add,1,0,notify,credit,available,return,need,more,buffers
RemoteInputChannel -> @Override 	public boolean notifyBufferAvailable(Buffer buffer);1515534998;The Buffer pool notifies this channel of an available floating buffer. If the channel is released or_currently does not need extra buffers, the buffer should be recycled to the buffer pool. Otherwise,_the buffer will be added into the <tt>bufferQueue</tt> and the unannounced credit is increased_by one.__@param buffer Buffer that becomes available in buffer pool._@return True when this channel is waiting for more floating buffers, otherwise false.;@Override_	public boolean notifyBufferAvailable(Buffer buffer) {_		_		_		if (isReleased.get()) {_			buffer.recycleBuffer()__			return false__		}__		boolean needMoreBuffers = false__		synchronized (bufferQueue) {_			checkState(isWaitingForFloatingBuffers, "This channel should be waiting for floating buffers.")___			_			_			if (isReleased.get() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {_				buffer.recycleBuffer()__				return false__			}__			bufferQueue.addFloatingBuffer(buffer)___			if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {_				isWaitingForFloatingBuffers = false__			} else {_				needMoreBuffers =  true__			}_		}__		if (unannouncedCredit.getAndAdd(1) == 0) {_			notifyCreditAvailable()__		}__		return needMoreBuffers__	};the,buffer,pool,notifies,this,channel,of,an,available,floating,buffer,if,the,channel,is,released,or,currently,does,not,need,extra,buffers,the,buffer,should,be,recycled,to,the,buffer,pool,otherwise,the,buffer,will,be,added,into,the,tt,buffer,queue,tt,and,the,unannounced,credit,is,increased,by,one,param,buffer,buffer,that,becomes,available,in,buffer,pool,return,true,when,this,channel,is,waiting,for,more,floating,buffers,otherwise,false;override,public,boolean,notify,buffer,available,buffer,buffer,if,is,released,get,buffer,recycle,buffer,return,false,boolean,need,more,buffers,false,synchronized,buffer,queue,check,state,is,waiting,for,floating,buffers,this,channel,should,be,waiting,for,floating,buffers,if,is,released,get,buffer,queue,get,available,buffer,size,num,required,buffers,buffer,recycle,buffer,return,false,buffer,queue,add,floating,buffer,buffer,if,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,else,need,more,buffers,true,if,unannounced,credit,get,and,add,1,0,notify,credit,available,return,need,more,buffers
RemoteInputChannel -> @Override 	public boolean notifyBufferAvailable(Buffer buffer);1516801403;The Buffer pool notifies this channel of an available floating buffer. If the channel is released or_currently does not need extra buffers, the buffer should be recycled to the buffer pool. Otherwise,_the buffer will be added into the <tt>bufferQueue</tt> and the unannounced credit is increased_by one.__@param buffer Buffer that becomes available in buffer pool._@return True when this channel is waiting for more floating buffers, otherwise false.;@Override_	public boolean notifyBufferAvailable(Buffer buffer) {_		_		_		if (isReleased.get()) {_			buffer.recycleBuffer()__			return false__		}__		boolean needMoreBuffers = false__		synchronized (bufferQueue) {_			checkState(isWaitingForFloatingBuffers, "This channel should be waiting for floating buffers.")___			_			_			if (isReleased.get() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {_				buffer.recycleBuffer()__				return false__			}__			bufferQueue.addFloatingBuffer(buffer)___			if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {_				isWaitingForFloatingBuffers = false__			} else {_				needMoreBuffers =  true__			}_		}__		if (unannouncedCredit.getAndAdd(1) == 0) {_			notifyCreditAvailable()__		}__		return needMoreBuffers__	};the,buffer,pool,notifies,this,channel,of,an,available,floating,buffer,if,the,channel,is,released,or,currently,does,not,need,extra,buffers,the,buffer,should,be,recycled,to,the,buffer,pool,otherwise,the,buffer,will,be,added,into,the,tt,buffer,queue,tt,and,the,unannounced,credit,is,increased,by,one,param,buffer,buffer,that,becomes,available,in,buffer,pool,return,true,when,this,channel,is,waiting,for,more,floating,buffers,otherwise,false;override,public,boolean,notify,buffer,available,buffer,buffer,if,is,released,get,buffer,recycle,buffer,return,false,boolean,need,more,buffers,false,synchronized,buffer,queue,check,state,is,waiting,for,floating,buffers,this,channel,should,be,waiting,for,floating,buffers,if,is,released,get,buffer,queue,get,available,buffer,size,num,required,buffers,buffer,recycle,buffer,return,false,buffer,queue,add,floating,buffer,buffer,if,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,else,need,more,buffers,true,if,unannounced,credit,get,and,add,1,0,notify,credit,available,return,need,more,buffers
RemoteInputChannel -> @Override 	public boolean notifyBufferAvailable(Buffer buffer);1519310498;The Buffer pool notifies this channel of an available floating buffer. If the channel is released or_currently does not need extra buffers, the buffer should be recycled to the buffer pool. Otherwise,_the buffer will be added into the <tt>bufferQueue</tt> and the unannounced credit is increased_by one.__@param buffer Buffer that becomes available in buffer pool._@return True when this channel is waiting for more floating buffers, otherwise false.;@Override_	public boolean notifyBufferAvailable(Buffer buffer) {_		_		_		if (isReleased.get()) {_			buffer.recycleBuffer()__			return false__		}__		boolean needMoreBuffers = false__		synchronized (bufferQueue) {_			checkState(isWaitingForFloatingBuffers, "This channel should be waiting for floating buffers.")___			_			_			if (isReleased.get() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {_				isWaitingForFloatingBuffers = false__				buffer.recycleBuffer()__				return false__			}__			bufferQueue.addFloatingBuffer(buffer)___			if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {_				isWaitingForFloatingBuffers = false__			} else {_				needMoreBuffers =  true__			}_		}__		if (unannouncedCredit.getAndAdd(1) == 0) {_			notifyCreditAvailable()__		}__		return needMoreBuffers__	};the,buffer,pool,notifies,this,channel,of,an,available,floating,buffer,if,the,channel,is,released,or,currently,does,not,need,extra,buffers,the,buffer,should,be,recycled,to,the,buffer,pool,otherwise,the,buffer,will,be,added,into,the,tt,buffer,queue,tt,and,the,unannounced,credit,is,increased,by,one,param,buffer,buffer,that,becomes,available,in,buffer,pool,return,true,when,this,channel,is,waiting,for,more,floating,buffers,otherwise,false;override,public,boolean,notify,buffer,available,buffer,buffer,if,is,released,get,buffer,recycle,buffer,return,false,boolean,need,more,buffers,false,synchronized,buffer,queue,check,state,is,waiting,for,floating,buffers,this,channel,should,be,waiting,for,floating,buffers,if,is,released,get,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,buffer,recycle,buffer,return,false,buffer,queue,add,floating,buffer,buffer,if,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,else,need,more,buffers,true,if,unannounced,credit,get,and,add,1,0,notify,credit,available,return,need,more,buffers
RemoteInputChannel -> @Override 	public boolean notifyBufferAvailable(Buffer buffer);1519350957;The Buffer pool notifies this channel of an available floating buffer. If the channel is released or_currently does not need extra buffers, the buffer should be recycled to the buffer pool. Otherwise,_the buffer will be added into the <tt>bufferQueue</tt> and the unannounced credit is increased_by one.__@param buffer Buffer that becomes available in buffer pool._@return True when this channel is waiting for more floating buffers, otherwise false.;@Override_	public boolean notifyBufferAvailable(Buffer buffer) {_		_		_		if (isReleased.get()) {_			buffer.recycleBuffer()__			return false__		}__		boolean needMoreBuffers = false__		synchronized (bufferQueue) {_			checkState(isWaitingForFloatingBuffers, "This channel should be waiting for floating buffers.")___			_			_			if (isReleased.get() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {_				isWaitingForFloatingBuffers = false__				buffer.recycleBuffer()__				return false__			}__			bufferQueue.addFloatingBuffer(buffer)___			if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {_				isWaitingForFloatingBuffers = false__			} else {_				needMoreBuffers =  true__			}_		}__		if (unannouncedCredit.getAndAdd(1) == 0) {_			notifyCreditAvailable()__		}__		return needMoreBuffers__	};the,buffer,pool,notifies,this,channel,of,an,available,floating,buffer,if,the,channel,is,released,or,currently,does,not,need,extra,buffers,the,buffer,should,be,recycled,to,the,buffer,pool,otherwise,the,buffer,will,be,added,into,the,tt,buffer,queue,tt,and,the,unannounced,credit,is,increased,by,one,param,buffer,buffer,that,becomes,available,in,buffer,pool,return,true,when,this,channel,is,waiting,for,more,floating,buffers,otherwise,false;override,public,boolean,notify,buffer,available,buffer,buffer,if,is,released,get,buffer,recycle,buffer,return,false,boolean,need,more,buffers,false,synchronized,buffer,queue,check,state,is,waiting,for,floating,buffers,this,channel,should,be,waiting,for,floating,buffers,if,is,released,get,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,buffer,recycle,buffer,return,false,buffer,queue,add,floating,buffer,buffer,if,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,else,need,more,buffers,true,if,unannounced,credit,get,and,add,1,0,notify,credit,available,return,need,more,buffers
RemoteInputChannel -> @Override 	public boolean notifyBufferAvailable(Buffer buffer);1530744513;The Buffer pool notifies this channel of an available floating buffer. If the channel is released or_currently does not need extra buffers, the buffer should be recycled to the buffer pool. Otherwise,_the buffer will be added into the <tt>bufferQueue</tt> and the unannounced credit is increased_by one.__@param buffer Buffer that becomes available in buffer pool._@return True when this channel is waiting for more floating buffers, otherwise false.;@Override_	public boolean notifyBufferAvailable(Buffer buffer) {_		_		_		if (isReleased.get()) {_			buffer.recycleBuffer()__			return false__		}__		boolean recycleBuffer = true__		try {_			boolean needMoreBuffers = false__			synchronized (bufferQueue) {_				checkState(isWaitingForFloatingBuffers,_					"This channel should be waiting for floating buffers.")___				_				_				if (isReleased.get() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {_					isWaitingForFloatingBuffers = false__					recycleBuffer = false_ _					buffer.recycleBuffer()__					return false__				}__				recycleBuffer = false__				bufferQueue.addFloatingBuffer(buffer)___				if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {_					isWaitingForFloatingBuffers = false__				} else {_					needMoreBuffers = true__				}__				if (unannouncedCredit.getAndAdd(1) == 0) {_					notifyCreditAvailable()__				}_			}__			return needMoreBuffers__		} catch (Throwable t) {_			if (recycleBuffer) {_				buffer.recycleBuffer()__			}_			setError(t)__			return false__		}_	};the,buffer,pool,notifies,this,channel,of,an,available,floating,buffer,if,the,channel,is,released,or,currently,does,not,need,extra,buffers,the,buffer,should,be,recycled,to,the,buffer,pool,otherwise,the,buffer,will,be,added,into,the,tt,buffer,queue,tt,and,the,unannounced,credit,is,increased,by,one,param,buffer,buffer,that,becomes,available,in,buffer,pool,return,true,when,this,channel,is,waiting,for,more,floating,buffers,otherwise,false;override,public,boolean,notify,buffer,available,buffer,buffer,if,is,released,get,buffer,recycle,buffer,return,false,boolean,recycle,buffer,true,try,boolean,need,more,buffers,false,synchronized,buffer,queue,check,state,is,waiting,for,floating,buffers,this,channel,should,be,waiting,for,floating,buffers,if,is,released,get,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,recycle,buffer,false,buffer,recycle,buffer,return,false,recycle,buffer,false,buffer,queue,add,floating,buffer,buffer,if,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,else,need,more,buffers,true,if,unannounced,credit,get,and,add,1,0,notify,credit,available,return,need,more,buffers,catch,throwable,t,if,recycle,buffer,buffer,recycle,buffer,set,error,t,return,false
RemoteInputChannel -> @Override 	public boolean notifyBufferAvailable(Buffer buffer);1533422492;The Buffer pool notifies this channel of an available floating buffer. If the channel is released or_currently does not need extra buffers, the buffer should be recycled to the buffer pool. Otherwise,_the buffer will be added into the <tt>bufferQueue</tt> and the unannounced credit is increased_by one.__@param buffer Buffer that becomes available in buffer pool._@return True when this channel is waiting for more floating buffers, otherwise false.;@Override_	public boolean notifyBufferAvailable(Buffer buffer) {_		boolean recycleBuffer = true__		try {_			boolean needMoreBuffers = false__			synchronized (bufferQueue) {_				checkState(isWaitingForFloatingBuffers,_					"This channel should be waiting for floating buffers.")___				_				_				_				_				_				_				_				if (isReleased.get() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {_					isWaitingForFloatingBuffers = false__					recycleBuffer = false_ _					buffer.recycleBuffer()__					return false__				}__				recycleBuffer = false__				bufferQueue.addFloatingBuffer(buffer)___				if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {_					isWaitingForFloatingBuffers = false__				} else {_					needMoreBuffers = true__				}_			}__			if (unannouncedCredit.getAndAdd(1) == 0) {_				notifyCreditAvailable()__			}__			return needMoreBuffers__		} catch (Throwable t) {_			if (recycleBuffer) {_				buffer.recycleBuffer()__			}_			setError(t)__			return false__		}_	};the,buffer,pool,notifies,this,channel,of,an,available,floating,buffer,if,the,channel,is,released,or,currently,does,not,need,extra,buffers,the,buffer,should,be,recycled,to,the,buffer,pool,otherwise,the,buffer,will,be,added,into,the,tt,buffer,queue,tt,and,the,unannounced,credit,is,increased,by,one,param,buffer,buffer,that,becomes,available,in,buffer,pool,return,true,when,this,channel,is,waiting,for,more,floating,buffers,otherwise,false;override,public,boolean,notify,buffer,available,buffer,buffer,boolean,recycle,buffer,true,try,boolean,need,more,buffers,false,synchronized,buffer,queue,check,state,is,waiting,for,floating,buffers,this,channel,should,be,waiting,for,floating,buffers,if,is,released,get,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,recycle,buffer,false,buffer,recycle,buffer,return,false,recycle,buffer,false,buffer,queue,add,floating,buffer,buffer,if,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,else,need,more,buffers,true,if,unannounced,credit,get,and,add,1,0,notify,credit,available,return,need,more,buffers,catch,throwable,t,if,recycle,buffer,buffer,recycle,buffer,set,error,t,return,false
RemoteInputChannel -> @Override 	public boolean notifyBufferAvailable(Buffer buffer);1534276258;The Buffer pool notifies this channel of an available floating buffer. If the channel is released or_currently does not need extra buffers, the buffer should be recycled to the buffer pool. Otherwise,_the buffer will be added into the <tt>bufferQueue</tt> and the unannounced credit is increased_by one.__@param buffer Buffer that becomes available in buffer pool._@return True when this channel is waiting for more floating buffers, otherwise false.;@Override_	public boolean notifyBufferAvailable(Buffer buffer) {_		_		_		if (isReleased.get()) {_			buffer.recycleBuffer()__			return false__		}__		boolean recycleBuffer = true__		try {_			boolean needMoreBuffers = false__			synchronized (bufferQueue) {_				checkState(isWaitingForFloatingBuffers,_					"This channel should be waiting for floating buffers.")___				_				_				if (isReleased.get() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {_					isWaitingForFloatingBuffers = false__					recycleBuffer = false_ _					buffer.recycleBuffer()__					return false__				}__				recycleBuffer = false__				bufferQueue.addFloatingBuffer(buffer)___				if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {_					isWaitingForFloatingBuffers = false__				} else {_					needMoreBuffers = true__				}__				if (unannouncedCredit.getAndAdd(1) == 0) {_					notifyCreditAvailable()__				}_			}__			return needMoreBuffers__		} catch (Throwable t) {_			if (recycleBuffer) {_				buffer.recycleBuffer()__			}_			setError(t)__			return false__		}_	};the,buffer,pool,notifies,this,channel,of,an,available,floating,buffer,if,the,channel,is,released,or,currently,does,not,need,extra,buffers,the,buffer,should,be,recycled,to,the,buffer,pool,otherwise,the,buffer,will,be,added,into,the,tt,buffer,queue,tt,and,the,unannounced,credit,is,increased,by,one,param,buffer,buffer,that,becomes,available,in,buffer,pool,return,true,when,this,channel,is,waiting,for,more,floating,buffers,otherwise,false;override,public,boolean,notify,buffer,available,buffer,buffer,if,is,released,get,buffer,recycle,buffer,return,false,boolean,recycle,buffer,true,try,boolean,need,more,buffers,false,synchronized,buffer,queue,check,state,is,waiting,for,floating,buffers,this,channel,should,be,waiting,for,floating,buffers,if,is,released,get,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,recycle,buffer,false,buffer,recycle,buffer,return,false,recycle,buffer,false,buffer,queue,add,floating,buffer,buffer,if,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,else,need,more,buffers,true,if,unannounced,credit,get,and,add,1,0,notify,credit,available,return,need,more,buffers,catch,throwable,t,if,recycle,buffer,buffer,recycle,buffer,set,error,t,return,false
RemoteInputChannel -> @Override 	public boolean notifyBufferAvailable(Buffer buffer);1534864589;The Buffer pool notifies this channel of an available floating buffer. If the channel is released or_currently does not need extra buffers, the buffer should be recycled to the buffer pool. Otherwise,_the buffer will be added into the <tt>bufferQueue</tt> and the unannounced credit is increased_by one.__@param buffer Buffer that becomes available in buffer pool._@return True when this channel is waiting for more floating buffers, otherwise false.;@Override_	public boolean notifyBufferAvailable(Buffer buffer) {_		_		_		if (isReleased.get()) {_			buffer.recycleBuffer()__			return false__		}__		boolean recycleBuffer = true__		try {_			boolean needMoreBuffers = false__			synchronized (bufferQueue) {_				checkState(isWaitingForFloatingBuffers,_					"This channel should be waiting for floating buffers.")___				_				_				if (isReleased.get() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {_					isWaitingForFloatingBuffers = false__					recycleBuffer = false_ _					buffer.recycleBuffer()__					return false__				}__				recycleBuffer = false__				bufferQueue.addFloatingBuffer(buffer)___				if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {_					isWaitingForFloatingBuffers = false__				} else {_					needMoreBuffers = true__				}__				if (unannouncedCredit.getAndAdd(1) == 0) {_					notifyCreditAvailable()__				}_			}__			return needMoreBuffers__		} catch (Throwable t) {_			if (recycleBuffer) {_				buffer.recycleBuffer()__			}_			setError(t)__			return false__		}_	};the,buffer,pool,notifies,this,channel,of,an,available,floating,buffer,if,the,channel,is,released,or,currently,does,not,need,extra,buffers,the,buffer,should,be,recycled,to,the,buffer,pool,otherwise,the,buffer,will,be,added,into,the,tt,buffer,queue,tt,and,the,unannounced,credit,is,increased,by,one,param,buffer,buffer,that,becomes,available,in,buffer,pool,return,true,when,this,channel,is,waiting,for,more,floating,buffers,otherwise,false;override,public,boolean,notify,buffer,available,buffer,buffer,if,is,released,get,buffer,recycle,buffer,return,false,boolean,recycle,buffer,true,try,boolean,need,more,buffers,false,synchronized,buffer,queue,check,state,is,waiting,for,floating,buffers,this,channel,should,be,waiting,for,floating,buffers,if,is,released,get,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,recycle,buffer,false,buffer,recycle,buffer,return,false,recycle,buffer,false,buffer,queue,add,floating,buffer,buffer,if,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,else,need,more,buffers,true,if,unannounced,credit,get,and,add,1,0,notify,credit,available,return,need,more,buffers,catch,throwable,t,if,recycle,buffer,buffer,recycle,buffer,set,error,t,return,false
RemoteInputChannel -> @Override 	public boolean notifyBufferAvailable(Buffer buffer);1534865689;The Buffer pool notifies this channel of an available floating buffer. If the channel is released or_currently does not need extra buffers, the buffer should be recycled to the buffer pool. Otherwise,_the buffer will be added into the <tt>bufferQueue</tt> and the unannounced credit is increased_by one.__@param buffer Buffer that becomes available in buffer pool._@return True when this channel is waiting for more floating buffers, otherwise false.;@Override_	public boolean notifyBufferAvailable(Buffer buffer) {_		_		_		if (isReleased.get()) {_			buffer.recycleBuffer()__			return false__		}__		boolean recycleBuffer = true__		try {_			boolean needMoreBuffers = false__			synchronized (bufferQueue) {_				checkState(isWaitingForFloatingBuffers,_					"This channel should be waiting for floating buffers.")___				_				_				_				_				_				_				_				if (isReleased.get() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {_					isWaitingForFloatingBuffers = false__					recycleBuffer = false_ _					buffer.recycleBuffer()__					return false__				}__				recycleBuffer = false__				bufferQueue.addFloatingBuffer(buffer)___				if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {_					isWaitingForFloatingBuffers = false__				} else {_					needMoreBuffers = true__				}_			}__			if (unannouncedCredit.getAndAdd(1) == 0) {_				notifyCreditAvailable()__			}__			return needMoreBuffers__		} catch (Throwable t) {_			if (recycleBuffer) {_				buffer.recycleBuffer()__			}_			setError(t)__			return false__		}_	};the,buffer,pool,notifies,this,channel,of,an,available,floating,buffer,if,the,channel,is,released,or,currently,does,not,need,extra,buffers,the,buffer,should,be,recycled,to,the,buffer,pool,otherwise,the,buffer,will,be,added,into,the,tt,buffer,queue,tt,and,the,unannounced,credit,is,increased,by,one,param,buffer,buffer,that,becomes,available,in,buffer,pool,return,true,when,this,channel,is,waiting,for,more,floating,buffers,otherwise,false;override,public,boolean,notify,buffer,available,buffer,buffer,if,is,released,get,buffer,recycle,buffer,return,false,boolean,recycle,buffer,true,try,boolean,need,more,buffers,false,synchronized,buffer,queue,check,state,is,waiting,for,floating,buffers,this,channel,should,be,waiting,for,floating,buffers,if,is,released,get,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,recycle,buffer,false,buffer,recycle,buffer,return,false,recycle,buffer,false,buffer,queue,add,floating,buffer,buffer,if,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,else,need,more,buffers,true,if,unannounced,credit,get,and,add,1,0,notify,credit,available,return,need,more,buffers,catch,throwable,t,if,recycle,buffer,buffer,recycle,buffer,set,error,t,return,false
RemoteInputChannel -> private void checkError() throws IOException;1427189152;Checks whether this channel got notified by the network I/O thread about an error.;private void checkError() throws IOException {_		final Throwable t = error___		if (t != null) {_			throw new IOException(t)__		}_	};checks,whether,this,channel,got,notified,by,the,network,i,o,thread,about,an,error;private,void,check,error,throws,ioexception,final,throwable,t,error,if,t,null,throw,new,ioexception,t
RemoteInputChannel -> private void checkError() throws IOException;1431354895;Checks whether this channel got notified about an error.;private void checkError() throws IOException {_		final Throwable t = error.get()___		if (t != null) {_			if (t instanceof IOException) {_				throw (IOException) t__			}_			else {_				throw new IOException(t)__			}_		}_	};checks,whether,this,channel,got,notified,about,an,error;private,void,check,error,throws,ioexception,final,throwable,t,error,get,if,t,null,if,t,instanceof,ioexception,throw,ioexception,t,else,throw,new,ioexception,t
RemoteInputChannel -> AvailableBufferQueue -> @Nullable 		Buffer takeBuffer();1502342953;Takes the floating buffer first in order to make full use of floating_buffers reasonably.__@return An available floating or exclusive buffer, may be null_if the channel is released.;@Nullable_		Buffer takeBuffer() {_			if (floatingBuffers.size() > 0) {_				return floatingBuffers.poll()__			} else {_				return exclusiveBuffers.poll()__			}_		};takes,the,floating,buffer,first,in,order,to,make,full,use,of,floating,buffers,reasonably,return,an,available,floating,or,exclusive,buffer,may,be,null,if,the,channel,is,released;nullable,buffer,take,buffer,if,floating,buffers,size,0,return,floating,buffers,poll,else,return,exclusive,buffers,poll
RemoteInputChannel -> AvailableBufferQueue -> @Nullable 		Buffer takeBuffer();1502969925;Takes the floating buffer first in order to make full use of floating_buffers reasonably.__@return An available floating or exclusive buffer, may be null_if the channel is released.;@Nullable_		Buffer takeBuffer() {_			if (floatingBuffers.size() > 0) {_				return floatingBuffers.poll()__			} else {_				return exclusiveBuffers.poll()__			}_		};takes,the,floating,buffer,first,in,order,to,make,full,use,of,floating,buffers,reasonably,return,an,available,floating,or,exclusive,buffer,may,be,null,if,the,channel,is,released;nullable,buffer,take,buffer,if,floating,buffers,size,0,return,floating,buffers,poll,else,return,exclusive,buffers,poll
RemoteInputChannel -> AvailableBufferQueue -> @Nullable 		Buffer takeBuffer();1506613166;Takes the floating buffer first in order to make full use of floating_buffers reasonably.__@return An available floating or exclusive buffer, may be null_if the channel is released.;@Nullable_		Buffer takeBuffer() {_			if (floatingBuffers.size() > 0) {_				return floatingBuffers.poll()__			} else {_				return exclusiveBuffers.poll()__			}_		};takes,the,floating,buffer,first,in,order,to,make,full,use,of,floating,buffers,reasonably,return,an,available,floating,or,exclusive,buffer,may,be,null,if,the,channel,is,released;nullable,buffer,take,buffer,if,floating,buffers,size,0,return,floating,buffers,poll,else,return,exclusive,buffers,poll
RemoteInputChannel -> AvailableBufferQueue -> @Nullable 		Buffer takeBuffer();1506753379;Takes the floating buffer first in order to make full use of floating_buffers reasonably.__@return An available floating or exclusive buffer, may be null_if the channel is released.;@Nullable_		Buffer takeBuffer() {_			if (floatingBuffers.size() > 0) {_				return floatingBuffers.poll()__			} else {_				return exclusiveBuffers.poll()__			}_		};takes,the,floating,buffer,first,in,order,to,make,full,use,of,floating,buffers,reasonably,return,an,available,floating,or,exclusive,buffer,may,be,null,if,the,channel,is,released;nullable,buffer,take,buffer,if,floating,buffers,size,0,return,floating,buffers,poll,else,return,exclusive,buffers,poll
RemoteInputChannel -> AvailableBufferQueue -> @Nullable 		Buffer takeBuffer();1515514130;Takes the floating buffer first in order to make full use of floating_buffers reasonably.__@return An available floating or exclusive buffer, may be null_if the channel is released.;@Nullable_		Buffer takeBuffer() {_			if (floatingBuffers.size() > 0) {_				return floatingBuffers.poll()__			} else {_				return exclusiveBuffers.poll()__			}_		};takes,the,floating,buffer,first,in,order,to,make,full,use,of,floating,buffers,reasonably,return,an,available,floating,or,exclusive,buffer,may,be,null,if,the,channel,is,released;nullable,buffer,take,buffer,if,floating,buffers,size,0,return,floating,buffers,poll,else,return,exclusive,buffers,poll
RemoteInputChannel -> AvailableBufferQueue -> @Nullable 		Buffer takeBuffer();1515534998;Takes the floating buffer first in order to make full use of floating_buffers reasonably.__@return An available floating or exclusive buffer, may be null_if the channel is released.;@Nullable_		Buffer takeBuffer() {_			if (floatingBuffers.size() > 0) {_				return floatingBuffers.poll()__			} else {_				return exclusiveBuffers.poll()__			}_		};takes,the,floating,buffer,first,in,order,to,make,full,use,of,floating,buffers,reasonably,return,an,available,floating,or,exclusive,buffer,may,be,null,if,the,channel,is,released;nullable,buffer,take,buffer,if,floating,buffers,size,0,return,floating,buffers,poll,else,return,exclusive,buffers,poll
RemoteInputChannel -> AvailableBufferQueue -> @Nullable 		Buffer takeBuffer();1516801403;Takes the floating buffer first in order to make full use of floating_buffers reasonably.__@return An available floating or exclusive buffer, may be null_if the channel is released.;@Nullable_		Buffer takeBuffer() {_			if (floatingBuffers.size() > 0) {_				return floatingBuffers.poll()__			} else {_				return exclusiveBuffers.poll()__			}_		};takes,the,floating,buffer,first,in,order,to,make,full,use,of,floating,buffers,reasonably,return,an,available,floating,or,exclusive,buffer,may,be,null,if,the,channel,is,released;nullable,buffer,take,buffer,if,floating,buffers,size,0,return,floating,buffers,poll,else,return,exclusive,buffers,poll
RemoteInputChannel -> AvailableBufferQueue -> @Nullable 		Buffer takeBuffer();1519310498;Takes the floating buffer first in order to make full use of floating_buffers reasonably.__@return An available floating or exclusive buffer, may be null_if the channel is released.;@Nullable_		Buffer takeBuffer() {_			if (floatingBuffers.size() > 0) {_				return floatingBuffers.poll()__			} else {_				return exclusiveBuffers.poll()__			}_		};takes,the,floating,buffer,first,in,order,to,make,full,use,of,floating,buffers,reasonably,return,an,available,floating,or,exclusive,buffer,may,be,null,if,the,channel,is,released;nullable,buffer,take,buffer,if,floating,buffers,size,0,return,floating,buffers,poll,else,return,exclusive,buffers,poll
RemoteInputChannel -> AvailableBufferQueue -> @Nullable 		Buffer takeBuffer();1519350957;Takes the floating buffer first in order to make full use of floating_buffers reasonably.__@return An available floating or exclusive buffer, may be null_if the channel is released.;@Nullable_		Buffer takeBuffer() {_			if (floatingBuffers.size() > 0) {_				return floatingBuffers.poll()__			} else {_				return exclusiveBuffers.poll()__			}_		};takes,the,floating,buffer,first,in,order,to,make,full,use,of,floating,buffers,reasonably,return,an,available,floating,or,exclusive,buffer,may,be,null,if,the,channel,is,released;nullable,buffer,take,buffer,if,floating,buffers,size,0,return,floating,buffers,poll,else,return,exclusive,buffers,poll
RemoteInputChannel -> AvailableBufferQueue -> @Nullable 		Buffer takeBuffer();1530744513;Takes the floating buffer first in order to make full use of floating_buffers reasonably.__@return An available floating or exclusive buffer, may be null_if the channel is released.;@Nullable_		Buffer takeBuffer() {_			if (floatingBuffers.size() > 0) {_				return floatingBuffers.poll()__			} else {_				return exclusiveBuffers.poll()__			}_		};takes,the,floating,buffer,first,in,order,to,make,full,use,of,floating,buffers,reasonably,return,an,available,floating,or,exclusive,buffer,may,be,null,if,the,channel,is,released;nullable,buffer,take,buffer,if,floating,buffers,size,0,return,floating,buffers,poll,else,return,exclusive,buffers,poll
RemoteInputChannel -> AvailableBufferQueue -> @Nullable 		Buffer takeBuffer();1533422492;Takes the floating buffer first in order to make full use of floating_buffers reasonably.__@return An available floating or exclusive buffer, may be null_if the channel is released.;@Nullable_		Buffer takeBuffer() {_			if (floatingBuffers.size() > 0) {_				return floatingBuffers.poll()__			} else {_				return exclusiveBuffers.poll()__			}_		};takes,the,floating,buffer,first,in,order,to,make,full,use,of,floating,buffers,reasonably,return,an,available,floating,or,exclusive,buffer,may,be,null,if,the,channel,is,released;nullable,buffer,take,buffer,if,floating,buffers,size,0,return,floating,buffers,poll,else,return,exclusive,buffers,poll
RemoteInputChannel -> AvailableBufferQueue -> @Nullable 		Buffer takeBuffer();1534276258;Takes the floating buffer first in order to make full use of floating_buffers reasonably.__@return An available floating or exclusive buffer, may be null_if the channel is released.;@Nullable_		Buffer takeBuffer() {_			if (floatingBuffers.size() > 0) {_				return floatingBuffers.poll()__			} else {_				return exclusiveBuffers.poll()__			}_		};takes,the,floating,buffer,first,in,order,to,make,full,use,of,floating,buffers,reasonably,return,an,available,floating,or,exclusive,buffer,may,be,null,if,the,channel,is,released;nullable,buffer,take,buffer,if,floating,buffers,size,0,return,floating,buffers,poll,else,return,exclusive,buffers,poll
RemoteInputChannel -> AvailableBufferQueue -> @Nullable 		Buffer takeBuffer();1534864589;Takes the floating buffer first in order to make full use of floating_buffers reasonably.__@return An available floating or exclusive buffer, may be null_if the channel is released.;@Nullable_		Buffer takeBuffer() {_			if (floatingBuffers.size() > 0) {_				return floatingBuffers.poll()__			} else {_				return exclusiveBuffers.poll()__			}_		};takes,the,floating,buffer,first,in,order,to,make,full,use,of,floating,buffers,reasonably,return,an,available,floating,or,exclusive,buffer,may,be,null,if,the,channel,is,released;nullable,buffer,take,buffer,if,floating,buffers,size,0,return,floating,buffers,poll,else,return,exclusive,buffers,poll
RemoteInputChannel -> AvailableBufferQueue -> @Nullable 		Buffer takeBuffer();1534865689;Takes the floating buffer first in order to make full use of floating_buffers reasonably.__@return An available floating or exclusive buffer, may be null_if the channel is released.;@Nullable_		Buffer takeBuffer() {_			if (floatingBuffers.size() > 0) {_				return floatingBuffers.poll()__			} else {_				return exclusiveBuffers.poll()__			}_		};takes,the,floating,buffer,first,in,order,to,make,full,use,of,floating,buffers,reasonably,return,an,available,floating,or,exclusive,buffer,may,be,null,if,the,channel,is,released;nullable,buffer,take,buffer,if,floating,buffers,size,0,return,floating,buffers,poll,else,return,exclusive,buffers,poll
RemoteInputChannel -> AvailableBufferQueue -> @Nullable 		Buffer takeBuffer();1543328832;Takes the floating buffer first in order to make full use of floating_buffers reasonably.__@return An available floating or exclusive buffer, may be null_if the channel is released.;@Nullable_		Buffer takeBuffer() {_			if (floatingBuffers.size() > 0) {_				return floatingBuffers.poll()__			} else {_				return exclusiveBuffers.poll()__			}_		};takes,the,floating,buffer,first,in,order,to,make,full,use,of,floating,buffers,reasonably,return,an,available,floating,or,exclusive,buffer,may,be,null,if,the,channel,is,released;nullable,buffer,take,buffer,if,floating,buffers,size,0,return,floating,buffers,poll,else,return,exclusive,buffers,poll
RemoteInputChannel -> void onSenderBacklog(int backlog) throws IOException;1502969925;Receives the backlog from the producer's buffer response. If the number of available_buffers is less than backlog + initialCredit, it will request floating buffers from the buffer_pool, and then notify unannounced credits to the producer.__@param backlog The number of unsent buffers in the producer's sub partition.;void onSenderBacklog(int backlog) throws IOException {_		int numRequestedBuffers = 0___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				return__			}__			numRequiredBuffers = backlog + initialCredit__			while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {_				Buffer buffer = inputGate.getBufferPool().requestBuffer()__				if (buffer != null) {_					bufferQueue.addFloatingBuffer(buffer)__					numRequestedBuffers++__				} else if (inputGate.getBufferProvider().addBufferListener(this)) {_					_					isWaitingForFloatingBuffers = true__					break__				}_			}_		}__		if (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};receives,the,backlog,from,the,producer,s,buffer,response,if,the,number,of,available,buffers,is,less,than,backlog,initial,credit,it,will,request,floating,buffers,from,the,buffer,pool,and,then,notify,unannounced,credits,to,the,producer,param,backlog,the,number,of,unsent,buffers,in,the,producer,s,sub,partition;void,on,sender,backlog,int,backlog,throws,ioexception,int,num,requested,buffers,0,synchronized,buffer,queue,if,is,released,get,return,num,required,buffers,backlog,initial,credit,while,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,buffer,buffer,input,gate,get,buffer,pool,request,buffer,if,buffer,null,buffer,queue,add,floating,buffer,buffer,num,requested,buffers,else,if,input,gate,get,buffer,provider,add,buffer,listener,this,is,waiting,for,floating,buffers,true,break,if,num,requested,buffers,0,unannounced,credit,get,and,add,num,requested,buffers,0,notify,credit,available
RemoteInputChannel -> void onSenderBacklog(int backlog) throws IOException;1506613166;Receives the backlog from the producer's buffer response. If the number of available_buffers is less than backlog + initialCredit, it will request floating buffers from the buffer_pool, and then notify unannounced credits to the producer.__@param backlog The number of unsent buffers in the producer's sub partition.;void onSenderBacklog(int backlog) throws IOException {_		int numRequestedBuffers = 0___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				return__			}__			numRequiredBuffers = backlog + initialCredit__			while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {_				Buffer buffer = inputGate.getBufferPool().requestBuffer()__				if (buffer != null) {_					bufferQueue.addFloatingBuffer(buffer)__					numRequestedBuffers++__				} else if (inputGate.getBufferProvider().addBufferListener(this)) {_					_					isWaitingForFloatingBuffers = true__					break__				}_			}_		}__		if (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};receives,the,backlog,from,the,producer,s,buffer,response,if,the,number,of,available,buffers,is,less,than,backlog,initial,credit,it,will,request,floating,buffers,from,the,buffer,pool,and,then,notify,unannounced,credits,to,the,producer,param,backlog,the,number,of,unsent,buffers,in,the,producer,s,sub,partition;void,on,sender,backlog,int,backlog,throws,ioexception,int,num,requested,buffers,0,synchronized,buffer,queue,if,is,released,get,return,num,required,buffers,backlog,initial,credit,while,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,buffer,buffer,input,gate,get,buffer,pool,request,buffer,if,buffer,null,buffer,queue,add,floating,buffer,buffer,num,requested,buffers,else,if,input,gate,get,buffer,provider,add,buffer,listener,this,is,waiting,for,floating,buffers,true,break,if,num,requested,buffers,0,unannounced,credit,get,and,add,num,requested,buffers,0,notify,credit,available
RemoteInputChannel -> void onSenderBacklog(int backlog) throws IOException;1506753379;Receives the backlog from the producer's buffer response. If the number of available_buffers is less than backlog + initialCredit, it will request floating buffers from the buffer_pool, and then notify unannounced credits to the producer.__@param backlog The number of unsent buffers in the producer's sub partition.;void onSenderBacklog(int backlog) throws IOException {_		int numRequestedBuffers = 0___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				return__			}__			numRequiredBuffers = backlog + initialCredit__			while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {_				Buffer buffer = inputGate.getBufferPool().requestBuffer()__				if (buffer != null) {_					bufferQueue.addFloatingBuffer(buffer)__					numRequestedBuffers++__				} else if (inputGate.getBufferProvider().addBufferListener(this)) {_					_					isWaitingForFloatingBuffers = true__					break__				}_			}_		}__		if (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};receives,the,backlog,from,the,producer,s,buffer,response,if,the,number,of,available,buffers,is,less,than,backlog,initial,credit,it,will,request,floating,buffers,from,the,buffer,pool,and,then,notify,unannounced,credits,to,the,producer,param,backlog,the,number,of,unsent,buffers,in,the,producer,s,sub,partition;void,on,sender,backlog,int,backlog,throws,ioexception,int,num,requested,buffers,0,synchronized,buffer,queue,if,is,released,get,return,num,required,buffers,backlog,initial,credit,while,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,buffer,buffer,input,gate,get,buffer,pool,request,buffer,if,buffer,null,buffer,queue,add,floating,buffer,buffer,num,requested,buffers,else,if,input,gate,get,buffer,provider,add,buffer,listener,this,is,waiting,for,floating,buffers,true,break,if,num,requested,buffers,0,unannounced,credit,get,and,add,num,requested,buffers,0,notify,credit,available
RemoteInputChannel -> void onSenderBacklog(int backlog) throws IOException;1515514130;Receives the backlog from the producer's buffer response. If the number of available_buffers is less than backlog + initialCredit, it will request floating buffers from the buffer_pool, and then notify unannounced credits to the producer.__@param backlog The number of unsent buffers in the producer's sub partition.;void onSenderBacklog(int backlog) throws IOException {_		int numRequestedBuffers = 0___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				return__			}__			numRequiredBuffers = backlog + initialCredit__			while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {_				Buffer buffer = inputGate.getBufferPool().requestBuffer()__				if (buffer != null) {_					bufferQueue.addFloatingBuffer(buffer)__					numRequestedBuffers++__				} else if (inputGate.getBufferProvider().addBufferListener(this)) {_					_					isWaitingForFloatingBuffers = true__					break__				}_			}_		}__		if (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};receives,the,backlog,from,the,producer,s,buffer,response,if,the,number,of,available,buffers,is,less,than,backlog,initial,credit,it,will,request,floating,buffers,from,the,buffer,pool,and,then,notify,unannounced,credits,to,the,producer,param,backlog,the,number,of,unsent,buffers,in,the,producer,s,sub,partition;void,on,sender,backlog,int,backlog,throws,ioexception,int,num,requested,buffers,0,synchronized,buffer,queue,if,is,released,get,return,num,required,buffers,backlog,initial,credit,while,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,buffer,buffer,input,gate,get,buffer,pool,request,buffer,if,buffer,null,buffer,queue,add,floating,buffer,buffer,num,requested,buffers,else,if,input,gate,get,buffer,provider,add,buffer,listener,this,is,waiting,for,floating,buffers,true,break,if,num,requested,buffers,0,unannounced,credit,get,and,add,num,requested,buffers,0,notify,credit,available
RemoteInputChannel -> void onSenderBacklog(int backlog) throws IOException;1515534998;Receives the backlog from the producer's buffer response. If the number of available_buffers is less than backlog + initialCredit, it will request floating buffers from the buffer_pool, and then notify unannounced credits to the producer.__@param backlog The number of unsent buffers in the producer's sub partition.;void onSenderBacklog(int backlog) throws IOException {_		int numRequestedBuffers = 0___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				return__			}__			numRequiredBuffers = backlog + initialCredit__			while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {_				Buffer buffer = inputGate.getBufferPool().requestBuffer()__				if (buffer != null) {_					bufferQueue.addFloatingBuffer(buffer)__					numRequestedBuffers++__				} else if (inputGate.getBufferProvider().addBufferListener(this)) {_					_					isWaitingForFloatingBuffers = true__					break__				}_			}_		}__		if (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};receives,the,backlog,from,the,producer,s,buffer,response,if,the,number,of,available,buffers,is,less,than,backlog,initial,credit,it,will,request,floating,buffers,from,the,buffer,pool,and,then,notify,unannounced,credits,to,the,producer,param,backlog,the,number,of,unsent,buffers,in,the,producer,s,sub,partition;void,on,sender,backlog,int,backlog,throws,ioexception,int,num,requested,buffers,0,synchronized,buffer,queue,if,is,released,get,return,num,required,buffers,backlog,initial,credit,while,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,buffer,buffer,input,gate,get,buffer,pool,request,buffer,if,buffer,null,buffer,queue,add,floating,buffer,buffer,num,requested,buffers,else,if,input,gate,get,buffer,provider,add,buffer,listener,this,is,waiting,for,floating,buffers,true,break,if,num,requested,buffers,0,unannounced,credit,get,and,add,num,requested,buffers,0,notify,credit,available
RemoteInputChannel -> void onSenderBacklog(int backlog) throws IOException;1516801403;Receives the backlog from the producer's buffer response. If the number of available_buffers is less than backlog + initialCredit, it will request floating buffers from the buffer_pool, and then notify unannounced credits to the producer.__@param backlog The number of unsent buffers in the producer's sub partition.;void onSenderBacklog(int backlog) throws IOException {_		int numRequestedBuffers = 0___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				return__			}__			numRequiredBuffers = backlog + initialCredit__			while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {_				Buffer buffer = inputGate.getBufferPool().requestBuffer()__				if (buffer != null) {_					bufferQueue.addFloatingBuffer(buffer)__					numRequestedBuffers++__				} else if (inputGate.getBufferProvider().addBufferListener(this)) {_					_					isWaitingForFloatingBuffers = true__					break__				}_			}_		}__		if (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};receives,the,backlog,from,the,producer,s,buffer,response,if,the,number,of,available,buffers,is,less,than,backlog,initial,credit,it,will,request,floating,buffers,from,the,buffer,pool,and,then,notify,unannounced,credits,to,the,producer,param,backlog,the,number,of,unsent,buffers,in,the,producer,s,sub,partition;void,on,sender,backlog,int,backlog,throws,ioexception,int,num,requested,buffers,0,synchronized,buffer,queue,if,is,released,get,return,num,required,buffers,backlog,initial,credit,while,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,buffer,buffer,input,gate,get,buffer,pool,request,buffer,if,buffer,null,buffer,queue,add,floating,buffer,buffer,num,requested,buffers,else,if,input,gate,get,buffer,provider,add,buffer,listener,this,is,waiting,for,floating,buffers,true,break,if,num,requested,buffers,0,unannounced,credit,get,and,add,num,requested,buffers,0,notify,credit,available
RemoteInputChannel -> void onSenderBacklog(int backlog) throws IOException;1519310498;Receives the backlog from the producer's buffer response. If the number of available_buffers is less than backlog + initialCredit, it will request floating buffers from the buffer_pool, and then notify unannounced credits to the producer.__@param backlog The number of unsent buffers in the producer's sub partition.;void onSenderBacklog(int backlog) throws IOException {_		int numRequestedBuffers = 0___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				return__			}__			numRequiredBuffers = backlog + initialCredit__			while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {_				Buffer buffer = inputGate.getBufferPool().requestBuffer()__				if (buffer != null) {_					bufferQueue.addFloatingBuffer(buffer)__					numRequestedBuffers++__				} else if (inputGate.getBufferProvider().addBufferListener(this)) {_					_					isWaitingForFloatingBuffers = true__					break__				}_			}_		}__		if (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};receives,the,backlog,from,the,producer,s,buffer,response,if,the,number,of,available,buffers,is,less,than,backlog,initial,credit,it,will,request,floating,buffers,from,the,buffer,pool,and,then,notify,unannounced,credits,to,the,producer,param,backlog,the,number,of,unsent,buffers,in,the,producer,s,sub,partition;void,on,sender,backlog,int,backlog,throws,ioexception,int,num,requested,buffers,0,synchronized,buffer,queue,if,is,released,get,return,num,required,buffers,backlog,initial,credit,while,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,buffer,buffer,input,gate,get,buffer,pool,request,buffer,if,buffer,null,buffer,queue,add,floating,buffer,buffer,num,requested,buffers,else,if,input,gate,get,buffer,provider,add,buffer,listener,this,is,waiting,for,floating,buffers,true,break,if,num,requested,buffers,0,unannounced,credit,get,and,add,num,requested,buffers,0,notify,credit,available
RemoteInputChannel -> void onSenderBacklog(int backlog) throws IOException;1519350957;Receives the backlog from the producer's buffer response. If the number of available_buffers is less than backlog + initialCredit, it will request floating buffers from the buffer_pool, and then notify unannounced credits to the producer.__@param backlog The number of unsent buffers in the producer's sub partition.;void onSenderBacklog(int backlog) throws IOException {_		int numRequestedBuffers = 0___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				return__			}__			numRequiredBuffers = backlog + initialCredit__			while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {_				Buffer buffer = inputGate.getBufferPool().requestBuffer()__				if (buffer != null) {_					bufferQueue.addFloatingBuffer(buffer)__					numRequestedBuffers++__				} else if (inputGate.getBufferProvider().addBufferListener(this)) {_					_					isWaitingForFloatingBuffers = true__					break__				}_			}_		}__		if (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};receives,the,backlog,from,the,producer,s,buffer,response,if,the,number,of,available,buffers,is,less,than,backlog,initial,credit,it,will,request,floating,buffers,from,the,buffer,pool,and,then,notify,unannounced,credits,to,the,producer,param,backlog,the,number,of,unsent,buffers,in,the,producer,s,sub,partition;void,on,sender,backlog,int,backlog,throws,ioexception,int,num,requested,buffers,0,synchronized,buffer,queue,if,is,released,get,return,num,required,buffers,backlog,initial,credit,while,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,buffer,buffer,input,gate,get,buffer,pool,request,buffer,if,buffer,null,buffer,queue,add,floating,buffer,buffer,num,requested,buffers,else,if,input,gate,get,buffer,provider,add,buffer,listener,this,is,waiting,for,floating,buffers,true,break,if,num,requested,buffers,0,unannounced,credit,get,and,add,num,requested,buffers,0,notify,credit,available
RemoteInputChannel -> void onSenderBacklog(int backlog) throws IOException;1530744513;Receives the backlog from the producer's buffer response. If the number of available_buffers is less than backlog + initialCredit, it will request floating buffers from the buffer_pool, and then notify unannounced credits to the producer.__@param backlog The number of unsent buffers in the producer's sub partition.;void onSenderBacklog(int backlog) throws IOException {_		int numRequestedBuffers = 0___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				return__			}__			numRequiredBuffers = backlog + initialCredit__			while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {_				Buffer buffer = inputGate.getBufferPool().requestBuffer()__				if (buffer != null) {_					bufferQueue.addFloatingBuffer(buffer)__					numRequestedBuffers++__				} else if (inputGate.getBufferProvider().addBufferListener(this)) {_					_					isWaitingForFloatingBuffers = true__					break__				}_			}_		}__		if (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};receives,the,backlog,from,the,producer,s,buffer,response,if,the,number,of,available,buffers,is,less,than,backlog,initial,credit,it,will,request,floating,buffers,from,the,buffer,pool,and,then,notify,unannounced,credits,to,the,producer,param,backlog,the,number,of,unsent,buffers,in,the,producer,s,sub,partition;void,on,sender,backlog,int,backlog,throws,ioexception,int,num,requested,buffers,0,synchronized,buffer,queue,if,is,released,get,return,num,required,buffers,backlog,initial,credit,while,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,buffer,buffer,input,gate,get,buffer,pool,request,buffer,if,buffer,null,buffer,queue,add,floating,buffer,buffer,num,requested,buffers,else,if,input,gate,get,buffer,provider,add,buffer,listener,this,is,waiting,for,floating,buffers,true,break,if,num,requested,buffers,0,unannounced,credit,get,and,add,num,requested,buffers,0,notify,credit,available
RemoteInputChannel -> void onSenderBacklog(int backlog) throws IOException;1533422492;Receives the backlog from the producer's buffer response. If the number of available_buffers is less than backlog + initialCredit, it will request floating buffers from the buffer_pool, and then notify unannounced credits to the producer.__@param backlog The number of unsent buffers in the producer's sub partition.;void onSenderBacklog(int backlog) throws IOException {_		int numRequestedBuffers = 0___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				return__			}__			numRequiredBuffers = backlog + initialCredit__			while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {_				Buffer buffer = inputGate.getBufferPool().requestBuffer()__				if (buffer != null) {_					bufferQueue.addFloatingBuffer(buffer)__					numRequestedBuffers++__				} else if (inputGate.getBufferProvider().addBufferListener(this)) {_					_					isWaitingForFloatingBuffers = true__					break__				}_			}_		}__		if (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};receives,the,backlog,from,the,producer,s,buffer,response,if,the,number,of,available,buffers,is,less,than,backlog,initial,credit,it,will,request,floating,buffers,from,the,buffer,pool,and,then,notify,unannounced,credits,to,the,producer,param,backlog,the,number,of,unsent,buffers,in,the,producer,s,sub,partition;void,on,sender,backlog,int,backlog,throws,ioexception,int,num,requested,buffers,0,synchronized,buffer,queue,if,is,released,get,return,num,required,buffers,backlog,initial,credit,while,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,buffer,buffer,input,gate,get,buffer,pool,request,buffer,if,buffer,null,buffer,queue,add,floating,buffer,buffer,num,requested,buffers,else,if,input,gate,get,buffer,provider,add,buffer,listener,this,is,waiting,for,floating,buffers,true,break,if,num,requested,buffers,0,unannounced,credit,get,and,add,num,requested,buffers,0,notify,credit,available
RemoteInputChannel -> void onSenderBacklog(int backlog) throws IOException;1534276258;Receives the backlog from the producer's buffer response. If the number of available_buffers is less than backlog + initialCredit, it will request floating buffers from the buffer_pool, and then notify unannounced credits to the producer.__@param backlog The number of unsent buffers in the producer's sub partition.;void onSenderBacklog(int backlog) throws IOException {_		int numRequestedBuffers = 0___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				return__			}__			numRequiredBuffers = backlog + initialCredit__			while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {_				Buffer buffer = inputGate.getBufferPool().requestBuffer()__				if (buffer != null) {_					bufferQueue.addFloatingBuffer(buffer)__					numRequestedBuffers++__				} else if (inputGate.getBufferProvider().addBufferListener(this)) {_					_					isWaitingForFloatingBuffers = true__					break__				}_			}_		}__		if (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};receives,the,backlog,from,the,producer,s,buffer,response,if,the,number,of,available,buffers,is,less,than,backlog,initial,credit,it,will,request,floating,buffers,from,the,buffer,pool,and,then,notify,unannounced,credits,to,the,producer,param,backlog,the,number,of,unsent,buffers,in,the,producer,s,sub,partition;void,on,sender,backlog,int,backlog,throws,ioexception,int,num,requested,buffers,0,synchronized,buffer,queue,if,is,released,get,return,num,required,buffers,backlog,initial,credit,while,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,buffer,buffer,input,gate,get,buffer,pool,request,buffer,if,buffer,null,buffer,queue,add,floating,buffer,buffer,num,requested,buffers,else,if,input,gate,get,buffer,provider,add,buffer,listener,this,is,waiting,for,floating,buffers,true,break,if,num,requested,buffers,0,unannounced,credit,get,and,add,num,requested,buffers,0,notify,credit,available
RemoteInputChannel -> void onSenderBacklog(int backlog) throws IOException;1534864589;Receives the backlog from the producer's buffer response. If the number of available_buffers is less than backlog + initialCredit, it will request floating buffers from the buffer_pool, and then notify unannounced credits to the producer.__@param backlog The number of unsent buffers in the producer's sub partition.;void onSenderBacklog(int backlog) throws IOException {_		int numRequestedBuffers = 0___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				return__			}__			numRequiredBuffers = backlog + initialCredit__			while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {_				Buffer buffer = inputGate.getBufferPool().requestBuffer()__				if (buffer != null) {_					bufferQueue.addFloatingBuffer(buffer)__					numRequestedBuffers++__				} else if (inputGate.getBufferProvider().addBufferListener(this)) {_					_					isWaitingForFloatingBuffers = true__					break__				}_			}_		}__		if (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};receives,the,backlog,from,the,producer,s,buffer,response,if,the,number,of,available,buffers,is,less,than,backlog,initial,credit,it,will,request,floating,buffers,from,the,buffer,pool,and,then,notify,unannounced,credits,to,the,producer,param,backlog,the,number,of,unsent,buffers,in,the,producer,s,sub,partition;void,on,sender,backlog,int,backlog,throws,ioexception,int,num,requested,buffers,0,synchronized,buffer,queue,if,is,released,get,return,num,required,buffers,backlog,initial,credit,while,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,buffer,buffer,input,gate,get,buffer,pool,request,buffer,if,buffer,null,buffer,queue,add,floating,buffer,buffer,num,requested,buffers,else,if,input,gate,get,buffer,provider,add,buffer,listener,this,is,waiting,for,floating,buffers,true,break,if,num,requested,buffers,0,unannounced,credit,get,and,add,num,requested,buffers,0,notify,credit,available
RemoteInputChannel -> void onSenderBacklog(int backlog) throws IOException;1534865689;Receives the backlog from the producer's buffer response. If the number of available_buffers is less than backlog + initialCredit, it will request floating buffers from the buffer_pool, and then notify unannounced credits to the producer.__@param backlog The number of unsent buffers in the producer's sub partition.;void onSenderBacklog(int backlog) throws IOException {_		int numRequestedBuffers = 0___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				return__			}__			numRequiredBuffers = backlog + initialCredit__			while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {_				Buffer buffer = inputGate.getBufferPool().requestBuffer()__				if (buffer != null) {_					bufferQueue.addFloatingBuffer(buffer)__					numRequestedBuffers++__				} else if (inputGate.getBufferProvider().addBufferListener(this)) {_					_					isWaitingForFloatingBuffers = true__					break__				}_			}_		}__		if (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};receives,the,backlog,from,the,producer,s,buffer,response,if,the,number,of,available,buffers,is,less,than,backlog,initial,credit,it,will,request,floating,buffers,from,the,buffer,pool,and,then,notify,unannounced,credits,to,the,producer,param,backlog,the,number,of,unsent,buffers,in,the,producer,s,sub,partition;void,on,sender,backlog,int,backlog,throws,ioexception,int,num,requested,buffers,0,synchronized,buffer,queue,if,is,released,get,return,num,required,buffers,backlog,initial,credit,while,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,buffer,buffer,input,gate,get,buffer,pool,request,buffer,if,buffer,null,buffer,queue,add,floating,buffer,buffer,num,requested,buffers,else,if,input,gate,get,buffer,provider,add,buffer,listener,this,is,waiting,for,floating,buffers,true,break,if,num,requested,buffers,0,unannounced,credit,get,and,add,num,requested,buffers,0,notify,credit,available
RemoteInputChannel -> void onSenderBacklog(int backlog) throws IOException;1543328832;Receives the backlog from the producer's buffer response. If the number of available_buffers is less than backlog + initialCredit, it will request floating buffers from the buffer_pool, and then notify unannounced credits to the producer.__@param backlog The number of unsent buffers in the producer's sub partition.;void onSenderBacklog(int backlog) throws IOException {_		int numRequestedBuffers = 0___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				return__			}__			numRequiredBuffers = backlog + initialCredit__			while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {_				Buffer buffer = inputGate.getBufferPool().requestBuffer()__				if (buffer != null) {_					bufferQueue.addFloatingBuffer(buffer)__					numRequestedBuffers++__				} else if (inputGate.getBufferProvider().addBufferListener(this)) {_					_					isWaitingForFloatingBuffers = true__					break__				}_			}_		}__		if (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};receives,the,backlog,from,the,producer,s,buffer,response,if,the,number,of,available,buffers,is,less,than,backlog,initial,credit,it,will,request,floating,buffers,from,the,buffer,pool,and,then,notify,unannounced,credits,to,the,producer,param,backlog,the,number,of,unsent,buffers,in,the,producer,s,sub,partition;void,on,sender,backlog,int,backlog,throws,ioexception,int,num,requested,buffers,0,synchronized,buffer,queue,if,is,released,get,return,num,required,buffers,backlog,initial,credit,while,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,buffer,buffer,input,gate,get,buffer,pool,request,buffer,if,buffer,null,buffer,queue,add,floating,buffer,buffer,num,requested,buffers,else,if,input,gate,get,buffer,provider,add,buffer,listener,this,is,waiting,for,floating,buffers,true,break,if,num,requested,buffers,0,unannounced,credit,get,and,add,num,requested,buffers,0,notify,credit,available
RemoteInputChannel -> public int getAndResetUnannouncedCredit();1502969925;Gets the unannounced credit and resets it to <tt>0</tt> atomically.__@return Credit which was not announced to the sender yet.;public int getAndResetUnannouncedCredit() {_		return unannouncedCredit.getAndSet(0)__	};gets,the,unannounced,credit,and,resets,it,to,tt,0,tt,atomically,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,and,reset,unannounced,credit,return,unannounced,credit,get,and,set,0
RemoteInputChannel -> public int getAndResetUnannouncedCredit();1506613166;Gets the unannounced credit and resets it to <tt>0</tt> atomically.__@return Credit which was not announced to the sender yet.;public int getAndResetUnannouncedCredit() {_		return unannouncedCredit.getAndSet(0)__	};gets,the,unannounced,credit,and,resets,it,to,tt,0,tt,atomically,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,and,reset,unannounced,credit,return,unannounced,credit,get,and,set,0
RemoteInputChannel -> public int getAndResetUnannouncedCredit();1506753379;Gets the unannounced credit and resets it to <tt>0</tt> atomically.__@return Credit which was not announced to the sender yet.;public int getAndResetUnannouncedCredit() {_		return unannouncedCredit.getAndSet(0)__	};gets,the,unannounced,credit,and,resets,it,to,tt,0,tt,atomically,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,and,reset,unannounced,credit,return,unannounced,credit,get,and,set,0
RemoteInputChannel -> public int getAndResetUnannouncedCredit();1515514130;Gets the unannounced credit and resets it to <tt>0</tt> atomically.__@return Credit which was not announced to the sender yet.;public int getAndResetUnannouncedCredit() {_		return unannouncedCredit.getAndSet(0)__	};gets,the,unannounced,credit,and,resets,it,to,tt,0,tt,atomically,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,and,reset,unannounced,credit,return,unannounced,credit,get,and,set,0
RemoteInputChannel -> public int getAndResetUnannouncedCredit();1515534998;Gets the unannounced credit and resets it to <tt>0</tt> atomically.__@return Credit which was not announced to the sender yet.;public int getAndResetUnannouncedCredit() {_		return unannouncedCredit.getAndSet(0)__	};gets,the,unannounced,credit,and,resets,it,to,tt,0,tt,atomically,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,and,reset,unannounced,credit,return,unannounced,credit,get,and,set,0
RemoteInputChannel -> public int getAndResetUnannouncedCredit();1516801403;Gets the unannounced credit and resets it to <tt>0</tt> atomically.__@return Credit which was not announced to the sender yet.;public int getAndResetUnannouncedCredit() {_		return unannouncedCredit.getAndSet(0)__	};gets,the,unannounced,credit,and,resets,it,to,tt,0,tt,atomically,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,and,reset,unannounced,credit,return,unannounced,credit,get,and,set,0
RemoteInputChannel -> public int getAndResetUnannouncedCredit();1519310498;Gets the unannounced credit and resets it to <tt>0</tt> atomically.__@return Credit which was not announced to the sender yet.;public int getAndResetUnannouncedCredit() {_		return unannouncedCredit.getAndSet(0)__	};gets,the,unannounced,credit,and,resets,it,to,tt,0,tt,atomically,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,and,reset,unannounced,credit,return,unannounced,credit,get,and,set,0
RemoteInputChannel -> public int getAndResetUnannouncedCredit();1519350957;Gets the unannounced credit and resets it to <tt>0</tt> atomically.__@return Credit which was not announced to the sender yet.;public int getAndResetUnannouncedCredit() {_		return unannouncedCredit.getAndSet(0)__	};gets,the,unannounced,credit,and,resets,it,to,tt,0,tt,atomically,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,and,reset,unannounced,credit,return,unannounced,credit,get,and,set,0
RemoteInputChannel -> public int getAndResetUnannouncedCredit();1530744513;Gets the unannounced credit and resets it to <tt>0</tt> atomically.__@return Credit which was not announced to the sender yet.;public int getAndResetUnannouncedCredit() {_		return unannouncedCredit.getAndSet(0)__	};gets,the,unannounced,credit,and,resets,it,to,tt,0,tt,atomically,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,and,reset,unannounced,credit,return,unannounced,credit,get,and,set,0
RemoteInputChannel -> public int getAndResetUnannouncedCredit();1533422492;Gets the unannounced credit and resets it to <tt>0</tt> atomically.__@return Credit which was not announced to the sender yet.;public int getAndResetUnannouncedCredit() {_		return unannouncedCredit.getAndSet(0)__	};gets,the,unannounced,credit,and,resets,it,to,tt,0,tt,atomically,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,and,reset,unannounced,credit,return,unannounced,credit,get,and,set,0
RemoteInputChannel -> public int getAndResetUnannouncedCredit();1534276258;Gets the unannounced credit and resets it to <tt>0</tt> atomically.__@return Credit which was not announced to the sender yet.;public int getAndResetUnannouncedCredit() {_		return unannouncedCredit.getAndSet(0)__	};gets,the,unannounced,credit,and,resets,it,to,tt,0,tt,atomically,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,and,reset,unannounced,credit,return,unannounced,credit,get,and,set,0
RemoteInputChannel -> public int getAndResetUnannouncedCredit();1534864589;Gets the unannounced credit and resets it to <tt>0</tt> atomically.__@return Credit which was not announced to the sender yet.;public int getAndResetUnannouncedCredit() {_		return unannouncedCredit.getAndSet(0)__	};gets,the,unannounced,credit,and,resets,it,to,tt,0,tt,atomically,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,and,reset,unannounced,credit,return,unannounced,credit,get,and,set,0
RemoteInputChannel -> public int getAndResetUnannouncedCredit();1534865689;Gets the unannounced credit and resets it to <tt>0</tt> atomically.__@return Credit which was not announced to the sender yet.;public int getAndResetUnannouncedCredit() {_		return unannouncedCredit.getAndSet(0)__	};gets,the,unannounced,credit,and,resets,it,to,tt,0,tt,atomically,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,and,reset,unannounced,credit,return,unannounced,credit,get,and,set,0
RemoteInputChannel -> public int getAndResetUnannouncedCredit();1543328832;Gets the unannounced credit and resets it to <tt>0</tt> atomically.__@return Credit which was not announced to the sender yet.;public int getAndResetUnannouncedCredit() {_		return unannouncedCredit.getAndSet(0)__	};gets,the,unannounced,credit,and,resets,it,to,tt,0,tt,atomically,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,and,reset,unannounced,credit,return,unannounced,credit,get,and,set,0
