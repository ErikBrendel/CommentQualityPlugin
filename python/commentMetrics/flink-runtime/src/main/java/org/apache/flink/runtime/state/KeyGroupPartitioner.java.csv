# id;timestamp;commentText;codeText;commentWords;codeWords
KeyGroupPartitioner -> public StateSnapshot.KeyGroupPartitionedSnapshot partitionByKeyGroup();1529089579;Partitions the data into key-groups and returns the result via {@link PartitioningResult}.;public StateSnapshot.KeyGroupPartitionedSnapshot partitionByKeyGroup() {_		if (computedResult == null) {_			reportAllElementKeyGroups()__			buildHistogramByAccumulatingCounts()__			executePartitioning()__		}_		return computedResult__	};partitions,the,data,into,key,groups,and,returns,the,result,via,link,partitioning,result;public,state,snapshot,key,group,partitioned,snapshot,partition,by,key,group,if,computed,result,null,report,all,element,key,groups,build,histogram,by,accumulating,counts,execute,partitioning,return,computed,result
KeyGroupPartitioner -> public StateSnapshot.KeyGroupPartitionedSnapshot partitionByKeyGroup();1530639128;Partitions the data into key-groups and returns the result via {@link PartitioningResult}.;public StateSnapshot.KeyGroupPartitionedSnapshot partitionByKeyGroup() {_		if (computedResult == null) {_			reportAllElementKeyGroups()__			buildHistogramByAccumulatingCounts()__			executePartitioning()__		}_		return computedResult__	};partitions,the,data,into,key,groups,and,returns,the,result,via,link,partitioning,result;public,state,snapshot,key,group,partitioned,snapshot,partition,by,key,group,if,computed,result,null,report,all,element,key,groups,build,histogram,by,accumulating,counts,execute,partitioning,return,computed,result
KeyGroupPartitioner -> public KeyGroupPartitioner( 		@Nonnull T[] partitioningSource, 		@Nonnegative int numberOfElements, 		@Nonnull T[] partitioningDestination, 		@Nonnull KeyGroupRange keyGroupRange, 		@Nonnegative int totalKeyGroups, 		@Nonnull KeyExtractorFunction<T> keyExtractorFunction, 		@Nonnull ElementWriterFunction<T> elementWriterFunction);1529089579;Creates a new {@link KeyGroupPartitioner}.__@param partitioningSource the input for the partitioning. All elements must be densely packed in the index_interval [0, {@link #numberOfElements}[, without null values._@param numberOfElements the number of elements to consider from the input, starting at input index 0._@param partitioningDestination the output of the partitioning. Must have capacity of at least numberOfElements._@param keyGroupRange the key-group range of the data that will be partitioned by this instance._@param totalKeyGroups the total number of key groups in the job._@param keyExtractorFunction this function extracts the partition key from an element.;public KeyGroupPartitioner(_		@Nonnull T[] partitioningSource,_		@Nonnegative int numberOfElements,_		@Nonnull T[] partitioningDestination,_		@Nonnull KeyGroupRange keyGroupRange,_		@Nonnegative int totalKeyGroups,_		@Nonnull KeyExtractorFunction<T> keyExtractorFunction,_		@Nonnull ElementWriterFunction<T> elementWriterFunction) {__		Preconditions.checkState(partitioningSource != partitioningDestination)__		Preconditions.checkState(partitioningSource.length >= numberOfElements)__		Preconditions.checkState(partitioningDestination.length >= numberOfElements)___		this.partitioningSource = partitioningSource__		this.partitioningDestination = partitioningDestination__		this.numberOfElements = numberOfElements__		this.keyGroupRange = keyGroupRange__		this.totalKeyGroups = totalKeyGroups__		this.keyExtractorFunction = keyExtractorFunction__		this.elementWriterFunction = elementWriterFunction__		this.firstKeyGroup = keyGroupRange.getStartKeyGroup()__		this.elementKeyGroups = new int[numberOfElements]__		this.counterHistogram = new int[keyGroupRange.getNumberOfKeyGroups()]__		this.computedResult = null__	};creates,a,new,link,key,group,partitioner,param,partitioning,source,the,input,for,the,partitioning,all,elements,must,be,densely,packed,in,the,index,interval,0,link,number,of,elements,without,null,values,param,number,of,elements,the,number,of,elements,to,consider,from,the,input,starting,at,input,index,0,param,partitioning,destination,the,output,of,the,partitioning,must,have,capacity,of,at,least,number,of,elements,param,key,group,range,the,key,group,range,of,the,data,that,will,be,partitioned,by,this,instance,param,total,key,groups,the,total,number,of,key,groups,in,the,job,param,key,extractor,function,this,function,extracts,the,partition,key,from,an,element;public,key,group,partitioner,nonnull,t,partitioning,source,nonnegative,int,number,of,elements,nonnull,t,partitioning,destination,nonnull,key,group,range,key,group,range,nonnegative,int,total,key,groups,nonnull,key,extractor,function,t,key,extractor,function,nonnull,element,writer,function,t,element,writer,function,preconditions,check,state,partitioning,source,partitioning,destination,preconditions,check,state,partitioning,source,length,number,of,elements,preconditions,check,state,partitioning,destination,length,number,of,elements,this,partitioning,source,partitioning,source,this,partitioning,destination,partitioning,destination,this,number,of,elements,number,of,elements,this,key,group,range,key,group,range,this,total,key,groups,total,key,groups,this,key,extractor,function,key,extractor,function,this,element,writer,function,element,writer,function,this,first,key,group,key,group,range,get,start,key,group,this,element,key,groups,new,int,number,of,elements,this,counter,histogram,new,int,key,group,range,get,number,of,key,groups,this,computed,result,null
KeyGroupPartitioner -> public KeyGroupPartitioner( 		@Nonnull T[] partitioningSource, 		@Nonnegative int numberOfElements, 		@Nonnull T[] partitioningDestination, 		@Nonnull KeyGroupRange keyGroupRange, 		@Nonnegative int totalKeyGroups, 		@Nonnull KeyExtractorFunction<T> keyExtractorFunction, 		@Nonnull ElementWriterFunction<T> elementWriterFunction);1530639128;Creates a new {@link KeyGroupPartitioner}.__@param partitioningSource the input for the partitioning. All elements must be densely packed in the index_interval [0, {@link #numberOfElements}[, without null values._@param numberOfElements the number of elements to consider from the input, starting at input index 0._@param partitioningDestination the output of the partitioning. Must have capacity of at least numberOfElements._@param keyGroupRange the key-group range of the data that will be partitioned by this instance._@param totalKeyGroups the total number of key groups in the job._@param keyExtractorFunction this function extracts the partition key from an element.;public KeyGroupPartitioner(_		@Nonnull T[] partitioningSource,_		@Nonnegative int numberOfElements,_		@Nonnull T[] partitioningDestination,_		@Nonnull KeyGroupRange keyGroupRange,_		@Nonnegative int totalKeyGroups,_		@Nonnull KeyExtractorFunction<T> keyExtractorFunction,_		@Nonnull ElementWriterFunction<T> elementWriterFunction) {__		Preconditions.checkState(partitioningSource != partitioningDestination)__		Preconditions.checkState(partitioningSource.length >= numberOfElements)__		Preconditions.checkState(partitioningDestination.length >= numberOfElements)___		this.partitioningSource = partitioningSource__		this.partitioningDestination = partitioningDestination__		this.numberOfElements = numberOfElements__		this.keyGroupRange = keyGroupRange__		this.totalKeyGroups = totalKeyGroups__		this.keyExtractorFunction = keyExtractorFunction__		this.elementWriterFunction = elementWriterFunction__		this.firstKeyGroup = keyGroupRange.getStartKeyGroup()__		this.elementKeyGroups = new int[numberOfElements]__		this.counterHistogram = new int[keyGroupRange.getNumberOfKeyGroups()]__		this.computedResult = null__	};creates,a,new,link,key,group,partitioner,param,partitioning,source,the,input,for,the,partitioning,all,elements,must,be,densely,packed,in,the,index,interval,0,link,number,of,elements,without,null,values,param,number,of,elements,the,number,of,elements,to,consider,from,the,input,starting,at,input,index,0,param,partitioning,destination,the,output,of,the,partitioning,must,have,capacity,of,at,least,number,of,elements,param,key,group,range,the,key,group,range,of,the,data,that,will,be,partitioned,by,this,instance,param,total,key,groups,the,total,number,of,key,groups,in,the,job,param,key,extractor,function,this,function,extracts,the,partition,key,from,an,element;public,key,group,partitioner,nonnull,t,partitioning,source,nonnegative,int,number,of,elements,nonnull,t,partitioning,destination,nonnull,key,group,range,key,group,range,nonnegative,int,total,key,groups,nonnull,key,extractor,function,t,key,extractor,function,nonnull,element,writer,function,t,element,writer,function,preconditions,check,state,partitioning,source,partitioning,destination,preconditions,check,state,partitioning,source,length,number,of,elements,preconditions,check,state,partitioning,destination,length,number,of,elements,this,partitioning,source,partitioning,source,this,partitioning,destination,partitioning,destination,this,number,of,elements,number,of,elements,this,key,group,range,key,group,range,this,total,key,groups,total,key,groups,this,key,extractor,function,key,extractor,function,this,element,writer,function,element,writer,function,this,first,key,group,key,group,range,get,start,key,group,this,element,key,groups,new,int,number,of,elements,this,counter,histogram,new,int,key,group,range,get,number,of,key,groups,this,computed,result,null
KeyGroupPartitioner -> public KeyGroupPartitioner( 		@Nonnull T[] partitioningSource, 		@Nonnegative int numberOfElements, 		@Nonnull T[] partitioningDestination, 		@Nonnull KeyGroupRange keyGroupRange, 		@Nonnegative int totalKeyGroups, 		@Nonnull KeyExtractorFunction<T> keyExtractorFunction, 		@Nonnull ElementWriterFunction<T> elementWriterFunction);1531771917;Creates a new {@link KeyGroupPartitioner}.__@param partitioningSource the input for the partitioning. All elements must be densely packed in the index_interval [0, {@link #numberOfElements}[, without null values._@param numberOfElements the number of elements to consider from the input, starting at input index 0._@param partitioningDestination the output of the partitioning. Must have capacity of at least numberOfElements._@param keyGroupRange the key-group range of the data that will be partitioned by this instance._@param totalKeyGroups the total number of key groups in the job._@param keyExtractorFunction this function extracts the partition key from an element.;public KeyGroupPartitioner(_		@Nonnull T[] partitioningSource,_		@Nonnegative int numberOfElements,_		@Nonnull T[] partitioningDestination,_		@Nonnull KeyGroupRange keyGroupRange,_		@Nonnegative int totalKeyGroups,_		@Nonnull KeyExtractorFunction<T> keyExtractorFunction,_		@Nonnull ElementWriterFunction<T> elementWriterFunction) {__		Preconditions.checkState(partitioningSource != partitioningDestination)__		Preconditions.checkState(partitioningSource.length >= numberOfElements)__		Preconditions.checkState(partitioningDestination.length >= numberOfElements)___		this.partitioningSource = partitioningSource__		this.partitioningDestination = partitioningDestination__		this.numberOfElements = numberOfElements__		this.keyGroupRange = keyGroupRange__		this.totalKeyGroups = totalKeyGroups__		this.keyExtractorFunction = keyExtractorFunction__		this.elementWriterFunction = elementWriterFunction__		this.firstKeyGroup = keyGroupRange.getStartKeyGroup()__		this.elementKeyGroups = new int[numberOfElements]__		this.counterHistogram = new int[keyGroupRange.getNumberOfKeyGroups()]__		this.computedResult = null__	};creates,a,new,link,key,group,partitioner,param,partitioning,source,the,input,for,the,partitioning,all,elements,must,be,densely,packed,in,the,index,interval,0,link,number,of,elements,without,null,values,param,number,of,elements,the,number,of,elements,to,consider,from,the,input,starting,at,input,index,0,param,partitioning,destination,the,output,of,the,partitioning,must,have,capacity,of,at,least,number,of,elements,param,key,group,range,the,key,group,range,of,the,data,that,will,be,partitioned,by,this,instance,param,total,key,groups,the,total,number,of,key,groups,in,the,job,param,key,extractor,function,this,function,extracts,the,partition,key,from,an,element;public,key,group,partitioner,nonnull,t,partitioning,source,nonnegative,int,number,of,elements,nonnull,t,partitioning,destination,nonnull,key,group,range,key,group,range,nonnegative,int,total,key,groups,nonnull,key,extractor,function,t,key,extractor,function,nonnull,element,writer,function,t,element,writer,function,preconditions,check,state,partitioning,source,partitioning,destination,preconditions,check,state,partitioning,source,length,number,of,elements,preconditions,check,state,partitioning,destination,length,number,of,elements,this,partitioning,source,partitioning,source,this,partitioning,destination,partitioning,destination,this,number,of,elements,number,of,elements,this,key,group,range,key,group,range,this,total,key,groups,total,key,groups,this,key,extractor,function,key,extractor,function,this,element,writer,function,element,writer,function,this,first,key,group,key,group,range,get,start,key,group,this,element,key,groups,new,int,number,of,elements,this,counter,histogram,new,int,key,group,range,get,number,of,key,groups,this,computed,result,null
KeyGroupPartitioner -> public KeyGroupPartitioner( 		@Nonnull T[] partitioningSource, 		@Nonnegative int numberOfElements, 		@Nonnull T[] partitioningDestination, 		@Nonnull KeyGroupRange keyGroupRange, 		@Nonnegative int totalKeyGroups, 		@Nonnull KeyExtractorFunction<T> keyExtractorFunction, 		@Nonnull ElementWriterFunction<T> elementWriterFunction);1533318024;Creates a new {@link KeyGroupPartitioner}.__@param partitioningSource the input for the partitioning. All elements must be densely packed in the index_interval [0, {@link #numberOfElements}[, without null values._@param numberOfElements the number of elements to consider from the input, starting at input index 0._@param partitioningDestination the output of the partitioning. Must have capacity of at least numberOfElements._@param keyGroupRange the key-group range of the data that will be partitioned by this instance._@param totalKeyGroups the total number of key groups in the job._@param keyExtractorFunction this function extracts the partition key from an element.;public KeyGroupPartitioner(_		@Nonnull T[] partitioningSource,_		@Nonnegative int numberOfElements,_		@Nonnull T[] partitioningDestination,_		@Nonnull KeyGroupRange keyGroupRange,_		@Nonnegative int totalKeyGroups,_		@Nonnull KeyExtractorFunction<T> keyExtractorFunction,_		@Nonnull ElementWriterFunction<T> elementWriterFunction) {__		Preconditions.checkState(partitioningSource != partitioningDestination)__		Preconditions.checkState(partitioningSource.length >= numberOfElements)__		Preconditions.checkState(partitioningDestination.length >= numberOfElements)___		this.partitioningSource = partitioningSource__		this.partitioningDestination = partitioningDestination__		this.numberOfElements = numberOfElements__		this.keyGroupRange = keyGroupRange__		this.totalKeyGroups = totalKeyGroups__		this.keyExtractorFunction = keyExtractorFunction__		this.elementWriterFunction = elementWriterFunction__		this.firstKeyGroup = keyGroupRange.getStartKeyGroup()__		this.elementKeyGroups = new int[numberOfElements]__		this.counterHistogram = new int[keyGroupRange.getNumberOfKeyGroups()]__		this.computedResult = null__	};creates,a,new,link,key,group,partitioner,param,partitioning,source,the,input,for,the,partitioning,all,elements,must,be,densely,packed,in,the,index,interval,0,link,number,of,elements,without,null,values,param,number,of,elements,the,number,of,elements,to,consider,from,the,input,starting,at,input,index,0,param,partitioning,destination,the,output,of,the,partitioning,must,have,capacity,of,at,least,number,of,elements,param,key,group,range,the,key,group,range,of,the,data,that,will,be,partitioned,by,this,instance,param,total,key,groups,the,total,number,of,key,groups,in,the,job,param,key,extractor,function,this,function,extracts,the,partition,key,from,an,element;public,key,group,partitioner,nonnull,t,partitioning,source,nonnegative,int,number,of,elements,nonnull,t,partitioning,destination,nonnull,key,group,range,key,group,range,nonnegative,int,total,key,groups,nonnull,key,extractor,function,t,key,extractor,function,nonnull,element,writer,function,t,element,writer,function,preconditions,check,state,partitioning,source,partitioning,destination,preconditions,check,state,partitioning,source,length,number,of,elements,preconditions,check,state,partitioning,destination,length,number,of,elements,this,partitioning,source,partitioning,source,this,partitioning,destination,partitioning,destination,this,number,of,elements,number,of,elements,this,key,group,range,key,group,range,this,total,key,groups,total,key,groups,this,key,extractor,function,key,extractor,function,this,element,writer,function,element,writer,function,this,first,key,group,key,group,range,get,start,key,group,this,element,key,groups,new,int,number,of,elements,this,counter,histogram,new,int,key,group,range,get,number,of,key,groups,this,computed,result,null
KeyGroupPartitioner -> ElementWriterFunction -> void writeElement(@Nonnull T element, @Nonnull DataOutputView dov) throws IOException_;1529089579;This method defines how to write a single element to the output.__@param element the element to be written._@param dov     the output view to write the element._@throws IOException on write-related problems.;void writeElement(@Nonnull T element, @Nonnull DataOutputView dov) throws IOException_;this,method,defines,how,to,write,a,single,element,to,the,output,param,element,the,element,to,be,written,param,dov,the,output,view,to,write,the,element,throws,ioexception,on,write,related,problems;void,write,element,nonnull,t,element,nonnull,data,output,view,dov,throws,ioexception
KeyGroupPartitioner -> ElementWriterFunction -> void writeElement(@Nonnull T element, @Nonnull DataOutputView dov) throws IOException_;1530639128;This method defines how to write a single element to the output.__@param element the element to be written._@param dov     the output view to write the element._@throws IOException on write-related problems.;void writeElement(@Nonnull T element, @Nonnull DataOutputView dov) throws IOException_;this,method,defines,how,to,write,a,single,element,to,the,output,param,element,the,element,to,be,written,param,dov,the,output,view,to,write,the,element,throws,ioexception,on,write,related,problems;void,write,element,nonnull,t,element,nonnull,data,output,view,dov,throws,ioexception
KeyGroupPartitioner -> ElementWriterFunction -> void writeElement(@Nonnull T element, @Nonnull DataOutputView dov) throws IOException_;1531771917;This method defines how to write a single element to the output.__@param element the element to be written._@param dov     the output view to write the element._@throws IOException on write-related problems.;void writeElement(@Nonnull T element, @Nonnull DataOutputView dov) throws IOException_;this,method,defines,how,to,write,a,single,element,to,the,output,param,element,the,element,to,be,written,param,dov,the,output,view,to,write,the,element,throws,ioexception,on,write,related,problems;void,write,element,nonnull,t,element,nonnull,data,output,view,dov,throws,ioexception
KeyGroupPartitioner -> ElementWriterFunction -> void writeElement(@Nonnull T element, @Nonnull DataOutputView dov) throws IOException_;1533318024;This method defines how to write a single element to the output.__@param element the element to be written._@param dov     the output view to write the element._@throws IOException on write-related problems.;void writeElement(@Nonnull T element, @Nonnull DataOutputView dov) throws IOException_;this,method,defines,how,to,write,a,single,element,to,the,output,param,element,the,element,to,be,written,param,dov,the,output,view,to,write,the,element,throws,ioexception,on,write,related,problems;void,write,element,nonnull,t,element,nonnull,data,output,view,dov,throws,ioexception
KeyGroupPartitioner -> private void buildHistogramByAccumulatingCounts();1529089579;This method creates a histogram from the counts per key-group in {@link #counterHistogram}.;private void buildHistogramByAccumulatingCounts() {_		int sum = 0__		for (int i = 0_ i < counterHistogram.length_ ++i) {_			int currentSlotValue = counterHistogram[i]__			counterHistogram[i] = sum__			sum += currentSlotValue__		}__		_		Preconditions.checkState(sum == numberOfElements)__	};this,method,creates,a,histogram,from,the,counts,per,key,group,in,link,counter,histogram;private,void,build,histogram,by,accumulating,counts,int,sum,0,for,int,i,0,i,counter,histogram,length,i,int,current,slot,value,counter,histogram,i,counter,histogram,i,sum,sum,current,slot,value,preconditions,check,state,sum,number,of,elements
KeyGroupPartitioner -> private void buildHistogramByAccumulatingCounts();1530639128;This method creates a histogram from the counts per key-group in {@link #counterHistogram}.;private void buildHistogramByAccumulatingCounts() {_		int sum = 0__		for (int i = 0_ i < counterHistogram.length_ ++i) {_			int currentSlotValue = counterHistogram[i]__			counterHistogram[i] = sum__			sum += currentSlotValue__		}__		_		Preconditions.checkState(sum == numberOfElements)__	};this,method,creates,a,histogram,from,the,counts,per,key,group,in,link,counter,histogram;private,void,build,histogram,by,accumulating,counts,int,sum,0,for,int,i,0,i,counter,histogram,length,i,int,current,slot,value,counter,histogram,i,counter,histogram,i,sum,sum,current,slot,value,preconditions,check,state,sum,number,of,elements
KeyGroupPartitioner -> private void buildHistogramByAccumulatingCounts();1531771917;This method creates a histogram from the counts per key-group in {@link #counterHistogram}.;private void buildHistogramByAccumulatingCounts() {_		int sum = 0__		for (int i = 0_ i < counterHistogram.length_ ++i) {_			int currentSlotValue = counterHistogram[i]__			counterHistogram[i] = sum__			sum += currentSlotValue__		}__		_		Preconditions.checkState(sum == numberOfElements)__	};this,method,creates,a,histogram,from,the,counts,per,key,group,in,link,counter,histogram;private,void,build,histogram,by,accumulating,counts,int,sum,0,for,int,i,0,i,counter,histogram,length,i,int,current,slot,value,counter,histogram,i,counter,histogram,i,sum,sum,current,slot,value,preconditions,check,state,sum,number,of,elements
KeyGroupPartitioner -> public StateSnapshot.StateKeyGroupWriter partitionByKeyGroup();1531771917;Partitions the data into key-groups and returns the result via {@link PartitioningResult}.;public StateSnapshot.StateKeyGroupWriter partitionByKeyGroup() {_		if (computedResult == null) {_			reportAllElementKeyGroups()__			buildHistogramByAccumulatingCounts()__			executePartitioning()__		}_		return computedResult__	};partitions,the,data,into,key,groups,and,returns,the,result,via,link,partitioning,result;public,state,snapshot,state,key,group,writer,partition,by,key,group,if,computed,result,null,report,all,element,key,groups,build,histogram,by,accumulating,counts,execute,partitioning,return,computed,result
KeyGroupPartitioner -> public StateSnapshot.StateKeyGroupWriter partitionByKeyGroup();1533318024;Partitions the data into key-groups and returns the result via {@link PartitioningResult}.;public StateSnapshot.StateKeyGroupWriter partitionByKeyGroup() {_		if (computedResult == null) {_			reportAllElementKeyGroups()__			int outputNumberOfElements = buildHistogramByAccumulatingCounts()__			executePartitioning(outputNumberOfElements)__		}_		return computedResult__	};partitions,the,data,into,key,groups,and,returns,the,result,via,link,partitioning,result;public,state,snapshot,state,key,group,writer,partition,by,key,group,if,computed,result,null,report,all,element,key,groups,int,output,number,of,elements,build,histogram,by,accumulating,counts,execute,partitioning,output,number,of,elements,return,computed,result
KeyGroupPartitioner -> protected void reportKeyGroupOfElementAtIndex(int index, int keyGroup);1529089579;This method reports in the bookkeeping data that the element at the given index belongs to the given key-group.;protected void reportKeyGroupOfElementAtIndex(int index, int keyGroup) {_		final int keyGroupIndex = keyGroup - firstKeyGroup__		elementKeyGroups[index] = keyGroupIndex__		++counterHistogram[keyGroupIndex]__	};this,method,reports,in,the,bookkeeping,data,that,the,element,at,the,given,index,belongs,to,the,given,key,group;protected,void,report,key,group,of,element,at,index,int,index,int,key,group,final,int,key,group,index,key,group,first,key,group,element,key,groups,index,key,group,index,counter,histogram,key,group,index
KeyGroupPartitioner -> protected void reportKeyGroupOfElementAtIndex(int index, int keyGroup);1530639128;This method reports in the bookkeeping data that the element at the given index belongs to the given key-group.;protected void reportKeyGroupOfElementAtIndex(int index, int keyGroup) {_		final int keyGroupIndex = keyGroup - firstKeyGroup__		elementKeyGroups[index] = keyGroupIndex__		++counterHistogram[keyGroupIndex]__	};this,method,reports,in,the,bookkeeping,data,that,the,element,at,the,given,index,belongs,to,the,given,key,group;protected,void,report,key,group,of,element,at,index,int,index,int,key,group,final,int,key,group,index,key,group,first,key,group,element,key,groups,index,key,group,index,counter,histogram,key,group,index
KeyGroupPartitioner -> protected void reportKeyGroupOfElementAtIndex(int index, int keyGroup);1531771917;This method reports in the bookkeeping data that the element at the given index belongs to the given key-group.;protected void reportKeyGroupOfElementAtIndex(int index, int keyGroup) {_		final int keyGroupIndex = keyGroup - firstKeyGroup__		elementKeyGroups[index] = keyGroupIndex__		++counterHistogram[keyGroupIndex]__	};this,method,reports,in,the,bookkeeping,data,that,the,element,at,the,given,index,belongs,to,the,given,key,group;protected,void,report,key,group,of,element,at,index,int,index,int,key,group,final,int,key,group,index,key,group,first,key,group,element,key,groups,index,key,group,index,counter,histogram,key,group,index
KeyGroupPartitioner -> protected void reportKeyGroupOfElementAtIndex(int index, int keyGroup);1533318024;This method reports in the bookkeeping data that the element at the given index belongs to the given key-group.;protected void reportKeyGroupOfElementAtIndex(int index, int keyGroup) {_		final int keyGroupIndex = keyGroup - firstKeyGroup__		elementKeyGroups[index] = keyGroupIndex__		++counterHistogram[keyGroupIndex]__	};this,method,reports,in,the,bookkeeping,data,that,the,element,at,the,given,index,belongs,to,the,given,key,group;protected,void,report,key,group,of,element,at,index,int,index,int,key,group,final,int,key,group,index,key,group,first,key,group,element,key,groups,index,key,group,index,counter,histogram,key,group,index
KeyGroupPartitioner -> protected void reportAllElementKeyGroups();1529089579;This method iterates over the input data and reports the key-group for each element.;protected void reportAllElementKeyGroups() {__		Preconditions.checkState(partitioningSource.length >= numberOfElements)___		for (int i = 0_ i < numberOfElements_ ++i) {_			int keyGroup = KeyGroupRangeAssignment.assignToKeyGroup(_				keyExtractorFunction.extractKeyFromElement(partitioningSource[i]), totalKeyGroups)__			reportKeyGroupOfElementAtIndex(i, keyGroup)__		}_	};this,method,iterates,over,the,input,data,and,reports,the,key,group,for,each,element;protected,void,report,all,element,key,groups,preconditions,check,state,partitioning,source,length,number,of,elements,for,int,i,0,i,number,of,elements,i,int,key,group,key,group,range,assignment,assign,to,key,group,key,extractor,function,extract,key,from,element,partitioning,source,i,total,key,groups,report,key,group,of,element,at,index,i,key,group
KeyGroupPartitioner -> protected void reportAllElementKeyGroups();1530639128;This method iterates over the input data and reports the key-group for each element.;protected void reportAllElementKeyGroups() {__		Preconditions.checkState(partitioningSource.length >= numberOfElements)___		for (int i = 0_ i < numberOfElements_ ++i) {_			int keyGroup = KeyGroupRangeAssignment.assignToKeyGroup(_				keyExtractorFunction.extractKeyFromElement(partitioningSource[i]), totalKeyGroups)__			reportKeyGroupOfElementAtIndex(i, keyGroup)__		}_	};this,method,iterates,over,the,input,data,and,reports,the,key,group,for,each,element;protected,void,report,all,element,key,groups,preconditions,check,state,partitioning,source,length,number,of,elements,for,int,i,0,i,number,of,elements,i,int,key,group,key,group,range,assignment,assign,to,key,group,key,extractor,function,extract,key,from,element,partitioning,source,i,total,key,groups,report,key,group,of,element,at,index,i,key,group
KeyGroupPartitioner -> protected void reportAllElementKeyGroups();1531771917;This method iterates over the input data and reports the key-group for each element.;protected void reportAllElementKeyGroups() {__		Preconditions.checkState(partitioningSource.length >= numberOfElements)___		for (int i = 0_ i < numberOfElements_ ++i) {_			int keyGroup = KeyGroupRangeAssignment.assignToKeyGroup(_				keyExtractorFunction.extractKeyFromElement(partitioningSource[i]), totalKeyGroups)__			reportKeyGroupOfElementAtIndex(i, keyGroup)__		}_	};this,method,iterates,over,the,input,data,and,reports,the,key,group,for,each,element;protected,void,report,all,element,key,groups,preconditions,check,state,partitioning,source,length,number,of,elements,for,int,i,0,i,number,of,elements,i,int,key,group,key,group,range,assignment,assign,to,key,group,key,extractor,function,extract,key,from,element,partitioning,source,i,total,key,groups,report,key,group,of,element,at,index,i,key,group
KeyGroupPartitioner -> protected void reportAllElementKeyGroups();1533318024;This method iterates over the input data and reports the key-group for each element.;protected void reportAllElementKeyGroups() {__		Preconditions.checkState(partitioningSource.length >= numberOfElements)___		for (int i = 0_ i < numberOfElements_ ++i) {_			int keyGroup = KeyGroupRangeAssignment.assignToKeyGroup(_				keyExtractorFunction.extractKeyFromElement(partitioningSource[i]), totalKeyGroups)__			reportKeyGroupOfElementAtIndex(i, keyGroup)__		}_	};this,method,iterates,over,the,input,data,and,reports,the,key,group,for,each,element;protected,void,report,all,element,key,groups,preconditions,check,state,partitioning,source,length,number,of,elements,for,int,i,0,i,number,of,elements,i,int,key,group,key,group,range,assignment,assign,to,key,group,key,extractor,function,extract,key,from,element,partitioning,source,i,total,key,groups,report,key,group,of,element,at,index,i,key,group
